<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>微信小程序-分包加载</title>
    <link href="/2025/07/09/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E5%88%86%E5%8C%85%E5%8A%A0%E8%BD%BD/"/>
    <url>/2025/07/09/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E5%88%86%E5%8C%85%E5%8A%A0%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<h1 id="分包加载"><a href="#分包加载" class="headerlink" title="分包加载"></a>分包加载</h1><p>主包存放小程序的默认启动页面和tabbar页面，还有一些所有分包的共同依赖文件</p><p>分包按照业务功能划分，当小程序加载到某一个分包时，该分包在下载加载，实现懒加载</p><p>小程序中规定，主包大小不能超过2M，分包大小总计不能超过20M</p><hr><h3 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h3><p>小程序如果想要配置分包加载，需要在app.json中，通过subPackages或者subpackages定义分包结构</p><p>每个分包结构包含三个常用字段：</p><ul><li>root：分包的根目录，该目录下的所有文件都会背打包成一个独立的包</li><li>name：分包的别名，用于在代码中引用该分包</li><li>pages：指定当前分包中包含哪些页面</li></ul><p>在跳转到分包页面时，同样是通过navigator去跳转，但路径签应加上root目录</p><hr><h3 id="独立分包"><a href="#独立分包" class="headerlink" title="独立分包"></a>独立分包</h3><p>开发者可以将功能相对独立的页面配置到独立分包中，因为独立分包不依赖主包可以运行，可以很大程度上提升分包页面的启动速度</p><p>给subPackages定义的分包结构中添加independent字段为true，即可声明对应分包为独立分包</p><p>主包中的app.wxss对独立分包无效，独立分包不能依赖主包和其他分包的资源</p><hr><h3 id="分包预下载"><a href="#分包预下载" class="headerlink" title="分包预下载"></a>分包预下载</h3><p>分包预下载指的是访问小程序的某个页面时，预先下载其他分包的代码和资源</p><p>在app.json中通过preloadRule配置项来配置访问哪个页面需要进行预下载，通过其中的network字段可以配置wifi预下载和所有网络预下载，其中的package字段配置分包的别名，用来配置预下载哪些分包</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;preloadRule&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <br>  <span class="hljs-attr">&quot;page/index/index&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span> <span class="hljs-comment">// 当访问主页面时进行预下载</span><br>    <span class="hljs-attr">&quot;network&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;all&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 在所有网络下都预下载</span><br>    <span class="hljs-attr">&quot;packages&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;goodMoudule&quot;</span><span class="hljs-punctuation">]</span> <span class="hljs-comment">// 预下载goodMoudule分包</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>同时，我们也可以配置访问独立分包时预下载主包</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;module/goodModule/pages/good/good&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span> <span class="hljs-comment">// 分包root</span><br>  <span class="hljs-attr">&quot;network&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;all&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;packages&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;__APP__&quot;</span><span class="hljs-punctuation">]</span> <span class="hljs-comment">// 主包的固定写法</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>JAVAWEB</category>
      
      <category>微信小程序</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>微信小程序-npm</title>
    <link href="/2025/07/08/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-npm/"/>
    <url>/2025/07/08/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-npm/</url>
    
    <content type="html"><![CDATA[<h1 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h1><p>目前小程序已经支持使用npm安装第三方包，因为node_modules目录中的包不会参与小程序项目的编译、上传和打包，所以小程序如果想要使用npm包，必须要走一遍构建npm的过程</p><blockquote><p>npm init -y</p></blockquote><hr><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><p>微信小程序的默认目录中，源码是直接放在根目录下的，这不利于平日开发中项目规范，例如vue就会将源码放入src目录下</p><p>在project.config.json配置文件中，配置miniprogramRoot配置项，可配置源码文件的位置</p><p>在project.config.json配置文件中，配置setting配置项packNpmManually为true，可配置允许自定义npm相关目录</p><p>在project.config.json配置文件中，配置setting配置项packNpmRelationList，可配置npm相关目录</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;miniprogramRoot&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;./src&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 配置小程序源码根目录</span><br><span class="hljs-attr">&quot;setting&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;packNpmManually&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 允许自定义npm相关目录</span><br>  <span class="hljs-attr">&quot;packNpmRelationList&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;packageJsonPath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;./package&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 配置npm配置文件地址</span><br>      <span class="hljs-attr">&quot;miniprogramNpmDistDir&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;./src&quot;</span> <span class="hljs-comment">// 将构建好的npm依赖存放到源代码包下</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><hr><h3 id="Vant-Weapp"><a href="#Vant-Weapp" class="headerlink" title="Vant Weapp"></a>Vant Weapp</h3><p><a href="https://vant-ui.github.io/vant-weapp/#/home">Vant 是一个<strong>轻量、可定制的移动端组件库</strong></a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm i @vant/weapp<br></code></pre></td></tr></table></figure><p>安装之后也不能正常使用，我们需要找到工具-&gt; 构建npm选项</p><p>会生成miniprogram_npm文件夹，这就是npm组件构建的内容</p><p><em>因为运行环境的特殊性，并不是所有的包都能在微信小程序中使用，需要使用专门为小程序定制的npm包</em></p><p><strong>组件样式版本</strong></p><p>微信小程序在版本更新后提供了很多新的组件和组件样式，这使得Vant Weapp的组件样式很难覆盖</p><p>我们在使用Vant Weapp之前，先取消掉小程序新版样式，在app.json中，删掉style配置项即可</p><p><strong>注册组件</strong></p><p>可以选择在app.json中全局注册组件，或选择在页面.json中局部注册组件</p><p><strong>图片组件</strong></p><p>在使用van-image图片组件时，如果需要渲染本地图片，不能使用相对路径来找图，而是使用相对于小程序的源码的目录来查找图片才可以找到</p><p>组件也提供了很多事件属性，比如图片组件提供了bind:tap作为点击事件使用</p><p><strong>组件样式修改方法</strong></p><ol><li>取消组件样式隔离</li><li>使用外部样式类</li><li>使用CSS变量</li></ol><hr>]]></content>
    
    
    <categories>
      
      <category>JAVAWEB</category>
      
      <category>微信小程序</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>微信小程序-自定义组件扩展</title>
    <link href="/2025/07/07/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E6%89%A9%E5%B1%95/"/>
    <url>/2025/07/07/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E6%89%A9%E5%B1%95/</url>
    
    <content type="html"><![CDATA[<h1 id="数据监听器"><a href="#数据监听器" class="headerlink" title="数据监听器"></a>数据监听器</h1><p>数据监听器主要用于监听任何属性（properties）和数据（data）的变化</p><p>在组件中需要进行数据监听，需要用到<strong>observers</strong></p><p>如果是data中的数据，数据变化时可触发监听</p><p>如果是properties的数据，数据传递时就会触发监听</p><hr><h1 id="组件通讯"><a href="#组件通讯" class="headerlink" title="组件通讯"></a>组件通讯</h1><h3 id="父往子传递"><a href="#父往子传递" class="headerlink" title="父往子传递"></a>父往子传递</h3><p>properties就是父子传递的方式</p><h3 id="子往父传递"><a href="#子往父传递" class="headerlink" title="子往父传递"></a>子往父传递</h3><p>当子组件需要向父组件发送数据时，它会触发一个自定义事件，并把数据作为事件的一部分传递出去。父组件则监听这个事件，并在事件触发时执行相应的方法来接收数据。</p><p>子组件通过触发函数调用 <code>this.triggerEvent(eventName, detail, options)</code> 方法来定义并触发一个自定义事件eventName，并添加想要传输的数据detail。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 引用子组件，并监听其自定义事件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">my-child</span></span><br><span class="hljs-tag">  <span class="hljs-attr">bind:eventName</span>=<span class="hljs-string">&quot;handleChildEvent&quot;</span></span><br><span class="hljs-tag">&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">my-child</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在引用子组件时，将自定义事件作为属性，绑定触发一个处理函数</p><p>处理方法会接收到一个事件对象 <code>event</code>。子组件传递的数据会存储在 <code>event.detail</code> 属性中</p><hr><p><strong>获取子组件实例</strong></p><p>在父组件中，我们可以通过类选择器或者id选择器作为参数，调用this.selectComponent方法来获取到子组件的实例，就可以获取到子组件的所有信息</p><hr><h1 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h1><p>组件的生命周期需要在lifetimes字段进行声明，组件的生命周期有五个函数</p><ul><li><strong><code>options</code> (组件选项，仅限组件)created</strong>：指主键实例被创建好时执行</li><li><strong>attached</strong>：指主键被挂载到页面上时执行</li><li>ready</li><li>moved</li><li><strong>detached</strong>：组件被销毁时执行</li></ul><p><em>注：在created声明周期时，不能调用setData函数</em></p><hr><h3 id="组件所在页面的生命周期"><a href="#组件所在页面的生命周期" class="headerlink" title="组件所在页面的生命周期"></a>组件所在页面的生命周期</h3><p>组件所在也页面的生命周期有四个，需要在pageLifetimes进行声明</p><ul><li><strong>show</strong>：监听组件所在的页面展示状态</li><li><strong>hide</strong>：监听组件所在的页面隐藏状态</li><li>resize</li><li>routeDone</li></ul><hr><h1 id="使用组件来构造页面"><a href="#使用组件来构造页面" class="headerlink" title="使用组件来构造页面"></a>使用组件来构造页面</h1><p>小程序中区分了组件和页面，但仍然可以使用component来构造页面</p><p>注意事项：</p><ol><li>要求.json文件中必须包含usingComponents字段</li><li>里面的配置项要与Component保持一致</li><li>页面中Page方法有一些钩子函数，和事件监听方法等必须放在method中</li></ol><p><strong>最佳实践中，不推荐直接将组件来作为页面使用，而是选择页面容器模式，页面的主要职责是装组件，作为一个容器，不实现具体逻辑</strong></p><hr><h1 id="组件复用机制"><a href="#组件复用机制" class="headerlink" title="组件复用机制"></a>组件复用机制</h1><p><code>Behavior</code> 是微信小程序中实现代码复用和逻辑共享的强大工具。通过将通用的数据、方法和生命周期封装到 <code>Behavior</code> 中，你可以大大减少代码冗余，提高开发效率，并使代码结构更加清晰和易于维护。在实际项目中，它被广泛应用于处理各种跨组件&#x2F;页面的通用逻辑。</p><p>我们可以在behavior中预定义一些逻辑，例如上拉加载更多数据，在其中预定义了一些方法和数据</p><p>当组合在页面或组件中时，相同的数据会覆盖掉behavior中的数据，然后可以调用预定义的方法，来执行相应的逻辑</p><hr><h3 id="微信小程序-Behavior-冲突解决原则"><a href="#微信小程序-Behavior-冲突解决原则" class="headerlink" title="微信小程序 Behavior 冲突解决原则"></a>微信小程序 Behavior 冲突解决原则</h3><p>核心思想是：<strong>页面&#x2F;组件拥有最终的控制权。</strong> 大多数情况下，如果页面&#x2F;组件与 <code>Behavior</code> 定义了同名的字段，页面&#x2F;组件的定义会覆盖 <code>Behavior</code> 的定义。但生命周期函数是例外，它们会按顺序执行。</p><p><strong>1. <code>data</code> 对象 (数据字段)</strong></p><ul><li><p><strong>合并方式：</strong> 浅合并 (Shallow Merge) + 覆盖。</p></li><li><p><strong>冲突解决：</strong></p><ul><li>如果 <code>Behavior</code> 和页面&#x2F;组件都定义了某个同名的数据字段（例如 <code>message</code>），<strong>页面&#x2F;组件中的值会覆盖 <code>Behavior</code> 中的值</strong>。</li><li>如果数据字段是对象，且同名，则整个对象会被替换，而不是深度合并。</li><li>如果只有 <code>Behavior</code> 定义了，则该字段会被合并到页面&#x2F;组件的 <code>data</code> 中。</li><li>如果只有页面&#x2F;组件定义了，则该字段保持不变。</li></ul></li></ul><p><strong>2. <code>properties</code> 对象 (组件属性，仅限组件)</strong></p><ul><li><strong>合并方式：</strong> 浅合并 (Shallow Merge) + 覆盖。</li><li><strong>冲突解决：</strong> 与 <code>data</code> 类似，如果 <code>Behavior</code> 和组件都定义了某个同名属性，<strong>组件中的定义会覆盖 <code>Behavior</code> 中的定义</strong>。</li></ul><p><strong>3. <code>methods</code> 对象 (方法)</strong></p><ul><li><p><strong>合并方式：</strong> 覆盖。</p></li><li><p><strong>冲突解决：</strong> 如果 <code>Behavior</code> 和页面&#x2F;组件都定义了某个同名方法，<strong>页面&#x2F;组件中的方法会覆盖 <code>Behavior</code> 中的方法</strong>。这允许你在特定页面&#x2F;组件中对 <code>Behavior</code> 提供的通用方法进行定制或重写。</p></li></ul><p><strong>4. 生命周期函数 (<code>lifetimes</code>, <code>pageLifetimes</code>)</strong></p><ul><li><p><strong>合并方式：</strong> 顺序执行 (而非覆盖)。</p></li><li><p><strong>冲突解决：</strong></p><ul><li><code>Behavior</code> 中定义的生命周期函数会<strong>先于</strong>页面&#x2F;组件中定义的同名生命周期函数执行。</li><li>如果引入了多个 <code>Behavior</code>，它们的生命周期函数会按照在 <code>behaviors</code> 数组中声明的顺序依次执行，然后再执行页面&#x2F;组件自身的生命周期函数。</li><li><strong>注意：</strong> <code>created</code> 和 <code>attached</code> 是特例，它们在 <code>Behavior</code> 中执行时，<code>this.data</code> 尚未完全合并，可能无法访问到页面&#x2F;组件独有的数据。通常建议在 <code>ready</code> 中进行数据初始化。</li></ul></li></ul><p><strong>5. <code>behaviors</code> 数组 (引入其他 Behavior)</strong></p><ul><li><p><strong>合并方式：</strong> 数组连接 (Concatenation)。</p></li><li><p><strong>冲突解决：</strong> 数组会进行合并。如果一个组件引入了多个 <code>Behavior</code>，并且这些 <code>Behavior</code> 之间也有重叠（例如都定义了 <code>data.a</code>），那么<strong>后引入的 <code>Behavior</code> 会覆盖先引入的 <code>Behavior</code></strong>。最终，页面&#x2F;组件的定义会覆盖所有 <code>Behavior</code> 的定义。</p></li></ul><ol start="6"><li><strong><code>observers</code> (数据监听器，仅限组件)</strong></li></ol><ul><li><strong>合并方式：</strong> 数组连接。</li><li><strong>冲突解决：</strong> <code>Behavior</code> 和组件的 <code>observers</code> 数组会合并。所有定义的监听器都会被执行。</li></ul><ol start="7"><li><strong><code>relations</code> (组件间关系，仅限组件)</strong></li></ol><ul><li><strong>合并方式：</strong> 对象合并。</li><li><strong>冲突解决：</strong> 如果 <code>Behavior</code> 和组件定义了同名的 <code>relations</code> 键，<strong>组件的定义会覆盖 <code>Behavior</code> 的定义</strong>。</li></ul><ol start="8"><li><strong><code>externalClasses</code> (外部样式类，仅限组件)</strong></li></ol><ul><li><strong>合并方式：</strong> 数组连接。</li><li><strong>冲突解决：</strong> <code>Behavior</code> 和组件的 <code>externalClasses</code> 数组会合并。</li></ul><ol start="9"><li><strong><code>options</code> (组件选项，仅限组件)</strong></li></ol><ul><li><strong>合并方式：</strong> 对象合并。</li><li><strong>冲突解决：</strong> 如果 <code>Behavior</code> 和组件定义了同名的 <code>options</code> 键，<strong>组件的定义会覆盖 <code>Behavior</code> 的定义</strong></li></ul><hr><h1 id="外部样式类"><a href="#外部样式类" class="headerlink" title="外部样式类"></a>外部样式类</h1><p>外部样式类本质上是组件内部预留的<strong>占位符类名</strong>。当组件被引用时，外部可以通过一个特定的属性将实际的样式类名传递给这些占位符，从而实现对组件内部元素的样式控制。</p><p>可以把它想象成一个插槽，但这个插槽是用来插入CSS类名的。</p><p>在子组件中定义好默认的样式，但配置额外的样式占位符，并通过externalClasses: [‘custom-class’, ‘text-class’]关键字声明</p><p>在调用组件时，在wxml的模板文件中将外部样式类作为属性传递值，或者直接在父组件的css文件中编辑样式文件即可</p><h3 id="CSS-变量（Custom-Properties）"><a href="#CSS-变量（Custom-Properties）" class="headerlink" title="CSS 变量（Custom Properties）"></a>CSS 变量（Custom Properties）</h3><p>小程序也支持 CSS 变量（<code>--var-name: value;</code>）。在某些场景下，CSS 变量可以作为外部样式类的替代方案，甚至更优：</p><ul><li><strong>外部样式类：</strong> 适用于需要完全替换或添加一组样式规则的场景（如改变背景色、边框、字体等）。它传递的是一个完整的类名。</li><li><strong>CSS 变量：</strong> 适用于需要调整组件内部某个具体样式属性值的场景（如主题色、间距、字体大小等）。它传递的是一个值。</li></ul><p><strong>示例（CSS 变量）：</strong><br>组件内部：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* components/my-button/my-button.wxss */</span><br><span class="hljs-selector-class">.button-wrapper</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">var</span>(--button-bg-color, <span class="hljs-number">#007bff</span>); <span class="hljs-comment">/* 默认蓝色 */</span><br>  <span class="hljs-attribute">padding</span>: <span class="hljs-built_in">var</span>(--button-padding, <span class="hljs-number">10px</span> <span class="hljs-number">20px</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>外部使用：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* pages/index/index.wxss */</span><br>my-<span class="hljs-selector-tag">button</span> &#123;<br>  <span class="hljs-attr">--button-bg-color</span>: red;<br>  <span class="hljs-attr">--button-padding</span>: <span class="hljs-number">5px</span> <span class="hljs-number">10px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>CSS 变量的优势在于它更细粒度，不需要暴露内部的 DOM 结构，更符合“配置”而非“覆盖”的理念。但它不能像外部样式类那样直接添加新的 CSS 规则（比如 <code>border</code>），只能修改已有的属性值。</p><hr>]]></content>
    
    
    <categories>
      
      <category>JAVAWEB</category>
      
      <category>微信小程序</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>微信小程序-自定义组件</title>
    <link href="/2025/07/07/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6/"/>
    <url>/2025/07/07/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><p>开发中常见的组件有两种：<code>公共组件</code>和<code>页面组件</code>，组件在创建好之后需要用不同的方式注册</p><ul><li>全局注册：在app.json文件中配置usingComponents进行注册，注册后可以在任意界面使用</li><li>局部注册：在页面的json文件中配置usingComponents进行注册，注册之后只能在当前页面使用</li></ul><p>与vue不同，小程序单独对页面和组件进行了区分</p><ul><li><strong>小程序：</strong> 强调“轻量级”和“快速开发”，其页面-组件分离的设计在一定程度上简化了对页面级别事件（如下拉刷新、触底加载）的处理，因为这些事件天然属于“页面”的范畴。</li><li><strong>Vue：</strong> 强调“组件化”和“可组合性”，将一切视为组件可以带来更高的灵活性和代码复用性，使得构建复杂、高度定制化的 UI 变得更加容易。</li></ul><hr><h3 id="组件的数据和方法"><a href="#组件的数据和方法" class="headerlink" title="组件的数据和方法"></a>组件的数据和方法</h3><p>组件的数据和方法需要在组件.js的component方法中进行定义，Component创建自定义组件</p><ul><li><p>data：定义组件的内部数据</p></li><li><p>methods：在组件中事件处理程序需要写在methods中才可以</p></li><li><p><strong>properties</strong>：是组件的对外属性，主要用来接收组件使用者传递给组件内的数据，和data一同用于组件的模板渲染</p></li></ul><p><em>properties就像是vue中的props，用于组件的父传子</em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">properties</span>: &#123;<br>  <span class="hljs-attr">extClass</span>: &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,<br>    <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;&#x27;</span><br>  &#125;<br></code></pre></td></tr></table></figure><p>这里的type用来配置数据类型，可使用的数据类型有：String、Number、Boolean、Object、Array</p><p>或者直接配置成null，表示不限制类型</p><p>value用来设置该属性如果没有被传递的默认值</p><hr><h3 id="组件插槽"><a href="#组件插槽" class="headerlink" title="组件插槽"></a>组件插槽</h3><p>小程序的插槽和vue没什么太大区别</p><p>小程序中默认是不支持具名插槽，即多个插槽，需要在component方法中配置options开启multipleSlots</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Component</span>(&#123;<br>  <span class="hljs-attr">options</span>: &#123;<br>    <span class="hljs-attr">multipleSlots</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">// 在组件定义时的选项中启用多slot支持</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>需要注意，微信小程序并没有提供类似vue的作用域插槽，想要实现组件的子传父，需要利用事件来完成</em></p><hr><h3 id="组件样式"><a href="#组件样式" class="headerlink" title="组件样式"></a>组件样式</h3><ul><li>在自定义组件的wxss文件中，不允许使用标签、id、属性选择器，尽量使用类选择器进行样式编辑</li><li>子选择器只能用于view和子组件，用于其他组件可以会出现样式失效的问题</li><li>继承样式、例如color\font都会从组件外继承</li><li>全局样式、组件所在页面的样式文件都对组件无效</li><li>不建议在全局样式文件和页面样式文件中使用标签选择器</li><li>组件和组件使用者，如果使用后代选择器，可能会出现一些非预期情况</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Component</span>(&#123;<br>  <span class="hljs-attr">options</span>: &#123;<br>     <span class="hljs-comment">// 配置组件样式隔离，isolated是默认值，即开启组件隔离</span><br>    <span class="hljs-attr">styleIsolation</span>: <span class="hljs-string">&quot;isolated&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>apply-shared：页面能够影响到组件，但组件内的样式不会影响到页面</p><p>shared：页面和组件的样式会相互影响，还会影响到其他配置为apply-shared和shared的自定义组件</p><hr><h3 id="内部组件的样式修改"><a href="#内部组件的样式修改" class="headerlink" title="内部组件的样式修改"></a>内部组件的样式修改</h3><p>在使用小程序提供的内部组件时，例如checkbox复选框，我们为其直接添加类选择器并进行修改样式是无效的</p><p>先使用小程序官方提供的定制方式，其次通过开发者工具定位内部结构进行精准修改，并始终注意样式作用域。</p><p><strong>优先使用原生组件提供的属性</strong></p><ul><li><strong>思路：</strong> 查阅小程序官方文档，看原生组件是否提供了直接控制样式的属性（如 <code>color</code>、<code>size</code>、<code>checked-color</code> 等）。</li><li><strong>优点：</strong> 最稳定、最兼容、最推荐的方式。</li><li><strong>示例：</strong> <code>checkbox</code> 组件本身没有太多直接的样式属性，但 <code>button</code> 有 <code>size</code>、<code>type</code> 等。</li></ul><p><strong>通过开发者工具定位内部结构进行精准修改（针对 <code>checkbox</code> 等）</strong></p><ul><li><strong>思路：</strong> 当原生组件没有提供直接的样式属性时，利用微信开发者工具的 <strong>WXML 面板</strong>和 <strong>Styles 面板</strong>来检查其渲染后的 DOM 结构，找到可以被修改的内部类名或伪元素。</li><li><strong>步骤：</strong><ol><li>在 <code>wxml</code> 中放置一个 <code>checkbox</code>。</li><li>在开发者工具中，选中 <code>checkbox</code> 元素。</li><li>在右侧的 WXML 面板中展开 <code>checkbox</code> 的内部结构，通常会看到 <code>wx-checkbox-input</code> 这样的类名。</li><li>在 Styles 面板中，查看这些内部类名或伪元素（如 <code>::before</code>, <code>::after</code>）的默认样式。</li></ol></li></ul><hr>]]></content>
    
    
    <categories>
      
      <category>JAVAWEB</category>
      
      <category>微信小程序</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>异步</title>
    <link href="/2025/07/03/%E5%BC%82%E6%AD%A5/"/>
    <url>/2025/07/03/%E5%BC%82%E6%AD%A5/</url>
    
    <content type="html"><![CDATA[<p><em>2025年7月3日，终于将JS的异步请求搞懂</em></p><h3 id="异步调用"><a href="#异步调用" class="headerlink" title="异步调用"></a>异步调用</h3><p>其实异步调用是可以并发性的处理一个需求，这往往会涉及到多线程，lambda表达式的知识点</p><p>异步调用会提前定义一个回调函数，当异步调用返回结果时，再来触发由用户定义的回调函数，实现异步调用</p><p>那么回调函数本身就是非常适合Lambda表达式来完成编写的</p><hr><p>在.NET框架中，有await和async的语法糖来实现异步调用，其本质是多线程</p><p>在Spring的框架中，一个请求严格是一个线程，但可以通过SpringAsync将异步任务交给别的程序执行</p><p>在C#语法中，有委托来解决强类型语言来编写回调函数的问题</p><p>在Java中，有函数式接口来解决强语言类型编写回调函数的问题</p><p>但JS中，无需这些，因为Javascript是弱语言类型，其回调函数可以随便定义</p><hr><p>虽然JS是单线程执行，但可以通过浏览器的多线程去异步的调用一些API，例如Axios就是异步调用</p><p>js的异步操作进行的是相对较多的，在之后为了解决回调地域的问题，ES推出了Promise来解决</p><p>Promise中又提供了catch语法糖，这样，then来解决成功，catch来解决失败，条理已经和清晰明了</p><p>后来，出现了await，async的语法糖，让异步调用结构清晰，使用方便</p><hr><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>举例在Axios的请求中，如果有两个异步操作具有数据依赖关系，我们可以通过await语法糖将其写成类同步的操作，将其有顺序执行</p><p>在并发的异步操作中，我们可以使用多个.then和.catch写多个请求的方式，就是并发的异步请求</p><p>我们也可以通过async语法，在最后promise.all中使用await获取所有异步调用的结果值，也是处理并发的很好方案</p><hr>]]></content>
    
    
    <categories>
      
      <category>JAVAWEB</category>
      
      <category>微信小程序</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>微信小程序-API</title>
    <link href="/2025/07/03/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-API/"/>
    <url>/2025/07/03/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-API/</url>
    
    <content type="html"><![CDATA[<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>小程序的API分三种</p><ul><li>异步API</li><li>同步API</li><li>事件监听API</li></ul><hr><h3 id="网络请求API"><a href="#网络请求API" class="headerlink" title="网络请求API"></a>网络请求API</h3><p>发起网络请求，微信小程序提供了wx.request()，这就是一个异步的API</p><p><strong>wx.request请求的域名必须在微信公众平台进行配置</strong></p><p><code>wx.request(Object object)</code> 接受一个配置对象作为参数，其中包含以下常用属性：</p><ul><li><p><strong><code>url</code> (String):</strong> <strong>必填。</strong> 开发者服务器接口地址。</p></li><li><p><strong><code>method</code> (String):</strong> 请求方法，默认为 <code>&#39;GET&#39;</code>。可选值有 <code>&#39;GET&#39;</code>, <code>&#39;POST&#39;</code>, <code>&#39;PUT&#39;</code>, <code>&#39;DELETE&#39;</code>, <code>&#39;HEAD&#39;</code>, <code>&#39;OPTIONS&#39;</code>, <code>&#39;TRACE&#39;</code>, <code>&#39;CONNECT&#39;</code>。</p></li><li><p><code>data</code> (Object&#x2F;String&#x2F;ArrayBuffer):请求的参数。</p><ul><li>对于 <code>GET</code> 请求，<code>data</code> 会自动拼接在 <code>url</code> 后面作为查询参数。</li><li>对于 <code>POST</code> 请求，<code>data</code> 会放在请求体中。</li><li>如果 <code>header</code> 中 <code>Content-Type</code> 为 <code>application/json</code>，<code>data</code> 会自动转换为 JSON 字符串。</li></ul></li><li><p><code>header</code> (Object):设置请求的&#96;header&#96;&#96;</p><ul><li><p>&#96;&#96;header<code>中不能设置  </code>Referer&#96;</p></li><li><p>常用设置：<code>&#39;Content-Type&#39;: &#39;application/json&#39;</code> 或 <code>&#39;Content-Type&#39;: &#39;application/x-www-form-urlencoded&#39;</code>。</p></li><li><p>也可以设置 <code>Authorization</code> 等认证信息。</p></li></ul></li><li><p><code>success</code> (Function):接口调用成功的回调函数。</p><ul><li><p>回调参数<code>res</code></p><p>对象包含：</p><ul><li><code>res.data</code>: 服务器返回的数据。</li><li><code>res.statusCode</code>: HTTP 状态码（如 200, 404, 500）。</li><li><code>res.header</code>: 服务器返回的 <code>header</code>。</li></ul></li></ul></li><li><p><code>fail</code> (Function):接口调用失败的回调函数（通常是网络问题、超时、域名不合法等）。</p><ul><li>回调参数 <code>err</code> 对象包含错误信息。</li></ul></li><li><p><strong><code>complete</code> (Function):</strong> 接口调用结束的回调函数（无论成功或失败都会调用）。常用于隐藏加载提示。</p></li><li><p><strong><code>timeout</code> (Number):</strong> 超时时间，单位毫秒。默认为 60000ms (60秒)。</p></li></ul><hr><h3 id="界面交互-loading提示框"><a href="#界面交互-loading提示框" class="headerlink" title="界面交互-loading提示框"></a>界面交互-loading提示框</h3><p>小程序提供了wx.showLoading()和wx.hideLoading()来开启&#x2F;关闭加载提示框</p><p>配合wx.request可以实现在发送请求时显示提示框</p><ul><li><code>title</code> (String): <strong>必填。</strong> 提示的内容，例如 <code>&#39;加载中...&#39;</code>。</li><li><code>mask</code> (Boolean): 可选。是否显示透明蒙层，防止触摸穿透。默认为 <code>false</code>。建议设置为 <code>true</code>，以防止用户在加载时误触页面元素。</li></ul><p>配合wx.request的 complete回调方法，在其中实现关闭提示框即可</p><hr><h3 id="界面交互-模态对话框和消息提示框"><a href="#界面交互-模态对话框和消息提示框" class="headerlink" title="界面交互-模态对话框和消息提示框"></a>界面交互-模态对话框和消息提示框</h3><p>wx.showModal()：模态对话框，常用与询问用户是否执行一些操作</p><p>wx.showToast()：消息提示框，根据用户的操作来告知操作的结果</p><hr><h3 id="本地存储"><a href="#本地存储" class="headerlink" title="本地存储"></a>本地存储</h3><p>小程序的本地存储有同步存储和异步存储两种方式</p><p>小程序中的同步&#x2F;异步存储（<code>wx.setStorageSync</code>&#x2F;<code>wx.setStorage</code> 等相当于浏览器中的本地存储（<code>localStorage</code>&#x2F;<code>sessionStorage</code>）。</p><hr><h3 id="编程式路由"><a href="#编程式路由" class="headerlink" title="编程式路由"></a>编程式路由</h3><p>除了使用navigator属性进行声明式路由外，可以使用编程式路由API进行跳转</p><hr><h3 id="上拉加载"><a href="#上拉加载" class="headerlink" title="上拉加载"></a>上拉加载</h3><p>在json文件中配置上拉加载高度</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;onReachBottomDistance&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><p>将数据更改和推送的逻辑写在onReachBottom方法中，通过vx:for来实现页面的实时变更</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Page</span>(&#123;<br>  <span class="hljs-attr">data</span>:&#123;<br>    <span class="hljs-attr">numList</span>: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>  &#125;,<br>  <span class="hljs-title function_">onReachBottom</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">const</span> lastNum = <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>.<span class="hljs-property">numList</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>.<span class="hljs-property">numList</span>.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">const</span> newArr = [lastNum+<span class="hljs-number">1</span>, lastNum+<span class="hljs-number">2</span>,lastNum+<span class="hljs-number">3</span>]<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setData</span>(&#123;<br>      <span class="hljs-attr">numList</span>: [...<span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>.<span class="hljs-property">numList</span> , ...newArr]<br>    &#125;);<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><hr><h3 id="下拉刷新"><a href="#下拉刷新" class="headerlink" title="下拉刷新"></a>下拉刷新</h3><p>在json中配置允许下拉刷新</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;enablePullDownRefresh&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br></code></pre></td></tr></table></figure><p>将重新获取数据的逻辑写在方法中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">onPullDownRefresh</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setData</span>(&#123;<br>    <span class="hljs-comment">// 重新获取数据</span><br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="Scroll-view组件"><a href="#Scroll-view组件" class="headerlink" title="Scroll-view组件"></a>Scroll-view组件</h3><p>使用scroll-view组件实现下拉加载更多</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">scroll-view</span> </span><br><span class="hljs-tag"><span class="hljs-attr">scroll-y</span> </span><br><span class="hljs-tag"><span class="hljs-attr">class</span>=<span class="hljs-string">&quot;scroll-y&quot;</span> </span><br><span class="hljs-tag"></span><br><span class="hljs-tag"><span class="hljs-attr">lower-threshold</span>=<span class="hljs-string">&quot;100&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">bindscrolltolower</span>=<span class="hljs-string">&quot;getMore&quot;</span>&gt;</span> <br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">getMore</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">const</span> lastNum = <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>.<span class="hljs-property">numList</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>.<span class="hljs-property">numList</span>.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>]<br>  <span class="hljs-keyword">const</span> newArr = [lastNum+<span class="hljs-number">1</span>, lastNum+<span class="hljs-number">2</span>,lastNum+<span class="hljs-number">3</span>]<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setData</span>(&#123;<br>    <span class="hljs-attr">numList</span>: [...<span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>.<span class="hljs-property">numList</span> , ...newArr]<br>  &#125;);<br>&#125;,<br></code></pre></td></tr></table></figure><p>组件中提供enable-back-to-top属性，可以点击标题返回至顶部</p><p>组件中提供refresher-enabled属性，可以配置下拉刷新</p><p>通过refresher-*来配置下拉刷新的样式refresher-enabled&#x3D;</p><p>通过bindrefresherrefresh属性配置下拉刷新要执行的逻辑</p><p>refresher-triggered属性配置下拉刷新的状态</p><hr>]]></content>
    
    
    <categories>
      
      <category>JAVAWEB</category>
      
      <category>微信小程序</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>微信小程序-生命周期</title>
    <link href="/2025/07/03/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <url>/2025/07/03/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="启动状态"><a href="#启动状态" class="headerlink" title="启动状态"></a>启动状态</h1><p>小程序分为两个启动状态，第一个是冷启动，第二个是热启动</p><p>小程序进入后台状态5s后，微信停止小程序JS的线程执行，小程序进入挂起状态。但当开发者使用了后台播放音乐，后台地理位置等能力，小程序在后台持续运行，不会挂起</p><p>小程序在挂起阶段持续30分钟之后，微信会将小程序销毁，即完全停止运行</p><hr><h1 id="小程序更新机制"><a href="#小程序更新机制" class="headerlink" title="小程序更新机制"></a>小程序更新机制</h1><p>启动时同步更新：微信运行时，会定期检查最近使用的小程序是否有更新。</p><p>启动时异步更新：每次冷启动时，都会进行异步检查是否有更新版本，如果发现有新版本将在下一次启动时更新使用新版本</p><p>在启动时异步更新的情况下，如果开发者希望立刻进行版本更新，可以使用wx.getUpdateManagerAPI进行处理</p><hr><h1 id="小程序的生命周期"><a href="#小程序的生命周期" class="headerlink" title="小程序的生命周期"></a>小程序的生命周期</h1><p>与vue相同，小程序也提供了生命周期钩子</p><h3 id="应用的生命周期"><a href="#应用的生命周期" class="headerlink" title="应用的生命周期"></a>应用的生命周期</h3><p>应用生命周期函数要定义在app.js文件中的App()方法中进行定义</p><p>应用生命周期伴随一些函数，我们称为应用生命周期函数，应用生命周期函数需要在app.js文件的App()方法中进行定义</p><p>App()方法必须在app.js中进行调用，主要用来注册小程序</p><ul><li>onLaunch</li><li>onShow</li><li>onHide</li></ul><p>小程序如果被销毁，重新冷启动则会运行onLaunch生命周期，如果是后台切前台的热启动则会运行onShow生命周期</p><h3 id="页面的生命周期"><a href="#页面的生命周期" class="headerlink" title="页面的生命周期"></a>页面的生命周期</h3><p>页面生命周期就是指小程序页面从加载-&gt;运行-&gt;销毁的整个过程</p><p>页面生命周期函数需要在Page()方法中进行定义</p><ul><li>onLoad：监听页面加载</li><li>onShow：鉴听页面展示</li><li>onReady：监听初次渲染完成</li><li>onHide：监听页面隐藏</li><li>onUnload：监听页面卸载</li></ul><p>需要注意的是，onLoad和onReady函数一个页面只会执行一次</p><p>当页面来回切换时，没有页面被销毁，只会被隐藏</p><p>当点击左上角进行回退操作时，会销毁当前页面，展示前一个页面</p><hr>]]></content>
    
    
    <categories>
      
      <category>JAVAWEB</category>
      
      <category>微信小程序</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>微信小程序-列表和条件渲染</title>
    <link href="/2025/07/03/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E5%88%97%E8%A1%A8%E5%92%8C%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/"/>
    <url>/2025/07/03/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E5%88%97%E8%A1%A8%E5%92%8C%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/</url>
    
    <content type="html"><![CDATA[<h1 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h1><p>在组件中使用wx:for属性绑定一个数组或对象，即可使用每一项数据重复渲染当前的组件</p><p>每一项的变量默认名为item，下标变量默认名为index</p><p>建议使用wx:key属性</p><ul><li><strong>字符串：</strong> 如果循环项是对象，并且对象中有一个唯一的属性（如 <code>id</code>），可以直接指定该属性名作为 <code>wx:key</code> 的值，例如 <code>wx:key=&quot;id&quot;</code>。</li><li><strong><code>*this</code>：</strong> 如果循环项本身就是唯一的字符串或数字，可以使用 <code>*this</code> 作为 <code>wx:key</code> 的值，例如 <code>wx:key=&quot;*this&quot;</code>。</li></ul><p><em>如果列表对象中没有id属性，则使用index做替代</em></p><hr><h3 id="block"><a href="#block" class="headerlink" title="block"></a>block</h3><p>等同于vue中的template，小程序也提供了block标签供wx:if和wx:for组合使用</p><hr><h1 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h1><ul><li><p>wx:if、wx:elif、wx:else属性组实现</p></li><li><p>使用hideen属性实现</p></li></ul><p>hidden的用法与v-show相同</p><hr>]]></content>
    
    
    <categories>
      
      <category>JAVAWEB</category>
      
      <category>微信小程序</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>微信小程序-事件和数据</title>
    <link href="/2025/07/02/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E4%BA%8B%E4%BB%B6%E5%92%8C%E6%95%B0%E6%8D%AE/"/>
    <url>/2025/07/02/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E4%BA%8B%E4%BB%B6%E5%92%8C%E6%95%B0%E6%8D%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><h3 id="绑定事件"><a href="#绑定事件" class="headerlink" title="绑定事件"></a>绑定事件</h3><p>绑定事件的方式有两种</p><ul><li>bind:事件名</li><li>bind事件名</li></ul><p>在vue中，单击事件是click，而小程序是tap</p><p>事件处理函数要写到.js文件中，需要用小程序提供的Page方法来注册页面，可以在Page方法中创建事件处理函数</p><hr><h3 id="冒泡事件"><a href="#冒泡事件" class="headerlink" title="冒泡事件"></a>冒泡事件</h3><p>使用bind绑定的事件，会触发事件冒泡</p><p> 如果不想让事件冒泡，就使用catch来绑定事件</p><hr><h3 id="事件传参"><a href="#事件传参" class="headerlink" title="事件传参"></a>事件传参</h3><p>在触发事件时，将一些数据作为参数传递给事件处理函数的过程，就是事件传参</p><p>data-*&#x3D;””，使用这个属性来传递自定义数据</p><p>mark:*&#x3D;””，使用这个属性来传递自定义参数</p><p>通过事件对象获取mark传递参数时，会冒泡传递，即会获取到触发节点事件和父节点身上的所有mark</p><hr><h3 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h3><p>event对象中，会有很多属性</p><ul><li>currentTarget：事件绑定者</li><li>Target：事件触发者</li></ul><p>当事件冒泡时，两者就有了差别</p><p>事件对象中绑定的数据key使用中划线<code>-</code>分割，在事件对象中采用小驼峰写法转换</p><p>事件对象中绑定的数据key使用小驼峰写法，在事件对象中采用全小写写法转换</p><hr><h1 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h1><p>小程序页面中使用的数据需要在Page()方法的data对象中进行声明定义</p><p>在wxml中使用mustache语法（双大括号<code>&#123;&#123;&#125;&#125;</code>）将变量包起来，从而将数据绑定</p><p>不同于vue，如果需要动态绑定组件中的属性，同样也使用双大括号<code>&#123;&#123;&#125;&#125;</code></p><hr><h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><p>小程序中不使用赋值的方式修改数据，而是使用setData()函数来修改数据</p><p><strong>修改对象中的数据</strong></p><p>如果给对象新增属性，可以将key写成数据路径的方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// index.js</span><br><span class="hljs-title class_">Page</span>(&#123;<br>  <span class="hljs-attr">data</span>:&#123;<br>    <span class="hljs-attr">userInfo</span>:&#123;<br>      <span class="hljs-attr">name</span>:<span class="hljs-string">&quot;xiaobai&quot;</span>,<br>      <span class="hljs-attr">age</span>:<span class="hljs-string">&quot;18&quot;</span><br>    &#125;<br>  &#125;,<br>  <span class="hljs-title function_">updateUserInfo</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setData</span>(&#123;<br>      <span class="hljs-string">&quot;userInfo.name&quot;</span> : <span class="hljs-string">&quot;小白&quot;</span>,<br>      <span class="hljs-string">&quot;userInfo.age&quot;</span>: <span class="hljs-number">24</span><br>    &#125;)<br>  &#125;<br>&#125;)<br><br></code></pre></td></tr></table></figure><p>这样将数据展开写在setData中的行为不是狠优雅，我们可以使用ES6的展开运算符准备一个新的userInfo对象，然后通过setData完成对象的拷贝</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// index.js</span><br><span class="hljs-title class_">Page</span>(&#123;<br>  <span class="hljs-attr">data</span>:&#123;<br>    <span class="hljs-attr">userInfo</span>:&#123;<br>      <span class="hljs-attr">name</span>:<span class="hljs-string">&quot;xiaobai&quot;</span>,<br>      <span class="hljs-attr">age</span>:<span class="hljs-string">&quot;18&quot;</span><br>    &#125;<br>  &#125;,<br>  <span class="hljs-title function_">updateUserInfo</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">const</span> userInfo = &#123;<br>      ...<span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>.<span class="hljs-property">userInfo</span>,<br>      <span class="hljs-attr">name</span>:<span class="hljs-string">&quot;小白&quot;</span>,<br>      <span class="hljs-attr">age</span>:<span class="hljs-string">&quot;24&quot;</span><br>    &#125;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setData</span>(&#123;<br>      <span class="hljs-comment">// &quot;userInfo&quot; : userInfo简写成以下</span><br>      userInfo<br>    &#125;)<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>我们还可以通过Object.assign方法将多个对象合并到同一个对象，其中后覆盖前</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// index.js</span><br><span class="hljs-title class_">Page</span>(&#123;<br>  <span class="hljs-attr">data</span>:&#123;<br>    <span class="hljs-attr">userInfo</span>:&#123;<br>      <span class="hljs-attr">name</span>:<span class="hljs-string">&quot;xiaobai&quot;</span>,<br>      <span class="hljs-attr">age</span>:<span class="hljs-string">&quot;18&quot;</span><br>    &#125;<br>  &#125;,<br>  <span class="hljs-title function_">updateUserInfo</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">const</span> userInfo = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>.<span class="hljs-property">userInfo</span>,&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;小白&quot;</span>&#125;,&#123;<span class="hljs-attr">age</span>:<span class="hljs-number">24</span>&#125;)<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setData</span>(&#123;<br>      <span class="hljs-comment">// &quot;userInfo&quot; : userInfo简写成以下</span><br>      userInfo<br>    &#125;)<br>  &#125;<br>&#125;)<br><br></code></pre></td></tr></table></figure><p><strong>数组相同，其本质是先组织数据，然后用setData更新页面</strong></p><hr><h3 id="双向绑定"><a href="#双向绑定" class="headerlink" title="双向绑定"></a>双向绑定</h3><p>在input、checkbox等组件中，使用model:来修饰value属性，搭配<code>&#123;&#123;&#125;&#125;</code>，就能完成简易的双向绑定</p><hr>]]></content>
    
    
    <categories>
      
      <category>JAVAWEB</category>
      
      <category>微信小程序</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>sass</title>
    <link href="/2025/07/02/sass/"/>
    <url>/2025/07/02/sass/</url>
    
    <content type="html"><![CDATA[<h1 id="Sass"><a href="#Sass" class="headerlink" title="Sass"></a>Sass</h1><p>Sass (Syntactically Awesome Style Sheets) 是一种 CSS 预处理器。它不是直接在浏览器中运行的，而是需要通过编译（或转译）生成标准的 CSS 文件，然后浏览器才能识别和渲染。</p><p>它扩展了 CSS 的功能，引入了变量、嵌套、混合（Mixins）、函数、继承等编程特性。</p><h3 id="核心特性"><a href="#核心特性" class="headerlink" title="核心特性"></a>核心特性</h3><p><strong>变量 (Variables)</strong></p><ul><li><p><strong>概念：</strong> 用 <code>$name</code> 定义一个值，可以在样式表中多次使用。</p></li><li><p><strong>用途：</strong> 统一管理颜色、字体、间距等常用值，方便修改。</p></li><li><p>示例：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs scss">SCSS<span class="hljs-variable">$primary-color</span>: <span class="hljs-number">#3498db</span>;<br><span class="hljs-variable">$font-stack</span>: Helvetica, sans-serif;<br><br><span class="hljs-selector-tag">body</span> &#123;<br>  <span class="hljs-attribute">font</span>: <span class="hljs-number">100%</span> <span class="hljs-variable">$font-stack</span>;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-variable">$primary-color</span>;<br>&#125;<br><br><span class="hljs-selector-class">.button</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-variable">$primary-color</span>;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span> <span class="hljs-number">20px</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><strong>嵌套 (Nesting)</strong></p><ul><li><p><strong>概念：</strong> 将选择器嵌套在另一个选择器内部，模拟 HTML 的层级结构。</p></li><li><p><strong>用途：</strong> 提高代码的可读性和组织性，减少重复选择器。</p></li><li><p><strong>注意：</strong> 不要过度嵌套，通常不超过三层。<code>&amp;</code> 符号代表父选择器。</p></li><li><p>示例：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs scss">SCSSnav &#123;<br>  <span class="hljs-selector-tag">ul</span> &#123;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">list-style</span>: none;<br><br>    <span class="hljs-selector-tag">li</span> &#123;<br>      <span class="hljs-attribute">display</span>: inline-block;<br>      <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">10px</span>;<br><br>      <span class="hljs-selector-tag">a</span> &#123;<br>        <span class="hljs-attribute">display</span>: block;<br>        <span class="hljs-attribute">padding</span>: <span class="hljs-number">5px</span> <span class="hljs-number">10px</span>;<br>        <span class="hljs-selector-tag">text</span>-decoration: none;<br>        <span class="hljs-attribute">color</span>: <span class="hljs-number">#333</span>;<br><br>        &amp;<span class="hljs-selector-pseudo">:hover</span> &#123; <span class="hljs-comment">// &amp; 代表父选择器 a</span><br>          <span class="hljs-attribute">color</span>: <span class="hljs-number">#007bff</span>;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><strong>局部文件与导入 (Partials &amp; Import)</strong></p><ul><li><strong>概念：</strong> 将 Sass 代码拆分成多个小文件（局部文件，文件名以下划线 <code>_</code> 开头），然后使用 <code>@import</code> 规则导入到主文件中。</li><li><strong>用途：</strong> 模块化管理代码，提高可维护性。</li></ul><p><strong>混合 (Mixins)</strong></p><ul><li><strong>概念：</strong> 使用 <code>@mixin</code> 定义一组可重用的 CSS 声明，然后使用 <code>@include</code> 引入。可以接受参数。</li><li><strong>用途：</strong> 封装重复的样式块，特别是那些需要参数来调整的样式（如响应式断点、CSS3 前缀等）。</li></ul><p><strong>继承 (Extend&#x2F;Inheritance)</strong></p><ul><li><strong>概念：</strong> 使用 <code>@extend</code> 关键字，让一个选择器继承另一个选择器的所有样式。</li><li><strong>用途：</strong> 减少重复代码，但与 Mixin 的侧重点不同。Mixin 是复制样式，Extend 是共享样式（在编译后的 CSS 中会合并选择器）。</li><li><strong>注意：</strong> 谨慎使用，过度使用可能导致生成的 CSS 文件过大或选择器过于复杂。通常用于语义化相似但样式略有不同的元素。</li></ul><p><strong>函数 (Functions)</strong></p><ul><li><p><strong>概念：</strong> 使用 <code>@function</code> 定义可执行计算并返回值的代码块。</p></li><li><p><strong>用途：</strong> 处理颜色、单位转换、数学计算等。</p></li><li><p>示例：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scss">SCSS<span class="hljs-keyword">@function</span> em(<span class="hljs-variable">$pixels</span>, <span class="hljs-variable">$context</span>: <span class="hljs-number">16px</span>) &#123;<br>  <span class="hljs-keyword">@return</span> (<span class="hljs-variable">$pixels</span> / <span class="hljs-variable">$context</span>) * <span class="hljs-number">1em</span>;<br>&#125;<br><br><span class="hljs-selector-class">.title</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-built_in">em</span>(<span class="hljs-number">24px</span>); <span class="hljs-comment">// 转换为 1.5em</span><br>  <span class="hljs-selector-tag">line</span>-<span class="hljs-attribute">height</span>: <span class="hljs-built_in">em</span>(<span class="hljs-number">36px</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><strong>控制指令 (Control Directives)</strong></p><ul><li><p><strong>概念：</strong> Sass 提供了 <code>@if</code>, <code>@for</code>, <code>@each</code>, <code>@while</code> 等指令，用于实现条件判断和循环。</p></li><li><p><strong>用途：</strong> 生成复杂的、有规律的样式。</p></li><li><p>示例 (以 @for 为例)：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss">SCSS<span class="hljs-keyword">@for</span> <span class="hljs-variable">$i</span> from <span class="hljs-number">1</span> through <span class="hljs-number">3</span> &#123;<br>  <span class="hljs-selector-class">.item-</span>#&#123;<span class="hljs-variable">$i</span>&#125; &#123; <span class="hljs-comment">// #&#123;&#125; 用于插值，将变量值插入到字符串中</span><br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">10px</span> * <span class="hljs-variable">$i</span>;<br>  &#125;<br></code></pre></td></tr></table></figure></li></ul><hr><p>其中，嵌套、变量、混合、局部导入这四个核心特性构成了Sass的核心竞争力</p><hr>]]></content>
    
    
    <categories>
      
      <category>JAVAWEB</category>
      
      <category>微信小程序</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>微信小程序</title>
    <link href="/2025/07/01/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    <url>/2025/07/01/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="微信小程序"><a href="#微信小程序" class="headerlink" title="微信小程序"></a>微信小程序</h1><p>微信小程序对比一些市面上流行的前端框架多一个自己的json配置文件</p><ul><li>app.json：小程序全局配置文件，配置小程序的一些全局属性和页面路由</li><li>页面.json：小程序页面配置文件，也称局部配置文件，配置当前页面的窗口样式、页面标题等</li><li>project.config.json：小程序项目配置文件，用于保存项目的一些配置信息和开发者的个人设置</li><li>sitemap.json：配置小程序及其页面是否允许被微信索引，提高小程序在搜索引擎中搜索到的概率</li></ul><p><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/">微信小程序配置文件</a></p><hr><h3 id="app-json"><a href="#app-json" class="headerlink" title="app.json"></a>app.json</h3><p><strong>pages字段</strong></p><p>用来指定小程序由哪些页面组成，用于让小程序知道哪些页面组成以及页面定义在哪个目录，每一项都对应一个页面的路由信息</p><ul><li>页面路由不需要写后缀名，框架会自动寻找对应的四个文件进行处理</li><li>小程序中新增，减少页面，都需要修改pages数组，也可以通过这个字段来添加页面</li><li>未指定entryPagePath是，数组的第一项为小程序的首页</li></ul><hr><p><strong>window字段</strong></p><p>用于设置小程序的状态栏、导航条、标题、窗口背景色</p><hr><p><strong>tabbar字段</strong></p><p>通过tabBar配置项指定tab栏的表现，以及tab切换时显示得到对应页面</p><p>tab按数组的顺序排序，list配置最少2个，最多5个</p><ul><li>text：分类</li><li>pagePath：路由跳转</li><li>iconPath：未选中图标</li><li>selectedIconPath：已选中图标</li></ul><hr><h3 id="页面配置"><a href="#页面配置" class="headerlink" title="页面配置"></a>页面配置</h3><p>页面配置的属性和全局配置基本相同，但相同的配置项会覆盖掉全局配置</p><hr><h3 id="项目配置文件"><a href="#项目配置文件" class="headerlink" title="项目配置文件"></a>项目配置文件</h3><p>project.config.json和project.private.config.json</p><p>project.config.json是项目共有配置，常用来进行配置的公共配置</p><p>project.private.config.json是项目私有配置，常用来配置个人的配置</p><p><em>注：个人配置需要写到.gitignore文件中避免上传到仓库</em></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;useCompilerPlugins&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;sass&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 开启sass支持</span><br></code></pre></td></tr></table></figure><hr><h3 id="sitemap-json"><a href="#sitemap-json" class="headerlink" title="sitemap.json"></a>sitemap.json</h3><p>配置小程序及其页面是否允许被微信索引，提高小程序在微信内部被用户搜索到的概率</p><ul><li>没有sitemaap.json则默认所有页面都能被索引</li><li>{“action”:”allow”,”page”:”*”}</li></ul><p><em>这个文件一般不需要配置，默认即可</em></p><hr><h1 id="样式和组件"><a href="#样式和组件" class="headerlink" title="样式和组件"></a>样式和组件</h1><p>WXML提供了view、text、image、navigator等表现构建页面结构，只不过在小程序中将标签识别为组件</p><p>WXSS对CSS扩充和修改，新增了尺寸单位rpx、提供了全局的样式和局部样式，另外需要注意的是WXSS仅支持部分选择器</p><hr><h3 id="rpx"><a href="#rpx" class="headerlink" title="rpx"></a>rpx</h3><p>随着收集发展，收集设备的宽度多元化，为了解决屏幕适配的问题，微信小程序推出了rpx单位</p><p>小程序规定，任何宽度的收集屏幕的rpx参数都是750</p><p>iphone6作为视觉稿的标准，iphone6设备宽度为375px，在这种情况下，px和rpx的换算标准为1rpx&#x3D;0.5px</p><hr><h3 id="全局样式"><a href="#全局样式" class="headerlink" title="全局样式"></a>全局样式</h3><p>app.wxss是全局样式，局部样式可以替换掉全局样式</p><hr><h3 id="常用组件"><a href="#常用组件" class="headerlink" title="常用组件"></a>常用组件</h3><p><strong>view组件</strong></p><p>小程序提供的容器组件，可以直接当成div使用</p><p><strong>swiper和swiper-item组件</strong></p><p>通过这两个组件来实现轮播图</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">swiper</span></span><br><span class="hljs-tag">  <span class="hljs-attr">autoplay</span>          &lt;!<span class="hljs-attr">--</span> <span class="hljs-attr">是否自动播放</span>。<span class="hljs-attr">如果设置为</span> <span class="hljs-attr">true</span>，<span class="hljs-attr">轮播图会自动切换到下一张</span>。 <span class="hljs-attr">--</span>&gt;</span><br>  circular          <span class="hljs-comment">&lt;!-- 是否采用衔接滑动。如果设置为 true，当滑到最后一张时，会无缝切换回第一张，形成无限循环。 --&gt;</span><br>  indicator-dots    <span class="hljs-comment">&lt;!-- 是否显示面板指示点。这些小点通常显示在轮播图底部，用于指示当前是第几张以及总共有多少张。 --&gt;</span><br>  interval=&quot;2000&quot;   <span class="hljs-comment">&lt;!-- 自动播放间隔时间，单位为毫秒 (ms)。这里设置为 2000ms，即每 2 秒切换一次。 --&gt;</span><br>  indicator-color=&quot;#fff&quot; <span class="hljs-comment">&lt;!-- 指示点的颜色。这里设置为白色 (#fff)，表示未选中状态的指示点颜色。 --&gt;</span><br>  indicator-active-color=&quot;#000&quot; <span class="hljs-comment">&lt;!-- 当前选中指示点的颜色。这里设置为黑色 (#000)，表示当前显示页面的指示点颜色。 --&gt;</span><br>&gt;<br></code></pre></td></tr></table></figure><p><strong>image组件</strong></p><ul><li>src属性：图片资源地址</li><li>mode属性：图片裁剪、缩放的模式<ul><li>top、left这种方位会裁切图片</li><li>aspectFill以短边裁切</li><li>aspectFit以长边裁切</li></ul></li><li>show-menu-by-long-press属性：长安图片显示菜单</li><li>lazy-load属性：图片懒加载</li></ul><p><em>注：在微信小程序中，image组件具有默认的宽和高，宽320px，高240px</em></p><p><strong>text组件</strong></p><ul><li>user-select：文本是否可选，用于长按选择文本</li><li>space：显示连续空格</li></ul><p>除了文本组件之外的其他组件都无法长按选中文本，且text组件内仅支持text嵌套</p><p><strong>navigator组件</strong></p><p>在小程序中如果想要完成跳转连接，需要使用navigator插件</p><ul><li>url：当前小程序的跳转连接</li><li>open-type：跳转方式<ul><li>navigate：保留当前页面，跳转到应用内的某个页面，但不能跳转到tabbar页面</li><li>redirect：关闭当前页面，跳转到应用内的某个页面，但不能跳转到tabbar页面</li><li>switchTab：跳转到tabBar页面，并关闭其他所有非tabBar页面</li><li>reLaunch：关闭所有页面，打开到应用内的某个页面</li><li>navigateBack：关闭当前页面，返回上一页面或多级页面</li></ul></li></ul><p>路径后可以带有参数，在onLoad(options)生命周期函数中获取传递的参数，但open-type&#x3D;”switchTab”时不支持传参</p><p><strong>scroll-view组件</strong></p><p>可滚动视图区域，适用于需要滚动展示内容的场景，用于在小程序中实现类似于网页中的滚动条效果</p><ul><li>scroll-x：横向滚动</li><li>scroll-y：纵向滚动</li></ul><p><strong>字体图标</strong></p><p>在小程序中，我们推荐项目中不使用本地svg图标，而是从阿里的图标库中获取，导入样式文件之后在线引用</p><hr><p>微信小程序的背景图不可以使用本地文件，可以使用网络格式或base64格式</p><hr>]]></content>
    
    
    <categories>
      
      <category>JAVAWEB</category>
      
      <category>微信小程序</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Elasticsearch</title>
    <link href="/2025/06/30/Elasticsearch/"/>
    <url>/2025/06/30/Elasticsearch/</url>
    
    <content type="html"><![CDATA[<h1 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h1><p><a href="https://lucene.apache.org/">Lucene是一个Java语言的搜索引擎类库，是Apache公司的顶级项目</a></p><ul><li>易扩展</li><li>高性能（基于倒排序索引）</li></ul><p>2004年Shay Banon基于Lucene开发了Compass</p><p>2010年Shay Banon重写了Compass，并取名为Elasticsearch</p><p><a href="https://www.elastic.co/elasticsearch">OPEN SOURCE SEARCH, ANALYTICS, AND AI PLATFORM</a></p><ul><li>支持分布式，可水平扩展</li><li>提供Restful接口，可以被任何语言调用</li></ul><hr>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
      <category>SpringCloud</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ-高级</title>
    <link href="/2025/06/26/RabbitMQ-%E9%AB%98%E7%BA%A7/"/>
    <url>/2025/06/26/RabbitMQ-%E9%AB%98%E7%BA%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="MQ高级"><a href="#MQ高级" class="headerlink" title="MQ高级"></a>MQ高级</h1><h3 id="发送者的可靠性"><a href="#发送者的可靠性" class="headerlink" title="发送者的可靠性"></a>发送者的可靠性</h3><p><strong>发送者重连</strong></p><p>有的时候由于网络波动，可能出现发送者连接MQ失败的情况。通过配置我们可以开启连接失败后的重连机制（这个设置默认是关闭的）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">connection-timeout:</span> <span class="hljs-string">1s</span> <span class="hljs-comment"># 设置MQ的连接超时时间</span><br>    <span class="hljs-attr">template:</span><br>      <span class="hljs-attr">retry:</span><br>        <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 开启超时重试机制</span><br>        <span class="hljs-attr">initial-interval:</span> <span class="hljs-string">1000ms</span> <span class="hljs-comment"># 失败后的初始等待时间</span><br>        <span class="hljs-attr">multiplier:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 失败后下次的等待时长倍数, 下次等待时长 = initial-interval * multiplier</span><br>        <span class="hljs-attr">max-attempts:</span> <span class="hljs-number">3</span> <span class="hljs-comment"># 最大重试次数</span><br></code></pre></td></tr></table></figure><hr><p><strong>发送者确认</strong></p><p>Spring AMQP提供了Publisher Confirm 和 Publisher Return两种机制</p><ul><li>消息投递到MQ，但路由失败，Publisher Retuen返回路由异常，但返回ACK，告知投递成功<ul><li>临时消息投递到MQ，并且入队成功，返回ACK，告知投递成功</li></ul></li><li>持久消息投递到MQ，并且入队完成持久话，返 回ACK，告知投递成功</li><li>其他情况都返回NACK，告知投递失败</li></ul><p><strong>通过配置来开启发送者确认机制</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span> <br>  <span class="hljs-attr">publisher-confirm-type:</span> <span class="hljs-string">correlated</span><br>  <span class="hljs-attr">publisher-returns:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>这里的publisher-confirm-type有三种模式可选：</p><ul><li>none：关闭confirm机制</li><li>simple：同步阻塞等待MQ的回执消息</li><li>correlated： MQ异步回调方式返回回执消息</li></ul><p><strong>编写配置类为RabbitTemplate添加ReturnCallback</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostConstruct</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initRabbitTemplate</span><span class="hljs-params">()</span> &#123;<br>    rabbitTemplate.setReturnsCallback(returnedMessage -&gt; &#123;<br>        log.error(<span class="hljs-string">&quot;触发return callback&quot;</span>);<br>        log.debug(<span class="hljs-string">&quot;exchange:&#123;&#125;&quot;</span>,returnedMessage.getExchange());<br>        log.debug(<span class="hljs-string">&quot;routingKey:&#123;&#125;&quot;</span>,returnedMessage.getRoutingKey());<br>        log.debug(<span class="hljs-string">&quot;message:&#123;&#125;&quot;</span>,returnedMessage.getMessage());<br>        log.debug(<span class="hljs-string">&quot;replyCode:&#123;&#125;&quot;</span>,returnedMessage.getReplyCode());<br>        log.debug(<span class="hljs-string">&quot;replyText:&#123;&#125;&quot;</span>,returnedMessage.getReplyText());<br>    &#125;);编写代码添加ConfirmCallback5<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>编写代码添加ConfirmCallback</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testPublisherConfirm</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-comment">// 1. 创建CorrelationData</span><br>    <span class="hljs-type">CorrelationData</span> <span class="hljs-variable">cd</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CorrelationData</span>();<br>    <span class="hljs-comment">// 2. 给Future添加ConfirmCallback</span><br>    cd.getFuture().addCallback(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ListenableFutureCallback</span>&lt;CorrelationData.Confirm&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onFailure</span><span class="hljs-params">(Throwable ex)</span> &#123;<br>            <span class="hljs-comment">// 2.1.Future发生异常时的处理逻辑，基本不会触发</span><br>            log.error(<span class="hljs-string">&quot;handle message ack fail&quot;</span>, ex);<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onSuccess</span><span class="hljs-params">(CorrelationData.Confirm result)</span> &#123;<br>            <span class="hljs-comment">// 2.2.Future接收到回调的处理逻辑，参数中的result就是回调内容</span><br>            <span class="hljs-keyword">if</span> (result.isAck()) &#123; <span class="hljs-comment">// result.isAck(), boolean类型, true代表ack回调, false 代表 nack回调</span><br>                log.debug(<span class="hljs-string">&quot;发送消息成功，收到 ack!&quot;</span>);<br>            &#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">// result.getReason(), String类型，返回nack时的异常描述</span><br>                log.error(<span class="hljs-string">&quot;发送消息失败，收到 nack, reason : &#123;&#125;&quot;</span>, result.getReason());<br>            &#125;<br>        &#125;<br>    &#125;);<br>    <span class="hljs-comment">// 3. 发送消息</span><br>    rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;hmall.direct&quot;</span>, <span class="hljs-string">&quot;red1&quot;</span>, <span class="hljs-string">&quot;hello&quot;</span>, cd);<br>&#125;<br></code></pre></td></tr></table></figure><p>编写代码添加ConfirmCallbackACK和NACK是由ConfirmCallback来返回的，如果ACK但路由失败，则由ReturnBack返回具体的原因</p><hr><h3 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h3><p><strong>交换机持久化与队列持久化</strong></p><p>交换机和队列在MQ中默认的设置就是持久话，即重启RabbitMQ交换机和队列不会丢失</p><p><strong>消息持久话</strong></p><p>在发送消息时，发送持久话消息即可做到消息持久化</p><p>SpringAMQP默认发送消息就是持久化消息</p><p>RabbitMQ非持久化策略，是被动持久化，即内存写满之后才会写入磁盘，但写入磁盘的过程中会导致IO阻塞，影响性能</p><p>而持久化策略是同步持久化，边接受消息边写入磁盘</p><p><em>总结：SpringAMQP是全部持久化策略，所以不需要做任何调整</em></p><hr><h3 id="Lazy-Queue"><a href="#Lazy-Queue" class="headerlink" title="Lazy Queue"></a>Lazy Queue</h3><p>在RabbitMQ的3.6.0版本开始加入Lazy Queue的概念，也就是惰性队列</p><ul><li>接到信息后直接存到磁盘中，不会加载到内存</li><li>消费者消费消息时才会从磁盘中读取消息到内存</li></ul><p><em>在3.12版本后，所有队列都是Lazy Queue模式，无法更改</em></p><hr><h3 id="消费者的可靠性"><a href="#消费者的可靠性" class="headerlink" title="消费者的可靠性"></a>消费者的可靠性</h3><p><strong>消费者确认机制</strong></p><p>当消费者处理消息结束后，应该向RabbitMQ发送一个回执，告知RabbitMQ自己消息处理状态</p><p><em>注：无论哪种消息都是进行业务逻辑之后再返回的</em></p><ul><li>ack：成功处理消息，RabbitMQ从队列中删除该消息</li><li>Nack：处理消息失败，RabbitMQ再次投递消息给消费者，直到成功为止</li><li>reject：消息处理失败并拒绝该消息，RabbitMQ从队列中删除该消息</li></ul><p>SpringAMQP实现了消息确认功能，并允许我们通过配置文件选择ACK处理方式，有三种方式：</p><ul><li>none：不处理，即消息投递后理科返回ack，消息会立刻从MQ删除，非常不安全</li><li>manual：手动模式，需要自己在业务代码中调用API，发送ack或reject，存在业务入侵，但灵活</li><li>auto：自动模式，SpringAMQP利用AOP对我们的消息处理逻辑做了环绕增强<ul><li>业务正常执行：返回ack</li><li>业务异常：返回Nack</li><li>消息处理或者校验异常，返回reject</li></ul></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">listener:</span><br>      <span class="hljs-attr">simple:</span><br>        <span class="hljs-attr">acknowledge-mode:</span> <span class="hljs-string">auto</span><br></code></pre></td></tr></table></figure><p><em>这里的默认值就是auto</em></p><hr><p><strong>失败重试机制</strong></p><p>SpringAMQP提供了消费者失败重试机制，消费者失败后利用本地重试，而不是请求mq</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">listener:</span><br>      <span class="hljs-attr">simple:</span><br>        <span class="hljs-attr">retry:</span><br>          <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 是否开启重试</span><br>          <span class="hljs-attr">initial-interval:</span> <span class="hljs-number">5000</span> <span class="hljs-comment"># 重试间隔</span><br>          <span class="hljs-attr">multiplier:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 重试间隔倍数</span><br>          <span class="hljs-attr">max-attempts:</span> <span class="hljs-number">3</span> <span class="hljs-comment"># 最大重试次数</span><br>          <span class="hljs-attr">stateless:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 是否无状态，有事务关联改成false，无事务关联使用true</span><br></code></pre></td></tr></table></figure><p>在开启失败本地重试之后，重试次数耗尽消息仍然失败，则需要有MessageRecoverer接口来处理，他包含三种不同的实现：</p><ul><li>RejectAndDontRequeueRecoverer：重试耗尽后，直接reject，丢弃消息（默认方式）</li><li>ImmediateRequeueMessageRecoverer：重试耗尽后，返回nack，消息重新入队（之前的默认策略）</li><li>RepublishMessageRecoverer：重试耗尽后，将失败消息投递到制定的交换机，将执行错误的消息最后通过邮件的方式发送到开发者手中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RabbitTemplate rabbitTemplate;<br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> MessageRecoverer <span class="hljs-title function_">messageRecoverer</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">// rabbitTemplate ，交换机名字，BindingKey</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RepublishMessageRecoverer</span>(rabbitTemplate, <span class="hljs-string">&quot;error.direct&quot;</span>, <span class="hljs-string">&quot;error&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="业务幂等性"><a href="#业务幂等性" class="headerlink" title="业务幂等性"></a>业务幂等性</h3><p>同一个业务执行一次和多次的结果是一样的，那么他就是幂等的</p><p>更改订单状态，就是幂等业务</p><p>但是用户下单扣减库存，就是非幂等业务</p><p><strong>唯一消息id</strong></p><ul><li>每条消息都生成一个唯一的消息id，与消息一起投递给消费者</li><li>消费者接受到消息后处理业务，处理成功后将消息id保存到数据库</li><li>下次收到消息，先去数据库查询判断是否存在，存在则为重复消息放弃处理</li></ul><p>在配置底层使用jackson消息转换器时，配置成自动生成id</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> MessageConverter <span class="hljs-title function_">messageConverter</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">Jackson2JsonMessageConverter</span> <span class="hljs-variable">converter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jackson2JsonMessageConverter</span>();<br>    <span class="hljs-comment">// 开启消息头id生成</span><br>    converter.setCreateMessageIds(<span class="hljs-literal">true</span>);<br>    <span class="hljs-keyword">return</span> converter;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenSimpleQueueMessage</span><span class="hljs-params">(Message msg)</span> &#123;<br>    <span class="hljs-comment">// 拿到消息头id，做校验，保证业务幂等性</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">messageId</span> <span class="hljs-operator">=</span> msg.getMessageProperties().getMessageId();<br>    log.info(<span class="hljs-string">&quot;消费者接收到的消息是：&#123;&#125;&quot;</span>, msg.getBody().toString());<br>&#125;<br></code></pre></td></tr></table></figure><hr><p><strong>业务判断</strong></p><p>并不是所有业务都适配使用业务判断的方式来实现保证业务的x-dead-letter-exchange：指定一个交换机，当消息过期成为死信幂等性</p><p>比如修改订单状态到已支付，这个业务在修改之前，查询订单状态是否为未支付，只有为未支付才改变订单状态</p><p>这样就可以通过业务判断的模式将非幂等业务修改为幂等业务</p><hr><h3 id="延迟消息"><a href="#延迟消息" class="headerlink" title="延迟消息"></a>延迟消息</h3><p><strong>死信交换机</strong></p><p>当一个队列中的消息满足下列情况之一，就会成为死信（dead letter）</p><ul><li>消费者使用basic.reject或basic.nack声明消费失败，并且消息的requeue参数设置为false（失败消息不回队列）</li><li>消息是一个过期消息（达到了队列或消息本身设置的过期时间）超时无人消费</li><li>要投递的队列消息堆积满了，最早的消息可能成为死信</li></ul><p>如果队列通过dead-letter-exchange属性指定了一个交换机，那么该队列中的死信就会投递到这个交换机中，这个交换机称为死信交换机（Dead Letter Exchange，简称DLX）  </p><p>死信交换机的设计本意是用以记录失败的消息，可以通过死信队列来设计“死信消费者”</p><p>死信交换机和死信队列可以作为实现延迟消息的一种<strong>变通方案</strong>，但它存在明显的<strong>队头阻塞</strong>和<strong>管理复杂性</strong>问题。在支持原生延迟消息功能的MQ系统（如RabbitMQ安装了 <code>rabbitmq_delayed_message_exchange</code> 插件）中，<strong>强烈推荐使用原生功能</strong>，因为它更高效、更灵活、更易于管理</p><hr><p><strong>延迟消息插件</strong></p><p>下载，安装DelayExchange插件，在声明交换机时将delay属性设置为true</p><p>发布者在发布消息时设置delay属性，即可实现消息的延迟发送</p><p>消息会被在交换机延时，到时间再发送给指定队列</p><p><em>MQ的延迟消息会使用cpu来计算时钟，如果同一时间有大量的延迟消息，cpu压力会很大</em></p><hr><p><strong>取消订单</strong></p><p>未支付订单的自动取消是MQ延迟消息最经典、最常见的应用场景之一</p><p><em>它解决了定时任务取消订单不够即时，释放商品库存不够即时的痛点问题</em></p><p>用户下单之后就发送延迟消息，在15分钟后检查订单支付状态：</p><ul><li>已支付：更新订单状态为已支付</li><li>未支付：更新订单状态为关闭订单，并且将商品库存恢复</li></ul><p>查询支付状态时，要查询订单状态是否为已支付，也要查询订单状态是否为已支付（防止订单服务改变而支付状态未变）</p><hr>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
      <category>SpringCloud</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>微服务-消息队列</title>
    <link href="/2025/06/24/%E5%BE%AE%E6%9C%8D%E5%8A%A1-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    <url>/2025/06/24/%E5%BE%AE%E6%9C%8D%E5%8A%A1-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><h3 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h3><p>同步调用有很强的时效性，且业务中百分之八十的业务都会使用同步调用方式</p><p>但同步调用对于性能方面也有很大缺点，且耦合性强</p><p>我们可以将一些边缘业务的服务调用放到消息队列中，异步调用其他服务</p><hr><h3 id="MQ技术选型"><a href="#MQ技术选型" class="headerlink" title="MQ技术选型"></a>MQ技术选型</h3><p>MQ（MessageQueue），中文是消息队列，字面来看是存放消息的队列，也就是异步调用中的Broker</p><p>RabbitMQ：对吞吐量要求不是极致高，但对消息路由和可靠性要求严格的场景。</p><p>RocketMQ：对吞吐量、可用性、消息特性 (如事务消息、顺序消息、定时消息) 有较高要求的场景。</p><p>Kafka：对吞吐量要求不是极致高，但对消息路由和可靠性要求严格的场景。</p><p>由阿里云开发的RocketMQ并不支持多语言的微服务之间通讯，而RabbitMQ支持</p><p>Kafka是Apache公司开发的针对于大数据和高吞吐量的中间件</p><hr><h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><p>RabbitMQ的整体架构：</p><ul><li>virtual-host：虚拟主机，类似于命名空间，当有多个项目共用一个MQ时使用</li><li>publisher：消息发送者</li><li>consumer：消息消费者</li><li>queue：队列，存储消息</li><li>exchange：交换机，负责路由消息</li></ul><p>消息发送者把消息发送到交换机，但交换机本身不存储消息，需要配置对应路由规则，将消息发送到指定的队列</p><hr><h3 id="数据隔离"><a href="#数据隔离" class="headerlink" title="数据隔离"></a>数据隔离</h3><p>为新项目添加新用户，在新用户下添加新的虚拟主机</p><hr><h3 id="JAVA客户端"><a href="#JAVA客户端" class="headerlink" title="JAVA客户端"></a>JAVA客户端</h3><p>在这里我们使用SpringAMQP客户端，RabbitMQ支持此协议通讯</p><p>基于RabbitMQ的API，Spring提供了spring-rabbit的具体实现</p><p>导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--AMQP依赖，包含RabbitMQ--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-string">localhost</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">hmall</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123</span><br>    <span class="hljs-attr">virtual-host:</span> <span class="hljs-string">/hmall</span><br></code></pre></td></tr></table></figure><p>通过RabbitTemplate简单向队列直接发送消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span> <span class="hljs-comment">// 使用 @Autowired 注解在字段上</span><br><span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSimpleQueue</span><span class="hljs-params">()</span>&#123;<br>    rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;simple.queue&quot;</span>,<span class="hljs-string">&quot;hello,spring amqp&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>编写Rabbit的监听器，让队列触发该消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringRabbitListener</span> &#123;<br>    <span class="hljs-meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenSimpleQueueMessage</span><span class="hljs-params">(String msg)</span> &#123;<br>        log.info(<span class="hljs-string">&quot;消费者接收到的消息是：&#123;&#125;&quot;</span>, msg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>06-25 11:19:07:597  INFO 229826 — [ntContainer#0-1] c.i.consumer.mq.SpringRabbitListener     : 消费者接收到的消息是：hello,spring amqp</p></blockquote><hr><h3 id="Work-Queues"><a href="#Work-Queues" class="headerlink" title="Work Queues"></a>Work Queues</h3><p>让多个消费者绑定同一个队列，共同消费队列中的消息</p><p>同一条消息，被一个消费者处理后，这条消息就被删除了，不能被其他消费者处理</p><p>对于大量消息，我们通过Work Queues的特性，创建多个消费者消费同一个队列，这样能做到负载均衡</p><p>Work Queues的默认策略是根据消费者的数量平均分配消息数量（不论消费者的处理性能）</p><p>修改配置文件preFetch值为1，确保同一时刻最多投递给消费者1条消息</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">listener:</span><br>      <span class="hljs-attr">simple:</span><br>        <span class="hljs-attr">prefetch:</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><em>这样就不是消费者平均分配任务，而是“能者多劳”</em></p><hr><h3 id="交换机exchange"><a href="#交换机exchange" class="headerlink" title="交换机exchange"></a>交换机exchange</h3><p><strong>Fanout广播交换机</strong></p><p>就算是把多个消费者绑定同一个队列，这个队列中的消息也不会同时被多个消费者消费</p><p>但通过广播交换机，我们可以实现多个消费者共同消费一条消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSimpleQueue</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">exchange</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hmall.fanout&quot;</span>;<br>    <span class="hljs-comment">// 不同于给队列直接发消息，给交换机发消息是有三个参数</span><br>    rabbitTemplate.convertAndSend(exchange,<span class="hljs-literal">null</span>,<span class="hljs-string">&quot;hello,spring amqp&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Direct交换机</strong></p><p>每一个Queue都设置一个BingdingKey</p><p>发布者发送消息时，指定消息的RoutingKey</p><p>在这里，BingdingKey是可以重复的，重复的BindingKey会以Fanout相同的方式复制消息分别发送到对列，形成广播</p><p><strong>Topic交换机</strong></p><p>在发送消息到交换机时，可以使用通配符</p><p>#：指代0个或多个单词</p><p>*：指代一个单词</p><hr><h3 id="队列和交换机的声明"><a href="#队列和交换机的声明" class="headerlink" title="队列和交换机的声明"></a>队列和交换机的声明</h3><p> SpringAMQP提供了几个类，用来声明队列，交换机和绑定关系</p><ul><li>Queue：用于声明队列，可以用工厂类QueueBuilder构建</li><li>Exchange：用于声明交换机，可以用工厂类ExchangeBuilder构建</li><li>Binding：用于声明队列和交换机的绑定关系，可以用工厂类BingdingBuilder构建</li></ul><p>在SpringBoot项目中，我们可以通过编写配置类的方式，在项目初始化时完成交换机和队列的创建及绑定</p><p>通常情况下，在消费者一端去创建和绑定RabbitMQ</p><p>SpringAMQP还提供了注解的方式来实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RabbitListener(bindings = @QueueBinding(</span><br><span class="hljs-meta">    value = @Queue(name = &quot;direct.queue1&quot;),</span><br><span class="hljs-meta">    exchange = @Exchange(name = &quot;itcast.direct&quot;, type = ExchangeTypes.DIRECT),</span><br><span class="hljs-meta">    key = &#123;&quot;red&quot;, &quot;blue&quot;&#125;</span><br><span class="hljs-meta">))</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenDirectQueue1</span><span class="hljs-params">(String msg)</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;消费者1接收到Direct消息: [&quot;</span>+msg+<span class="hljs-string">&quot;]&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>将队列绑定到消费者的同时，初始化队列和交换机，指定交换机类型并将其绑定</p><hr><h3 id="消息转换器"><a href="#消息转换器" class="headerlink" title="消息转换器"></a>消息转换器</h3><p>Spring在对消息对象的处理时默认实现是SimpleMessageConverter，是基于JDK的ObjectOutputStream来实现的，但这样做会存在很多问题：</p><ul><li>JDK的序列化有安全风险</li><li>JDK序列化的消息太大</li><li>JDK序列化的消息可读性差</li></ul><p>建议采用JSON序列化来替代默认的JDK序列化</p><p><strong>导入依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-databind<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>在发布者和消费者都添加配置类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitMQConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> MessageConverter <span class="hljs-title function_">messageConverter</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jackson2JsonMessageConverter</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>这样就实现了使用jackson的Json转换来替换默认的JDK字节流转换</em></p><hr>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
      <category>SpringCloud</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>微服务-分布式事务</title>
    <link href="/2025/06/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    <url>/2025/06/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h1><h3 id="Seata"><a href="#Seata" class="headerlink" title="Seata"></a>Seata</h3><p><a href="https://seata.apache.org/zh-cn/">Apache Seata(incubating) 是一款开源的分布式事务解决方案，致力于在微服务架构下提供高性能和简单易用的分布式事务服务。</a></p><p>解决分布式事务，各个子事务之间必须能够感知到彼此的事务状态，才能保证一致</p><p>Seata事务中有三个重要的角色</p><ul><li>TC（Transaction Coordinator）-事务协调者：维护全局和分支的事务状态，协调全局事务提交或回滚</li><li>TM（Transaction Manager）-事务管理器：定义全局事务的范围、开始全局事务、提交或回滚全局事务</li><li>RM（Resource Manager）-资源管理器：管理分支事务，与TC交谈以注册分支事务和报告分支事务的状态</li></ul><h3 id="部署TC服务"><a href="#部署TC服务" class="headerlink" title="部署TC服务"></a>部署TC服务</h3><p>Seata支持多钟存储模式，但考虑到数据持久话的需要，我们一般选择基于数据库存储</p><blockquote><p>这里seata的搭建需要大量的配置，他本质上是一个springboot的服务，通过application或者nacos进行配置都可。其中，数据持久化也可以选择基于Redis或者MySQL</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">seata:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">seataio/seata-server:1.5.2</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">seata</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;8099:8099&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;7099:7099&quot;</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./seata:/seata-server/resources</span><br>    <span class="hljs-attr">privileged:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-literal">no</span><br>    <span class="hljs-attr">networks:</span> <br>      <span class="hljs-bullet">-</span> <span class="hljs-string">my_app_network</span> <br><br><span class="hljs-attr">networks:</span> <span class="hljs-comment"># &lt;-- 定义网络</span><br>  <span class="hljs-attr">my_app_network:</span><br>    <span class="hljs-attr">external:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 告诉 Docker Compose 这个网络已经存在，不要尝试创建它</span><br><br></code></pre></td></tr></table></figure><hr><h3 id="微服务中集成Seata"><a href="#微服务中集成Seata" class="headerlink" title="微服务中集成Seata"></a>微服务中集成Seata</h3><p>在微服务中引入Seata依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-seata<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在微服务中配置TC地址，在这里，Seata可能会被配置成集群注册到Nacos中，所以让微服务通过Nacos来获取TC服务的地址</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">seata:</span><br>  <span class="hljs-attr">registry:</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">nacos</span><br>    <span class="hljs-attr">nacos:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span><br>        <span class="hljs-attr">namespace:</span> <span class="hljs-string">&quot;&quot;</span><br>        <span class="hljs-attr">group:</span> <span class="hljs-string">DEFAULT_GROUP</span><br>        <span class="hljs-attr">application:</span> <span class="hljs-string">seata-server</span><br>        <span class="hljs-attr">username:</span> <span class="hljs-string">nacos</span><br>        <span class="hljs-attr">password:</span> <span class="hljs-string">nacos</span><br>  <span class="hljs-attr">tx-service-group:</span> <span class="hljs-string">hmall</span> <span class="hljs-comment"># 事务组名称</span><br>  <span class="hljs-attr">service:</span><br>    <span class="hljs-attr">vgroup-mapping:</span> <span class="hljs-comment"># 事务组和tc集群的映射关系</span><br>          <span class="hljs-attr">hmall:</span> <span class="hljs-string">&quot;default&quot;</span><br></code></pre></td></tr></table></figure><p><em>这里的配置文件可以抽出来在Nacos做共享配置文件</em></p><hr><h3 id="XA模式"><a href="#XA模式" class="headerlink" title="XA模式"></a>XA模式</h3><p>事务具有强一致性，所有的分支事务仅执行不提交，等所有的分支事务执行完成后一起提交</p><p>常用数据库都支持，实现简单，并且没有代码侵入</p><p>性能恩差，依赖关系行数据库实现事务</p><p><strong>开启方法</strong></p><p>在配置文件中开启XA</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">seata:</span><br>  <span class="hljs-attr">data-source-proxy-mode:</span> <span class="hljs-string">XA</span><br></code></pre></td></tr></table></figure><p>在事务的入口方法处添加@GlobalTransactional注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@GlobalTransactional</span><br><span class="hljs-keyword">public</span> Long <span class="hljs-title function_">createOrder</span><span class="hljs-params">(OrderFormDTO orderFormDTO)</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>分支事务也要加上@Transactional注解以便回滚</em></p><hr><h3 id="AT模式"><a href="#AT模式" class="headerlink" title="AT模式"></a>AT模式</h3><p>Seata主推的是AT模式，AT模式同样是分阶段提交的事务模型，不过弥补了XA模型中资源锁定周期过长的缺陷</p><p>XA模式是直接上一把物理排他锁，在事务过程中，任何请求都阻塞（包括读写）</p><p>AT模式是分支事务上物理锁，释放的很快，全局事务上一把逻辑锁（全局写锁）</p><p>虽然其他写的请求无法正常执行，但不影响读的请求</p><p>这也意味着在事务执行期间，AT模式会出现“脏读”问题，但<strong>最终一致性</strong>可以得到保障</p><p><strong>开启AT模式</strong></p><p>AT模式需要为每一个微服务提供undo_log表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 注意此处0.3.0+ 增加唯一索引 ux_undo_log</span><br><span class="hljs-keyword">CREATE TABLE</span> `undo_log` (<br>  `id` <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT NULL</span> AUTO_INCREMENT,<br>  `branch_id` <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT NULL</span>,<br>  `xid` <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT NULL</span>,<br>  `context` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">NOT NULL</span>,<br>  `rollback_info` longblob <span class="hljs-keyword">NOT NULL</span>,<br>  `log_status` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT NULL</span>,<br>  `log_created` datetime <span class="hljs-keyword">NOT NULL</span>,<br>  `log_modified` datetime <span class="hljs-keyword">NOT NULL</span>,<br>  `ext` <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY KEY</span> (`id`),<br>  <span class="hljs-keyword">UNIQUE</span> KEY `ux_undo_log` (`xid`,`branch_id`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB AUTO_INCREMENT<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8;<br></code></pre></td></tr></table></figure><p>在配置文件中开启AT，但这个属性的默认值就是AT（约定大于配置）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">seata:</span><br>  <span class="hljs-attr">data-source-proxy-mode:</span> <span class="hljs-string">AT</span><br></code></pre></td></tr></table></figure><p>同XA模式，在事务的入口方法处添加@GlobalTransactional注解</p><p><em>分支事务也要加上@Transactional注解以便回滚</em></p><hr>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
      <category>SpringCloud</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>微服务-雪崩</title>
    <link href="/2025/06/20/%E5%BE%AE%E6%9C%8D%E5%8A%A1-%E9%9B%AA%E5%B4%A9/"/>
    <url>/2025/06/20/%E5%BE%AE%E6%9C%8D%E5%8A%A1-%E9%9B%AA%E5%B4%A9/</url>
    
    <content type="html"><![CDATA[<h1 id="雪崩问题"><a href="#雪崩问题" class="headerlink" title="雪崩问题"></a>雪崩问题</h1><p>微服务调用链路中的某个服务故障，引起整个链路中的所有微服务都不可用，这就是雪崩</p><p><strong>雪崩问题产生的原因？</strong></p><ul><li>微服务相互调用，服务提供者出现故障或阻塞</li><li>服务调用者没做好异常处理，导致自身故障</li><li>调用链中的所有服务级联失败，导致整个集群故障</li></ul><p><strong>解决问题的思路有哪些？</strong></p><p>尽量避免服务中出现问题或阻塞</p><ul><li>保证代码的健壮性</li><li>保证网络畅通</li><li>能应对较高的并发请求</li></ul><hr><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p><strong>服务保护方案-请求限流</strong></p><p>限制流量在服务可以处理的范围，避免因突发流量和故障</p><p><strong>服务保护方案-线程隔离</strong></p><p>控制业务可用的线程数量，将故障隔离在一定范围</p><p><strong>服务保护方案-服务熔断</strong></p><p>将异常比例过高的接口断开，拒绝所有请求，直接走fallback</p><hr><h3 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h3><p><strong>搭建Sentinel</strong></p><p><a href="https://github.com/alibaba/Sentinelhttps://github.com/alibaba/Sentinel">Sentinel: The Sentinel of Your Microservices</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">java -Dserver.port=8090 -Dcsp.sentinel.dashboard.server=localhost:8090 -Dproject.name=sentinel-dashboard -jar sentinel-dashboard-1.8.8.jar<br></code></pre></td></tr></table></figure><p>sentinel是一个控制台应用程序，可以将其看作类似于Nacos的独立服务</p><p><strong>整合Sentinel</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--sentinel--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>簇点链路</strong></p><p>簇点链路就是单机调用链路，是一次请求进入服务后经过的每一个被Sentinel监控的资源链。默认Sentinel会监控SpringMVC的每一个Endpoint（http接口）。限流、熔断都是针对于簇点链路的资源设置的。而资源名默认就是接口的请求路径。</p><p><strong>请求方式前缀</strong></p><p>Restful风格的API请求路径一般都相同，这会导致簇点资源名称重复，因此我们要修改配置，把请求方式+请求路径作为簇点资源名称</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span> <br>  <span class="hljs-attr">cloud:</span> <br>    <span class="hljs-attr">sentinel:</span> <br>      <span class="hljs-attr">transport:</span> <br>        <span class="hljs-attr">dashboard:</span> <span class="hljs-string">localhost:8090</span><br>      <span class="hljs-attr">http-method-specify:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 开启请求方式前缀</span><br></code></pre></td></tr></table></figure><hr><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>在Sentinel中，可以针对于簇点链路进行限流&#x2F;线程数量控制</p><p>当一个服务调用过慢，会将资源抢占耗尽，别的服务则无法正常调用，这个时候就应该配置线程隔离</p><p> 将FeignClient作为Sentinel的簇点资源，让<strong>服务间调用也被sentinel监控</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">feign:</span><br>  <span class="hljs-attr">sentinel:</span> <br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 开启sentinel支持</span><br></code></pre></td></tr></table></figure><hr><p><strong>Fallback</strong></p><p>基于FallbackFactory，编写FeignClient的fallback逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ItemClientFallbackFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">FallbackFactory</span>&lt;ItemClient&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> ItemClient <span class="hljs-title function_">create</span><span class="hljs-params">(Throwable cause)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ItemClient</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> List&lt;ItemApiDTO&gt; <span class="hljs-title function_">queryItemByIds</span><span class="hljs-params">(Collection&lt;Long&gt; ids)</span> &#123;<br>                log.error(<span class="hljs-string">&quot;查询商品失败&quot;</span>, cause);<br>                <span class="hljs-keyword">return</span> CollUtils.emptyList();<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deductStock</span><span class="hljs-params">(List&lt;OrderDetailApiDTO&gt; items)</span> &#123;<br>                log.error(<span class="hljs-string">&quot;减少商品库存失败&quot;</span>, cause);<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(cause);<br>            &#125;<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在Feign的配置文件中，将fallback注册到bean中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> ItemClientFallbackFactory <span class="hljs-title function_">itemClientFallbackFactory</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ItemClientFallbackFactory</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>在APIClient中，加载该bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(value = &quot;item-service&quot;, fallbackFactory = ItemClientFallbackFactory.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ItemClient</span> &#123;<br>    <span class="hljs-meta">@GetMapping(&quot;/items&quot;)</span><br>    List&lt;ItemApiDTO&gt; <span class="hljs-title function_">queryItemByIds</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;ids&quot;)</span> Collection&lt;Long&gt; ids )</span>;<br><br>    <span class="hljs-meta">@PutMapping(&quot;/items/stock/deduct&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deductStock</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> List&lt;OrderDetailApiDTO&gt; items)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Nacos提供注册服务 -&gt; Feign调用服务 -&gt; Sentinel进行流控或线程隔离抛出异常 -&gt; fallback逻辑触发</p></blockquote><hr><p><strong>配置熔断</strong></p><p>熔断可以进一步增加性能优化，线程隔离和QPS可以保证服务可用，但仍然会尝试去请求，只有超时或线程不够才会失败</p><p>而熔断是设置一个规则，在尝试不行时直接先断开不用这个服务，过一段时间再尝试请求一下，如果还是失败，就继续断开</p><hr>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
      <category>SpringCloud</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SpringCloud-配置中心</title>
    <link href="/2025/06/19/SpringCloud-%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/"/>
    <url>/2025/06/19/SpringCloud-%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/</url>
    
    <content type="html"><![CDATA[<h1 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h1><p>目前的配置有以下痛点：</p><ul><li><p>微服务重复配置过多，维护成本高</p></li><li><p>业务配置经常变动，每次修改都要重启服务</p></li><li><p>网关路由配置写死，如果变更需要重启网关</p></li></ul><hr><h3 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h3><p>Nacos不仅仅具备注册中心功能，还能实现配置管理服务</p><p>在之前，我们进行配置管理的方式是通过application.yaml文件来做统一管理</p><p>在加入SpringCloud的配置中心，我们将其很多共享配置提取管理，形成单独的一套配置管理文件</p><p>这样两条配置会一起加载，最后合并配置，完成初始化即可</p><p><strong>导入依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--nacos 配置管理--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!--读取bootstrap文件--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-bootstrap<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>配置bootstrap.yaml</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">cart-service</span><br>    <span class="hljs-attr">profiles:</span><br>      <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span><br>    <span class="hljs-attr">cloud:</span><br>      <span class="hljs-attr">nacos:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span><br>        <span class="hljs-attr">config:</span><br>          <span class="hljs-attr">file-extension:</span> <span class="hljs-string">yaml</span><br>          <span class="hljs-attr">shared-configs:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">data-id:</span> <span class="hljs-string">shared-jdbc.yaml</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">data-id:</span> <span class="hljs-string">shared-log.yaml</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">data-id:</span> <span class="hljs-string">shared-swagger.yaml</span><br></code></pre></td></tr></table></figure><hr><h3 id="配置热更新"><a href="#配置热更新" class="headerlink" title="配置热更新"></a>配置热更新</h3><p>nacos中创建一个与微服务名有关的配置文件</p><p>微服务中要以特定的方式读取需要热更新的配置属性（配置属性类）</p><hr><h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><p>在进行微服务的路由改变时（增加模块或删除模块），我们需要停掉网关服务更改其网关的配置文件才行</p><p><em>新版本中已经实现了动态路由的简单配置，通过Nacos的配置热更新可以直接实现Gateway的路由配置变更</em></p><hr>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
      <category>SpringCloud</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SpringCloud-网关</title>
    <link href="/2025/06/18/SpringCloud-%E7%BD%91%E5%85%B3/"/>
    <url>/2025/06/18/SpringCloud-%E7%BD%91%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h1 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h1><p><strong>纵向拆分 (Vertical Splitting &#x2F; Business Domain Splitting):</strong> 关注点是<strong>业务功能完整性</strong>。每个服务是一个独立的业务单元，例如：用户服务、商品服务、订单服务、支付服务。它们通常有自己的数据库。</p><p><strong>水平拆分 (Horizontal Splitting &#x2F; Cross-cutting Concern Splitting):</strong> 关注点是<strong>通用能力或技术功能</strong>。这些功能被多个业务服务共享，例如：认证授权服务、日志服务、配置服务、消息队列服务、文件存储服务。它们通常是无状态的或有自己的独立数据存储。</p><p><strong>API 网关 (API Gateway):</strong> 它是微服务架构中的一个关键组件，扮演着<strong>门面 (Facade)</strong> 的角色。它不仅处理横切关注点（如认证、限流），更重要的是提供<strong>统一的入口和路由</strong>，将内部复杂的微服务结构对外部客户端透明化，从而简化客户端与微服务系统的交互。</p><hr><h3 id="SpringCloudGateway"><a href="#SpringCloudGateway" class="headerlink" title="SpringCloudGateway"></a>SpringCloudGateway</h3><p>相比于Netfilx的Zuul，SpringCloudGateway更好用，也更受欢迎</p><h3 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.heima<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hm-common<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--网关--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--nacos discovery--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--负载均衡--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalancer<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">finalName</span>&gt;</span>$&#123;project.artifactId&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">finalName</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="配置路由规则"><a href="#配置路由规则" class="headerlink" title="配置路由规则"></a>配置路由规则</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">gateway</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:8848</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">routes:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">item-service</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://item-service</span><br>          <span class="hljs-attr">predicates:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/items/**,/search/**</span><br>  <span class="hljs-string">……</span><br></code></pre></td></tr></table></figure><hr><h3 id="路由断言"><a href="#路由断言" class="headerlink" title="路由断言"></a>路由断言</h3><p>Spring提供了多种基本的RoutePredicateFactory</p><p><a href="https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway-server-webflux/configuring-route-predicate-factories-and-filter-factories.html">路由断言的模板使用方法</a></p><table><thead><tr><th align="center"><strong>名称</strong></th><th align="center"><strong>说明</strong></th></tr></thead><tbody><tr><td align="center">After</td><td align="center">是某个时间点后的请求</td></tr><tr><td align="center">Before</td><td align="center">是某个时间点之前的请求</td></tr><tr><td align="center">Between</td><td align="center">是某两个时间点之前的请求</td></tr><tr><td align="center">Cookie</td><td align="center">请求必须包含某些cookie</td></tr><tr><td align="center">Header</td><td align="center">请求必须包含某些header</td></tr><tr><td align="center">Host</td><td align="center">请求必须是访问某个host (域名)</td></tr><tr><td align="center">Method</td><td align="center">请求方式必须是指定方式</td></tr><tr><td align="center">Path</td><td align="center">请求路径必须符合指定规则</td></tr><tr><td align="center">Query</td><td align="center">请求参数必须包含指定参数</td></tr><tr><td align="center">RemoteAddr</td><td align="center">请求者的ip必须是指定范围</td></tr><tr><td align="center">Weight</td><td align="center">权重处理</td></tr><tr><td align="center">XForwarded Remote Addr</td><td align="center">基于请求的来源IP做判断</td></tr></tbody></table><hr><h3 id="路由过滤器"><a href="#路由过滤器" class="headerlink" title="路由过滤器"></a>路由过滤器</h3><p>路由过滤器有更多中配置的方式，在此处我们列出常用的路由配置</p><p>同样的，我们也可以去官网找到配置说明和样板代码</p><table><thead><tr><th align="center"><strong>名称</strong></th><th align="center"><strong>说明</strong></th></tr></thead><tbody><tr><td align="center">AddRequestHeader</td><td align="center">给当前请求添加一个请求头</td></tr><tr><td align="center">RemoveRequestHeader</td><td align="center">移除请求中的一个请求头</td></tr><tr><td align="center">AddResponseHeader</td><td align="center">给响应结果中添加一个响应头</td></tr><tr><td align="center">RemoveResponseHeader</td><td align="center">从响应结果中移除一个响应头</td></tr><tr><td align="center">RewritePath</td><td align="center">请求路径重写</td></tr><tr><td align="center">StripPrefix</td><td align="center">去除请求路径中的N段前缀</td></tr></tbody></table><p>如果想要该过滤器对所有的路由都生效，则需要配置默认过滤器</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">gateway:</span><br>  <span class="hljs-attr">routes:</span><br>    <span class="hljs-string">……</span><br>  <span class="hljs-attr">default-filters:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">AddResponseHeader=</span> <span class="hljs-string">truth,</span> <span class="hljs-string">try</span><br></code></pre></td></tr></table></figure><hr><h3 id="自定义过滤器"><a href="#自定义过滤器" class="headerlink" title="自定义过滤器"></a>自定义过滤器</h3><p>自定义过滤器也分为普通过滤器和全局过滤器</p><p>在这里，普通过滤器自定义起来很难，也很少有应用场景，所以大多使用全局过滤器</p><p><strong>GlobalFilter</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyGlobalFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">GlobalFilter</span>, Ordered &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 实现全局过滤器接口的方法</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> exchange 登陆上下文，用以获取参数</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> chain    网关过滤器链，当前过滤器执行完之后放行</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Mono&lt;Void&gt; <span class="hljs-title function_">filter</span><span class="hljs-params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;<br>        <span class="hljs-type">ServerHttpRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> exchange.getRequest();<br>        <span class="hljs-comment">// 模拟登陆校验</span><br>        <span class="hljs-keyword">return</span> chain.filter(exchange);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 实现排序接口方法，设置过滤器优先级</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getOrder</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="登陆校验"><a href="#登陆校验" class="headerlink" title="登陆校验"></a>登陆校验</h3><p>在网关处自定义一个全局过滤器，获取请求头中的path信息，比对排除地址，看是否需要校验token</p><p>从请求头中拿到token，调用JwtTool解析token，拿到userId放到请求头中向下传递并放行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 全局认证过滤器。</span><br><span class="hljs-comment"> * 负责在请求到达后端服务之前，进行JWT令牌的校验和用户身份的认证。</span><br><span class="hljs-comment"> * 如果认证失败，则直接返回未授权响应。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span> <span class="hljs-comment">// 标记为Spring组件，Spring容器会自动扫描并管理这个类的实例（Bean）</span><br><span class="hljs-meta">@RequiredArgsConstructor</span> <span class="hljs-comment">// Lombok注解：自动生成一个包含所有final字段的构造函数，用于依赖注入</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AuthGlobalFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">GlobalFilter</span>, Ordered &#123;<br><br>    <span class="hljs-comment">// 认证相关的配置属性，例如需要排除认证的路径列表</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AuthProperties authProperties;<br><br>    <span class="hljs-comment">// JWT工具类，用于JWT的创建、解析和验证</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> JwtTool jwtTool;<br><br>    <span class="hljs-comment">// Ant风格路径匹配器，用于判断请求路径是否匹配某个模式（例如排除路径）</span><br>    <span class="hljs-comment">// 这里直接实例化，因为它是一个无状态的工具类，不需要Spring容器管理其生命周期</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AntPathMatcher</span> <span class="hljs-variable">antPathMatcher</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AntPathMatcher</span>();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 定义过滤器的执行顺序。</span><br><span class="hljs-comment">     * 数值越小，优先级越高，越早执行。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 过滤器的顺序值。这里返回0，表示这是一个较早执行的过滤器。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getOrder</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 核心过滤逻辑。</span><br><span class="hljs-comment">     * 在每个请求通过网关时执行。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> exchange 包含请求和响应的Web交换对象。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> chain    过滤器链，用于将请求传递给下一个过滤器或目标服务。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 一个Mono&lt;Void&gt;，表示过滤操作的完成。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Mono&lt;Void&gt; <span class="hljs-title function_">filter</span><span class="hljs-params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;<br>        <span class="hljs-comment">// 1. 获取当前请求对象</span><br>        <span class="hljs-type">ServerHttpRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> exchange.getRequest();<br><br>        <span class="hljs-comment">// 2. 判断当前请求路径是否在排除认证的列表中</span><br>        <span class="hljs-keyword">if</span> (isExcludePath(request.getPath().toString())) &#123;<br>            <span class="hljs-comment">// 如果是排除路径，则直接放行，不进行后续的认证逻辑</span><br>            <span class="hljs-keyword">return</span> chain.filter(exchange);<br>        &#125;<br><br>        <span class="hljs-comment">// 3. 从请求头中获取Authorization（授权）令牌</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        List&lt;String&gt; authorization = request.getHeaders().get(<span class="hljs-string">&quot;Authorization&quot;</span>);<br>        <span class="hljs-keyword">if</span> (authorization != <span class="hljs-literal">null</span> &amp;&amp; !authorization.isEmpty()) &#123;<br>            token = authorization.get(<span class="hljs-number">0</span>); <span class="hljs-comment">// 通常Authorization头只有一个值</span><br>            <span class="hljs-comment">// 注意：如果token是&quot;Bearer xxx&quot;格式，JwtTool需要能处理或在此处剥离&quot;Bearer &quot;前缀</span><br>            <span class="hljs-comment">// 你的JwtTool目前直接处理整个字符串，所以如果前端发送&quot;Bearer xxx&quot;，JwtTool需要能识别</span><br>            <span class="hljs-comment">// 假设JwtTool能够处理或期望原始token，或者前端不带&quot;Bearer &quot;</span><br>        &#125;<br><br>        <span class="hljs-comment">// 4. 解析并验证JWT令牌，获取用户ID</span><br>        <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            userId = jwtTool.parseToken(token); <span class="hljs-comment">// 调用JwtTool解析token</span><br>            <span class="hljs-comment">// 成功解析后，可以将userId存储到exchange的属性中，以便后续服务获取</span><br>            <span class="hljs-comment">// 例如：exchange.getAttributes().put(&quot;userId&quot;, userId);</span><br>        &#125; <span class="hljs-keyword">catch</span> (UnauthorizedException e) &#123;<br>            <span class="hljs-comment">// 如果解析token过程中抛出UnauthorizedException（如token为空、无效、过期）</span><br>            <span class="hljs-type">ServerHttpResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> exchange.getResponse();<br>            response.setStatusCode(HttpStatus.UNAUTHORIZED); <span class="hljs-comment">// 设置HTTP状态码为401未授权</span><br>            <span class="hljs-keyword">return</span> response.setComplete(); <span class="hljs-comment">// 终止请求，返回响应</span><br>        &#125;<br><br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 传递用户信息到下游服务</span><br><br>        <span class="hljs-comment">// 5. 如果认证成功，则将请求传递给过滤器链中的下一个过滤器或最终的目标服务</span><br>        <span class="hljs-keyword">return</span> chain.filter(exchange);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断给定的路径是否在认证排除列表中。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> path 待检查的请求路径。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 如果路径匹配任何一个排除模式，则返回true；否则返回false。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isExcludePath</span><span class="hljs-params">(String path)</span> &#123;<br>        <span class="hljs-comment">// 遍历配置中所有需要排除认证的路径模式</span><br>        <span class="hljs-keyword">for</span> (String pathPattern : authProperties.getExcludePaths())&#123;<br>            <span class="hljs-comment">// 使用AntPathMatcher进行路径匹配</span><br>            <span class="hljs-keyword">if</span> (antPathMatcher.match(pathPattern, path)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 如果匹配成功，说明该路径需要排除认证</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 所有模式都不匹配，表示该路径需要认证</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="UserId"><a href="#UserId" class="headerlink" title="UserId"></a>UserId</h3><p>在微服务中，我们可以设置MVC的过滤器，拿到请求头的userId并存放到ThreadLocal中</p><p><strong>设置请求头</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 传递用户信息</span><br><span class="hljs-type">String</span> <span class="hljs-variable">userInfo</span> <span class="hljs-operator">=</span> userId.toString();<br><span class="hljs-type">ServerWebExchange</span> <span class="hljs-variable">swe</span> <span class="hljs-operator">=</span> exchange.mutate().request(<br>        builder -&gt; builder<br>                .header(<span class="hljs-string">&quot;user-info&quot;</span>, userInfo)<br>                ).build();<br></code></pre></td></tr></table></figure><p><strong>获取请求头</strong></p><p>每一个微服务都需要使用拦截器获取到请求头中的userId，所以我们将获取逻辑抽取到Common库中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserInfoInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 清理用户</span><br>        UserContext.removeUser();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 1.获取请求头中的 token</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">UserInfo</span> <span class="hljs-operator">=</span> request.getHeader(<span class="hljs-string">&quot;User-Info&quot;</span>);<br>        <span class="hljs-keyword">if</span> (StrUtil.isBlank(UserInfo)) &#123;<br>            <span class="hljs-comment">// 2.存入上下文</span><br>            UserContext.setUser(Long.valueOf(UserInfo));<br>        &#125;<br>        <span class="hljs-comment">// 3.放行</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>别忘了要在common中新建一个配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ConditionalOnClass(DispatcherServlet.class)</span> <span class="hljs-comment">// 只有SpringMVC才加载此配置类，防止网关加载</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br>        registry.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">UserInfoInterceptor</span>());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>spring.factories</strong></p><p>在 Spring Boot 微服务架构中，当 common 模块作为共享库被其他微服务依赖时，common 模块中定义的配置类在微服务启动时不会被自动装配。</p><p>Spring Boot 默认的组件扫描机制仅会扫描主应用类所在的包及其子包。如果 common 模块的配置类位于不同的根包下，或不在主应用类的扫描路径内，它们将无法被 Spring Boot 容器发现和加载。</p><p>为了使 common 模块的配置类能够被引用它的微服务自动加载，我们应利用 Spring Boot 的自动配置机制</p><blockquote><p>在 common 模块的 src&#x2F;main&#x2F;resources&#x2F;META-INF&#x2F; 目录下创建 spring.factories 文件</p></blockquote><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="hljs-string">\</span><br><span class="hljs-string">  com.hmall.common.config.MyBatisConfig,\</span><br><span class="hljs-string">  com.hmall.common.config.MvcConfig,\</span><br><span class="hljs-string">  com.hmall.common.config.JsonConfig</span><br></code></pre></td></tr></table></figure><hr><h3 id="OpenFeign传递UserInfo"><a href="#OpenFeign传递UserInfo" class="headerlink" title="OpenFeign传递UserInfo"></a>OpenFeign传递UserInfo</h3><p>OpenFeign服务间调用并不会走Mvc，也就不会走Mvc的过滤器（也就是提取UserInfo）</p><p>那么在服务间调用应该如何传递UserInfo呢？</p><p>OpenFeign中提供了拦截器的接口，所有由OpenFeign发起的请求都会先调用拦截器处理请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> RequestInterceptor <span class="hljs-title function_">requestInterceptor</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestInterceptor</span>()&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">apply</span><span class="hljs-params">(feign.RequestTemplate requestTemplate)</span> &#123;<br>            <span class="hljs-type">Long</span> <span class="hljs-variable">userid</span> <span class="hljs-operator">=</span> UserContext.getUser();<br>            <span class="hljs-keyword">if</span> (userid != <span class="hljs-literal">null</span>)<br>            &#123;<br>                requestTemplate.header(<span class="hljs-string">&quot;user-id&quot;</span>, userid.toString());<br>            &#125;<br>        &#125;<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>别忘了在启动类的注释中应用这个拦截器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableFeignClients(basePackages = &quot;com.hmall.api.client&quot;,defaultConfiguration = FeignInterceptor.class)</span><br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
      <category>SpringCloud</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SpringCloud-服务间调用</title>
    <link href="/2025/06/16/SpringCloud-%E6%9C%8D%E5%8A%A1%E9%97%B4%E8%B0%83%E7%94%A8/"/>
    <url>/2025/06/16/SpringCloud-%E6%9C%8D%E5%8A%A1%E9%97%B4%E8%B0%83%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="服务间调用"><a href="#服务间调用" class="headerlink" title="服务间调用"></a>服务间调用</h1><p>Sprint提供了RestTemplate工具，可以实现服务间调用</p><h3 id="注入IOC的方式"><a href="#注入IOC的方式" class="headerlink" title="注入IOC的方式"></a>注入IOC的方式</h3><p>Spring推荐使用构造函数注入，而不是简单的Autoware注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> RestTemplate restTemplate;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">CartServiceImpl</span><span class="hljs-params">(RestTemplate restTemplate)</span> &#123;<br>    <span class="hljs-built_in">this</span>.restTemplate = restTemplate;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以通过搭配使用lombok来实现注解注入构造函数</p><p>@AllArgsConstructor注解可以为所有成员变量生成构造函数，但这种方式并不是我们想要的</p><p>因为有一些变量是无需加入构造函数的（也无需使用IOC容器注入）</p><p>用final来修饰的变量必须有初值，所以我们可以搭配@RequiredArgsConstructor注释，实现给必要的变量生成构造函数，其最终效果为：<strong>为使用final修饰的属性加构造函数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequiredArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CartServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ServiceImpl</span>&lt;CartMapper, Cart&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ICartService</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RestTemplate restTemplate;<br>    ……<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><h3 id="RestTemplate"><a href="#RestTemplate" class="headerlink" title="RestTemplate"></a>RestTemplate</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">YourService</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RestTemplate restTemplate; <span class="hljs-comment">// 假设 RestTemplate 已经被注入</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">YourService</span><span class="hljs-params">(RestTemplate restTemplate)</span> &#123;<br>        <span class="hljs-built_in">this</span>.restTemplate = restTemplate;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processCarts</span><span class="hljs-params">(List&lt;Long&gt; itemIds)</span> &#123; <span class="hljs-comment">// 假设 itemIds 是一个商品ID列表</span><br>        <span class="hljs-comment">// 1. 构建请求URL和参数</span><br>        <span class="hljs-comment">// 使用 Hutool 的 CollUtil.join 方法，将商品ID列表 (itemIds) 转换为逗号分隔的字符串</span><br>        <span class="hljs-comment">// 例如：[1, 2, 3] -&gt; &quot;1,2,3&quot;</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">idsParam</span> <span class="hljs-operator">=</span> CollUtil.join(itemIds, <span class="hljs-string">&quot;,&quot;</span>);<br><br>        <span class="hljs-comment">// 2. 使用 RestTemplate 发送 GET 请求到远程商品服务</span><br>        <span class="hljs-comment">// &quot;http://localhost:8081/items?ids=&#123;ids&#125;&quot; 是请求的URL模板</span><br>        <span class="hljs-comment">// HttpMethod.GET 指定请求方法为 GET</span><br>        <span class="hljs-comment">// null 表示请求体为空 (GET 请求通常没有请求体)</span><br>        <span class="hljs-comment">// new ParameterizedTypeReference&lt;List&lt;ItemDTO&gt;&gt;() &#123;&#125; 用于处理泛型响应类型，确保正确反序列化为 List&lt;ItemDTO&gt;</span><br>        <span class="hljs-comment">// Map.of(&quot;ids&quot;, idsParam) 将 idsParam 映射到 URL 模板中的 &#123;ids&#125; 占位符</span><br>        ResponseEntity&lt;List&lt;ItemDTO&gt;&gt; re = restTemplate.exchange(<br>                <span class="hljs-string">&quot;http://localhost:8081/items?ids=&#123;ids&#125;&quot;</span>, <span class="hljs-comment">// 请求URL，包含占位符</span><br>                HttpMethod.GET,                           <span class="hljs-comment">// 请求方法</span><br>                <span class="hljs-literal">null</span>,                                     <span class="hljs-comment">// 请求实体 (无请求体)</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ParameterizedTypeReference</span>&lt;List&lt;ItemDTO&gt;&gt;() &#123;&#125;, <span class="hljs-comment">// 响应类型 (泛型列表)</span><br>                Map.of(<span class="hljs-string">&quot;ids&quot;</span>, idsParam)                   <span class="hljs-comment">// URL参数，使用Hutool处理后的ID字符串</span><br>        );<br><br>        <span class="hljs-comment">// 3. 检查HTTP响应状态码</span><br>        <span class="hljs-comment">// re.getStatusCode().is2xxSuccessful() 判断响应状态码是否为 2xx 系列 (表示成功)</span><br>        <span class="hljs-comment">// 如果请求失败 (例如 4xx, 5xx 错误)，则直接返回，不继续处理</span><br>        <span class="hljs-keyword">if</span> (!re.getStatusCode().is2xxSuccessful())&#123;<br>            <span class="hljs-comment">// 可以在这里添加日志记录或抛出自定义异常</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 4. 从成功响应中获取数据体</span><br>        <span class="hljs-comment">// re.getBody() 获取 HTTP 响应的实际数据内容，即 List&lt;ItemDTO&gt;</span><br>        List&lt;ItemDTO&gt; items = re.getBody();<br><br>        <span class="hljs-comment">// 5. 再次检查获取到的数据列表是否为空</span><br>        <span class="hljs-comment">// 使用 Hutool 的 CollUtil.isEmpty 方法，判断列表是否为 null 或不包含任何元素</span><br>        <span class="hljs-comment">// 如果列表为空，则直接返回，终止后续处理</span><br>        <span class="hljs-keyword">if</span> (CollUtil.isEmpty(items)) &#123;<br>            <span class="hljs-comment">// 可以在这里添加日志记录</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h3><p>为了解决HttpTemplate的一系列服务间调用问题，我们使用服务中心来进行最佳实践</p><p>很多框架中都提供了注册中心的服务，我们来学习经典的一款——nacos</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">nacos:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nacos/nacos-server:v2.1.0-slim</span> <span class="hljs-comment"># 推荐使用特定版本，避免不兼容问题</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">nacos-server</span><br>    <span class="hljs-attr">env_file:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./custom.env</span> <span class="hljs-comment"># 引用外部环境变量文件</span><br>    <span class="hljs-comment"># volumes:</span><br>      <span class="hljs-comment"># 持久化Nacos的配置和数据，防止容器删除后数据丢失</span><br>      <span class="hljs-comment"># 请根据你的实际需求调整路径</span><br>      <span class="hljs-comment"># - ./logs:/home/nacos/logs</span><br>      <span class="hljs-comment"># - ./conf:/home/nacos/conf</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;8848:8848&quot;</span> <span class="hljs-comment"># Nacos 控制台端口</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;9848:9848&quot;</span> <span class="hljs-comment"># Nacos GRPC 端口 (客户端连接)</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;9849:9849&quot;</span> <span class="hljs-comment"># Nacos GRPC 端口 (集群间通信，单机模式也需要)</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">my_app_network</span> <span class="hljs-comment"># 将Nacos服务加入到你创建的共享网络</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-literal">no</span> <span class="hljs-comment"># 容器退出后总是重启</span><br><br><span class="hljs-attr">networks:</span><br>  <span class="hljs-attr">my_app_network:</span><br>    <span class="hljs-attr">external:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 告知Compose这个网络已经存在，不要尝试创建它</span><br><br></code></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">PREFER_HOST_MODE</span>=<span class="hljs-string">hostname</span><br><span class="hljs-attr">MODE</span>=<span class="hljs-string">standalone</span><br><span class="hljs-attr">SPRING_DATASOURCE_PLATFORM</span>=<span class="hljs-string">mysql</span><br><span class="hljs-attr">MYSQL_SERVICE_HOST</span>=<span class="hljs-string">mysql</span><br><span class="hljs-attr">MYSQL_SERVICE_DB_NAME</span>=<span class="hljs-string">nacos</span><br><span class="hljs-attr">MYSQL_SERVICE_PORT</span>=<span class="hljs-string">3306</span><br><span class="hljs-attr">MYSQL_SERVICE_USER</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">MYSQL_SERVICE_PASSWORD</span>=<span class="hljs-string">Zhuwenxue2002</span><br><span class="hljs-attr">MYSQL_SERVICE_DB_PARAM</span>=<span class="hljs-string">characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useSSL=false&amp;allowPublicKeyRetrieval=true&amp;serverTimezone=Asia/Shanghai</span><br></code></pre></td></tr></table></figure><p><em>注：这里使用docker网络管理的最佳实现，即自定义网络之后，让相关联服务都加入此网络，可直接通过服务名称代替主机名访问服务</em></p><hr><h3 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h3><p>引入nacos discovery依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--nacos 服务注册发现--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>配置nacos地址</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">item-service</span> <span class="hljs-comment"># 服务名称</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span> <span class="hljs-comment"># nacos地址</span><br></code></pre></td></tr></table></figure><hr><p>配置好服务后，nacos的web管理界面<code>http://localhost:8848/nacos/index.html</code>的服务列表中就可以发现服务</p><p>请注意，这里的服务名就是yaml的配置项spring-application-name，当配置多台服务时，我们只要保证服务名相同，即达成同一服务的多个实例配置</p><hr><h3 id="服务依赖"><a href="#服务依赖" class="headerlink" title="服务依赖"></a>服务依赖</h3><p>同样的，我们先来引入依赖（与服务注册相同的依赖）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--nacos 服务注册发现--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>配置nacos地址（也相同）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">item-service</span> <span class="hljs-comment"># 服务名称</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span> <span class="hljs-comment"># nacos地址</span><br></code></pre></td></tr></table></figure><p>DiscoveryClient接口是SpringCloud定义的标准接口，通过DI注入来获取到Nacos针对此接口的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 通过discoveryClient拉取实例列表</span><br>List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(<span class="hljs-string">&quot;item-service&quot;</span>);<br><span class="hljs-keyword">if</span> (CollUtils.isEmpty(instances)) &#123;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-type">ServiceInstance</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> instances.get(RandomUtil.randomInt(instances.size()));<br><br>ResponseEntity&lt;List&lt;ItemDTO&gt;&gt; re = restTemplate.exchange(instance.getUri() + <span class="hljs-string">&quot;/items?ids=&#123;ids&#125;&quot;</span>,<br>        HttpMethod.GET,<br>        <span class="hljs-literal">null</span>,<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ParameterizedTypeReference</span>&lt;List&lt;ItemDTO&gt;&gt;() &#123;<br>        &#125;,<br>        Map.of(<span class="hljs-string">&quot;ids&quot;</span>, CollUtils.join(itemIds, <span class="hljs-string">&quot;,&quot;</span>)));<br><br><span class="hljs-keyword">if</span> (!re.getStatusCode().is2xxSuccessful())&#123;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br>List&lt;ItemDTO&gt; items = re.getBody();<br><br><span class="hljs-keyword">if</span> (CollUtils.isEmpty(items)) &#123;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，我们通过动态Nacos获取到服务的URI，即可直接访问服务</p><ul><li>在服务的时候，可以实现负载均衡的访问</li><li>在某一个服务挂掉的时候，仍然可以正常通过其他服务访问</li></ul><hr><h3 id="OpenFeign"><a href="#OpenFeign" class="headerlink" title="OpenFeign"></a>OpenFeign</h3><p>注入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- OpenFeign --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!--负载均衡--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalancer<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在启动类上加上@EnableFeignClients注解，开启OpenFeign</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@MapperScan(&quot;com.hmall.cart.mapper&quot;)</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableFeignClients</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CartApplication</span> &#123;<br></code></pre></td></tr></table></figure><p>编写FeignClient，将服务间的API写成类Controller的形式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(&quot;item-service&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ItemClient</span> &#123;<br>    <span class="hljs-meta">@GetMapping</span><br>    List&lt;ItemDTO&gt; <span class="hljs-title function_">queryItemByIds</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;ids&quot;)</span> List&lt;Long&gt; ids )</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="OKHttp"><a href="#OKHttp" class="headerlink" title="OKHttp"></a>OKHttp</h3><p>OpenFiegn对Http请求做了优雅的封装，其底层默认使用HttpURLConection的发送方式（JDK自带）</p><p>性能很低且不支持连接池，但OpenFiegn对于底层的连接方式做了可插拔式设计</p><p>我们可以通过简单配置为其更换其他底层连接方式（支持连接池）：</p><ul><li>Apache HttpClient</li><li>OKHttp</li></ul><p>首先引入okhttp的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.github.openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>feign-okhttp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>开启feign-okhttp的支持</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">feign:</span><br>  <span class="hljs-attr">okhttp:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 开启OKHttp连接池支持</span><br></code></pre></td></tr></table></figure><p>至此，OpenFiegn的底层已经是使用OkHttp进行发送请求，且支持连接池</p><hr><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><p><strong>方案一：重构服务</strong></p><p>将一个微服务重构，每一个微服务再拆成三个模块:</p><ul><li>api：存放api供外部调用</li><li>dto：api所需传输实体</li><li>biz：属于微服务本身的业务逻辑</li></ul><p>如果有需求，就将api和dto两个模块作为依赖引入，就可以直接实现服务间调用</p><hr><p><strong>方案二：抽取API</strong></p><p>将所有的API以及DTO抽取出到一个模块中，所有项目都依赖此模块</p><p>将API独立模块之后，Feign会找不到API包模块，需要指定FeignClient位置才行</p><p>方式一：指定所在包</p><blockquote><p>@EnableFeignClients(basePackages &#x3D; “com.hmall.api.clients”)</p></blockquote><p>方式二：指定字节码文件</p><blockquote><p>@EnableFeignClients(clients &#x3D; {UserClient.class})</p></blockquote><hr><h3 id="日志管理"><a href="#日志管理" class="headerlink" title="日志管理"></a>日志管理</h3><p>默认情况下OpenFeign不提供任何的日志记录，<em>一般情况下也不需要配置日志，只有调试时需要</em></p><p>创建一个配置类，但不要加配置类注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultFeignConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Logger.Level <span class="hljs-title function_">feignLoggerLevel</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Logger.Level.FULL;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为单个client配置日志</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(value = &quot;item-service&quot;,configuration = DefaultFeignConfig.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ItemClient</span> &#123;<br>    <span class="hljs-meta">@GetMapping(&quot;/items&quot;)</span><br>    List&lt;ItemDTO&gt; <span class="hljs-title function_">queryItemByIds</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;ids&quot;)</span> Collection&lt;Long&gt; ids )</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>为该服务整体配置日志</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@MapperScan(&quot;com.hmall.cart.mapper&quot;)</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableFeignClients(basePackages = &quot;com.hmall.api.client&quot;, defaultConfiguration = DefaultFeignConfig.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CartApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(CartApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
      <category>SpringCloud</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>docker</title>
    <link href="/2025/06/05/docker/"/>
    <url>/2025/06/05/docker/</url>
    
    <content type="html"><![CDATA[<p>docker在微服务的体系架构中也是重中之重，让我们一起来复习一下docker的相关知识</p><p>alias可以为linux的命令起别名，通过将alias的命令写入~&#x2F;.bashrc中，可实现永久别名</p><blockquote><p>例如我们可以将docker ps -a 起一个别名：dpa</p></blockquote><hr><h3 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h3><p>通过docker exec -it [] bash来进入容器，如果该容器内置了bash就可以正常进入</p><p>但有一些容器没有集成bash，就得进入sh（亦或者是dash）来输入命令</p><h3 id="卷"><a href="#卷" class="headerlink" title="卷"></a>卷</h3><p>通过docker volume inspect 命令查看卷的详情</p><p>事实上，宿主及可以直接通过卷来修改配置文件，但更推荐使用绑定挂载的方式</p><p>通过docker volume prune来清楚没有挂载到任何容器的卷</p><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>通过docker inspect命令查看容器的详情</p><h3 id="自定义镜像"><a href="#自定义镜像" class="headerlink" title="自定义镜像"></a>自定义镜像</h3><p>构建一个Java的项目docker，往往需要一个linux的运行环境，和java的运行环境</p><p>但linux的运行环境并不是需要一整个系统，而是可以提取出所需系统函数库</p><p>分层式抽取后，打包后的产物就叫做基础镜像（BaseImage）</p><p>我们每次构建项目都可以直接基于基础镜像构建了</p><h3 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h3><table><thead><tr><th align="center">指令</th><th align="center">说明</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">FROM</td><td align="center">指定基础镜像</td><td align="center">FROM centos:6</td></tr><tr><td align="center">ENV</td><td align="center">设置环境变量，可在后面指令使用</td><td align="center">ENV key value</td></tr><tr><td align="center">COPY</td><td align="center">拷贝本地文件到镜像的指定目录</td><td align="center">COPY .&#x2F;jrell.tar.gz &#x2F;tmp</td></tr><tr><td align="center">RUN</td><td align="center">执行Linux的shell命令，一般是安装过程的命令</td><td align="center">RUN tar -zxvf &#x2F;tmp&#x2F;jrell.tar.gz &amp;&amp; EXPORTS path&#x3D;&#x2F;tmp&#x2F;jrell:$path</td></tr><tr><td align="center">EXPOSE</td><td align="center">指定容器运行时监听的端口，是给镜像使用者看的</td><td align="center">EXPOSE 8080</td></tr><tr><td align="center">ENTRYPOINT</td><td align="center">镜像中应用的启动命令，容器运行时调用</td><td align="center">ENTRYPOINT java -jar xx.jar</td></tr></tbody></table><h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><p>通过docker build -t myImage:1.0 . 来构建镜像</p><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><p>默认情况下，所有构建的容器都处于同一个内网中，共用一个网关，所有容器都是以bridge方式连接到Docker的一个虚拟网桥</p><hr>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
      <category>docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MyBatis-Plus-扩展功能</title>
    <link href="/2025/06/05/MyBatis-Plus-%E6%89%A9%E5%B1%95%E5%8A%9F%E8%83%BD/"/>
    <url>/2025/06/05/MyBatis-Plus-%E6%89%A9%E5%B1%95%E5%8A%9F%E8%83%BD/</url>
    
    <content type="html"><![CDATA[<h1 id="扩展功能"><a href="#扩展功能" class="headerlink" title="扩展功能"></a>扩展功能</h1><h3 id="代码生成功能"><a href="#代码生成功能" class="headerlink" title="代码生成功能"></a>代码生成功能</h3><p>Mybatis还是一个DBFirst的ORM开发框架，所以它具有强大代码生成器</p><p><strong>MyBatisX</strong></p><p>官方推荐使用MyBatisX作为代码生成的工具，在开发中我们也使用过很多次了</p><p><strong>MyBatisPlus</strong></p><p>一款代码生成软件</p><p><strong>MyBatisCodeHelper-Pro</strong></p><p>idea插件商店中评分最高的代码生成插件</p><hr><h3 id="静态工具"><a href="#静态工具" class="headerlink" title="静态工具"></a>静态工具</h3><p>MybatisPlus还提供了Db静态工具，可以直接通过DB调用方法，将类字节码文件作为参数传递之后，可以直接对数据库进行增删改查</p><hr><h3 id="逻辑删除"><a href="#逻辑删除" class="headerlink" title="逻辑删除"></a>逻辑删除</h3><p>逻辑删除可以手动实现，mybatis也提供配置以实现全局的逻辑删除操作</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">mybatis-plus:</span><br>  <span class="hljs-attr">global-config:</span><br>    <span class="hljs-attr">db-config:</span><br>      <span class="hljs-attr">logic-delete-field:</span> <span class="hljs-string">flag</span> <span class="hljs-comment"># 全局逻辑删除的实体字段名，字段类型可以是boolean, integer</span><br>      <span class="hljs-attr">logic-delete-value:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 逻辑已删除值(默认为 1)</span><br>      <span class="hljs-attr">logic-not-delete-value:</span> <span class="hljs-number">0</span> <span class="hljs-comment"># 逻辑未删除值(默认为 0)</span><br></code></pre></td></tr></table></figure><p>当配置好逻辑删除后，代码中调用.remove方法删除数据时，会默认使用逻辑删除操作</p><hr><h3 id="枚举处理器"><a href="#枚举处理器" class="headerlink" title="枚举处理器"></a>枚举处理器</h3><p>配置枚举处理器</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">mybatis-plus:</span><br>  <span class="hljs-attr">configuration:</span><br>    <span class="hljs-attr">default-enum-type-handler:</span> <span class="hljs-string">com.baomidou.mybatisplus.core.handlers.MybatisEnumTypeHandler</span><br></code></pre></td></tr></table></figure><p>创建枚举类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Getter</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Status</span> &#123;<br>    NORMAL(value: <span class="hljs-number">1</span>, desc: <span class="hljs-string">&quot;正常&quot;</span>),<br>    FROZEN(value: <span class="hljs-number">2</span>, desc: <span class="hljs-string">&quot;停用&quot;</span>),<br>    ;<br><br>    <span class="hljs-meta">@EnumValue</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> value;<br>    <span class="hljs-meta">@JsonValue</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String desc;<br><br>    UserStatus(<span class="hljs-type">int</span> value, String desc) &#123;<br>        <span class="hljs-built_in">this</span>.value = value;<br>        <span class="hljs-built_in">this</span>.desc = desc;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注：在使用此枚举类型的实体类对象（包括dto,vo）中将int类型更改为枚举类型</p><p>Mybatis在处理该属性时，会将@EnumValue注解修饰的值存入数据库，会将@JsonValue修饰的值作为json的返回值</p><hr><h3 id="JSON处理器"><a href="#JSON处理器" class="headerlink" title="JSON处理器"></a>JSON处理器</h3><p>在开发过程中，如果数据库中储存了JSON格式的字段，那么对应JAVA会将其设置为String格式，String格式的数据我们取出来之后还需要手动的将其转换为对象</p><p>使用Mybatis的JSON处理器，可以直接实现实体类中属性和表中JSON字段的转换</p><hr><h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><h3 id="分页插件"><a href="#分页插件" class="headerlink" title="分页插件"></a>分页插件</h3><p>MybatisPlus没有强制使用分页插件，所以可以继续使用PageHelper</p><p>或者使用MybatisPlus内置的拦截器分页插件</p><h3 id="实体和工具方法"><a href="#实体和工具方法" class="headerlink" title="实体和工具方法"></a>实体和工具方法</h3><p>PageQuery和PageVO基本为固定类，可以单独定义</p><blockquote><p>将PageQuery的参数提取出来，创建IPage对象</p><p>将IPage对象的内容重新封装回PageVo</p></blockquote><p>这两个流程应该是相对固定，所以我们可以将其抽取出来作为静态工具方法</p><hr>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
      <category>MybatisPlus</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MyBatis-Plus-IService</title>
    <link href="/2025/06/05/MyBatis-Plus-IService/"/>
    <url>/2025/06/05/MyBatis-Plus-IService/</url>
    
    <content type="html"><![CDATA[<h1 id="IService"><a href="#IService" class="headerlink" title="IService"></a>IService</h1><p>在MybatisPlus中，其实极大程度的破坏了三层架构的基本规范，把三层架构打薄了，其实这是一种务实的妥协</p><p>它牺牲了一点点严格的职责划分的“纯粹性”，来换取巨大的开发效率提升。</p><p>MybatisPlus提供了IService接口和ServiceImpl实现类，底层通过调用BaseMapper可以直接在Service层直接完成对单表的增删改查</p><p>IService提供了lambdaQuery方法，可直接链式调用，使用非常类似EFCore的代码完成操作</p><hr><h3 id="最佳实现"><a href="#最佳实现" class="headerlink" title="最佳实现"></a>最佳实现</h3><p>我们可以在Service层直接实现简单的增删改查</p><p>复杂的，需要性能优化的查询可以交给xml编写模板文件</p><hr><h3 id="批量新增"><a href="#批量新增" class="headerlink" title="批量新增"></a>批量新增</h3><p>直接使用IService的批量新增方法即可</p><p>需要注意的是，如果Jdbc的rewriteBatchedStatement&#x3D;false（默认值为false），则不会自动拼接成一条sql，需要手动在数据库连接字符串处增加此配置，将其更改为true</p><hr>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
      <category>MybatisPlus</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MyBatis-Plus</title>
    <link href="/2025/06/04/MyBatis-Plus/"/>
    <url>/2025/06/04/MyBatis-Plus/</url>
    
    <content type="html"><![CDATA[<h1 id="Mybatis-Plus"><a href="#Mybatis-Plus" class="headerlink" title="Mybatis-Plus"></a>Mybatis-Plus</h1><p>在学习微服务之前，我们再次重温MybatisPlus的内容</p><p>个人理解，MybatisPlus提供了非常简便的接口以供快速开发单表的增删改查，所以非常契合微服务架构</p><h3 id="条件构造器"><a href="#条件构造器" class="headerlink" title="条件构造器"></a>条件构造器</h3><p>尤其是在使用体验和对SQL语句的封装程度上，Mybatis-Plus的<code>Wrapper</code>机制确实与EF Core的LINQ查询有异曲同工之妙，使得两者的调用方式在某些场景下显得非常相似</p><p>Mybatis-Plus的<code>Wrapper</code>机制，特别是其对Lambda表达式的支持，确实在很大程度上提供了与EF Core的LINQ查询相似的、面向对象的、流式化的SQL构建体验，极大地提升了开发效率</p><hr><p><strong>QueryWrapper&amp;UpdateWrapper</strong></p><p>当单纯的使用where作为条件拼接时，QueryWrapper可以完美的替代UpdateWrapper</p><p>在默认设置的更新策略下Redis（NOT_NULL），是不可以将数据库字段更新为空值的，但使用UpdateWrapper的set方法可以针对字段更新，那么也就可以将指定字段更新为null，这是 UpdateWrapper 的一个重要优势</p><p>UpdateWrapper提供了setSql()方法，允许你在SET子句中直接写入SQL片段，这对于实现column &#x3D; column + 1（自增）、update_time &#x3D; NOW()（更新时间戳）等操作非常有用</p><hr><p><strong>整合</strong></p><p>使用wrapper作为where的条件是正确思路，但直接将一些select语句写在service层又不符合企业规范</p><p>所以可以将条件的构建交给mybatisplus接管，使用wrapper构建，其他的sql语句仍然写在mapper.xml中</p><p>需要注意的是，在mapper层给mapper.xml传wrapper时，我们需要将wrapper参数加上 Param注解，且注解的值必须为ew</p><p><em>或者调用Constants.WRAPPER获取常量</em></p><hr><h3 id="哑巴“mapper”"><a href="#哑巴“mapper”" class="headerlink" title="哑巴“mapper”"></a>哑巴“mapper”</h3><p><strong>理想的“哑巴”Mapper：</strong></p><p>如果 Mapper 层是绝对的“哑巴”，它应该只知道如何将 User 实体对象映射到 user 表，并提供最基本的 CRUD 操作（insert(User)、update(User)、selectById(id)、deleteById(id)）。</p><p>它的方法签名和 XML 定义应该严格对应数据库的单表操作，不涉及任何业务概念上的“视图”或“聚合”。</p><p>在这种理想情况下，任何涉及多表联查、复杂聚合、或者需要特定字段组合的“业务视图”，都应该由 Service 层通过调用多个 Mapper 的单表方法，然后在内存中进行数据组装和处理。</p><p><strong>Mybatis 的现实与优势：</strong></p><p>Mybatis 的核心优势就是它能够让你直接编写 SQL。这意味着你可以利用数据库的强大能力来执行复杂的 JOIN、子查询、聚合函数、窗口函数等。</p><p>如果 Service 层需要一个“用户及其所有订单”的视图，让数据库通过一个 JOIN 查询一次性返回，通常比 Service 层先查用户，再循环查每个用户的订单（N+1 问题），或者查所有用户和所有订单然后在内存中匹配，要高效得多。</p><p>Mybatis 的 resultMap 机制也使得将复杂的 JOIN 结果直接映射到复杂的 DTO&#x2F;VO 对象变得非常方便，省去了 Service 层手动组装的繁琐。</p><p>在 Mybatis 的世界里，我们确实是利用了它方便编写 SQL 的特性，在 Mapper 层（特别是 XML 文件中）定义了许多<strong>针对 Service 层特定业务需求而定制的“抽象视图”或“聚合查询”</strong>。</p><p>这是一种<strong>务实且高效的架构选择</strong>，它在一定程度上“牺牲”了 Mapper 层的绝对“哑巴”特性，以换取更优的性能、更简洁的 Service 层代码（无需手动组装复杂对象），以及更灵活的 SQL 控制能力。这种折中在 Mybatis 社区中是普遍接受的最佳实践。</p><hr><h3 id="MybatisPlus的最佳实践"><a href="#MybatisPlus的最佳实践" class="headerlink" title="MybatisPlus的最佳实践"></a>MybatisPlus的最佳实践</h3><p>在微服务架构下，Mybatis-Plus 和 Mybatis 并非互斥，而是相辅相成的强大工具。理解它们的优势与适用场景，并遵循清晰的服务边界原则，是构建高效、可维护系统的关键。</p><p><strong>1. Mybatis (XML) 最佳实践：复杂查询与性能优化</strong></p><p>在服务内部，当面临需要高性能、复杂数据聚合的查询场景时，我们可以在 Mybatis 的 XML Mapper 中编写定制化的 SQL。</p><ul><li><strong>妥协“哑巴原则”：</strong> 在这种特定场景下，为了追求极致的性能和灵活性，我们可以适度偏离严格的“哑巴原则”（即 SQL 仅负责简单的 CRUD 映射）。</li><li><strong>采用“抽象视图原则”：</strong> 即在 XML 中编写复杂的 SQL（如多表 JOIN、子查询、聚合函数、窗口函数等），以构建针对特定业务需求的“数据视图”。</li><li><strong>优势：</strong> 这种方式能够充分利用数据库的优化能力，实现高性能的复杂查询，减少应用层的内存组装和网络往返。对于服务内部的复杂报表、统计或特定业务视图而言，其性能优势是显著的。</li><li><strong>局限性：</strong> 虽然可能降低 SQL 的通用复用性，因为这些 SQL 通常是为特定业务场景量身定制的。</li><li><strong>重要前提：</strong> <strong>此实践仅限于服务内部的数据操作。</strong></li></ul><p><strong>2. Mybatis-Plus 最佳实践：单表操作与动态条件</strong></p><p>Mybatis-Plus 在微服务架构中展现出巨大优势，尤其适用于处理服务内部的单表 CRUD (增删改查) 操作。</p><ul><li><strong>简化单表操作：</strong> Mybatis-Plus 提供了大量开箱即用的通用方法，极大地简化了单表操作的开发工作，减少了大量的样板代码。这与微服务中每个服务通常聚焦于其核心数据模型的特点高度契合。</li><li><strong>强大的 Wrapper 机制：</strong> 其核心亮点在于强大的 <code>Wrapper</code> 机制。通过 <code>Wrapper</code>，我们可以在 Java 代码中灵活、类型安全地拼接各种动态的 <code>WHERE</code> 条件、排序、分组等，以满足不同业务场景下对单表数据的查询需求。</li><li><strong>优势：</strong> 这使得业务逻辑层能够根据运行时参数动态构建查询，而无需为每种条件组合编写独立的 SQL，提高了开发效率和代码可维护性。</li></ul><p><strong>3. 核心准则：服务边界与数据所有权</strong></p><p>Mybatis-Plus 和 Mybatis 的协同使用，应严格遵循微服务架构的核心原则——<strong>服务边界与数据所有权</strong>。</p><ul><li><strong>黄金准则：</strong> <strong>同一服务内的多张表应该 JOIN，跨服务的表不应该 JOIN！</strong></li><li><strong>服务内 JOIN 的合理性：</strong><ul><li>服务内部的表通常属于同一个业务领域，共同构成该服务的数据模型。</li><li>在同一个数据库实例内进行 JOIN 操作，可以保证事务一致性，并利用数据库的优化能力，实现高效的数据聚合。</li><li>这符合服务内部数据内聚的原则。</li></ul></li><li><strong>跨服务 JOIN 的危害：</strong><ul><li><strong>打破封装性：</strong> 直接跨服务 JOIN 数据库表会严重破坏服务的封装性，侵入其他服务的内部实现细节。</li><li><strong>紧密耦合：</strong> 导致服务间紧密耦合，一旦被 JOIN 的服务修改了数据库结构，依赖方将立即受影响，阻碍服务的独立部署、独立演进和弹性伸缩。</li><li><strong>分布式事务复杂性：</strong> 跨库 JOIN 无法在一个本地事务中完成，若涉及数据一致性，将引入复杂的分布式事务问题。</li></ul></li></ul><hr>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
      <category>MybatisPlus</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式</title>
    <link href="/2025/01/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2025/01/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p>到2025年1月12号，终于明白宋红康说的这句话的含义：框架 &#x3D; 注解 + 反射 + 设计模式</p><h3 id="MVC-和三层架构"><a href="#MVC-和三层架构" class="headerlink" title="MVC 和三层架构"></a>MVC 和三层架构</h3><p>三层架构是一种软件设计模式，但又不同于传统意义上的设计模式，我们可以将其称之为<strong>设计架构</strong>，而MVC是设计模式的一种</p><p>三层架构分为：</p><ul><li><p>表示层（Presentation Layer）</p></li><li><p>业务逻辑层（Business Logic Layer, BLL）</p></li><li><p>数据访问层（Data Access Layer, DAL）</p></li></ul><p>这种架构使用了多个设计模式，具体取决于实现方式，但常见的设计模式包括但不限于：</p><ul><li><strong>MVC模式（Model-View-Controller）</strong>：在表示层中常见的一种模式，用于分离用户界面逻辑（View）、业务逻辑（Model）和输入控制（Controller）。</li><li><strong>工厂模式（Factory Pattern）</strong>：用于创建对象而无需指定具体的类，常用于业务逻辑层中创建复杂对象。</li><li><strong>单例模式（Singleton Pattern）</strong>：确保一个类只有一个实例，并提供一个全局访问点，经常用于配置管理或连接池等资源。</li><li><strong>仓库模式（Repository Pattern）</strong>：用于抽象数据访问层，使得业务逻辑层可以独立于数据源的具体实现。</li><li><strong>服务定位器模式（Service Locator Pattern）</strong>：帮助查找和缓存服务对象，有助于减少依赖关系。</li><li><strong>单元OfWork模式（Unit of Work Pattern）</strong>：保持一系列要作为一个整体提交或回滚的操作，通常在数据访问层中使用。</li></ul><hr><h5 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h5><p>在一个spring框架的后端项目中，可以使用三层架构来实现设计模式</p><ul><li><p>表示层：在前后的分离的项目中，在web API的设计中是Controller层，但也可以理解为这一层单独独立出一个前端工程</p></li><li><p>业务逻辑层：包含服务（Service）组件，负责业务逻辑</p></li><li><p>数据访问层：由仓库（Repository）或DAO（Data Access Object）组成，负责与数据库交互</p></li></ul><p>在组合mybatis框架之后，后端的数据访问层由mybatis的mapper层接管</p><p>但以MVC设计模式来理解后端，则为：</p><ul><li><p>Model（模型）</p><ul><li><p><strong>数据载体</strong>：模型代表应用程序的数据和业务逻辑。它不仅包括实体类（如POJOs），还可能包括DTO（数据传输对象）、VO（值对象）等。</p></li><li><p><strong>服务层</strong>：虽然严格来说，服务层不是MVC的一部分，但它与模型紧密相关，因为它是处理业务逻辑的地方。服务组件通常会操作模型，并且可以被控制器调用来执行特定的业务功能。</p></li></ul></li><li><p>View（视图）</p><ul><li><p><strong>视图解析器</strong>：在传统的Spring MVC应用中，视图通常是HTML页面、JSP文件、Thymeleaf模板等，用于展示给用户的数据。Spring使用视图解析器（ViewResolver）来确定哪个视图应该被渲染。</p></li><li><p><strong>前后端分离</strong>：在现代的前后端分离架构中，视图的概念有所变化。前端不再由后端直接生成，而是通过API接口接收JSON或XML格式的数据，然后由前端框架（如Vue.js、React等）负责渲染。此时，“视图”更倾向于指向前端如何解释和显示这些数据。</p></li></ul></li><li><p>Controller（控制器）</p><ul><li><p><strong>@Controller&#x2F;@RestController注解</strong>：控制器是MVC模式中最重要的部分之一，在Spring中通常通过<code>@Controller</code>或<code>@RestController</code>注解来标识。它们负责接收HTTP请求，处理请求参数，调用相应的服务方法，以及返回视图名称或直接返回数据（如JSON、XML）给客户端。</p></li><li><p><strong>RequestMapping</strong>：控制器中的方法通常使用<code>@RequestMapping</code>及其衍生注解（如<code>@GetMapping</code>、<code>@PostMapping</code>等）来映射具体的URL路径到方法上，从而实现对不同HTTP请求的处理。</p></li></ul></li></ul><hr><h5 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h5><p>Vue前端工程，也是可以看作使用mvc设计模式的，但也可以看作使用MVVM设计模式</p><ul><li><strong>HTML + CSS</strong>：用于构建用户界面（View）。这是用户直接交互的部分</li><li><strong>JavaScript&#x2F;TypeScript</strong>：用来实现视图模型（ViewModel，在MVVM模式下）或控制器（Controller，在MVC模式下）</li></ul><p>在前端，模型的概念可能不像在后端那样明确，尤其是在使用纯JavaScript时。然而，当你引入TypeScript时，你可以更加严格地定义接口和类型，这有助于更好地贯彻模型概念。例如，你可以创建TypeScript接口来定义从后端接收的数据结构，或者定义状态管理库（如Vuex）中的状态结构，这实际上是在前端实现了模型的概念。</p><hr>]]></content>
    
    
    <categories>
      
      <category>NET框架相关</category>
      
      <category>synyi</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>AI</title>
    <link href="/2025/01/11/AI/"/>
    <url>/2025/01/11/AI/</url>
    
    <content type="html"><![CDATA[<h1 id="AI"><a href="#AI" class="headerlink" title="AI"></a>AI</h1><h3 id="AIGC"><a href="#AIGC" class="headerlink" title="AIGC"></a>AIGC</h3><p>AIGC（AI-Generated Content）是指使用人工智能技术生成的内容</p><ul><li>通义灵码的代码生成</li><li>Midjourney的图片生成</li><li>剪映的AI视频生成</li><li>……</li></ul><h3 id="AGI"><a href="#AGI" class="headerlink" title="AGI"></a>AGI</h3><p>AGI（Artificial General Intelligence，通用人工智能）是指具有与人类智能相似的广泛认知能力的人工智能</p><ul><li>文心一言</li><li>讯飞星火</li><li>通义千问</li><li>……</li></ul><h3 id="Prompt"><a href="#Prompt" class="headerlink" title="Prompt"></a>Prompt</h3><p>对于合理使用AI而言，Prompt的提问方式是重中之重</p><ul><li><strong>角色</strong>：给AI定义一个最匹配任务的角色</li><li><strong>提示</strong>：对任务进行描述</li><li>上下文：给出任务相关的其他背景信息</li><li>例子：必要时给出举例</li><li>输入：任务的输入信息</li><li>输出：输出的格式描述，以便后续模块自动解析模型的输出结果</li></ul><hr><h3 id="具体功能"><a href="#具体功能" class="headerlink" title="具体功能"></a>具体功能</h3><ul><li>生成SQL脚本</li><li>根据SQL脚本生成数据库说明文档</li><li>根据代码生成流程图（可以让AI用mermaid语言来描述，使用md可直接解析）</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs markdown">你是一个软件工程师，帮我生成mysql的表结构：<br>需求如下：<br><span class="hljs-bullet">1.</span> 区域表，表明tb<span class="hljs-emphasis">_region,字段有主键id 、 区域名称</span><br><span class="hljs-emphasis">2. 合作商表，表明tb_</span>partner,字段有主键id、合作商名称、联系人、联系电话、分成比例（int类型）、账号、密码<br><span class="hljs-bullet">3.</span> 点位表，表名tb<span class="hljs-emphasis">_node，字段有主键id、点位名称、详细地址、商圈类型（int类型）</span><br><span class="hljs-emphasis">其他要求：</span><br><span class="hljs-emphasis">1. 每张表中都有创建时间（create_</span>time）、修改时间(date<span class="hljs-emphasis">_time)、创建人（create_</span>by）、修改人（update<span class="hljs-emphasis">_by） 、备注(remark)这些字段</span><br><span class="hljs-emphasis">2. 每张表的主键是自增的</span><br><span class="hljs-emphasis">3. 区域与点位是一对多的关系，合作商与点位也是一对多的关系，请用字段表示出来，并建立外键约束</span><br><span class="hljs-emphasis">4. 请为每个字段添加comment</span><br><span class="hljs-emphasis">5. 请帮我给生成的表中插入一些吉林城市相关区域、点位、合作商的测试数据</span><br></code></pre></td></tr></table></figure><hr><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">你是一个软件开发工程师，现在需要根据数据库的sql脚本，查询并显示合作商标所有的字段信息，同时显示每个合作商的点位数，sql脚本如下：<br><span class="hljs-emphasis">*将表的sql语句贴在这里*</span><br><br>这样就实现了AI生成的多表查询语句<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>NET框架相关</category>
      
      <category>synyi</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>VUE3-其他API</title>
    <link href="/2025/01/03/VUE3-%E5%85%B6%E4%BB%96API/"/>
    <url>/2025/01/03/VUE3-%E5%85%B6%E4%BB%96API/</url>
    
    <content type="html"><![CDATA[<h1 id="VUE3-其他API"><a href="#VUE3-其他API" class="headerlink" title="VUE3-其他API"></a>VUE3-其他API</h1><h3 id="shallowRef-shallowReactive"><a href="#shallowRef-shallowReactive" class="headerlink" title="shallowRef&amp;shallowReactive"></a>shallowRef&amp;shallowReactive</h3><p>浅层次的ref，对于修饰对象的ref来说，使用shallowRef仅映射第一层，shallowRef的效率更高</p><p>shallowReactive同理，对象中第一层中的内容是响应式的，但深层次的就不被修饰为响应式的</p><p>如果不想关注深层次的响应式内容，就可以使用这两个来修饰响应式数据，这使得属性的访问更快，可以提升性能</p><hr><h3 id="readonly和shallowReadonly"><a href="#readonly和shallowReadonly" class="headerlink" title="readonly和shallowReadonly"></a>readonly和shallowReadonly</h3><p>readonly和const是有区别的，const是针对于引用不可被重新赋值，但其属性可以改变，而readonly修饰的对象可以重新赋值，但属性不可改变</p><p>shallowReadonly 是一个浅层次的只读，第一层被保护无法修改，而深层次可以修改</p><hr><h3 id="toRaw-markRaw"><a href="#toRaw-markRaw" class="headerlink" title="toRaw&amp;markRaw"></a>toRaw&amp;markRaw</h3><p>toRaw可以获取一个响应式对象的原始对象，在需要将响应式对象给非Vue的库或外部系统时，使用toRaw可以确保他们收到的是非响应式对象</p><p>markRaw可以标记一个对象，使其永远不会成为响应式对象</p><p>例如使用mockjs时，为了防止错误的把mockjs变成响应式对象，可以使用markRaw去标记mockjs</p><hr><h3 id="customRef"><a href="#customRef" class="headerlink" title="customRef"></a>customRef</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 使用Vue提供的customRef定义响应式数据</span><br><span class="hljs-keyword">let</span> initValue = <span class="hljs-string">&#x27;你好&#x27;</span>;<br><br><span class="hljs-comment">// track(跟踪)、trigger(触发)</span><br><span class="hljs-keyword">let</span> msg = <span class="hljs-title function_">customRef</span>(<span class="hljs-function">(<span class="hljs-params">track, trigger</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-comment">// get何时调用？ — msg被读取时</span><br>    <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-title function_">track</span>(); <span class="hljs-comment">// 告诉Vue数据msg很重要，你要对msg进行持续关注，一旦msg变化就去更新</span><br>      <span class="hljs-keyword">return</span> initValue;<br>    &#125;,<br>    <span class="hljs-comment">// set何时调用？ — msg被修改时</span><br>    <span class="hljs-title function_">set</span>(<span class="hljs-params">value</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;set&#x27;</span>, value);<br>      initValue = value;<br>      <span class="hljs-title function_">trigger</span>(); <span class="hljs-comment">// 通知Vue一下数据msg变化了</span><br>    &#125;<br>  &#125;;<br>&#125;);<br></code></pre></td></tr></table></figure><p>这段代码使用了 Vue 的 <code>customRef</code> 来创建一个自定义的响应式引用。具体解释如下：</p><ol><li><strong>初始化值</strong>：<code>initValue</code> 是初始值。</li><li><strong><code>customRef</code></strong>：通过 <code>customRef</code> 创建一个自定义的响应式引用。</li><li><strong><code>get</code> 方法</strong>：当 <code>msg</code> 被读取时，会调用 <code>get</code> 方法，并返回 <code>initValue</code>。</li><li><strong><code>set</code> 方法</strong>：当 <code>msg</code> 被修改时，会调用 <code>set</code> 方法，并更新 <code>initValue</code>，同时触发依赖项更新。</li></ol><p><em>一般会将自定义ref封装成为一个hooks</em></p><hr><h3 id="teleport"><a href="#teleport" class="headerlink" title="teleport"></a>teleport</h3><p>teleport是一种能够让我们的组件html结构移动到指定位置的技术，多用于子组件中想将某一个结构移至父组件（弹窗）</p><hr><h3 id="Suspense"><a href="#Suspense" class="headerlink" title="Suspense"></a>Suspense</h3><p>如果子组件中包含着异步请求，我们可以通过Suspense元素+命名插槽的方式来处理</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:default</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">Child</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:fallback</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>加载中…………<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123;<span class="hljs-title class_">Suspense</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;Child.vue&#x27;</span></span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在这里，Child组件中有异步发送Axios请求的操作，利用Suspense配合命名插槽</p><p>当没有请求到内容时，插槽中显示h2标签的加载中，当请求到内容时，再将子组件内容渲染到插槽中</p><hr><p>在Vue2中，存在一个全局API，在Vue3中已经全部转移应用对象</p><h3 id="app-component"><a href="#app-component" class="headerlink" title="app.component"></a>app.component</h3><p>注册全局组件，再main.js中，调用app.component可以将组件注册为全局组件</p><h3 id="app-config"><a href="#app-config" class="headerlink" title="app.config"></a>app.config</h3><p>app.config.globalProperties可以添加全局属性，不推荐这么使用，因为无法追踪代码</p><h3 id="app-directive"><a href="#app-directive" class="headerlink" title="app.directive"></a>app.directive</h3><p>app.directive添加全局指令</p><h3 id="app-mount"><a href="#app-mount" class="headerlink" title="app.mount"></a>app.mount</h3><p>挂载应用</p><h3 id="app-unmount"><a href="#app-unmount" class="headerlink" title="app.unmount"></a>app.unmount</h3><p>卸载应用</p><h3 id="app-use"><a href="#app-use" class="headerlink" title="app.use"></a>app.use</h3><p>安装插件</p><hr>]]></content>
    
    
    <categories>
      
      <category>JAVAWEB</category>
      
      <category>vue</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>VUE3-组件通信</title>
    <link href="/2025/01/03/VUE3-%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/"/>
    <url>/2025/01/03/VUE3-%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="VUE3-组件通信"><a href="#VUE3-组件通信" class="headerlink" title="VUE3-组件通信"></a>VUE3-组件通信</h1><h3 id="props"><a href="#props" class="headerlink" title="props"></a>props</h3><p>props是使用频率最高的一种通信方式，对于父传子而言，这种方式很方便</p><p>使用props实现子传父，就现在父定义方法，将方法给子，然后子在合适的时机调用此方法将数据传给父</p><p><em>相当于子不直接把内容给父，而是父先给子一个盒子，子把东西装在盒子里扔给父</em></p><hr><h3 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h3><p><em>事件名为多个单词组成的情况下，推荐事件使用肉串（kebab-case）命名，函数使用驼峰命名</em></p><p>在父组件给子组件元素绑定一个自定义事件，并定义一个事件的回调函数</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">child</span> @<span class="hljs-attr">send-msg</span>=<span class="hljs-string">&quot;save&quot;</span>/ &gt;</span><br>    <br><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> child <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;child.vue&#x27;</span></span><br><span class="language-javascript">    </span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">save</span>(<span class="hljs-params">value</span>)&#123;</span><br><span class="language-javascript">        <span class="hljs-comment">// 事件的回调方法，参数value可以由子组件传递，在这里接收</span></span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在子组件使用defineEmits的方法接受此事件，并且在合适的时机触发事件</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> emit = <span class="hljs-title function_">defineEmits</span>([<span class="hljs-string">&#x27;send-msg&#x27;</span>])<br><br><span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;send-msg&#x27;</span>) <span class="hljs-comment">// 触发此事件</span><br></code></pre></td></tr></table></figure><p>尽管直接通过 <code>props</code> 传递回调函数也能实现子组件向父组件传递消息，但使用事件系统具有更好的实践意义，它能带来更清晰的代码结构、更高的可维护性和更好的职责分离，这些都是构建大型应用所必需的。因此，推荐使用自定义事件的方式来实现子组件向父组件的消息传递</p><hr><h3 id="mitt"><a href="#mitt" class="headerlink" title="mitt"></a>mitt</h3><p><code>mitt</code> 是一个轻量级的事件发射器（event emitter）库，它允许你创建一个简单的事件总线（event bus），以便在你的应用中不同组件或模块之间传递消息</p><p><a href="https://github.com/developit/mitt">developit&#x2F;mitt: 🥊 Tiny 200 byte functional event emitter &#x2F; pubsub.</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装工具</span><br>npm i mitt<br></code></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> mitt <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;mitt&#x27;</span><br><br><span class="hljs-keyword">const</span> emitter = <span class="hljs-title function_">mitt</span>()<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> emitter<br></code></pre></td></tr></table></figure><p>常用API：</p><ul><li>on：绑定事件</li><li>off：解绑事件</li><li>all.clear：解绑所有事件</li><li>emit：触发事件，参数为事件名称</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 使用生命周期钩子定义emitter的事件解绑，有利于资源释放</span><br><span class="hljs-title function_">onUnmouted</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>    emitter.<span class="hljs-title function_">off</span>(<span class="hljs-string">&#x27;send-toy&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><hr><h3 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h3><p>当v-model用于html标签上时，可以实现元素与数据之间的双向绑定，其底层原理是使用响应式数据+input事件触发的原理</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts">&lt;input <span class="hljs-keyword">type</span>=<span class="hljs-string">&#x27;text&#x27;</span> v-model=<span class="hljs-string">&#x27;username&#x27;</span>&gt;<br>&lt;!-- 底层原理 --&gt;<br>&lt;input type=&#x27;text&#x27; @input=&#x27;username = (&lt;HTMLInputElement&gt;$event.target).value&#x27;&gt;<br></code></pre></td></tr></table></figure><p>在实际开发中，我们经常使用组件库中的组件来代替类似于input的表单元素，实现精美的效果</p><p>但是一个普通的组件是无法使用v-model与数据进行双向绑定的</p><p>这里，底层使用的还是props与自定义事件来配合完成组件之间的通信</p><p>在使用时，我们也无需手动的props和自定义事件来实现数据的双向绑定，而是使用v-model直接语法糖使用</p><p>这样就完成了UI组件和调用组件之间的双向通信</p><hr><h3 id="attrs"><a href="#attrs" class="headerlink" title="$attrs"></a>$attrs</h3><p>这是一个vue对象中的属性，当父通过props的方式传参给子组件的时候，子组件没有使用defineProps显式接受的参数都会存在这个$attrs属性中</p><p>子组件可以通过将这个属性再次传递的方式将这组没被自己接受的参数再次传给子组件</p><p>这个属性在二次封装UI组件的时候很有用，不想写一堆属性的时候就可以写成： v-bind&#x3D;”$attrs”</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts">&lt;child v-bind=<span class="hljs-string">&quot;&#123;a:a,b:b&#125;&quot;</span>&gt;<br><span class="hljs-comment">// v-bind对象，可以批量传输props</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">child</span> <span class="hljs-attr">:a</span>=<span class="hljs-string">&quot;a&quot;</span> <span class="hljs-attr">:b</span>=<span class="hljs-string">&quot;b&quot;</span>&gt;</span></span><br></code></pre></td></tr></table></figure><hr><h3 id="ref-parent"><a href="#ref-parent" class="headerlink" title="$ref&amp;$parent"></a>$ref&amp;$parent</h3><p>这个特性我们用过，可以在父子组件中暴露数据让对方操作</p><p>使用defineExpose函数暴露，其参数是一个对象</p><p>我们可以使用ref操作子组件中暴露的内容</p><p>也可以使用parent操作父组件中暴露的内容</p><hr><h3 id="provide"><a href="#provide" class="headerlink" title="provide"></a>provide</h3><p>从vue对象中获取provide属性，这个属性可以向自己的所有后代提供数据</p><p>从vue对象中获取inject属性，这个属性可以注入已经提供的数据</p><p>这个数据如果是响应式数据，那么后代获取的也是响应式数据，即在后代中修改数据，其父组件的值也会被修改</p><hr><h3 id="slot"><a href="#slot" class="headerlink" title="slot"></a>slot</h3><p>默认插槽：组件也可以写成双标签的形式，vue会将组件起始标签和结束标签中的其他元素标签内容放到被slot标签占位的位置</p><p>具名插槽：子组件的slot元素标签使用name属性标识后，在父组件中的组件标签上加入v-slot&#x3D;[name属性值]的方式，把指定内容插入指定插槽中</p><p>在这里，可以在元素上包裹一层template标签，将v-slot属性直接加在template标签中</p><p>在这里，v-slot&#x3D;可以被简写成# ，很多UI组件库都将这里的属性简写成# </p><p>作用域插槽：UI组件库中会大量使用作用域插槽，一些弹窗，表格都是通过默认与插槽来实现的</p><hr>]]></content>
    
    
    <categories>
      
      <category>JAVAWEB</category>
      
      <category>vue</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>VUE3</title>
    <link href="/2025/01/03/VUE3/"/>
    <url>/2025/01/03/VUE3/</url>
    
    <content type="html"><![CDATA[<h1 id="VUE3"><a href="#VUE3" class="headerlink" title="VUE3"></a>VUE3</h1><p>和angular相同，vue同样具有vue-cli来初始化工程，但官方更推荐的工具为Vite</p><h3 id="Vite"><a href="#Vite" class="headerlink" title="Vite"></a>Vite</h3><p><a href="https://vitejs.cn/">Home | Vite中文网</a></p><p>Vite是新一代前端构建工具，在angular-cli和vue-cli中，都是使用webpack来作为构建工具的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建基于vite的vue项目</span><br>npm create vue@latest<br></code></pre></td></tr></table></figure><hr><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><ul><li>.vscode：提供一些关于vscode的相关配置文件夹</li><li>public：页签图标存放位置文件夹</li><li>src：源代码文件文件夹</li><li>.gitignore：git忽略文件</li><li>env.d.ts：vue官方把所有可能会写的文件后缀放在这里供ts识别</li><li>index.html：程序的默认页面，也是程序的入口</li><li>package.json：工程管理文件</li><li>tsconfig：ts语言配置文件</li><li>vite.config.ts：vite配置文件</li></ul><hr><h3 id="项目启动"><a href="#项目启动" class="headerlink" title="项目启动"></a>项目启动</h3><p>项目启动的顺序是：index.html -&gt; main.js -&gt; App.vue</p><p>以一盆花来举例说明main.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./assets/main.css&#x27;</span> <span class="hljs-comment">// 样式 不重要</span><br><br><span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span> <span class="hljs-comment">// 盆</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span> <span class="hljs-comment">// 根</span><br><br><span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>).<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>) <span class="hljs-comment">// 把根插在盆里，并把花摆在id为app的盒子中</span><br></code></pre></td></tr></table></figure><p>在这里，如果只看一层结构的话，vue其实仅仅接管了id为app的div容器，其内容是通过组件来实现的</p><hr><h3 id="vue"><a href="#vue" class="headerlink" title=".vue"></a>.vue</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>你好呀<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>&#123;</span><br><span class="language-javascript">        <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;App&#x27;</span></span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.app</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ddd</span>;</span><br><span class="language-css">    <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">10px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">10px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h3 id="Vue风格"><a href="#Vue风格" class="headerlink" title="Vue风格"></a>Vue风格</h3><ul><li>Vue2的API设计是Options（配置）风格的</li><li>Vue3的API设计是Composition（组合）风格的</li></ul><p>Options（配置）风格的弊端</p><p>Options类型的API，数据、方法、计算属性等，是分布在data、methods、computed中的，若想新增或者修改需求，及需要分别修改这些，不便于维护和复用</p><hr><h3 id="Setup"><a href="#Setup" class="headerlink" title="Setup"></a>Setup</h3><p>在Vue2中，选项式的配置在methods中的方法，在Vue3中都变成setup中的函数了</p><p>在Vue2中，选项式配置在data中的数据，在Vue3中的setup中简单的配置是无法做到响应式数据的</p><h5 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h5><p>setup的返回值可以直接指定渲染的内容（渲染函数）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-string">&quot;想要直接返回的内容&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><p>Vue3可以和Vue2的语法共存，且Vue2可以直接使用this获取setup中的数据，但Vue3不可以调用this</p><h5 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h5><p>在这里就相当于使用了一个setup函数，并且自动返回了style标签对中定义的内容</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ts&quot;</span> <span class="hljs-attr">setup</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h3 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h3><p>在Vue3中，setup中默认的数据不再是响应式数据，需要通过vue框架中的ref和reactive方法修饰</p><p>reactive修饰的对象不能直接赋值其他对象，但可以通过Object.assign()方法将新的对象赋值给响应式对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> person = <span class="hljs-title function_">reactive</span>(&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;xiaobai&#x27;</span>,<span class="hljs-attr">age</span>:<span class="hljs-string">&#x27;18&#x27;</span>&#125;)<br><br>person = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;xiaoming&quot;</span>, <span class="hljs-attr">age</span>:<span class="hljs-string">&#x27;19&#x27;</span>&#125; <span class="hljs-comment">//这种方法是错误的</span><br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(person,&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;xiaohong&quot;</span>, <span class="hljs-attr">age</span>:<span class="hljs-string">&quot;20&quot;</span>&#125;) <span class="hljs-comment">//这种方法是正确的</span><br></code></pre></td></tr></table></figure><h5 id="toRefs"><a href="#toRefs" class="headerlink" title="toRefs"></a>toRefs</h5><p>使用toRefs结构reactive的对象，其name和age和person对象进行深绑定</p><p>也就是说，操作name和age属性，就是直接操作person中的name和age</p><p>可以理解为 解构出来的name和age为person属性的代理对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> person = <span class="hljs-title function_">reactive</span>(&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;xiaobai&#x27;</span>,<span class="hljs-attr">age</span>:<span class="hljs-string">&#x27;18&#x27;</span>&#125;)<br><br><span class="hljs-keyword">let</span> &#123;name,age&#125;  = <span class="hljs-title function_">toRefs</span>(person)<br></code></pre></td></tr></table></figure><hr><h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><p>计算属性（computed properties）用于声明式地描述依赖于其他数据属性的值。计算属性会根据其依赖的数据自动更新，并且是基于它们的依赖进行缓存的，只有当依赖的数据发生变化时才会重新计算</p><p>在Vue2中，计算属性是一个选项式配置的属性，类似于data和methods的配置方式，属性名为Computed</p><p>在Vue3中，计算属性通过导入vue对象中的computed实现</p><p>需要注意的是，在vue中，计算属性默认是只读属性，可以通过单独配置getter和setter的方式将其变为可读可写</p><hr><h3 id="Watch"><a href="#Watch" class="headerlink" title="Watch"></a>Watch</h3><p>同计算属性一样，在vue2中，也是选项式配置的属性，在vue3中，使用组合式方式导入vue对象的watch使用</p><p>vue3中，watch能够监视四种数据</p><ul><li>ref定义的数据</li><li>reactive定义的数据</li><li>函数返回一个值（getter函数）</li><li>一个包含上述内容的数组</li></ul><p>ref定义的对象 ，如果想监视对象中属性的变化，需要开启深度监视</p><p>reactive定义的对象，默认开启了深度监视</p><p>如果想要监视对象中的某一个具体值，就需要用到函数返回一个值来监视（推荐使用箭头函数）</p><p>如果想要监视对象中的属性（对象类型的属性），就可以直接写，不需要使用getter函数的方式，但仍然推荐写成getter方式，再开启深度监视</p><hr><h3 id="组件的隔离"><a href="#组件的隔离" class="headerlink" title="组件的隔离"></a>组件的隔离</h3><p>在vue中，一个页面是由多个组件构成的：例如组件A，组件B</p><p>那么组件A中存在css样式，组件B中也有相同的样式，他们可能都作用于统一元素上，这可能不是本意</p><p>我们想让样式隔离，组件A的样式及仅应用于组件A，组件B的样式仅应用于组件B，就需要在style标签上加一个scope属性即可</p><p>那么针对js而言，如果采用id来操作元素的方式，组件A和组件B可能会出现id冲突的情况</p><p>这时，我们可以通过ref属性，为html元素添加标识，在js中创建该容器并且使用即可</p><h5 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h5><p>对于ref而言，我们不仅仅可以将此属性加载html原生的标签元素上，还可以直接加在组件标签元素上，</p><p><em>这里的逻辑是子组件向父组件暴露数据</em></p><p>但默认会有组件保护机制，无法直接拿到组件中内容（拿到的是组件的对象，没有实际意义）</p><p>可以在被调用组件中引入defineExpose()，将指定数据暴露，再通过ref就可以拿到数据了</p><h5 id="版本差距"><a href="#版本差距" class="headerlink" title="版本差距"></a>版本差距</h5><p>在vue2中的选项式API中，标记ref的元素会被加入到vue对象中，this.$refs.属性; 通过这种方式可以直接找到该元素</p><p>在vue3中的组合式API中，标记ref的元素推荐使用ref创建一下该元素即可</p><hr><h3 id="Ts"><a href="#Ts" class="headerlink" title="Ts"></a>Ts</h3><p>使用Ts来写Vue会更加的优雅，并且贴近后端OOP思维</p><p>例如 ，在创建响应式数据时，我们可以通过泛型来定义响应式数据的类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> personList = reactive&lt;<span class="hljs-title class_">Persons</span>&gt;(&#123;<br>    <br>&#125;)<br></code></pre></td></tr></table></figure><h5 id="defineProps"><a href="#defineProps" class="headerlink" title="defineProps"></a>defineProps</h5><p><em>这里的逻辑是从父组件向子组件传递数据</em></p><p>从vue对象中导入此属性，这条属性用于从父组件中接收传递过来的参数（通过在父组件中给子组件标签元素加入属性的方式传递）</p><p>在Ts中，可以通过泛型来约束父组件传递过来的参数类型，并判断可空性</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 传过来的属性list必须为Persons类型，且可空</span><br>defineProps&lt;&#123;<span class="hljs-attr">list</span>?:<span class="hljs-title class_">Persons</span>&#125;&gt;()<br></code></pre></td></tr></table></figure><h5 id="withDefaults"><a href="#withDefaults" class="headerlink" title="withDefaults"></a>withDefaults</h5><p>从vue对象中导入此属性，这条属性用于指定默认值</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-title function_">withDefaults</span>(defineProps&lt;&#123;<span class="hljs-attr">list</span>?:<span class="hljs-title class_">Persons</span>&#125;&gt;(),&#123;<br>  <span class="hljs-title class_">List</span>:<span class="hljs-function">() =&gt;</span> [&#123;<span class="hljs-attr">id</span>:<span class="hljs-string">&#x27;1&#x27;</span>&#125;,&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;xiaobai&#x27;</span>&#125;,&#123;<span class="hljs-attr">age</span>:<span class="hljs-number">18</span>&#125;]  <br>&#125;)<br></code></pre></td></tr></table></figure><p><em>注：define开头的函数为宏函数，在vue3中无需引入即可使用</em></p><hr><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>生命周期、生命周期函数、生命周期钩子，都指的是vue项目中在特定的时刻执行特定的函数</p><p>在Vue2中，生命周期有四个阶段，八个生命周期钩子</p><p>在Vue3中，生命周期有四个阶段，六个生命周期钩子</p><p><em>在创建阶段，Vue3中使用setup，所以去掉创建阶段一共六个</em></p><hr><h3 id="自定义hook"><a href="#自定义hook" class="headerlink" title="自定义hook"></a>自定义hook</h3><p>由vue2走向vue3的组合式，hooks可以真正的将组合式API进行逻辑分离的处理</p><p>相关的逻辑提取到单独的函数中，这些函数通常被称为“组合函数”或“自定义组合函数”</p><p>在这里，组合函数真正意义上的实现了封装这一OOP重要特性</p><p><em>hook文件一般以use开头</em></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-comment">// 将相关的逻辑提取到这里</span><br>    <br>    <br>    <span class="hljs-comment">// 将数据和方法暴露给调用者</span><br>    <span class="hljs-keyword">return</span> &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>TypeScript（TS）为组合函数提供了更好的支持，尤其是在确保数据类型一致性和减少运行时错误方面。</p><p>JavaScript（JS）虽然也可以使用组合函数，但由于缺乏静态类型检查，可能会导致一些潜在的问题，特别是在大型项目或跨文件使用时</p><hr><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><ol><li>导航区和展示区的确定</li><li>请来路由器</li><li>指定路由的具体规则（路径-&gt; 组件对应）</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装路由</span><br>npm i vue-router<br></code></pre></td></tr></table></figure><p>路由组件一般放在pages或views文件夹，其他组件一般放在components文件夹内</p><ul><li>路由组件：是通过路由规则渲染出来的</li><li>一般组件：是通过自己亲手写标签写出来的</li></ul><p>在vue3中，路由的完成就是将一个组件卸载 -&gt; 将一个组件挂载的一个过程</p><hr><h5 id="路由模式"><a href="#路由模式" class="headerlink" title="路由模式"></a>路由模式</h5><p>history模式：更加美观，不带有#，更接近传统网站URL。缺点是后期项目上线时，需要服务端配合处理路径问题，否则会出现404错误</p><p>hash模式：兼容性更好，因为不需要服务器端处理路径。缺点是url中带有#不美观，且在SEO优化方面相对较差</p><p>需要在后端配置路由回退机制，在后端返回未找到资源后，由vue重新接管该请求，解析到指定路由下</p><hr><h5 id="to的写法"><a href="#to的写法" class="headerlink" title="to的写法"></a>to的写法</h5><p>RouterLink的跳转按钮存在多种配置to属性的写法</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts">&lt;<span class="hljs-title class_">RouterLink</span> to=<span class="hljs-string">&quot;/home&quot;</span> active-<span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;active&quot;</span>&gt;首页&lt;/<span class="hljs-title class_">RouterLink</span>&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">RouterLink</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">&quot;&#123;path : &#x27;/home&#x27;&#125;&quot;</span> <span class="hljs-attr">active-class</span>=<span class="hljs-string">&quot;active&quot;</span>&gt;</span>首页<span class="hljs-tag">&lt;/<span class="hljs-name">RouterLink</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">RouterLink</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">&quot;&#123;name : &#x27;home&#x27;&#125;&quot;</span> <span class="hljs-attr">active-class</span>=<span class="hljs-string">&quot;active&quot;</span>&gt;</span>首页<span class="hljs-tag">&lt;/<span class="hljs-name">RouterLink</span>&gt;</span></span><br></code></pre></td></tr></table></figure><hr><h3 id="路由传参"><a href="#路由传参" class="headerlink" title="路由传参"></a>路由传参</h3><p>路由传参有param和query两种方式</p><p>其中，都可以通过RouterLink的to属性，配置对象中的query属性和param属性来实现</p><p>需要注意的是，param属性传递时需要在path中配置占位，在RouteLink跳转时推荐使用name属性跳转</p><h5 id="利用props"><a href="#利用props" class="headerlink" title="利用props"></a>利用props</h5><p>可以配置路由时增加一个属性：props:true</p><p>这个属性默认会将param参数转换为props，直接使用defineProps接受即可，但不会转化query参数</p><p>可以配置路由时重写props(){}方法，他会将返回值转换为defineProps，这样就可以显式的手动将query转化换</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-title function_">props</span>(<span class="hljs-params">route</span>)&#123;<br>    route.<span class="hljs-property">query</span><br>&#125;<br></code></pre></td></tr></table></figure><p><em>通过props方法转换参数后，其实就是将其组件传递参数的方式从路由传参转换为普通的组件传参</em></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-title function_">defineProps</span>([<span class="hljs-string">&#x27;id&#x27;</span>, <span class="hljs-string">&#x27;title&#x27;</span>, <span class="hljs-string">&#x27;content&#x27;</span>])<br><br><span class="hljs-comment">// 接受为一个对象</span><br><span class="hljs-keyword">const</span> props = <span class="hljs-title function_">defineProps</span>([<span class="hljs-string">&#x27;id&#x27;</span>, <span class="hljs-string">&#x27;title&#x27;</span>, <span class="hljs-string">&#x27;content&#x27;</span>])<br></code></pre></td></tr></table></figure><h5 id="replace和push"><a href="#replace和push" class="headerlink" title="replace和push"></a>replace和push</h5><p>vue默认开启了push模式，即每次跳转后会形成历史记录，可以通过浏览器的后退来返回上一个路由</p><p>在RouterLink上加上replace，则路由成为replace模式，即无法通过浏览器的后悔来返回上一个路由</p><hr><h3 id="编程式路由"><a href="#编程式路由" class="headerlink" title="编程式路由"></a>编程式路由</h3><p>vue2中，编程式路由重复跳转会报错，但vue3修复了此问题</p><p>从vue-router对象中拿到属性useRouter，调用方法实现跳转，这里push和replace方法的参数与RouteLink中的to属性的值是一样的</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123;userRouter&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><br><br><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">useRouter</span>()<br><br>router.<span class="hljs-title function_">push</span>() <span class="hljs-comment">// 通过调用push的方式实现路由跳转</span><br>router.<span class="hljs-title function_">replace</span>() <span class="hljs-comment">// 通过调用replace的方式实现路由跳转</span><br></code></pre></td></tr></table></figure><hr><h3 id="集中式状态管理"><a href="#集中式状态管理" class="headerlink" title="集中式状态管理"></a>集中式状态管理</h3><p>vue2中，使用臃肿的vuex来进行状态管理</p><p>vue3中，使用更好用的pinia来进行状态管理</p><p>在vuex中，直接拿到数据之后是无法进行修改的，但pinia能拿到数据就可以修改</p><p>在pinia中存储的对象如果想要解构出来使用，不推荐使用toRefs方法，而是使用Pinia提供的storeToRefs方法</p><hr><h5 id="subscribe"><a href="#subscribe" class="headerlink" title="subscribe"></a>subscribe</h5><p>此属性是pinia提供的一个类似于watch的监视属性，他能监视到pinia的变化，并回调用户自定义的函数</p><p>通常可以用于将pinia的数据持久化处理</p><hr><h5 id="组合式API"><a href="#组合式API" class="headerlink" title="组合式API"></a>组合式API</h5><p>Pinia也可以通过组合式API来达成实践，在组合式API中，getters和actions不再强制要求作为独立的部分进行定义</p><p>组合式API将内容放入组合函数中，再根据需求将内容暴露出来调用即可</p><hr>]]></content>
    
    
    <categories>
      
      <category>JAVAWEB</category>
      
      <category>vue</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Vue2</title>
    <link href="/2024/12/31/Vue2/"/>
    <url>/2024/12/31/Vue2/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue2"><a href="#Vue2" class="headerlink" title="Vue2"></a>Vue2</h1><h3 id="Vue2的创建实例"><a href="#Vue2的创建实例" class="headerlink" title="Vue2的创建实例"></a>Vue2的创建实例</h3><p>现在来学习Vue2的创建实例，仍然能够帮助我们更加深刻的理解Vue的工作原理</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-title class_">Vue</span>.<span class="hljs-property">config</span>.<span class="hljs-property">productionTip</span> = <span class="hljs-literal">false</span> <span class="hljs-comment">// 阻止 vue 在启动时生成生产提示</span></span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">        <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#root&quot;</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">data</span>: &#123;</span><br><span class="language-javascript">            <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;Hello Vue!&#x27;</span></span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-title class_">Vue</span>.<span class="hljs-property">config</span>.<span class="hljs-property">productionTip</span> = <span class="hljs-literal">false</span> <span class="hljs-comment">// 阻止 vue 在启动时生成生产提示</span></span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">        <span class="hljs-attr">data</span>: &#123;</span><br><span class="language-javascript">            <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;Hello Vue!&#x27;</span></span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript">    vm.$mount(<span class="hljs-string">&#x27;#root&#x27;</span>)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>通过html单独引入vue.js的应用模式下，我们可以很清晰的感受到，vue在工作的状态就是将编写好的模板翻译成html语言，实现响应式数据的功能</p><p>其中，Vue被导入进来后，作为一个函数存在，且必须要将其实例化为对象才能使用，通过<code>选项对象模式</code>来配置vue对象中的参数</p><p>然而，$mount（挂载方法）并不是由vue对象直接提供的，而是通过其原型对象中获取到的（原型链调用）</p><p>上面的示例是简介了挂载方式的两种方法：通过el属性配合css选择器的方式，或者是通过$mount方法调用的方式（以上两种方式在vue3中都不可用）</p><p>同样的，vue中data属性的赋值也有两种方式：</p><ul><li>对象式（组件中调用不适用）</li><li>函数式</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 对象式</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-attr">data</span>: &#123;<br>        <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;Hello Vue!&#x27;</span><br>    &#125;<br>&#125;)<br><br><span class="hljs-comment">// 函数式</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    data : <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>            msg : <span class="hljs-string">&#x27;Hello Vue!&#x27;</span><br>        &#125;<br>    &#125;<br>&#125;)<br><br><span class="hljs-comment">// 函数式（简写）</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-keyword">return</span> &#123;<br>            msg : <span class="hljs-string">&#x27;Hello Vue!&#x27;</span><br>        &#125;<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p><em>因为箭头函数this指向上级目录的缘故，在vm对象中使用函数式进行配置时都尽量不要使用箭头函数</em></p><hr><h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><p>Vue采用了很多MVVM的开发思想，vue对象就是一个vm视图模型，他通过很多操作将模板和数据关联起来，最终实现了数据绑定的效果</p><h5 id="数据代理"><a href="#数据代理" class="headerlink" title="数据代理"></a>数据代理</h5><p>Object.defineProperty这个方法是js提供的一个Object类的方法，可以为对象增加属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> person =&#123;<br>    name : <span class="hljs-string">&quot;xiaobai&quot;</span>,<br>    sex : <span class="hljs-string">&quot;男&quot;</span>,<br>    <span class="hljs-comment">//age :18</span><br>&#125;<br><br><span class="hljs-keyword">let</span> number = <span class="hljs-number">19</span><br><br><span class="hljs-comment">// 通过这个方法为age添加value值</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(person,<span class="hljs-string">&#x27;age&#x27;</span>,&#123;<br>    <span class="hljs-attr">value</span>:<span class="hljs-number">18</span>,<br>    <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">//可枚举，默认是false</span><br>    <span class="hljs-attr">writable</span>:<span class="hljs-literal">true</span>, <span class="hljs-comment">//可修改，默认是false</span><br>    <span class="hljs-attr">configurable</span>:<span class="hljs-literal">true</span> <span class="hljs-comment">//可删除，默认是false</span><br>    <br>    <span class="hljs-comment">// 一个回调函数，当此属性被访问的时候执行</span><br>    <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> number<br>&#125;<br><br><span class="hljs-comment">// 一个回调函数，当属性被修改的时候执行</span><br><span class="hljs-title function_">set</span>(<span class="hljs-params">value</span>)&#123;<br>        number = value<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>这样，我们就创建了一个数据代理，则number的值会影响到person对象中age属性的值</p><p>在对person.age执行get操作时，会直接返回number</p><p>在对person.age执行set操作时，会将number的值设置为新的值</p><p>这样number就是person.age对象的数据代理</p><hr><p>在vue中，vm对象的data对象就配置成为vm中新增属性的代理，也是通过defineProperty来配置的</p><p>在这段代码中，我们通过函数式为vm对象添加了属性msg，并且创建了代理属性data.msg</p><p>当使用插值表达式读取msg属性时，直接读取到data.msg属性</p><p>当为msg属性修改值时，直接修改data.msg属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-property">config</span>.<span class="hljs-property">productionTip</span> = <span class="hljs-literal">false</span> <span class="hljs-comment">// 阻止 vue 在启动时生成生产提示</span><br><span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;Hello Vue!&#x27;</span><br>    &#125;<br>&#125;)<br>vm.$mount(<span class="hljs-string">&#x27;#root&#x27;</span>)<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>JAVAWEB</category>
      
      <category>vue</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JS-原型&amp;原型链</title>
    <link href="/2024/12/31/JS-%E5%8E%9F%E5%9E%8B&amp;%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <url>/2024/12/31/JS-%E5%8E%9F%E5%9E%8B&amp;%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="JS-原型-原型链"><a href="#JS-原型-原型链" class="headerlink" title="JS-原型&amp;原型链"></a>JS-原型&amp;原型链</h1><p>JavaScript 的对象模型是基于原型的，这句话意味着 JavaScript 中的对象不是通过类来定义和继承的（如 Java 或 C++），而是通过一个称为“原型”的机制来进行属性查找和行为（方法）共享的</p><p>在js中，任何函数在被new关键字修饰函数后，就成为构造函数了，所以任何函数都有成为构造函数的可能</p><p>在js中，函数本身即对象，所以prototype是函数特有的属性</p><hr><h3 id="prototype-proto"><a href="#prototype-proto" class="headerlink" title="prototype&amp;_proto_"></a>prototype&amp;_<em>proto</em>_</h3><p>prototype是某一个构造函数实例化的所有对象可以找到公共的方法和属性，这个属性的设计之初，就是为了实现对象方法和属性的集成</p><p>__proto__属性是一个构造函数实例化成为对象后存在的属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> <span class="hljs-title class_">Parent</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><br>&#125;<br><br><span class="hljs-keyword">var</span> instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parent</span>();<br><br><span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;所有Parent的实例都可以读取到我&quot;</span>;<br><br><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parent</span>();<br><span class="hljs-keyword">let</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parent</span>();<br><br>p1.<span class="hljs-property">name</span> <span class="hljs-comment">//&quot;所有Parent的实例都可以读取到我&quot;;</span><br>p2.<span class="hljs-property">name</span> <span class="hljs-comment">//&quot;所有Parent的实例都可以读取到我&quot;;</span><br></code></pre></td></tr></table></figure><p>在这里，Parent在实例化为p1对象之前，通过这个方法的属性prototype，增加了一个name属性（还可以增加其他的属性或者方法）</p><p>但实例化p1对象之后，p1对象存在一个属性_<em>proto</em>_，这个属性等于其构造函数的prototype属性</p><p>当p1.name被执行时，首先寻找p1对象中是否存在这个name属性，如果不存在则找到_<em>proto</em>_，也就是找到其构造函数的prototype属性（他也是一个对象）</p><p>从中寻找到被添加的name属性</p><hr><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>每个对象都有一个内部链接（<code>[[Prototype]]</code>），它指向另一个对象，这个被链接的对象就是我们所说的“原型”。当尝试访问一个对象的属性时，如果该对象本身没有这个属性，JavaScript 引擎会沿着这条 <code>[[Prototype]]</code> 链向上查找，直到找到该属性或到达原型链的末端（即 <code>null</code>），因为 <code>null</code> 表示没有更多的原型可以访问。</p><h3 id="构造函数与原型"><a href="#构造函数与原型" class="headerlink" title="构造函数与原型"></a>构造函数与原型</h3><p>当你使用构造函数创建对象时，构造函数有一个名为 <code>prototype</code> 的属性，它是一个对象，所有由该构造函数创建的实例都会将它们的内部 <code>[[Prototype]]</code> 指向这个 <code>prototype</code> 对象。因此，这些实例共享了原型上的属性和方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayHello</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hello, &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;;<br><br><span class="hljs-keyword">let</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;Alice&#x27;</span>);<br>person1.<span class="hljs-title function_">sayHello</span>();  <span class="hljs-comment">// 输出: Hello, Alice</span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>person1</code> 的 <code>[[Prototype]]</code> 指向 <code>Person.prototype</code>，所以它可以访问 <code>sayHello</code> 方法，即使该方法并没有直接定义在 <code>person1</code> 上。</p><h3 id="动态特性"><a href="#动态特性" class="headerlink" title="动态特性"></a>动态特性</h3><p>由于原型链的存在，JavaScript 对象是动态的，这意味着你可以在运行时添加、修改或删除对象的属性和方法，甚至改变原型链。例如，你可以随时向原型添加新的方法，所有已经存在的实例也会立即获得这些新方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 给原型添加一个新的方法</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayGoodbye</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Goodbye, &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;;<br><br>person1.<span class="hljs-title function_">sayGoodbye</span>();  <span class="hljs-comment">// 输出: Goodbye, Alice</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JAVAWEB</category>
      
      <category>vue</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Angular</title>
    <link href="/2024/12/30/Angular/"/>
    <url>/2024/12/30/Angular/</url>
    
    <content type="html"><![CDATA[<h1 id="Angular"><a href="#Angular" class="headerlink" title="Angular"></a>Angular</h1><p>Angular 是一个 Web 框架，能够帮助开发者构建快速、可靠的应用。</p><p>由 Google 的专业团队维护，Angular 提供了广泛的工具、API 和库，简化和优化你的开发工作流程。Angular 为你提供了一个坚实的平台，可用于构建快速、可靠、能够随着团队规模和代码库规模扩展的应用程序。</p><h3 id="Angular-cli"><a href="#Angular-cli" class="headerlink" title="Angular-cli"></a>Angular-cli</h3><p>在装好nodejs和npm之后，全局安装Angualr-cli</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装angular-cli</span><br>npm install -g @angular/cli<br><br><span class="hljs-comment"># 展示angular-cli版本</span><br>ng version<br><br><span class="hljs-comment"># 新建一个angular项目</span><br>ng new [myapp]<br><br><span class="hljs-comment"># 安装项目依赖x</span><br>npm install<br><br><span class="hljs-comment"># 启动服务</span><br>ng serve<br></code></pre></td></tr></table></figure><blockquote><p>VScode ：Angular Language Service 插件安装</p></blockquote><h3 id="重要配置文件"><a href="#重要配置文件" class="headerlink" title="重要配置文件"></a>重要配置文件</h3><table><thead><tr><th>文件名</th><th>功能</th></tr></thead><tbody><tr><td>angular.json</td><td>angular框架配置文件</td></tr><tr><td>package.json</td><td>Node.js 项目配置文件</td></tr><tr><td>tsconfig.json</td><td>Ts相关配置类</td></tr></tbody></table><h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3><p>Angular作为前端框架，同样也包含三大件（三个重要模块）</p><ul><li><code>类：</code>Typescript-Componsent-Class</li><li><code>模板:</code>HTML-Template</li><li><code>样式</code>：CSS-Style</li></ul><p>如果是一个小的模板，我们可以直接将其放入类中，而对于大的模板，我们将其独立成为一个模板文件（.html）</p><p>如果是一个小的样式，我们可以直接将其放入类中，而对于大的模板，我们将其独立成为一个样式文件（.css）</p><h5 id="建立组件"><a href="#建立组件" class="headerlink" title="建立组件"></a>建立组件</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ng generate component Home --standalone --inline-template<br></code></pre></td></tr></table></figure><ul><li><strong><code>ng generate component</code></strong>：这是 Angular CLI 用来生成新组件的基本命令。</li><li><strong><code>Home</code></strong>：指定新组件的名称为 <code>Home</code>。</li><li><strong><code>--standalone</code></strong>：表示这个组件将是一个独立组件（standalone component），而不是依赖于 NgModule 的一部分。在 Angular 14 及以上版本中引入了这一特性，允许组件不隶属于任何模块而直接被导入和使用。</li><li><strong><code>--inline-template</code></strong>：告诉 Angular CLI 将模板代码直接嵌入到组件类文件中，而不是创建单独的 HTML 文件来存放模板。这可以使文件结构更简洁，尤其适用于小型或简单的组件。</li></ul><p>还有一些其他参数可以选择</p><ul><li><strong><code>--skip-tests</code></strong>：如果你不想生成测试文件，可以加上这个参数。</li><li><strong><code>--inline-style</code></strong>：如果你想让样式也内联到 <code>.ts</code> 文件中，可以加上这个参数。默认情况下，样式会放在单独的 <code>.css</code> 文件中。</li><li><strong><code>--flat</code></strong>：如果不希望为组件创建一个单独的目录，可以使用此参数。默认情况下，CLI 会为每个组件创建一个同名目录。</li></ul><h5 id="建立接口"><a href="#建立接口" class="headerlink" title="建立接口"></a>建立接口</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ng generate interface housingLocation<br></code></pre></td></tr></table></figure><ul><li><strong><code>ng generate interface</code></strong>：这是 Angular CLI 用来生成新接口的基本命令。</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">HousingLocation</span> &#123;<br>  <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">city</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">state</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">photo</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">availableUnits</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">wifi</span>: <span class="hljs-built_in">boolean</span>;<br>  <span class="hljs-attr">laundry</span>: <span class="hljs-built_in">boolean</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>在main.ts中导入angular框架的路由依赖</p>]]></content>
    
    
    <categories>
      
      <category>JAVAWEB</category>
      
      <category>angular</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>面试题整理</title>
    <link href="/2024/12/30/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/"/>
    <url>/2024/12/30/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="面试题整理"><a href="#面试题整理" class="headerlink" title="面试题整理"></a>面试题整理</h1><h3 id="JS-遍历数组的方式"><a href="#JS-遍历数组的方式" class="headerlink" title="JS 遍历数组的方式"></a>JS 遍历数组的方式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 假设我们有一个数组作为示例</span><br><span class="hljs-keyword">const</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><br><span class="hljs-comment">// 1. 使用 for 循环遍历数组</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; array.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`for循环: <span class="hljs-subst">$&#123;array[i]&#125;</span>`</span>);<br>&#125;<br><br><span class="hljs-comment">// 2. 使用 forEach 方法遍历数组</span><br>array.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">item, index</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`forEach方法: 索引<span class="hljs-subst">$&#123;index&#125;</span>的值为<span class="hljs-subst">$&#123;item&#125;</span>`</span>);<br>&#125;);<br><br><span class="hljs-comment">// 3. 使用 for...of 循环遍历数组 (ES6+)</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> array) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`for...of循环: <span class="hljs-subst">$&#123;item&#125;</span>`</span>);<br>&#125;<br><br><span class="hljs-comment">// 4. 使用 map 方法创建一个新数组，这里只是演示，不打印</span><br><span class="hljs-keyword">const</span> doubledArray = array.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item * <span class="hljs-number">2</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`map方法创建的新数组: <span class="hljs-subst">$&#123;doubledArray&#125;</span>`</span>);<br><br><span class="hljs-comment">// 5. 使用 filter 方法筛选出符合条件的元素，这里只是演示，不打印</span><br><span class="hljs-keyword">const</span> filteredArray = array.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item &gt; <span class="hljs-number">3</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`filter方法筛选后的数组: <span class="hljs-subst">$&#123;filteredArray&#125;</span>`</span>);<br><br><span class="hljs-comment">// 6. 使用 reduce 方法累加数组中的所有元素</span><br><span class="hljs-keyword">const</span> sum = array.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">accumulator, currentValue</span>) =&gt;</span> accumulator + currentValue, <span class="hljs-number">0</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`reduce方法计算的总和: <span class="hljs-subst">$&#123;sum&#125;</span>`</span>);<br><br><span class="hljs-comment">// 7. 使用 some 和 every 方法检查条件</span><br><span class="hljs-keyword">const</span> hasLargeNumber = array.<span class="hljs-title function_">some</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item &gt; <span class="hljs-number">4</span>); <span class="hljs-comment">// 至少有一个大于4的数</span><br><span class="hljs-keyword">const</span> allArePositive = array.<span class="hljs-title function_">every</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item &gt;= <span class="hljs-number">0</span>); <span class="hljs-comment">// 所有数都是非负的</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`some方法检查结果（是否有大于4的数字）: <span class="hljs-subst">$&#123;hasLargeNumber&#125;</span>`</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`every方法检查结果（是否全都是非负数）: <span class="hljs-subst">$&#123;allArePositive&#125;</span>`</span>);<br><br><span class="hljs-comment">// 8. 使用 while 循环遍历数组</span><br><span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (i &lt; array.<span class="hljs-property">length</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`while循环: <span class="hljs-subst">$&#123;array[i]&#125;</span>`</span>);<br>    i++;<br>&#125;<br><br><span class="hljs-comment">// 9. 使用 do...while 循环遍历数组</span><br><span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`do...while循环: <span class="hljs-subst">$&#123;array[j]&#125;</span>`</span>);<br>    j++;<br>&#125; <span class="hljs-keyword">while</span> (j &lt; array.<span class="hljs-property">length</span>);<br><br><span class="hljs-comment">// 注意：通常不推荐使用 for...in 遍历数组，因为它会遍历所有可枚举属性，包括原型链上的属性。</span><br></code></pre></td></tr></table></figure><hr><h3 id="Java中遍历数组的方式"><a href="#Java中遍历数组的方式" class="headerlink" title="Java中遍历数组的方式"></a>Java中遍历数组的方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayTraversalExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 定义一个整型数组用于演示</span><br>        <span class="hljs-type">int</span>[] intArray = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>        Integer[] objectArray = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;; <span class="hljs-comment">// 对象数组用于某些方法</span><br><br>        <span class="hljs-comment">// 1. 传统的for循环</span><br>        System.out.println(<span class="hljs-string">&quot;Traditional for loop:&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; intArray.length; i++) &#123;<br>            System.out.println(intArray[i]);<br>        &#125;<br><br>        <span class="hljs-comment">// 2. 增强型for循环（For-Each）</span><br>        System.out.println(<span class="hljs-string">&quot;Enhanced for loop:&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> element : intArray) &#123;<br>            System.out.println(element);<br>        &#125;<br><br>        <span class="hljs-comment">// 3. while循环</span><br>        System.out.println(<span class="hljs-string">&quot;While loop:&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; intArray.length) &#123;<br>            System.out.println(intArray[i]);<br>            i++;<br>        &#125;<br><br>        <span class="hljs-comment">// 4. do-while循环</span><br>        System.out.println(<span class="hljs-string">&quot;Do-while loop:&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">do</span> &#123;<br>            System.out.println(intArray[j]);<br>            j++;<br>        &#125; <span class="hljs-keyword">while</span> (j &lt; intArray.length);<br><br>        <span class="hljs-comment">// 5. 使用迭代器（Iterator）</span><br>        System.out.println(<span class="hljs-string">&quot;Using Iterator:&quot;</span>);<br>        List&lt;Integer&gt; list = Arrays.asList(objectArray);<br>        Iterator&lt;Integer&gt; iterator = list.iterator();<br>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>            System.out.println(iterator.next());<br>        &#125;<br><br>        <span class="hljs-comment">// 6. 使用Stream API（Java 8及以上）</span><br>        System.out.println(<span class="hljs-string">&quot;Using Stream API:&quot;</span>);<br>        Arrays.stream(intArray).forEach(System.out::println);<br>        <span class="hljs-comment">// 或者对于对象数组</span><br>        Stream.of(objectArray).forEach(System.out::println);<br><br>        <span class="hljs-comment">// 7. 使用Arrays类的静态方法</span><br>        System.out.println(<span class="hljs-string">&quot;Using Arrays.toString():&quot;</span>);<br>        System.out.println(Arrays.toString(intArray));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="UNION和UNION-ALL的区别"><a href="#UNION和UNION-ALL的区别" class="headerlink" title="UNION和UNION ALL的区别"></a>UNION和UNION ALL的区别</h3><p><code>UNION</code> 和 <code>UNION ALL</code> 是 SQL 中用于合并两个或多个 <code>SELECT</code> 语句结果集的关键字。它们的主要区别在于处理重复数据的方式：</p><ol><li><strong>UNION</strong>:<ul><li>当使用 <code>UNION</code> 时，它会自动去除两个（或多个）查询结果集中相同的行，确保最终结果集中的每一行都是唯一的。</li><li>这意味着 <code>UNION</code> 会在内部执行一个去重操作，这通常需要更多的处理时间和资源，尤其是在处理大型数据集时。</li></ul></li><li><strong>UNION ALL</strong>:<ul><li><code>UNION ALL</code> 不会去除重复的行，它只是简单地将两个结果集合并在一起，保留所有的重复项。</li><li>因为没有去重的操作，所以 <code>UNION ALL</code> 的执行速度通常比 <code>UNION</code> 更快，并且消耗的系统资源更少。</li></ul></li></ol><hr><h3 id="联合查询调优"><a href="#联合查询调优" class="headerlink" title="联合查询调优"></a>联合查询调优</h3><hr><h3 id="JS如何如何发送请求到后端"><a href="#JS如何如何发送请求到后端" class="headerlink" title="JS如何如何发送请求到后端"></a>JS如何如何发送请求到后端</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br>xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;http://example.com/api/data&quot;</span>, <span class="hljs-literal">true</span>);<br>xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">readyState</span> == <span class="hljs-number">4</span> &amp;&amp; xhr.<span class="hljs-property">status</span> == <span class="hljs-number">200</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(xhr.<span class="hljs-property">responseText</span>);<br>    &#125;<br>&#125;;<br>xhr.<span class="hljs-title function_">send</span>();<br></code></pre></td></tr></table></figure><hr><h3 id="SpringBoot的配置文件有几种形式"><a href="#SpringBoot的配置文件有几种形式" class="headerlink" title="SpringBoot的配置文件有几种形式"></a>SpringBoot的配置文件有几种形式</h3><ul><li><p>application.properties：这是最常见和最基本的配置方式，使用键值对的形式来定义配置项</p></li><li><p>application.yml 或 application.yaml：AML 是一种人类可读的数据序列化标准，适合表达层次结构数据。相比 <code>.properties</code> 文件，它在处理层级关系时更为简洁</p></li><li><p>外部配置文件：你可以将配置文件放置在应用程序外部的位置，这样可以方便地在不同环境中切换配置而无需重新打包应用程序。可以通过命令行参数指定配置文件的位置</p></li><li><p>环境变量：可以直接通过操作系统的环境变量或云平台提供的环境变量来设置配置项。这种方式非常适合于部署到云端或容器化的应用中</p></li><li><p>命令行参数：启动应用程序时，可以在命令行上直接传递参数给Spring Boot应用</p></li><li><p>JVM系统属性：你也可以通过JVM参数来传递配置信息</p></li><li><p>随机值生成：对于一些不需要精确控制的配置项，如密钥等，可以使用内置的随机值生成器</p></li><li><p>Profile-specific 配置文件：为了支持多环境配置（开发、测试、生产等），Spring Boot 提供了 profile-specific 的配置文件机制。例如，<code>application-dev.properties</code> 或 <code>application-prod.yml</code> 可以分别用于开发环境和生产环境</p></li><li><p>@ConfigurationProperties 注解类：可以创建一个Java类，并使用 <code>@ConfigurationProperties</code> 注解来绑定配置文件中的属性</p></li><li><p>SPRING_APPLICATION_JSON 环境变量：可以通过设置 <code>SPRING_APPLICATION_JSON</code> 环境变量来提供JSON格式的配置</p></li></ul><hr><h5 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h5><ul><li><strong>ASP.NET Core</strong>：配置源按照它们被添加到 <code>ConfigurationBuilder</code> 的顺序进行覆盖，即后配置的覆盖先配置的。</li><li><strong>Spring Boot</strong>：具有固定的优先级规则，某些配置源总是会覆盖其他特定的配置源，而不论它们是如何或何时被添加的。</li></ul><p>相比之下，Spring Boot 使用了一个固定的优先级规则来决定哪个配置源应该覆盖其他配置源。如前所述，Spring Boot 有明确的配置源优先级顺序，并且这个顺序是不可变的。</p><ol><li><strong>命令行参数</strong> (<code>--key=value</code>)<ul><li>直接在启动应用程序时通过命令行提供的参数。</li></ul></li><li><strong>来自 <code>SPRING_APPLICATION_JSON</code> 的属性（嵌入在环境变量或系统属性中）</strong><ul><li>例如：<code>SPRING_APPLICATION_JSON=&#39;&#123;&quot;key&quot;:&quot;value&quot;&#125;&#39;</code></li></ul></li><li><strong>ServletConfig 初始化参数</strong><ul><li>如果你的应用是一个Web应用，那么可以通过ServletConfig设置初始化参数。</li></ul></li><li><strong>ServletContext 初始化参数</strong><ul><li>类似于ServletConfig参数，但是针对整个Web应用程序上下文。</li></ul></li><li><strong>JNDI 属性 (java:comp&#x2F;env)</strong><ul><li>Java Naming and Directory Interface, 用于查找命名和目录服务中的资源。</li></ul></li><li><strong>Java 系统属性 (System.getProperties())</strong><ul><li>使用 <code>-D</code> 参数传递给 JVM 的系统属性。</li></ul></li><li><strong>操作系统环境变量</strong><ul><li>操作系统级别的环境变量。</li></ul></li><li><strong>随机值 (random.* )</strong><ul><li>Spring Boot 内置的随机值生成器，如 <code>$&#123;random.value&#125;</code>、<code>$&#123;random.int&#125;</code> 等。</li></ul></li><li><strong>打包外部配置文件</strong><ul><li>包括但不限于 <code>application.properties</code> 或 <code>application.yml</code> 文件，这些文件位于标准位置之外，并通过 <code>spring.config.location</code> 指定。</li></ul></li><li><strong>打包内部配置文件</strong><ul><li>包含在应用程序jar包内的 <code>application-&#123;profile&#125;.properties</code> 或 <code>application-&#123;profile&#125;.yml</code> 文件。</li></ul></li><li><strong>@Configuration 类上的 @PropertySource 注解</strong><ul><li>在Spring配置类上使用 <code>@PropertySource</code> 来指定额外的属性文件。</li></ul></li><li><strong>默认属性 (由 SpringApplication.setDefaultProperties 指定)</strong><ul><li>应用程序启动时通过编程方式设置的默认属性。</li></ul></li></ol><hr><h3 id="SpringBoot-的配置文件生效位置"><a href="#SpringBoot-的配置文件生效位置" class="headerlink" title="SpringBoot 的配置文件生效位置"></a>SpringBoot 的配置文件生效位置</h3><ol><li><strong>当前目录的 <code>/config</code> 子目录</strong>：这是为了方便开发和测试而提供的一个默认位置。</li><li><strong>当前目录</strong>：直接放置在应用程序启动路径下的配置文件也会被自动读取。</li><li><strong>类路径中的 <code>/config</code> 包</strong>：对于打包的应用程序，这通常是 <code>src/main/resources/config</code> 目录。</li><li><strong>类路径根目录</strong>：通常是指 <code>src/main/resources</code> 目录。</li></ol><p>这些位置按照优先级从高到低排列，意味着如果同一个配置项存在于多个位置，则较高优先级位置中的配置会覆盖较低优先级位置中的配置。</p><hr>]]></content>
    
    
    <categories>
      
      <category>NET框架相关</category>
      
      <category>synyi</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>TS</title>
    <link href="/2024/12/27/TS/"/>
    <url>/2024/12/27/TS/</url>
    
    <content type="html"><![CDATA[<h1 id="TS"><a href="#TS" class="headerlink" title="TS"></a>TS</h1><p>TypeScript（简称 TS）是由微软开发的一种开源的编程语言，它是 JavaScript 的一个超集，意味着所有的 JavaScript 代码都是有效的 TypeScript 代码。TypeScript 的主要特点是添加了静态类型检查，这使得开发者可以在编译时发现并修复许多类型的错误，从而提高代码的质量和可维护性。</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>JS的数据类型</p><ul><li>string</li><li>number</li><li>boolean</li><li>null</li><li>undefined</li><li>bigint</li><li>symbol</li><li>object：其中包含Array、Function、Date等</li></ul><p>TS增加了六种新的数据类型</p><ul><li>any</li><li>unknow</li><li>never</li><li>void</li><li>tuple</li><li>enum</li></ul><p>两个用于自定义类型的方式</p><ul><li>type</li><li>interface</li></ul><hr><h3 id="常用的数据类型"><a href="#常用的数据类型" class="headerlink" title="常用的数据类型"></a>常用的数据类型</h3><h5 id="any"><a href="#any" class="headerlink" title="any"></a>any</h5><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 显示定义any</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">a</span>: <span class="hljs-built_in">any</span><br><br><span class="hljs-comment">// 隐式的定义any</span><br><span class="hljs-keyword">let</span> b<br></code></pre></td></tr></table></figure><p>注意：any类型的对象，可以赋值给任意有数据类型的变量，这是一个非常破坏性的事情</p><p>使用any类型的对象，意味着后续对这个对象舍弃了所有静态类型检查</p><hr><h5 id="unknow"><a href="#unknow" class="headerlink" title="unknow"></a>unknow</h5><p>unknow可以理解为一个数据安全的any，但无法将unknown的对象赋值给有数据类型的对象（相对any更为安全）</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">a</span>: unknow<br>a = <span class="hljs-string">&#x27;hello&#x27;</span><br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">x</span>: <span class="hljs-built_in">string</span><br><br><span class="hljs-comment">// 第一种方式，类型判断后赋值</span><br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> a === <span class="hljs-string">&quot;string&quot;</span>)&#123;<br>    x = a<br>&#125;<br><br><span class="hljs-comment">// 第二种方式，断言（ts语法）</span><br>x = a <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span> <br><br><span class="hljs-comment">// 第三种方式，断言</span><br>x = &lt;<span class="hljs-built_in">string</span>&gt;a<br></code></pre></td></tr></table></figure><hr><h5 id="never"><a href="#never" class="headerlink" title="never"></a>never</h5><p>通过never来修饰函数没有任何返回值，这里需要注意，在ts中，一个函数的默认返回值是undefined，这和void返回空值是不一样的</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">demo</span>(<span class="hljs-params"></span>):<span class="hljs-built_in">never</span>&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;程序运行异常！！&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="void"><a href="#void" class="headerlink" title="void"></a>void</h5><ul><li>void通常用于函数返回值的声明，返回值为空的函数以void标识</li><li>void可以接受函数的默认返回值undefined</li><li>不应该依赖以void标识的函数的返回值进行任何操作</li></ul><hr><h5 id="object"><a href="#object" class="headerlink" title="object"></a>object</h5><p>开发中一般不使用object来做类型限制，因为object的范围过于宽泛，可以为任意引用类型</p><p>在这里Object的范围更加宽泛，除了null和undefined这两个类型，其他能够调用Object方法（.toString）都可以储存</p><hr><h5 id="声明对象类型"><a href="#声明对象类型" class="headerlink" title="声明对象类型"></a>声明对象类型</h5><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">person</span>:&#123;<br>    <span class="hljs-comment">// 这里的分隔符可以是逗号，分号，甚至是回车换行</span><br>    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>,<br>    <span class="hljs-attr">age</span>?: int <span class="hljs-comment">// 使用问好来标注此属性可以为空</span><br>&#125;<br>person = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;xiaobai&quot;</span> , <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>&#125;<br>person = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;xiaobai&quot;</span>&#125;<br></code></pre></td></tr></table></figure><p>添加索引签名，string类型的key，其值可以为任意值</p><p>添加索引签名后，此对象可以有任意数量的属性</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">person</span>:&#123;<br>    <span class="hljs-comment">// 这里的分隔符可以是逗号，分号，甚至是回车换行</span><br>    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>,<br>    <span class="hljs-attr">age</span>?: int <span class="hljs-comment">// 使用问好来标注此属性可以为空</span><br>    [<span class="hljs-attr">key</span>:<span class="hljs-built_in">string</span>]:<span class="hljs-built_in">any</span> <br>&#125;<br>person = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;xiaobai&quot;</span> , <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>&#125;<br>person = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;xiaobai&quot;</span>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="声明函数类型"><a href="#声明函数类型" class="headerlink" title="声明函数类型"></a>声明函数类型</h5><ul><li><strong>JavaScript</strong>：由于是动态类型语言，实现回调十分简单，没有类型的限制。</li><li><strong>C#</strong>：为了实现类型安全的回调机制，开发了委托功能，因为它是强类型语言。</li><li><strong>TypeScript</strong>：虽然是基于 JavaScript 的，但由于引入了静态类型检查，也需要使用类似委托的方式来定义回调，以确保类型安全。</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">count</span>: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">a</span>:<span class="hljs-built_in">number</span>,<span class="hljs-attr">b</span>:<span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">number</span><br><br>count = <span class="hljs-keyword">function</span>(<span class="hljs-params">a,b</span>)&#123;<br>    <span class="hljs-keyword">return</span> a+b<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="声明数组类型"><a href="#声明数组类型" class="headerlink" title="声明数组类型"></a>声明数组类型</h5><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">arr</span>: <span class="hljs-built_in">string</span>[]<br><br>arr = [<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>]<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">arr1</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">string</span>&gt;<br></code></pre></td></tr></table></figure><hr><h5 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h5><p>tuple元组是一种特殊的数组类型，可以存储固定数量的元素，并且元素类型也是固定类型的</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">arr1</span>: [<span class="hljs-built_in">string</span>,<span class="hljs-built_in">number</span>]<br>arr1 = [<span class="hljs-string">&quot;xiaobai&quot;</span> , <span class="hljs-number">18</span>]<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">arr2</span>: [<span class="hljs-built_in">string</span>,<span class="hljs-built_in">number</span>?]<br>arr2 = [<span class="hljs-string">&quot;xiaobai&quot;</span> , <span class="hljs-number">18</span>]<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">arr3</span>: [<span class="hljs-built_in">string</span>,...<span class="hljs-built_in">number</span>[]]<br>arr3 = [<span class="hljs-string">&quot;xiaobai&quot;</span>, <span class="hljs-number">1</span> , <span class="hljs-number">2</span> , <span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><hr><h5 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h5><p>枚举（enum）是一组命名常量，他能增强代码的可读性，让代码更好维护</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Direction</span>&#123;<br>    <span class="hljs-title class_">Up</span>,<br>    <span class="hljs-title class_">Down</span>,<br>    <span class="hljs-title class_">Left</span>,<br>    <span class="hljs-title class_">Right</span><br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Direction</span>[<span class="hljs-number">0</span>]) <span class="hljs-comment">// 取到Up</span><br></code></pre></td></tr></table></figure><p>使用关键字const定义枚举，在编译到js代码后，会在编译时进行内联，避免生成多余的代码</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Direction</span>&#123;<br>    <span class="hljs-title class_">Up</span>,<br>    <span class="hljs-title class_">Down</span>,<br>    <span class="hljs-title class_">Left</span>,<br>    <span class="hljs-title class_">Right</span><br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Direction</span>[<span class="hljs-number">0</span>]) <span class="hljs-comment">// 取到Up</span><br></code></pre></td></tr></table></figure><hr><h5 id="type"><a href="#type" class="headerlink" title="type"></a>type</h5><p>type是一个自定义类型关键字</p><p>使用type可以定义联合类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 定义新的类型，可以为number或者string</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Status</span> = <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span><br><span class="hljs-comment">// 定义新的字面量类型</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Gender</span> = <span class="hljs-string">&#x27;男&#x27;</span> | <span class="hljs-string">&#x27;女&#x27;</span><br></code></pre></td></tr></table></figure><p>使用type可以定义交叉类型</p><p>在这里，House类型的对象必须有Area和Address的属性，且属性类型必须对应</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Area</span> = &#123;<br>    <span class="hljs-attr">height</span>: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 高</span><br>    <span class="hljs-attr">width</span>: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 宽</span><br>&#125;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Address</span> = &#123;<br>    <span class="hljs-attr">num</span>: <span class="hljs-built_in">number</span> <span class="hljs-comment">// 楼号</span><br>    <span class="hljs-attr">cell</span>: <span class="hljs-built_in">number</span> <span class="hljs-comment">// 单元号</span><br>    <span class="hljs-attr">room</span>: <span class="hljs-built_in">string</span> <span class="hljs-comment">// 房间号</span><br>&#125;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">House</span> = <span class="hljs-title class_">Area</span> &amp;  <span class="hljs-title class_">Address</span><br></code></pre></td></tr></table></figure><p>使用type定义函数类型</p><p>这里有一个特殊情况：</p><ul><li>当定义函数时就定义了返回值类型，则会严格要求返回值类型</li><li>当定义函数时没有严格定义返回值类型，而是通过一个type定义一个返回值为void的函数类型，在以此来约束函数，则返回值类型不那么严格要求</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">LogFunc</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">f1</span>:<span class="hljs-title class_">LogFunc</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;xiaobai&quot;</span> <span class="hljs-comment">// 不严格要求返回值类型为void</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="类和接口"><a href="#类和接口" class="headerlink" title="类和接口"></a>类和接口</h3><p>在ts中，类的代码可以进行简写</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 简写前代码</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span><br>    <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">name</span>:<span class="hljs-built_in">string</span>, <span class="hljs-attr">age</span>:<span class="hljs-built_in">number</span></span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 简写后代码</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span><br><span class="hljs-params">    <span class="hljs-keyword">public</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>,</span><br><span class="hljs-params">    <span class="hljs-keyword">public</span> <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span></span><br><span class="hljs-params">    </span>)&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h5><p>TypeScript 支持三种访问修饰符：</p><ol><li><strong><code>public</code></strong>：成员可以被任何代码访问。这是默认的访问修饰符。</li><li><strong><code>private</code></strong>：成员只能在定义它的类内部访问。</li><li><strong><code>protected</code></strong>：成员只能在定义它的类及其子类中访问。</li></ol><p>与C#相同，ts中也可以使用readonly来标识只读属性</p><h5 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h5><p>在ts中，接口的作用不只是定义类，同样还可以用来定义对象结构和函数结构</p><p>在ts中，接口可以重复定义，所有接口中的结构定义最后会被合并（需要同时满足）</p><p>接口的使用场景：</p><ul><li>定义对象格式：描述类型数据、API响应格式、配置对象等等</li><li>类的契约：规定一个类需要实现的哪些属性和方法</li><li>自动合并：一般用于扩展第三方库的类型，在大型项目中很可能会用到</li></ul><hr><h3 id="一些相似概念的区别"><a href="#一些相似概念的区别" class="headerlink" title="一些相似概念的区别"></a>一些相似概念的区别</h3><p>interface和type都可以定义对象结构，两者在很多场景都可以互换</p><p>不同点：</p><ul><li>interface：更专注于用于类和对象的定义，并且支持自动合并和继承</li><li>type：可以定义类型的别名、联合类型、交叉类型，但不支持继承和合并</li></ul><hr><h3 id="类型定义文件"><a href="#类型定义文件" class="headerlink" title="类型定义文件"></a>类型定义文件</h3><p>类型声明文件是Ts中的一种特殊文件，通常以.d.ts作为文件扩展名，他的主要作用是为现有的JavaScript代码提供类型信息，使得TypeScript能够在这些使用JavaSript库或模块时进行类型检查或提示</p><hr>]]></content>
    
    
    <categories>
      
      <category>JAVAWEB</category>
      
      <category>angular</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CSS3-响应式布局</title>
    <link href="/2024/12/26/CSS3-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80/"/>
    <url>/2024/12/26/CSS3-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="CSS3-响应式布局"><a href="#CSS3-响应式布局" class="headerlink" title="CSS3-响应式布局"></a>CSS3-响应式布局</h1><p>网页布局复杂的情况下，不考虑使用响应式布局</p><p>而网页布局不复杂的情况下，可以考虑使用响应式布局</p><hr><h3 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h3><h5 id="媒体查询类型"><a href="#媒体查询类型" class="headerlink" title="媒体查询类型"></a>媒体查询类型</h5><p>媒体查询并没有任何的优先级，所以如果想要配置媒体查询的样式，需要将媒体查询写在正常的样式后</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 只有在打印机或打印预览时应用的样式 */</span><br><span class="hljs-keyword">@media</span> print &#123;<br>    <br>&#125;<br><br><span class="hljs-comment">/* 只有在屏幕上才应用的样式 */</span><br><span class="hljs-keyword">@media</span> screen &#123;<br>    <br>&#125;<br><br><span class="hljs-comment">/* 一直都应用的样式 */</span><br><span class="hljs-keyword">@media</span> all &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>全部的媒体查询类型：<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media">@media - CSS：层叠样式表 | MDN</a></p><hr><h5 id="媒体查询特性"><a href="#媒体查询特性" class="headerlink" title="媒体查询特性"></a>媒体查询特性</h5><p>orientation特性可以检测视口的旋转方向，以判断手机是否处于横屏状态</p><ul><li>portrait：视口处于纵向，即高度大于宽度</li><li>landscape：视口处于横向，即宽度大于高度</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 当视口宽度等于800像素时 */</span><br><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">width</span>:<span class="hljs-number">800px</span>)<br>&#123;<br>    <br>&#125;<br><br><span class="hljs-comment">/* 当视口宽度小于等于800像素时 */</span><br><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">max-width</span>:<span class="hljs-number">800px</span>)<br>&#123;<br>    <br>&#125;<br><br><span class="hljs-comment">/* 当视口宽度大于等于800像素时 */</span><br><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">min-width</span>:<span class="hljs-number">800px</span>)<br>&#123;<br>    <br>&#125;<br><br><span class="hljs-comment">/* 当设备宽度等于800像素时 */</span><br><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">device-width</span>:<span class="hljs-number">800px</span>)<br>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h5><p>可以用运算符连接多个媒体查询类型或媒体查询类型</p><ul><li>and：且运算符</li><li>or：或运算符</li><li>not：否定运算符</li></ul><hr><h1 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h1><p>BFC时Block Formatting Context（块级格式上下文），可以理解元素的一个“特异功能”</p><p>该“特异功能”，在默认的情况下属于关闭的状态，当元素满足某些条件后，该“特异功能”被激活</p><p>所谓“激活特异功能”，就是该元素创建了BFC（又称：开启了BFC）</p><ul><li>元素开启BFC后，其子元素不再产生margin塌陷问题</li><li>元素开启BFC后，自己不会被其他浮动元素所覆盖</li><li>元素开启BFC后，就算其子元素浮动，元素自身高度也不会塌陷</li></ul><hr><h3 id="如何开启BFC"><a href="#如何开启BFC" class="headerlink" title="如何开启BFC"></a>如何开启BFC</h3><ul><li>根元素</li><li>浮动元素</li><li>绝对定位、固定定位的元素</li><li>行内块元素</li><li>表格单元格：table、thead、tbody、tfoot、th、td、tr、caption</li><li>overflow的值不为visible的元素</li><li>伸缩项目</li><li>多列容器</li><li>column-span为all的元素（即使该元素没有包裹在多列容器中）</li><li>display的值，设置为flow-root</li></ul><hr>]]></content>
    
    
    <categories>
      
      <category>JAVAWEB</category>
      
      <category>angular</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CSS3-伸缩盒模型</title>
    <link href="/2024/12/26/CSS3-%E4%BC%B8%E7%BC%A9%E7%9B%92%E6%A8%A1%E5%9E%8B/"/>
    <url>/2024/12/26/CSS3-%E4%BC%B8%E7%BC%A9%E7%9B%92%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="CSS3-伸缩盒模型"><a href="#CSS3-伸缩盒模型" class="headerlink" title="CSS3-伸缩盒模型"></a>CSS3-伸缩盒模型</h1><p>2009年，W3C提出了一种新的盒子模型——Flexible Box（伸缩盒模型，又称：弹性盒子）</p><p>传统布局：基于传统盒状模型，主要靠：display属性+position属性+float属性</p><p>flex布局目前在移动端应用比较广泛，因为传统布局不能很好的呈现在移动设备上</p><hr><h3 id="伸缩容器"><a href="#伸缩容器" class="headerlink" title="伸缩容器"></a>伸缩容器</h3><ul><li>display: flex；：将容器变为伸缩容器</li><li>display: inline-flex; ：将容器变为伸缩容器的同时，将自己变为行内元素（很少使用）</li></ul><p>可以给伸缩容器的父容器配置为伸缩容器，其伸缩容器本身就变成了伸缩项目</p><hr><h3 id="伸缩项目"><a href="#伸缩项目" class="headerlink" title="伸缩项目"></a>伸缩项目</h3><p>伸缩容器中的子元素自动成为伸缩项目</p><p><strong>注：这里只有子元素，其孙子元素和其他后代元素是无法成为伸缩项目的（只有一层级）</strong></p><p>无论是哪种元素（块，行内块，行内），一档成为了伸缩项目，全部都会“块状化”</p><hr><h3 id="主轴方向"><a href="#主轴方向" class="headerlink" title="主轴方向"></a>主轴方向</h3><p>元素是根据主轴的方向排列的</p><ul><li>flex-direction: row; 主轴从左到右</li><li>flex-direction: row-reverse; 主轴从右到左</li><li>flex-direction: column; 主轴从上往下</li><li>flex-direction: column-reverse; 主轴从下到上</li></ul><hr><h3 id="主轴的换行方式"><a href="#主轴的换行方式" class="headerlink" title="主轴的换行方式"></a>主轴的换行方式</h3><p>在主轴方向上排列的元素默认不允许换行，如果遇到元素超出的部分，就会自动缩小盒子排列</p><p>通过flex-wrap属性来调整主轴换行方式</p><ul><li>nowrap：不换行，默认值</li><li>wrap：换行</li><li>wrap-reverse：反转换行</li></ul><p><em>注：CSS3提供了一个复合属性flex-flow，来同时配置主轴方向和主轴的换行方式</em></p><hr><h3 id="主轴的对齐方式"><a href="#主轴的对齐方式" class="headerlink" title="主轴的对齐方式"></a>主轴的对齐方式</h3><p>justify-content属性调整主轴的对齐方式</p><ul><li>flex-start：主轴的起始位置</li><li>flex-end：主轴的结束位置</li><li>center：主轴居中对齐</li><li>space-content：项目均匀的分布在一行中，项目之间的距离是项目距离边缘的2倍</li><li>space-between：项目均匀的分布在一行中，项目之间的距离是相等的，项目距离边缘没有距离</li><li>space-evenly：项目均匀的分布在一行中</li></ul><hr><h3 id="侧轴的对齐方式"><a href="#侧轴的对齐方式" class="headerlink" title="侧轴的对齐方式"></a>侧轴的对齐方式</h3><p>align-items属性调整侧轴的对齐方式，仅适用于一行项目</p><ul><li>flex-start：侧轴的起始位置</li><li>flex-end：侧轴的结束位置</li><li>center：侧轴的居中对齐</li><li>baseline：侧轴的基线对齐</li><li>stretch：侧轴的拉伸对齐（当伸缩项目没有高度的时候，拉伸到伸缩容器的高度），默认值</li></ul><p>align-content属性调整侧轴的对齐方式，适用于多行伸缩项目</p><ul><li>flex-start：侧轴的起始位置</li><li>flex-end：侧轴的结束位置</li><li>space-content：项目均匀的分布在一行中，项目之间的距离是项目距离边缘的2倍</li><li>space-between：项目均匀的分布在一行中，项目之间的距离是相等的，项目距离边缘没有距离</li><li>space-evenly：项目均匀的分布在一行中</li><li>stretch：侧轴拉伸对齐，将多行项目拉伸到平均高度，默认值</li></ul><hr><h3 id="利用flex布局实现水平居中对齐"><a href="#利用flex布局实现水平居中对齐" class="headerlink" title="利用flex布局实现水平居中对齐"></a>利用flex布局实现水平居中对齐</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 方案一 */</span><br><span class="hljs-selector-class">.outer</span>&#123;<br>    <span class="hljs-attribute">display</span>: flex;<br>    <span class="hljs-attribute">justify-content</span>: center;<br>    <span class="hljs-attribute">align-items</span>: crenter;<br>&#125;<br><br><br><span class="hljs-comment">/* 方案二 */</span><br><span class="hljs-selector-class">.outer</span>&#123;<br>    <span class="hljs-attribute">display</span>: flex;<br>&#125;<br><span class="hljs-selector-class">.inner</span>&#123;<br>    <span class="hljs-attribute">margin</span>: autp;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="基准长度"><a href="#基准长度" class="headerlink" title="基准长度"></a>基准长度</h3><p>使用flex-basis设置伸缩项目在主轴上的基准长度</p><p>若主轴为横向的，宽失效</p><p>若主轴为纵向的，长失效</p><p>此属性的默认值是auto，一般而言，我们也不会手动的设定主轴上的基准长度</p><hr><h3 id="伸缩"><a href="#伸缩" class="headerlink" title="伸缩"></a>伸缩</h3><p>flex-grow定义伸缩项目的放大比例，默认为0，即主轴存在剩余空间，也不放大</p><ul><li>当所有项目的值都为1时，如果有剩余空间，所有项目平分这些剩余空间</li><li>当三个伸缩项目的值为1，2，3时，分别瓜分到六分之一，六分之二，六分之三的剩余空间</li></ul><hr><p>flex-shrink定义伸缩项目的缩小比例，默认为1，即当伸缩容器的宽度小于伸缩项目时，伸缩容器自动缩小</p><p>这个属性在开发时很少使用，直接使用默认值1</p><hr>]]></content>
    
    
    <categories>
      
      <category>JAVAWEB</category>
      
      <category>angular</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CSS3-过渡&amp;动画</title>
    <link href="/2024/12/26/CSS3-%E8%BF%87%E6%B8%A1&amp;%E5%8A%A8%E7%94%BB/"/>
    <url>/2024/12/26/CSS3-%E8%BF%87%E6%B8%A1&amp;%E5%8A%A8%E7%94%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="CSS3-过渡"><a href="#CSS3-过渡" class="headerlink" title="CSS3-过渡"></a>CSS3-过渡</h1><p>使用属性transition为元素配置过度</p><p>能用数值配置的属性，基本上都可以通过transition-property配置过度，例如：</p><ul><li>height，width</li><li>background-color</li><li>2D变换和3D变换的属性都可以实现过渡</li><li>box-shadow</li><li>opacity</li><li>all：所有能过渡的属性，都发生过渡</li><li>……</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span>&#123;<br>    <span class="hljs-comment">/* 设置哪个属性需要配置过度 */</span><br>    <span class="hljs-attribute">transition-property</span>: height;<br>    <br>    <span class="hljs-comment">/* 设置过渡的时间 */</span><br>    <span class="hljs-attribute">transition-duration</span>: <span class="hljs-number">1s</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>duration中文释义：期间</em></p><hr><h3 id="高级使用"><a href="#高级使用" class="headerlink" title="高级使用"></a>高级使用</h3><h5 id="transition-delay"><a href="#transition-delay" class="headerlink" title="transition-delay"></a>transition-delay</h5><p>过渡延迟，当事件发生后经过延迟后在执行过渡</p><h5 id="transition-timing-function"><a href="#transition-timing-function" class="headerlink" title="transition-timing-function"></a>transition-timing-function</h5><p>过渡的动画方式</p><ul><li>ease：默认值，平滑过渡（慢-快-慢）</li><li>linear：匀速的</li><li>ease-in：先慢后快</li><li>ease-out：先快后慢</li><li>ease-in-out：慢快慢，相对于ease不够平滑</li><li>step–start：一步结束，不考虑时间</li><li>step-end：在duration时间过去后，一步结束</li><li>steps()：分步骤进行过度</li><li>cubic-bezier：贝塞尔曲线，可以用来实现橡皮筋效果</li></ul><p><a href="https://cubic-bezier.com/">cubic-bezier✿ cubic-bezier.com</a></p><p>通过这个网站来调整出贝塞尔曲线的具体数值</p><hr><h1 id="CSS3-动画"><a href="#CSS3-动画" class="headerlink" title="CSS3-动画"></a>CSS3-动画</h1><ul><li><p>animation-name：为元素增加动画</p></li><li><p>animation-duration：配置动画持续时间</p></li><li><p>animation-delay：配置动画的延迟时间</p></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.inner</span>&#123;<br>    <span class="hljs-attribute">animation-name</span>: donghua;<br>    <span class="hljs-attribute">animation-duration</span>: <span class="hljs-number">3s</span>;<br>&#125;<br><br><span class="hljs-comment">/* 简易配置模式 */</span><br><span class="hljs-keyword">@keyframes</span> donghua&#123;<br>    <span class="hljs-comment">/* 第一帧 */</span><br>    <span class="hljs-selector-tag">from</span>&#123;<br>        <br>    &#125;<br>    <span class="hljs-comment">/* 最后一帧 */</span><br>    <span class="hljs-selector-tag">to</span>&#123;<br>        <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(<span class="hljs-number">900px</span>);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">/* 完整配置方式 */</span><br><span class="hljs-keyword">@keyframes</span> donghua&#123;<br>    <span class="hljs-comment">/* 第一帧 */</span><br>    <span class="hljs-number">0%</span>&#123;<br>        <br>    &#125;<br>    <span class="hljs-comment">/* 最后一帧 */</span><br>    <span class="hljs-number">100%</span>&#123;<br>        <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(<span class="hljs-number">900px</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="其他属性"><a href="#其他属性" class="headerlink" title="其他属性"></a>其他属性</h3><ul><li><p>animation-timing-function：动画的过渡方式</p><ul><li>与过渡可选值相同</li></ul></li><li><p>animation-iteration-count：动画播放的次数</p><ul><li>infinite：无限循环</li></ul></li><li><p>animation-direction：动画的方向</p><ul><li>normal：正常方向（from-to）</li><li>reverse：反转方向（to-from）</li><li>alternate：往复运动</li><li>alternate-reverse：反转的往复运动</li></ul></li><li><p>animation-fill-mode：动画之外的效果（动画静止时的显示效果）</p><ul><li>forwards：保持最后一帧的状态</li><li>backwards：初始第一帧的状态</li></ul></li><li><p>animation-play-state：动画的播放状态</p><ul><li>pause：暂停动画</li></ul></li></ul><hr><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>过渡一定要加在想要执行过渡的原始元素上</li><li>两者都可以使用复合属性，需要注意的两个时间的顺序问题，第一个时间为持续时间，第二个属性为延迟时间，如果只写一个默认为持续时间</li><li>动画不需要任何的触发条件，过渡必须得有一个触发条件</li><li>动画可以通过对关键帧的控制来处理形变时的细枝末节，而过渡多数用来把控形变前和后的状态</li><li>过渡多用于交互的美观和流畅性，所以用的更多</li></ul><hr>]]></content>
    
    
    <categories>
      
      <category>JAVAWEB</category>
      
      <category>angular</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CSS3-变换</title>
    <link href="/2024/12/25/CSS3-%E5%8F%98%E6%8D%A2/"/>
    <url>/2024/12/25/CSS3-%E5%8F%98%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="CSS3-变换"><a href="#CSS3-变换" class="headerlink" title="CSS3-变换"></a>CSS3-变换</h1><h3 id="2D变换-位移"><a href="#2D变换-位移" class="headerlink" title="2D变换-位移"></a>2D变换-位移</h3><p>transform属性可以实现CSS3的所有变换操作</p><p>位移是通过其属性值translateX() 和translateY()来实现‘</p><ul><li>位移与相对定位很相似，都不脱离文档流，也不会影响到其他元素</li><li>相对定位的百分比值是参考父元素做定位，而位移的百分比值是参考自身位移</li><li>位移对行内元素无效</li><li>位移配合定位可以实现元素水平居中</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span>&#123;<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span> , -<span class="hljs-number">50%</span>);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="2D变换-缩放"><a href="#2D变换-缩放" class="headerlink" title="2D变换-缩放"></a>2D变换-缩放</h3><p>缩放通过属性值scaleX()和scaleY()来实现</p><p>这里的值没有单位，0为缩放至没有元素，但这个值可以为负数，-1则为翻转</p><p><em>我们可以通过缩放来调整文字大小小于浏览器默认大小</em></p><hr><h3 id="2D变换-旋转"><a href="#2D变换-旋转" class="headerlink" title="2D变换-旋转"></a>2D变换-旋转</h3><p>旋转通过属性值rotateZ()来实现</p><p>这里的值的单位是deg，直接给一个角度即可</p><hr><h3 id="2D变换-扭曲"><a href="#2D变换-扭曲" class="headerlink" title="2D变换-扭曲"></a>2D变换-扭曲</h3><p>扭曲通过属性值skewX()和skewY()来实现</p><p>这里的值的单位是deg，直接给一个角度即可</p><hr><h3 id="多重变换"><a href="#多重变换" class="headerlink" title="多重变换"></a>多重变换</h3><p>因为所有变换都是通过一个transform属性其中的属性值来调整的，所以在进行多重变换时，我们应该将多条属性值写在同一个transform属性中</p><p>应该注意所有变换的顺序，其中，旋转应该放在所有变换的最后</p><hr><h3 id="变换原点"><a href="#变换原点" class="headerlink" title="变换原点"></a>变换原点</h3><ul><li><p>通过transform-origin属性可以设置变换的原点</p></li><li><p>修改变换原点对位移没有影响，对旋转和缩放会产生影响</p></li><li><p>如果提供两个值，第一个值应用横坐标，第二个值应用纵坐标</p></li><li><p>如果只提供一个，若是像素值，表示横坐标，纵坐标取50%，若是关键词，则另一个坐标取50%</p></li></ul><hr><h3 id="3D空间与景深"><a href="#3D空间与景深" class="headerlink" title="3D空间与景深"></a>3D空间与景深</h3><ul><li>元素如果要进行3D变换的首要操作，就是将其父元素使用transform-style属性开启3D空间<ul><li>flat：2D空间，默认值</li><li>preserve-3D：让子元素位于此元素内的三维空间里</li></ul></li><li>景深指的是观察者与z&#x3D;0平面的距离，能让3D变换的元素产生透视效果，看起来更加立体，使用perspective属性设置景深<ul><li>none：不指定透视，默认值</li><li>长度值：指定观察者距离z&#x3D;0平面的距离，不允许负值</li></ul></li></ul><hr><h3 id="透视点位置"><a href="#透视点位置" class="headerlink" title="透视点位置"></a>透视点位置</h3><p>通过perspective-origin属性来调整透视点的位置</p><p>通常情况下，我们不需要调整透视点的位置</p><hr><h3 id="3D变换-位移"><a href="#3D变换-位移" class="headerlink" title="3D变换-位移"></a>3D变换-位移</h3><p>通过translateZ()和translate3D()实现3D变换的位移</p><hr><h3 id="3D变换-旋转"><a href="#3D变换-旋转" class="headerlink" title="3D变换-旋转"></a>3D变换-旋转</h3><ul><li>rotateX：设置x轴旋转角度，需要指定一个角度值（deg），面对x轴正方向，正值顺时针，负值逆时针</li><li>rotateY：设置y轴旋转角度，需要指定一个角度值（deg），面对y轴正方向，正值顺时针，负值逆时针</li><li>rotate3D：四个值，最后一个值为角度，前三个值为是否要在（X，Y，Z）轴上进行选装</li></ul><hr><h3 id="3D变换-缩放"><a href="#3D变换-缩放" class="headerlink" title="3D变换-缩放"></a>3D变换-缩放</h3><ul><li>scaleZ：设置z轴方向的缩放比例，值为一个数字</li><li>scale3d：第一个参数对应x轴，第二个参数对应y轴，第三个参数对应z轴，参数不允许省略</li></ul><hr>]]></content>
    
    
    <categories>
      
      <category>JAVAWEB</category>
      
      <category>angular</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CSS3</title>
    <link href="/2024/12/25/CSS3/"/>
    <url>/2024/12/25/CSS3/</url>
    
    <content type="html"><![CDATA[<h1 id="CSS3"><a href="#CSS3" class="headerlink" title="CSS3"></a>CSS3</h1><h3 id="CSS3私有前缀"><a href="#CSS3私有前缀" class="headerlink" title="CSS3私有前缀"></a>CSS3私有前缀</h3><p>针对于一些不同版本的浏览器支持，CSS3需要在测试中的属性上加入前缀</p><p>在实际开发中，开发者并不需要关心这个前缀问题，如果真的需要支持旧版浏览器，webpack会自动帮我们加含有前缀的属性</p><hr><h3 id="CSS3新增长度单位"><a href="#CSS3新增长度单位" class="headerlink" title="CSS3新增长度单位"></a>CSS3新增长度单位</h3><p>在css3中，除了rem、em单位之外，还存在vw和vh长度单位</p><p>vw利用视窗的width作为参考，wh利用视窗的height作为参考</p><p>wmax利用width和height数值大的作为参考</p><p>vmin利用width和height数值小的作为参考</p><p><em>在移动端常用这些长度单位</em></p><hr><h3 id="CSS3中新增的选择器和颜色"><a href="#CSS3中新增的选择器和颜色" class="headerlink" title="CSS3中新增的选择器和颜色"></a>CSS3中新增的选择器和颜色</h3><p>对于这两个知识点，在前面学习css的过程中已经讲完了</p><hr><h3 id="CSS3盒子模型"><a href="#CSS3盒子模型" class="headerlink" title="CSS3盒子模型"></a>CSS3盒子模型</h3><h5 id="box-sizing"><a href="#box-sizing" class="headerlink" title="box-sizing"></a>box-sizing</h5><p>box-sizing属性有两个可选值，一个是<code>content-box</code>，这个也是默认值，使用的是标准盒模型，其盒子模型的width和height是内容区的宽高</p><p>还有一个属性值是border-box，使用怪异盒模型，其盒子模型的width和height是盒子总大小</p><p><em>使用怪异盒模型后，再配置border和padding属性时就会向内扩张，影响内容区大小而不是盒子总大小</em></p><hr><h5 id="resize"><a href="#resize" class="headerlink" title="resize"></a>resize</h5><p>使用resize属性可以控制是否允许用户调节元素尺寸</p><ul><li>none：不允许用户调整大小（默认）</li><li>both：用户可以调节元素的宽度和高度</li><li>horizontal：用户可以调节元素的宽度</li><li>vertical：用户可以调节元素的高度</li></ul><hr><h5 id="box-shadow"><a href="#box-shadow" class="headerlink" title="box-shadow"></a>box-shadow</h5><p>box-shadow属性可以给元素添加阴影</p><ul><li>h-shadow：水平方向的阴影，必填项，可以为负值</li><li>v-shadow：垂直方向的阴影，必填项，可以为负值</li><li>blur：可选项，模糊距离</li><li>spread：可选项，阴影的外延值</li><li>color：可选项，改变阴影的颜色</li><li>inset：可选项，将外部阴影改为内部阴影</li></ul><hr><h5 id="opacity"><a href="#opacity" class="headerlink" title="opacity"></a>opacity</h5><p>opacity属性可以调整元素的透明度，其中可选值为0（完全透明）到1（完全不透明）</p><p>rgba和opacity是有区别的，opacity是设置该元素及其内容的透明度</p><p>rgba是单独调整颜色的透明程度</p><hr><h3 id="CSS3背景属性"><a href="#CSS3背景属性" class="headerlink" title="CSS3背景属性"></a>CSS3背景属性</h3><h5 id="background-origin"><a href="#background-origin" class="headerlink" title="background-origin"></a>background-origin</h5><p>背景的起点，其默认值是padding-box，也就是图片默认是从内边距左上角顶点开始展开</p><ul><li>content-box：从内容区左上角顶点展开</li><li>border-box：从边框的左上角顶点展开</li></ul><hr><h5 id="background-clip"><a href="#background-clip" class="headerlink" title="background-clip"></a>background-clip</h5><p>背景的裁剪，其默认值是border-box，也就是超出边框外的背景将会被裁剪</p><ul><li>content-box：超过内容区的内容会被裁剪</li><li>padding-box：超过内边距的内容会被裁剪</li><li>text：超过文本的内容会被裁剪（前置条件是将文字的字体颜色调整为transparent）</li></ul><hr><h5 id="background-size"><a href="#background-size" class="headerlink" title="background-size"></a>background-size</h5><ul><li>直接使用长度指定图片的大小</li><li>使用百分比指定图片的大小</li><li>auto：背景图片的真实大小，默认值</li><li>contain：将背景图片等比缩放，将长边放入容器中，需要注意，很有可能出现容器内存在空白的情况</li><li>cover：将背景图片等比缩放，将短边放入容器中，需要注意，会有一部分图片没有显示出来的情况</li></ul><hr><h5 id="多背景图"><a href="#多背景图" class="headerlink" title="多背景图"></a>多背景图</h5><p>利用复合属性backgroud配置多个图片，并配置状态和位置，使用逗号分隔</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">backgroud: <span class="hljs-built_in">url</span>(<span class="hljs-string">&quot;bg-lt.png&quot;</span>) no-repeat left top,<br>   <span class="hljs-built_in">url</span>(<span class="hljs-string">&quot;bg-rt.png&quot;</span>) no-repeat right top,<br>   <span class="hljs-built_in">url</span>(<span class="hljs-string">&quot;bg-lb.png&quot;</span>) no-repeat left bottom,<br>   <span class="hljs-built_in">url</span>(<span class="hljs-string">&quot;bg-rb.png&quot;</span>) no-repeat right bottom;<br></code></pre></td></tr></table></figure><hr><h3 id="新增边框属性"><a href="#新增边框属性" class="headerlink" title="新增边框属性"></a>新增边框属性</h3><h5 id="border-radius"><a href="#border-radius" class="headerlink" title="border-radius"></a>border-radius</h5><p>通过盒子的border-radius属性可以调整一个盒子的圆角</p><p>通过将border-radius设置为百分之50，可以将盒子调整成一个圆形</p><p>通过border-top-left-radius可以单独调整盒子的单独一个角来设置圆角</p><p>以此类推，其他三个角也可以通过这种方式配置</p><hr><h5 id="outline"><a href="#outline" class="headerlink" title="outline"></a>outline</h5><p>通过盒子的outline属性来配置盒子的外轮廓</p><p>外轮廓不计算入盒子大小，并且不占位</p><p>outline-offset可以调整外轮廓的偏移量，并且这个属性不能写在复合属性中</p><hr><h3 id="新增文本属性"><a href="#新增文本属性" class="headerlink" title="新增文本属性"></a>新增文本属性</h3><h5 id="text-shadow"><a href="#text-shadow" class="headerlink" title="text-shadow"></a>text-shadow</h5><p>通过text-shadow属性为文本配置阴影，其配置方式和box-shadow方法类似，但不能配置内部阴影和外延值</p><hr><h5 id="white-space"><a href="#white-space" class="headerlink" title="white-space"></a>white-space</h5><p>通过该属性可以调整文本的换行逻辑</p><ul><li><p>normal：默认值</p></li><li><p>pre：该属性值可以调整为容器内容按原文显示，类似pre标签的功能</p></li><li><p>pre-wrap：在pre效果的基础上，超出元素边界自动换行</p></li><li><p>pre-line：在pre效果的基础上，超出元素边界自动换行，且只识别文本中的换行，空格会忽略</p></li><li><p>nowrap：不换行，这个属性值很重要，通常搭配下面的文本溢出处理</p></li></ul><hr><h5 id="text-overflow"><a href="#text-overflow" class="headerlink" title="text-overflow"></a>text-overflow</h5><p>通过该属性可以调整文本溢出的处理</p><p>该属性要搭配white-space: nowrap; 且 overflow: hidden;</p><ul><li>clip：超出的部分裁剪掉</li><li>ellipsis：超出的部分以省略号代替</li></ul><hr><h5 id="text-decoration"><a href="#text-decoration" class="headerlink" title="text-decoration"></a>text-decoration</h5><p>在css2中，我们就已经学会了这个属性，用以给文本添加划线，中划线，下划线等修饰</p><p>在css3中，这个属性有很多子属性，可以为划线更改样式，颜色等</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">text-decoration</span>： overline solid blue;<br></code></pre></td></tr></table></figure><hr><h3 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h3><h5 id="线性渐变"><a href="#线性渐变" class="headerlink" title="线性渐变"></a>线性渐变</h5><p>配合js来循环调整角度，可以让渐变动起来</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 默认从上到下渐变 */</span><br><span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">linear-gradient</span>(red,yellow,green);<br><br><span class="hljs-comment">/* 默认从上到下渐变，调整颜色占比 */</span><br><span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">linear-gradient</span>(red <span class="hljs-number">50px</span>,yellow <span class="hljs-number">100px</span>,green <span class="hljs-number">150px</span>);<br><br><span class="hljs-comment">/* to right从左到右渐变 */</span><br><span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">linear-gradient</span>(to right,red,yellow,green);<br><br><span class="hljs-comment">/* to right top 从左下到右上渐变 */</span><br><span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">linear-gradient</span>(to right top,red,yellow,green);<br><br><span class="hljs-comment">/* 20deg 自定义角度渐变 */</span><br><span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">linear-gradient</span>(<span class="hljs-number">20deg</span>,red,yellow,green);<br></code></pre></td></tr></table></figure><hr><h5 id="径向渐变"><a href="#径向渐变" class="headerlink" title="径向渐变"></a>径向渐变</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 默认从中心点向四周 */</span><br><span class="hljs-attribute">background-image</span>：radial-gradient(red,yellow,green)<br><br><span class="hljs-comment">/* 默认从中心点向四周,调整颜色占比 */</span><br><span class="hljs-attribute">background-image</span>：radial-gradient(red <span class="hljs-number">50px</span>,yellow <span class="hljs-number">100px</span>,green <span class="hljs-number">150px</span>)<br><br><span class="hljs-comment">/* at left top调整中心位置为左上 */</span><br><span class="hljs-attribute">background-image</span>：radial-gradient(at <span class="hljs-attribute">left</span> <span class="hljs-attribute">top</span>,red,yellow,green)<br><br><span class="hljs-comment">/* at left top调整中心位置为左上 */</span><br><span class="hljs-attribute">background-image</span>：radial-gradient(at <span class="hljs-attribute">left</span> <span class="hljs-attribute">top</span>,red,yellow,green)<br><br><span class="hljs-comment">/* at 100px 50px调整中心位置为坐标值 */</span><br><span class="hljs-attribute">background-image</span>：radial-gradient(at <span class="hljs-number">100px</span> <span class="hljs-number">50px</span>,red,yellow,green)<br><br><span class="hljs-comment">/* 通过circle关键字调整图形样式为正圆 */</span><br><span class="hljs-attribute">background-image</span>：radial-gradient(<span class="hljs-selector-tag">circle</span>,red,yellow,green)<br><br><span class="hljs-comment">/* 通过像素调整图形样式为正圆 */</span><br><span class="hljs-attribute">background-image</span>：radial-gradient(<span class="hljs-number">100px</span> <span class="hljs-number">100px</span>,red,yellow,green)<br></code></pre></td></tr></table></figure><hr><h3 id="Web字体"><a href="#Web字体" class="headerlink" title="Web字体"></a>Web字体</h3><h5 id="引入-ttf"><a href="#引入-ttf" class="headerlink" title="引入.ttf"></a>引入.ttf</h5><p>在CSS2中，我们使用font-family来调整字体，但该字体必须为用户电脑已安装的字体</p><p>在CSS3中，我们可以通过Web字体功能引入网络字体，或引入字体文件</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@font-face</span>&#123;<br>    <span class="hljs-attribute">font-family</span>:<span class="hljs-string">&quot;方正手迹&quot;</span>;<br>    <span class="hljs-attribute">src</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&quot;./fonts/方正手迹.ttf&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="定制web字体"><a href="#定制web字体" class="headerlink" title="定制web字体"></a>定制web字体</h5><p>中文的字体文件很大，使用完整的字体文件不现实，如果只需要对页面的几个字体进行单独定制再引入，可以通过该平台定制相关文字的字体</p><p><a href="https://www.iconfont.cn/fonts/index?spm=a313x.7781068.0.0&type=3">iconfont-阿里巴巴矢量图标库</a></p><p><em>定制字体后的引入方式是相同的</em></p><hr><h5 id="字体图标"><a href="#字体图标" class="headerlink" title="字体图标"></a>字体图标</h5><ul><li>相比图片更加清晰</li><li>灵活性高，更方便改变大小、颜色、风格等</li><li>兼容性好，IE也支持</li></ul><p><a href="https://www.iconfont.cn/collections/index?spm=a313x.home_index.i1.1.442c3a818DoUNg">iconfont-阿里巴巴矢量图标库</a></p><p>有三种使用字体图标的方案，且均可在线使用和下载使用</p><hr>]]></content>
    
    
    <categories>
      
      <category>JAVAWEB</category>
      
      <category>angular</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>HTML5</title>
    <link href="/2024/12/24/HTML5/"/>
    <url>/2024/12/24/HTML5/</url>
    
    <content type="html"><![CDATA[<h1 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h1><h3 id="新增布局标签"><a href="#新增布局标签" class="headerlink" title="新增布局标签"></a>新增布局标签</h3><table><thead><tr><th>标签名</th><th>语义</th></tr></thead><tbody><tr><td>header</td><td>整个页面，或部分区域的头部</td></tr><tr><td>footer</td><td>整个页面，或部分区域的底部</td></tr><tr><td>nav</td><td>导航</td></tr><tr><td>acticle</td><td>文章、帖子、杂志、新闻、博客、评论等</td></tr><tr><td>section</td><td>页面中的某段文字，或文章中的某段文字（里面文字通常会包含标题）</td></tr><tr><td>aside</td><td>侧边栏</td></tr><tr><td>main</td><td>文档的主要内容，几乎不用</td></tr><tr><td>hgroup</td><td>包裹连续的标题，如文章主标题、副标题的组合</td></tr></tbody></table><hr><h3 id="新增状态标签"><a href="#新增状态标签" class="headerlink" title="新增状态标签"></a>新增状态标签</h3><h5 id="meter标签"><a href="#meter标签" class="headerlink" title="meter标签"></a>meter标签</h5><p>语义：定义一直范围内的标量测量，也被称为gauge（尺度）。用于：电量、磁盘用量等</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>high</td><td>规定高值</td></tr><tr><td>low</td><td>规定低值</td></tr><tr><td>max</td><td>规定最大值</td></tr><tr><td>min</td><td>规定最小值</td></tr><tr><td>optimum</td><td>规定最优值</td></tr><tr><td>value</td><td>设定当前值</td></tr></tbody></table><hr><h5 id="progress标签"><a href="#progress标签" class="headerlink" title="progress标签"></a>progress标签</h5><p>语义：显示某个任务完成的进度的指示器，一般用于表示进度条，例如：工作完成进度等</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>max</td><td>规定目标值</td></tr><tr><td>value</td><td>设定当前值</td></tr></tbody></table><hr><h3 id="新增列表标签"><a href="#新增列表标签" class="headerlink" title="新增列表标签"></a>新增列表标签</h3><table><thead><tr><th>标签名</th><th>语义</th></tr></thead><tbody><tr><td>datalist</td><td>用于搜索框的关键字提示</td></tr><tr><td>details</td><td>用于展示问题或答案，或对专有名词进行解释</td></tr><tr><td>summary</td><td>写在details的里面，用于指定问题或专有名词</td></tr></tbody></table><hr><h3 id="新增文本标签"><a href="#新增文本标签" class="headerlink" title="新增文本标签"></a>新增文本标签</h3><table><thead><tr><th>标签名</th><th>语义</th></tr></thead><tbody><tr><td>ruby</td><td>包裹需要注音的问题</td></tr><tr><td>rt</td><td>写注音，rt标签写在ruby标签的里面</td></tr><tr><td>mark</td><td>标记（W3C建议使用mark标签标记搜索结果中的关键字）</td></tr></tbody></table><hr><h3 id="新增表单控件属性"><a href="#新增表单控件属性" class="headerlink" title="新增表单控件属性"></a>新增表单控件属性</h3><table><thead><tr><th>属性名</th><th>功能</th></tr></thead><tbody><tr><td>placeholder</td><td>提示文字（注意：不是默认值，默认值是value），适用于文字输入类的表单控件</td></tr><tr><td>required</td><td>表示该输入项必填，适用于除按钮外其他表单控件</td></tr><tr><td>autofocus</td><td>自动获取焦点，适用于所有表单控件</td></tr><tr><td>autocomplete</td><td>自动完成，可以设置为on或者off，适用于文字输入类的表单控件</td></tr><tr><td>pattern</td><td>填写正则表达式，适用于文本输入类表单控件，注意：多行输入不可用，且空的输入框不会验证，通常与required标签连用</td></tr></tbody></table><hr><h5 id="input标签的type属性值"><a href="#input标签的type属性值" class="headerlink" title="input标签的type属性值"></a>input标签的type属性值</h5><table><thead><tr><th>属性值</th><th>功能</th></tr></thead><tbody><tr><td>email</td><td>邮箱类型</td></tr><tr><td>url</td><td>url类型</td></tr><tr><td>number</td><td>数字类型</td></tr><tr><td>search</td><td>搜索类型</td></tr><tr><td>tel</td><td>电话类型</td></tr><tr><td>range</td><td>范围选择</td></tr><tr><td>color</td><td>颜色选择</td></tr><tr><td>date</td><td>日期选择</td></tr><tr><td>month</td><td>月份选择</td></tr><tr><td>week</td><td>周选择</td></tr><tr><td>time</td><td>时间选择</td></tr><tr><td>datetime-local</td><td>日期+时间选择</td></tr></tbody></table><hr><h3 id="新增的多媒体标签"><a href="#新增的多媒体标签" class="headerlink" title="新增的多媒体标签"></a>新增的多媒体标签</h3><h5 id="video标签"><a href="#video标签" class="headerlink" title="video标签"></a>video标签</h5><table><thead><tr><th>属性值</th><th>值</th><th>功能</th></tr></thead><tbody><tr><td>src</td><td>url地址</td><td>视频地址</td></tr><tr><td>controls</td><td>-</td><td>向用户显示视频控件</td></tr><tr><td>muted</td><td>-</td><td>视频静音</td></tr><tr><td>autoplay</td><td>-</td><td>视频自动播放</td></tr><tr><td>loop</td><td>-</td><td>循环播放</td></tr><tr><td>poster</td><td>url地址</td><td>视频封面</td></tr><tr><td>preload</td><td>auto&#x2F;metadata&#x2F;none</td><td>视频预加载</td></tr></tbody></table><h5 id="audio标签"><a href="#audio标签" class="headerlink" title="audio标签"></a>audio标签</h5><p>音频标签对比视频标签少了封面属性，其他属性相同</p><hr><h3 id="HTML5的兼容性处理"><a href="#HTML5的兼容性处理" class="headerlink" title="HTML5的兼容性处理"></a>HTML5的兼容性处理</h3><p>对于一些HTML5新增的标签，也应该兼容一些不支持这些元素的浏览器，对于这种情况也是有多种解决方案</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--[if lt ie 9]&gt;</span><br><span class="hljs-comment">&lt;script src =&quot;./html5shiv.js&quot;&gt;&lt;/script&gt;</span><br><span class="hljs-comment">&lt;![endid]--&gt;</span><br></code></pre></td></tr></table></figure><p>当浏览器小于ie9时，这段注释会被解开，浏览器会导入这个js文件，以此来完成对老旧ie浏览器的支持</p><p>除此之外，还可以添加一些元数据标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 让IE浏览器处于一个最优的渲染模式 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-compatible&quot;</span> <span class="hljs-attr">content</span>&quot;<span class="hljs-attr">IE</span>=<span class="hljs-string">edge</span>&quot;&gt;</span><br><br><span class="hljs-comment">&lt;!-- 针对一些国产的“双核”浏览器的设置，让浏览器优先使用webkit内核渲染网页 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;render&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;webkit&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>JAVAWEB</category>
      
      <category>angular</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CSS-布局</title>
    <link href="/2024/12/22/CSS-%E5%B8%83%E5%B1%80/"/>
    <url>/2024/12/22/CSS-%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="CSS-布局"><a href="#CSS-布局" class="headerlink" title="CSS-布局"></a>CSS-布局</h1><h3 id="版心"><a href="#版心" class="headerlink" title="版心"></a>版心</h3><p>版心通常使用container作为class名</p><p>在网页的布局中，我们可以先设置容器，容器div不设置宽度，让其撑满页面，然后设置一个版心</p><p>版心的宽度则取自大多数电脑屏幕分辨率的宽度，推荐设置为960-1280px区间</p><p>版心可以有一个或多个</p><p>有一些高端的网页弱化了版心的概念，选用响应式布局</p><hr><h3 id="常用布局名词"><a href="#常用布局名词" class="headerlink" title="常用布局名词"></a>常用布局名词</h3><table><thead><tr><th>位置</th><th>对应单词</th></tr></thead><tbody><tr><td>顶部导航条</td><td>topbar</td></tr><tr><td>页头</td><td>header、page-header</td></tr><tr><td>导航</td><td>nav、navigator、narbar</td></tr><tr><td>搜索框</td><td>search、search-box</td></tr><tr><td>横幅、广告、宣传图</td><td>banner</td></tr><tr><td>主要内容</td><td>content、main</td></tr><tr><td>侧边栏</td><td>aside、sidebar</td></tr><tr><td>页脚</td><td>footer、page-footer</td></tr></tbody></table><hr><h3 id="重置默认样式"><a href="#重置默认样式" class="headerlink" title="重置默认样式"></a>重置默认样式</h3><p>很多的元素都存在其默认样式，例如：</p><ul><li>p元素有默认的上下margin</li><li>h1~h6标题有上下margin，且字体加粗</li><li>body元素有默认的8px外边距</li><li>超链接有默认的文字颜色和下划线</li><li>ul元素有默认的左padding</li><li>……</li></ul><p>在早期，默认样式可以帮我们快速的绘制网页，但随着网页的设计越来越复杂，默认样式可能会带来更多的麻烦</p><h5 id="方案一：全局选择器"><a href="#方案一：全局选择器" class="headerlink" title="方案一：全局选择器"></a>方案一：全局选择器</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">*&#123;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在实际开发中很少使用通配选择器，因为他会应用于页面的所有元素</p><h5 id="方案二：reset-css"><a href="#方案二：reset-css" class="headerlink" title="方案二：reset.css"></a>方案二：reset.css</h5><p>选择到具有默认样式的元素，清空其默认的样式</p><p>经过reset的网页就像是一张白纸，开发人员根据设计稿，精细的添加样式</p><p><em>各大公司都开源了自家的reset.css标准</em></p><h5 id="方案三：Normalize-css"><a href="#方案三：Normalize-css" class="headerlink" title="方案三：Normalize.css"></a>方案三：Normalize.css</h5><p>这是一种最新的方案，他在清除默认样式的基础上，保留了一些有价值的默认样式</p><p><a href="https://necolas.github.io/normalize.css/">Normalize.css: Make browsers render all elements more consistently.</a></p><ol><li><strong>保持默认样式</strong>：不像传统的 CSS 重置库那样完全清除所有元素的样式，<code>normalize.css</code> 试图保持有用的默认浏览器样式。</li><li><strong>修复浏览器差异</strong>：它解决了各个浏览器之间的渲染差异，比如在 HTML5 元素、表格、嵌入内容、表单控件等方面。</li><li><strong>HTML5 支持</strong>：它提供了对 HTML5 元素更好的支持，使得老版本的浏览器也能正确地显示新的 HTML5 标签。</li><li><strong>可读性和可维护性</strong>：<code>normalize.css</code> 的代码是开源的，易于阅读和理解，你可以根据自己的需要进行调整。</li><li><strong>文档化</strong>：每一个规则都被详细注释，解释其存在的原因以及所解决的问题。</li></ol><hr><h3 id="CSS3-多列布局"><a href="#CSS3-多列布局" class="headerlink" title="CSS3-多列布局"></a>CSS3-多列布局</h3><p>使用column属性来实现多列布局</p><ul><li>column-count：直接指定列数</li><li>column-width：指定每一列的宽度，会自动计算列数</li><li>column：复合属性（同时指定列数和列宽，不推荐使用）</li></ul><h5 id="调整列间距"><a href="#调整列间距" class="headerlink" title="调整列间距"></a>调整列间距</h5><ul><li>column-gap：调整列间距</li></ul><h5 id="调整列边框"><a href="#调整列边框" class="headerlink" title="调整列边框"></a>调整列边框</h5><ul><li>column-rule-width：宽度</li><li>column-rule-color：颜色</li><li>column-rule-style：风格</li><li>column-rule：复合属性（写起来跟border一样）</li></ul><h5 id="跨列"><a href="#跨列" class="headerlink" title="跨列"></a>跨列</h5><p>通常文章的标题需要横跨多个列</p><p>使用属性column-span:all; 来配置标题横跨所有列</p><h5 id="多列布局图片问题"><a href="#多列布局图片问题" class="headerlink" title="多列布局图片问题"></a>多列布局图片问题</h5><p>如果想让图片置于多列布局的文字中，直接将图片的width属性调制100%即可</p><hr><h3 id="CSS3-多列图片"><a href="#CSS3-多列图片" class="headerlink" title="CSS3-多列图片"></a>CSS3-多列图片</h3><p>这样就很简单的实现多列图片布局，很多壁纸网站都是类似的效果了</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-class">.outer</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">column-count</span>: <span class="hljs-number">5</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-tag">img</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><br><span class="language-css">        <span class="hljs-attribute">transition</span>: <span class="hljs-number">0.2s</span> linear;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-tag">img</span><span class="hljs-selector-pseudo">:hover</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0px</span> <span class="hljs-number">0px</span> <span class="hljs-number">20px</span> black;</span><br><span class="language-css">        <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">1.02</span>);</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;outer&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>        ……<br>        <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>JAVAWEB</category>
      
      <category>angular</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CSS-定位</title>
    <link href="/2024/12/22/CSS-%E5%AE%9A%E4%BD%8D/"/>
    <url>/2024/12/22/CSS-%E5%AE%9A%E4%BD%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="CSS-定位"><a href="#CSS-定位" class="headerlink" title="CSS-定位"></a>CSS-定位</h1><h3 id="相对定位"><a href="#相对定位" class="headerlink" title="相对定位"></a>相对定位</h3><p>position: relative;属性给元素开启相对定位</p><p>如果一个元素开启了相对定位，那么该元素的层级比其他元素高，但和浮动不同，定位并不脱离原本的文档流</p><p>如果同时存在多个开启定位的元素，后面的元素会覆盖在前面的元素上</p><p>通过left、right、top、bottom来调整位置，相对于自己原来的位置</p><p>相对定位可以和margin同时存在，但不推荐同时用</p><p>相对定位可以和浮动同时存在，但不推荐同时用</p><p>绝大多数情况下，相对定位和绝对定位要配合使用</p><hr><h3 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h3><p>position: absolute;属性给元素开启绝对定位</p><p>如果一个元素开启了绝对定位，该元素会脱离文档流，但和浮动不同，其文字仍会停留在原来的位置，不会环绕元素</p><p><em>浮动的设计初衷是实现文字环绕元素的效果，所以开启浮动后会导致文字被踢出元素外</em></p><p>绝对定位的位置参考，就是相对于其包含块的绝对位置</p><h5 id="包含块"><a href="#包含块" class="headerlink" title="包含块"></a>包含块</h5><ul><li>没有脱离文档流的元素，父元素就是包含块</li><li>脱离文档流的元素，第一个开启定位的祖先元素，该元素就是其包含块</li></ul><p>如果不考虑包含块的问题，所有绝对定位的元素都将以html为包含块来作为参考位置，这不是我们想要的效果</p><p>所以使用“子绝父相”的原则，让父元素为子元素的包含块，这样就可以做到让子元素参考父元素来做定位了</p><p>绝对定位可以和margin同时存在，但不推荐同时用</p><p>绝对定位不可以和浮动同时存在</p><hr><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>绝对定位会让元素脱离文档流，并且将元素的性质变为定位元素，如果该元素本身是一个行内元素，将其设置为绝对定位后，可以通过CSS配置其宽高</p><p>定位功能不能完全的替代浮动布局，而是搭配使用，先用布局设置大框架后使用定位配置框架中内容</p><hr><h3 id="固定定位"><a href="#固定定位" class="headerlink" title="固定定位"></a>固定定位</h3><p>position: fixed;属性给元素开启固定定位</p><p>固定定位的参考位置，直接以视口作为其元素的包含块</p><p>固定定位可以和margin同时存在，但不推荐使用</p><p>固定定位不可以和浮动同时存在</p><p>固定定位会让元素脱离文档流，且会让该元素成为定位元素</p><hr><h3 id="粘性定位"><a href="#粘性定位" class="headerlink" title="粘性定位"></a>粘性定位</h3><p>position: sticky;属性给元素开启固定定位</p><p>粘性定位的参考位置，是以最近拥有滚动条的元素作为参考点（无论该滚动条是否有效）</p><p>粘性定位的有效位置，是以其父元素作为有效范围</p><p>粘性定位不会脱离文档流，它是一种专门用于窗口滚动时的新的定位方式</p><p>粘性定位可以和margin同时存在，但不推荐同时用</p><p>粘性定位可以和浮动同时存在，但不推荐同时用</p><hr><h3 id="定位的层级"><a href="#定位的层级" class="headerlink" title="定位的层级"></a>定位的层级</h3><p>无论为何种定位，他们的层级是同优先级的，如果不进行配置，则遵循后者覆盖前者的规则</p><p>z-index属性是用于已设置定位的属性，可以手动调整他们的优先级、</p><p><em>如果z-index值大的元素，依然没有覆盖掉z-index值小的元素，请检查其包含块的层级</em></p><hr><h3 id="定位的注意事项"><a href="#定位的注意事项" class="headerlink" title="定位的注意事项"></a>定位的注意事项</h3><p>定位是参考整个盒子的，所以定位很有可能忽略掉父元素的padding属性，也就是忽略父元素的内边距</p><h5 id="特殊应用"><a href="#特殊应用" class="headerlink" title="特殊应用"></a>特殊应用</h5><p>定位之后，元素的性质变成定位元素，其宽高由内容撑开，如果还想让元素维持块元素的独占一行，撑满宽度，则需要额外增加几个属性</p><p><em>这里子元素的宽高未定义，其宽高由内容撑开</em></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 左右撑开父元素 */</span><br><span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br><span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">/* 上下撑开父元素 */</span><br><span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br><span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>不能加width: 100%;的属性，因为width是内容区宽度，再加上内边距和边框的长度势必会超出父元素</p><h5 id="设置子元素居中"><a href="#设置子元素居中" class="headerlink" title="设置子元素居中"></a>设置子元素居中</h5><p>当子元素有定义的宽高后，使用这些属性搭配可以将元素相对于父元素剧中</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br><span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br><span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br><span class="hljs-attribute">bottom</span> <span class="hljs-number">0</span>;<br><span class="hljs-attribute">margin</span>: auto;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>JAVAWEB</category>
      
      <category>angular</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CSS</title>
    <link href="/2024/12/20/CSS/"/>
    <url>/2024/12/20/CSS/</url>
    
    <content type="html"><![CDATA[<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><p>为学习Angular做铺垫，我们重新学习一下CSS的相关内容</p><p>在HTML中，我们使用link标签引入外部css样式文件</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">&lt;link rel=<span class="hljs-string">&quot;stylesheet&quot;</span> href=<span class="hljs-string">&quot;./xxx.css&quot;</span>&gt;<br></code></pre></td></tr></table></figure><hr><h3 id="样式优先级"><a href="#样式优先级" class="headerlink" title="样式优先级"></a>样式优先级</h3><p>行内样式 &gt; 内部样式 &#x3D; 外部样式</p><p>当内部样式和外部样式优先级相同，如果同时存在则和编写顺序有关，采用原则为后覆盖前</p><hr><h3 id="基本选择器"><a href="#基本选择器" class="headerlink" title="基本选择器"></a>基本选择器</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 统配选择器 */</span><br>*&#123;<br>    <br>&#125;<br><br><span class="hljs-comment">/* 元素选择器 */</span><br><span class="hljs-selector-attr">[元素名]</span>&#123;<br>    <br>&#125;<br><br><br><span class="hljs-comment">/* 类选择器 */</span><br>.<span class="hljs-selector-attr">[class属性名]</span>&#123;<br>    <br>&#125;<br><br><span class="hljs-comment">/* id选择器 */</span><br>#<span class="hljs-selector-attr">[id属性名]</span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>一个元素可以有多个类选择器</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 同时应用类选择器class1、class2、class3 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;class1 class2 class3&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h3 id="复合选择器"><a href="#复合选择器" class="headerlink" title="复合选择器"></a>复合选择器</h3><h5 id="交集选择器"><a href="#交集选择器" class="headerlink" title="交集选择器"></a>交集选择器</h5><p>一般用于元素和类名配合来定位标签</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 元素选择器&amp;类选择器（元素选择器写在前面）*/</span><br><span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.class1</span>&#123;<br>    <br>&#125;<br><br><span class="hljs-comment">/* 类选择器&amp;类选择器*/</span><br><span class="hljs-selector-class">.class1</span><span class="hljs-selector-class">.class2</span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h5 id="并集选择器"><a href="#并集选择器" class="headerlink" title="并集选择器"></a>并集选择器</h5><p>同时选中多个选择器来应用样式，也叫分组选择器</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 类选择器 | 类选择器 | id选择器 */</span><br>class1,<br>class2,<br><span class="hljs-selector-id">#id1</span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h5 id="后代选择器"><a href="#后代选择器" class="headerlink" title="后代选择器"></a>后代选择器</h5><p>选择一个选择器的所有后代选择器</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 选中ol的所有后代li（不论层级） */</span><br><span class="hljs-selector-tag">ol</span> <span class="hljs-selector-tag">li</span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h5 id="子代选择器"><a href="#子代选择器" class="headerlink" title="子代选择器"></a>子代选择器</h5><p>选择一个选择器的下一层及选择器</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 选中ol的下一层及的li */</span><br><span class="hljs-selector-tag">ol</span> &gt; <span class="hljs-selector-tag">li</span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h5 id="兄弟选择器"><a href="#兄弟选择器" class="headerlink" title="兄弟选择器"></a>兄弟选择器</h5><p>选择一个选择器的紧紧相邻的选择器，但无论是相邻的还是紧紧相邻的，都是往下选择器</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 选中与div元素紧紧相邻的p元素 */</span><br><span class="hljs-selector-tag">div</span>+<span class="hljs-selector-tag">p</span>&#123;<br>    <br>&#125;<br><br><span class="hljs-comment">/* 选中与div元素所有相邻的p元素 */</span><br><span class="hljs-selector-tag">div</span>~<span class="hljs-selector-tag">p</span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h5 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 选中属性为title */</span><br><span class="hljs-selector-attr">[title]</span>&#123;<br>    <br>&#125;<br><br><span class="hljs-comment">/* 选中属性为title且属性值为title1 */</span><br><span class="hljs-selector-attr">[title=<span class="hljs-string">&quot;title1&quot;</span>]</span>&#123;<br>    <br>&#125;<br><br><span class="hljs-comment">/* 选中属性为title且属性值为t开头 */</span><br><span class="hljs-selector-attr">[title^=<span class="hljs-string">&quot;t&quot;</span>]</span>&#123;<br>    <br>&#125;<br><br><span class="hljs-comment">/* 选中属性为title且属性值以t结尾 */</span><br><span class="hljs-selector-attr">[title$=<span class="hljs-string">&quot;t&quot;</span>]</span>&#123;<br>    <br>&#125;<br><br><span class="hljs-comment">/* 选中属性为title且属性值包含t */</span><br><span class="hljs-selector-attr">[title*=<span class="hljs-string">&quot;t&quot;</span>]</span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h3><p>lvha是通常的伪类选择器的编写顺序</p><p>其中hover和active为所有元素都可以具备的</p><p>focus是选择获取焦点的元素，为表单类元素才能使用的伪类</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 选中的是没有访问过的a元素 */</span><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:link</span>&#123;<br>    <br>&#125;<br><br><span class="hljs-comment">/* 选中的是访问过的a元素 */</span><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:visited</span>&#123;<br>    <br>&#125;<br><br><span class="hljs-comment">/* 选中的鼠标悬浮状态的a元素 */</span><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span>&#123;<br>    <br>&#125;<br><br><span class="hljs-comment">/* 选中的是激活状态的a元素 */</span><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:active</span>&#123;<br>    <br>&#125;<br><br><span class="hljs-comment">/* 选中的是处于焦点状态的input元素 */</span><br><span class="hljs-selector-tag">input</span><span class="hljs-selector-pseudo">:focus</span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h5 id="结构伪类"><a href="#结构伪类" class="headerlink" title="结构伪类"></a>结构伪类</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 选中的是div的第一个子元素p */</span><br><span class="hljs-selector-tag">div</span>&gt;<span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">:first-child</span>&#123;<br>    <br>&#125;<br><br><span class="hljs-comment">/* 选中的是div的后代元素p，且不论层级，且不论父级是谁，但p必须为其父级的第一个元素 */</span><br><span class="hljs-selector-tag">div</span> <span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">:first-child</span>&#123;<br>    <br>&#125;<br><br><span class="hljs-comment">/* 选中的是元素p，且不论层级，且不论父级是谁，但p必须为其父级的第一个元素 */</span><br><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">:first-child</span>&#123;<br>    <br>&#125;<br><br><span class="hljs-comment">/* 选中的是div的最后一个子元素p */</span><br><span class="hljs-selector-tag">div</span>&gt;<span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">:last-child</span>&#123;<br>    <br>&#125;<br><br><span class="hljs-comment">/* 选中的是div的第N个子元素p */</span><br><span class="hljs-selector-tag">div</span>&gt;<span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">:nth-child</span>(n)&#123;<br>    <br>&#125;<br><br><span class="hljs-comment">/* 选中的是div的偶数子元素p */</span><br><span class="hljs-comment">/* 这里可以使用even替代2n */</span><br><span class="hljs-selector-tag">div</span>&gt;<span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">2</span>n)&#123;<br>    <br>&#125;<br><br><span class="hljs-comment">/* 选中的是div的奇数子元素p */</span><br><span class="hljs-comment">/* 这里可以使用odd替代2n+1 */</span><br><span class="hljs-selector-tag">div</span>&gt;<span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">2</span>n+<span class="hljs-number">1</span>)&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr><p>注意，这里的结构伪类与选择器为同级优先级的选择器筛选范围，也就是说这里的元素要同时满足<code>div的后代p</code>和<code>div的第一个子元素</code></p><p>但可以使用first-of-type伪类，这样就可以选中第一个为此类型的元素了</p><p>那以此类推，还会存在last-of-type伪类和nth-of-type伪类</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 在这里没有元素被选中 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-tag">div</span>&gt;<span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">:first-child</span>&#123;</span><br><span class="language-css"></span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 在这里div中的第一个p标签会被选中 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-tag">div</span>&gt;<span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">:first-of-type</span>&#123;</span><br><span class="language-css"></span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br></code></pre></td></tr></table></figure><hr><p>nth-last-child：倒叙选择子元素</p><p>nth-last-of-type：倒叙选择子类型元素</p><p>only-chile：选择唯一子元素（兄弟元素中没有同元素）</p><p>only-of-type：选择唯一类型的子元素（兄弟元素中没有同类型元素）</p><p>root：选择根元素（选中html元素）</p><p>empty：选择元素内容为空的元素</p><hr><h5 id="否定伪类"><a href="#否定伪类" class="headerlink" title="否定伪类"></a>否定伪类</h5><p>not()：选择排除选择器以外的所有元素</p><hr><h5 id="UI伪类"><a href="#UI伪类" class="headerlink" title="UI伪类"></a>UI伪类</h5><p>checked：应用与单选按钮和复选框的动态的样式调整</p><p>disabled：应用与被禁用的表单控件的样式调整</p><p>enabled：应用与可用的表单控件的样式调整</p><hr><h5 id="目标伪类"><a href="#目标伪类" class="headerlink" title="目标伪类"></a>目标伪类</h5><p>target：选中锚点指向的元素</p><hr><h5 id="语言伪类"><a href="#语言伪类" class="headerlink" title="语言伪类"></a>语言伪类</h5><p>lang()：选中语言属性为指定类型的元素</p><hr><h3 id="伪元素选择器"><a href="#伪元素选择器" class="headerlink" title="伪元素选择器"></a>伪元素选择器</h3><p>选中一个元素的特殊位置</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 选中div元素中的第一个字母 */</span><br><span class="hljs-selector-tag">div</span><span class="hljs-selector-pseudo">::first-letter</span>&#123;<br>    <br>&#125;<br><br><span class="hljs-comment">/* 选中div元素中的首行 */</span><br><span class="hljs-selector-tag">div</span><span class="hljs-selector-pseudo">::first-line</span>&#123;<br>    <br>&#125;<br><br><span class="hljs-comment">/* 选中div元素中的被选中的内容 */</span><br><span class="hljs-selector-tag">div</span><span class="hljs-selector-pseudo">::selection</span>&#123;<br>    <br>&#125;<br><br><span class="hljs-comment">/* 选中input元素中的placeholder属性（更改此属性值的样式） */</span><br><span class="hljs-selector-tag">input</span><span class="hljs-selector-pseudo">::placeholder</span>&#123;<br>   <br>&#125;<br><br><span class="hljs-comment">/* 在p元素的内容最前面加上￥ */</span><br><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">::before</span>&#123;<br>    <span class="hljs-attribute">content</span>:<span class="hljs-string">&quot;￥&quot;</span>;<br>&#125;<br><br><span class="hljs-comment">/* 在p元素的内容末尾加上.00 */</span><br><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">::after</span>&#123;<br>    <span class="hljs-attribute">content</span>:<span class="hljs-string">&quot;.00&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="选择器的优先级"><a href="#选择器的优先级" class="headerlink" title="选择器的优先级"></a>选择器的优先级</h3><p>行内 &gt; ID选择器 &gt; 类选择器 &gt; 元素选择器 &gt; 通配选择器</p><p>对于复杂选择器，有固定计算权重的公式，相同权重的仍然采用后覆盖前的规则</p><p>通过!important样式属性值的后缀，可以强制应用这个样式</p><hr><h3 id="样式属性的继承"><a href="#样式属性的继承" class="headerlink" title="样式属性的继承"></a>样式属性的继承</h3><p>color和font-size是常用的继承样式</p><p>继承的样式的样式优先级是最低的，甚至比通配选择器的优先级还低</p><hr><h3 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h3><p>在css中，颜色有三种配置方式</p><ul><li>RGB 和 RGBA</li><li>HEX 和 HEXA</li><li>HSL 和 HSLA</li></ul><hr><h3 id="常用的css属性"><a href="#常用的css属性" class="headerlink" title="常用的css属性"></a>常用的css属性</h3><h5 id="字体相关"><a href="#字体相关" class="headerlink" title="字体相关"></a>字体相关</h5><table><thead><tr><th>属性名</th><th>功能</th></tr></thead><tbody><tr><td>font-size</td><td>字体大小（对于谷歌浏览器而言，默认最小的文字大小是12px，但默认的字号为16px）</td></tr><tr><td>font-family</td><td>设置字体</td></tr><tr><td>font-style</td><td>字体风格（normal，italic，oblique）</td></tr><tr><td>font-weight</td><td>字体粗细（lighter，normal，bold，bolder）</td></tr><tr><td>font</td><td>字体的混合属性（各个属性以空格隔开）</td></tr></tbody></table><h5 id="文本属性"><a href="#文本属性" class="headerlink" title="文本属性"></a>文本属性</h5><table><thead><tr><th>属性名</th><th>功能</th></tr></thead><tbody><tr><td>color</td><td>文本颜色</td></tr><tr><td>letter-spacing</td><td>字间距，单位为px</td></tr><tr><td>word-spacing</td><td>词间距，单位为px</td></tr><tr><td>text-decoration</td><td>文本修饰（overline，underline，line-through，none）</td></tr><tr><td>text-indent</td><td>文本缩进（em，px）</td></tr><tr><td>text-align</td><td>文本对齐（left，right，center）</td></tr><tr><td>line-height</td><td>行高（行高和字体大小不应相同，此属性默认值为normal，由浏览器决定合适的行高，尽量选择倍率的行高）</td></tr><tr><td>vertical-align</td><td>垂直对齐（此属性作用于元素本身相对于父元素，并且不能控制块级元素，其他文本属性作用于元素内文本本身）</td></tr></tbody></table><h5 id="列表相关属性"><a href="#列表相关属性" class="headerlink" title="列表相关属性"></a>列表相关属性</h5><table><thead><tr><th>属性名</th><th>功能</th></tr></thead><tbody><tr><td>list-style-type</td><td>调整列表项目符号（none）</td></tr><tr><td>list-style-position</td><td>列表符号的位置（inside，outside）</td></tr><tr><td>list-style-image</td><td>替换项目符号为图片（url(“”)）</td></tr><tr><td>list-style</td><td>复合属性，以空格分隔</td></tr></tbody></table><h5 id="表格相关属性"><a href="#表格相关属性" class="headerlink" title="表格相关属性"></a>表格相关属性</h5><p>在表格中，table元素使用为外边框，th，td元素使用的为单元格边框</p><table><thead><tr><th>属性名</th><th>功能</th></tr></thead><tbody><tr><td>border-width</td><td>表格边框宽度</td></tr><tr><td>border-color</td><td>表格边框颜色</td></tr><tr><td>border-style</td><td>表格边框样式（solid，dashed，dotted，double）</td></tr><tr><td>border</td><td>复合属性，以空格分隔</td></tr></tbody></table><p>在表格中，实现跨行和跨列的方式只有html，css中无法实现单元格跨行、跨列</p><table><thead><tr><th>属性名</th><th>功能</th></tr></thead><tbody><tr><td>table-layout</td><td>控制表格列宽（auto，fixed）</td></tr><tr><td>border-spacing</td><td>控制单元格间距</td></tr><tr><td>border-collapse</td><td>合并相邻单元格的边框（separate，collapse）（当此属性为collapse，border-spacing属性、empty-cells属性失效）</td></tr><tr><td>empty-cells</td><td>隐藏没有内容的单元格（show，hide）</td></tr><tr><td>caption-side</td><td>设置表格标题的位置（top，bottom）</td></tr></tbody></table><h5 id="背景相关属性"><a href="#背景相关属性" class="headerlink" title="背景相关属性"></a>背景相关属性</h5><table><thead><tr><th>属性名</th><th>功能</th></tr></thead><tbody><tr><td>backgroud-color</td><td>调整背景颜色</td></tr><tr><td>backgroud-image</td><td>调整背景图片</td></tr><tr><td>backgroud-repeat</td><td>调整背景图片是否重复（norepeat，repeat-y，repeat-x）</td></tr><tr><td>backgroud-position</td><td>调整背景图片位置</td></tr><tr><td>backgroud</td><td>复合属性，以空格隔开</td></tr></tbody></table><h5 id="鼠标相关属性"><a href="#鼠标相关属性" class="headerlink" title="鼠标相关属性"></a>鼠标相关属性</h5><table><thead><tr><th>属性名</th><th>功能</th></tr></thead><tbody><tr><td>cursor</td><td>设置鼠标光标的样式</td></tr><tr><td>cursor</td><td>url(“”)，可以直接自定义鼠标样式</td></tr></tbody></table><hr><h3 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h3><h5 id="CSS中的长度单位"><a href="#CSS中的长度单位" class="headerlink" title="CSS中的长度单位"></a>CSS中的长度单位</h5><table><thead><tr><th>单位标识符</th><th>单位</th></tr></thead><tbody><tr><td>px</td><td>像素</td></tr><tr><td>em</td><td>相当于当前元素的font-size的倍数（如果当前元素没有此属性，向父级寻找，如果都没有，则采用默认值16）</td></tr><tr><td>rem</td><td>相对于根元素的font-size的倍数</td></tr><tr><td>%</td><td>相对于其父元素的百分比</td></tr></tbody></table><h5 id="元素的显示模式"><a href="#元素的显示模式" class="headerlink" title="元素的显示模式"></a>元素的显示模式</h5><p>块元素（block）</p><p><em>div是比较典型的块元素</em></p><ul><li>在页面中独占一行</li><li>默认宽度：撑满父元素</li><li>默认高度：由内容撑开</li><li>可以通过css设置宽高</li></ul><p>行内元素（inline）</p><p><em>span是比较典型的行内元素</em></p><ul><li>在页面中不独占一行，从左到右排列</li><li>默认宽度：由内容撑开</li><li>默认高度：由内容撑开</li><li>无法通过css设置宽高</li></ul><p>行内块元素（inline-block）</p><p><em>src图片是比较典型的行内块元素</em></p><ul><li>在页面中不独占一行，从左到右排列</li><li>默认宽度：由内容撑开</li><li>默认高度：由内容撑开</li><li>可以通过css设置宽高</li></ul><p>display属性可以手动的指定一个元素的显示模式：block（块元素），inline-block（行内块元素），inline（行内元素），none（不显示该元素）</p><hr><h3 id="盒子模型的组成部分"><a href="#盒子模型的组成部分" class="headerlink" title="盒子模型的组成部分"></a>盒子模型的组成部分</h3><p>无论是什么元素，我们都将其看作一个盒子，盒子由四个部分组成</p><ul><li>margin（外边距）</li><li>padding（内边距）</li><li>border（边框）</li><li>content（内容）</li></ul><p>盒子的大小 &#x3D; padding + border + content</p><p>margin不影响盒子的大小，只影响盒子的位置</p><h5 id="盒子的内容区"><a href="#盒子的内容区" class="headerlink" title="盒子的内容区"></a>盒子的内容区</h5><p>在非行内元素中，我们可以通过width和height来调整盒子的宽高</p><p>min-width属性可以设置盒子的最小宽度，当页面小于这个宽度时，盒子不再缩小</p><p>max-width属性可以设置盒子的最大宽度，当页面大于最大宽度时，盒子不再放大</p><p>min-width属性可以设置盒子的最小高度，当内容撑开的盒子小于这个高度时，也仍然维持这个高度</p><p>max-width属性可以设置盒子的最大高度，当内容撑开的盒子大于这个高度时，也仍然维持这个高度</p><h5 id="盒子的内边距"><a href="#盒子的内边距" class="headerlink" title="盒子的内边距"></a>盒子的内边距</h5><p>行内元素的上下内边距会产生重叠</p><h5 id="盒子的外边距"><a href="#盒子的外边距" class="headerlink" title="盒子的外边距"></a>盒子的外边距</h5><p>子元素的位置是位于父元素的content内容区开始计算的</p><p>上、左的margin会影响自己的位置，下、右的margin会影响兄弟元素的位置</p><p>行内元素的上下外边距无效</p><p>margin的值可以是AUTO，给一个块级元素左右margin设置为auto，则设置在父元素中水平居中</p><p>margin的值可以为负数</p><hr><h3 id="存在的问题和小技巧"><a href="#存在的问题和小技巧" class="headerlink" title="存在的问题和小技巧"></a>存在的问题和小技巧</h3><h5 id="margin的塌陷问题"><a href="#margin的塌陷问题" class="headerlink" title="margin的塌陷问题"></a>margin的塌陷问题</h5><p>Margin 塌陷（也称为 margin collapse）是 CSS 中的一个特性，它发生在相邻的垂直外边距相遇时合并为一个单一的外边距</p><ul><li><strong>为父元素添加边框或内边距</strong>：这是最简单的方法之一，通过给父元素添加边框或者内边距，可以阻止其与子元素的外边距发生塌陷。</li><li><strong>使用 <code>overflow: hidden;</code> 或者其他的非 <code>visible</code> 值</strong>：设置父元素的 <code>overflow</code> 属性为 <code>hidden</code> 或者其他的非 <code>visible</code> 值（如 <code>auto</code>），可以创建一个新的块格式化上下文 (BFC)，从而防止 margin 塌陷。</li><li><strong>浮动父元素</strong>：使父元素浮动也可以避免 margin 塌陷，不过这可能会引起布局上的其他问题，需要谨慎使用。</li><li><strong>绝对定位</strong>：对子元素使用绝对定位可以使其脱离文档流，因此不会与父元素或其他兄弟元素发生 margin 塌陷。</li><li><strong>改变 display 属性</strong>：有时改变元素的 <code>display</code> 属性（例如从 <code>block</code> 改为 <code>inline-block</code> 或者 <code>flex</code>）也能解决 margin 塌陷的问题。</li></ul><h5 id="margin的合并问题"><a href="#margin的合并问题" class="headerlink" title="margin的合并问题"></a>margin的合并问题</h5><p>上面元素设置margin-bottom 下面兄弟元素设置margin-top，则会发生margin的合并问题，需要注意的是，这种问题只发生在上下兄弟之间，左右之间不会发生</p><p>无需解决，在布局时上下元素只设置一个元素即可</p><h5 id="内容溢出问题"><a href="#内容溢出问题" class="headerlink" title="内容溢出问题"></a>内容溢出问题</h5><p>在父级容器中使用overflow: hidden，可以设置超出容器的部分隐藏内容</p><p>overflow: scroll，显示滚动条，可拖拽</p><p>overflow: auto，超出容器的部分显示为滚动条，可拖拽</p><p>overflow: x和overflow: y可以单独设置横向和纵向的内容超出部分设置</p><h5 id="隐藏元素的两种方式"><a href="#隐藏元素的两种方式" class="headerlink" title="隐藏元素的两种方式"></a>隐藏元素的两种方式</h5><p>将display设置为none，即可隐藏该元素</p><p>将visibility设置为hidden，即可隐藏该元素，但仍然保持位置存在（占位）</p><h5 id="继承与元素的默认样式"><a href="#继承与元素的默认样式" class="headerlink" title="继承与元素的默认样式"></a>继承与元素的默认样式</h5><p>能够被继承的属性，都是和盒子模型没有关系的属性，不影响布局的属性，例如，字体样式，文本样式，文本颜色等</p><p>继承的属性优先级特别低，比浏览器用户代理（默认样式）的还要低</p><p>元素一般都有些默认的样式，如果想重置某一个元素的默认样式，可以使用元素选择器选中后，清除该元素的样式即可</p><h5 id="布局技巧"><a href="#布局技巧" class="headerlink" title="布局技巧"></a>布局技巧</h5><ul><li>让子元素相对于父元素水平居中<ul><li>若子元素为块元素，子元素加<code>margin: 0,auto;</code></li><li>若子元素为行内元素或行内块元素，给父元素加<code>text-align:center;</code></li></ul></li><li>让子元素相对于父元素垂直居中<ul><li>若子元素为块元素，子元素加<code>margin-top</code>，值为<code>父元素cotent-子元素盒子总高/2</code></li><li>若子元素为行内元素或行内块元素，让父元素的<code>height=line-height</code>，并给每个子元素都加上<code>vertical-align:middle</code>，若想绝对垂直居中，父元素字体大小为0</li></ul></li></ul><p>总结：行内元素和行内块元素都看作为文本处理，text-align、line-height、text-indent这些属性都能应用</p><h5 id="元素之间的空白问题"><a href="#元素之间的空白问题" class="headerlink" title="元素之间的空白问题"></a>元素之间的空白问题</h5><p>为父元素的<code>font-size</code>字体大小赋值为0，然后将单独为特定元素配置字体大小，就可以解决换行问题带来的元素之间默认存在空格的问题</p><h5 id="元素之间的幽灵空白问题"><a href="#元素之间的幽灵空白问题" class="headerlink" title="元素之间的幽灵空白问题"></a>元素之间的幽灵空白问题</h5><p>因为基线对齐的原则，元素之间会存在幽灵空白的问题，有以下三个解决方法</p><ol><li><p>设置一个垂直文本对齐方式即可</p></li><li><p>如果仅存在一个图片的话，可以将图片变成块元素，也可以解决幽灵空白的问题</p></li><li><p>为父元素设置<code>font-size=0</code>即可</p></li></ol><hr><h3 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h3><p>通过为元素配置属性float，即可实现文字环绕该元素的效果</p><p>在浮动设计初期，是为了实现文字环绕元素的效果，但前端发展至今，我们使用浮动来<strong>布局</strong></p><h5 id="浮动产生的效果"><a href="#浮动产生的效果" class="headerlink" title="浮动产生的效果"></a>浮动产生的效果</h5><ul><li><p>一个元素浮动之后，他就脱离了文档流</p></li><li><p>一个元素浮动之后，他的默认大小通常由内容撑开</p></li><li><p>一个元素浮动之后，可以和其他元素共用一行</p></li><li><p>一个元素浮动之后，不会margin合并，也不会margin塌陷，可以完美的设置四个方向的margin和padding</p></li><li><p>一个元素浮动之后，不会像行内块一样被当作文本处理</p></li></ul><h5 id="浮动产生的影响"><a href="#浮动产生的影响" class="headerlink" title="浮动产生的影响"></a>浮动产生的影响</h5><p>当一个元素浮动后，其父元素的高度塌陷（不被内容撑开），后面的兄弟的位置也会有影响，但父元素的宽度依然能束缚浮动的子元素</p><h5 id="解决浮动产生的影响"><a href="#解决浮动产生的影响" class="headerlink" title="解决浮动产生的影响"></a>解决浮动产生的影响</h5><ul><li>给父元素加高度</li><li>给父元素设置浮动</li><li>给父元素设置overflow:hidden</li><li>在所有元素后添加一个块元素，并配置属性<code>clear: both;</code></li></ul><p><code>clear: both;</code> 清除该元素因前面的兄弟元素浮动而产生的影响，前提是该元素不为浮动元素，且不能为行内元素或行内块元素</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-pseudo">::after</span>&#123;<br>    <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-attribute">display</span>: block;<br>    <span class="hljs-attribute">clear</span>: both;<br>&#125;<br></code></pre></td></tr></table></figure><p>这些方法也不是万能的，他无法解决浮动元素和非浮动元素混杂在同一个父元素下的情况，所以在设计页面时要保证一起浮动，或者一起不浮动</p>]]></content>
    
    
    <categories>
      
      <category>JAVAWEB</category>
      
      <category>angular</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>HTML</title>
    <link href="/2024/12/14/HTML/"/>
    <url>/2024/12/14/HTML/</url>
    
    <content type="html"><![CDATA[<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><p>为学习Angular做铺垫，我们重新学习一下HTML的相关内容</p><hr><h3 id="语义化标签"><a href="#语义化标签" class="headerlink" title="语义化标签"></a>语义化标签</h3><p>HTML 语义化标签是指那些能够清晰表达其内容含义的 HTML 标签。</p><p>使用语义化标签有助于提高代码的可读性、可维护性和可访问性，同时也有利于搜索引擎优化（SEO）</p><ul><li><p><strong><code>&lt;header&gt;</code></strong>：用于定义文档或部分的头部区域，通常包含网站标志、导航链接等。</p></li><li><p><strong><code>&lt;nav&gt;</code></strong>：专门用来定义导航链接的部分，适合放置页面的主要导航菜单。</p></li><li><p><strong><code>&lt;main&gt;</code></strong>：表示文档的主要内容，每个页面应该只有一个 <code>&lt;main&gt;</code> 元素，并且它不应该作为其他元素（如 <code>&lt;article&gt;</code> 或 <code>&lt;aside&gt;</code>）的一部分。</p></li><li><p><strong><code>&lt;article&gt;</code></strong>：用于定义独立的内容块，例如博客文章、新闻故事或评论，这些内容可以独立存在或者被分发到其他地方。</p></li><li><p><strong><code>&lt;section&gt;</code></strong>：用于将文档分成章节或逻辑部分，通常会有一个标题（<code>&lt;h1&gt;</code> 到 <code>&lt;h6&gt;</code>）来描述该部分的内容。</p></li><li><p><strong><code>&lt;aside&gt;</code></strong>：表示与主要内容相关的辅助信息，比如侧边栏或广告。</p></li><li><p><strong><code>&lt;footer&gt;</code></strong>：用于定义文档或部分的页脚，通常包含版权信息、联系人信息等。</p></li></ul><p>此外，还有一些其他的语义化标签，例如：</p><ul><li><strong><code>&lt;figure&gt;</code> 和 <code>&lt;figcaption&gt;</code></strong>：用于组合图片、图表和其他插图内容及其标题。</li><li><strong><code>&lt;time&gt;</code></strong>：用于标记时间或日期，可以包含 <code>datetime</code> 属性以提供更精确的时间格式。</li><li><strong><code>&lt;mark&gt;</code></strong>：用于高亮显示文本，表明该文本是引用或需要特别注意的部分。</li><li><strong><code>&lt;address&gt;</code></strong>：用于定义文档作者或拥有者的联系信息。</li></ul><h5 id="标签语义化"><a href="#标签语义化" class="headerlink" title="标签语义化"></a>标签语义化</h5><p>再嵌入CSS样式后，我们发现很多本身带有样式标签已经失去了本身的样式存在的意义</p><p>那么我们就更应该重视标签中的语义，比如em和strong标签就应该拿来标识重点内容</p><p>行标签和块标签有很多，但我们最常使用的行标签就是没有意义的span标签，最常使用的块标签是没有意义的div标签</p><hr><h3 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h3><p>超链接不只可以实现跳转页面，也可以完成对资源的请求，下载</p><h5 id="资源请求"><a href="#资源请求" class="headerlink" title="资源请求"></a>资源请求</h5><p>所有在浏览器能够打开的文件都可以通过超链接直接打开，例如MP4，JPG，PDF等</p><p>不能够在浏览器中打开的文件会自动弹出下载链接，例如ZIP文件等</p><hr><h5 id="资源下载"><a href="#资源下载" class="headerlink" title="资源下载"></a>资源下载</h5><p>可以在超链接后加入download属性，实现点击超链接下载该资源</p><p>可以通过配置download属性值来实现下载文件的重命名</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;tupian.jpg&quot;</span> <span class="hljs-attr">download</span>=<span class="hljs-string">&quot;图片.jpg&quot;</span>&gt;</span>图片下载<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span> <br></code></pre></td></tr></table></figure><hr><h5 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h5><p>可以通过超链接实现锚点的跳转，锚点可以为标签中的id属性</p><p><em>注：可以通过a标签直接跳转到其他页面的锚点</em></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#maodian&quot;</span>&gt;</span>跳转至锚点<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#maodian2&quot;</span>&gt;</span>跳转至锚点2<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span> <br><br><span class="hljs-comment">&lt;!-- 通过a标签制作锚点（name属性） --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maodian&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span> <br><span class="hljs-comment">&lt;!-- 通过id属性制作锚点（推荐方法） --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;maodian2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span> <br><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>回到顶部<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span>刷新页面<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 在超链接中可以包含js代码 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript: alert(); &quot;</span>&gt;</span>点我弹窗<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h5 id="唤起应用"><a href="#唤起应用" class="headerlink" title="唤起应用"></a>唤起应用</h5><p>超链接可以唤起本地应用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;tel:12312341234&quot;</span>&gt;</span>拨打电话<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;mailto:12312341234@gmail.com&quot;</span>&gt;</span>发送邮件<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sms:10086&quot;</span>&gt;</span>发送短信<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span> <br></code></pre></td></tr></table></figure><hr><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p><em>注：列表在最佳实践中也要遵循语义化标签，在使用css时，有序列表和无序列表的列表项都是可自定义的，<strong>即标签的实现效果是不重要的</strong></em></p><p>列表项（List Item） &#x3D;&gt; li标签</p><p>有序列表 （Ordered List） &#x3D;&gt; ol标签</p><p>无序列表 （Unordered List） &#x3D;&gt; ul标签</p><p>自定义列表 （Definition List） &#x3D;&gt; dl标签</p><p>自定义列表项目符号（Definition Term） &#x3D;&gt; dt标签</p><p>自定义列表描述（Definition Description）&#x3D;&gt; dt标签</p><hr><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>表格（table） &#x3D;&gt; table标签</p><p>表格标题（caption） &#x3D;&gt; caption标签</p><p>表格头部（table head） &#x3D;&gt; thead标签</p><p>表格主体（table body） &#x3D;&gt; tbody标签</p><p>表格脚注（table foort） &#x3D;&gt; tfoot标签</p><p>表格行（table row） &#x3D;&gt; tr标签</p><p>表头单元格（table head）&#x3D;&gt; th标签</p><p>表中单元格数据（table date） &#x3D;&gt; td标签</p><p><em>注：表格主题和表格脚注的单元格标签都使用td</em></p><h5 id="表格属性"><a href="#表格属性" class="headerlink" title="表格属性"></a>表格属性</h5><table><thead><tr><th align="left">属性名</th><th>功能</th></tr></thead><tbody><tr><td align="left">border</td><td>表格边框</td></tr><tr><td align="left">width</td><td>表格宽度，单元格列宽自动调整</td></tr><tr><td align="left">height</td><td>表格高度，单元格高度自动调整（表头和脚注的高度不变，如果想要调整表头和脚注高度，需将属性加在thead和tfoot标签中）</td></tr><tr><td align="left">cellspacing</td><td>单元格间距，（边框距离为0不代表边框重叠，仍然受单元格边框粗细影响）</td></tr><tr><td align="left">align</td><td>水平对齐方式（thead，tbody，tfoot），[left , center , right]</td></tr><tr><td align="left">valign</td><td>vertical align 垂直对齐方式（thead，tbody，tfoot），[top , middle , bottom]</td></tr></tbody></table><p>然而，遵循语义化标签，所有的表格样式仍然可以通过CSS来调整</p><h5 id="跨行与跨列"><a href="#跨行与跨列" class="headerlink" title="跨行与跨列"></a>跨行与跨列</h5><p>跨列（column span） &#x3D;&gt; colspan属性</p><p>跨行（row span）&#x3D;&gt; rowspan属性</p><p>在thead，tbody，tfoot中的th和td标签中使用跨行与跨列标签</p><hr><h3 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h3><p>在前端框架的开发中，我们仍然画很多表单和按钮，但作用不再是通过表单来提交信息内容，而是将表单中信息绑定到model上面，然后通过js逻辑来发送请求</p><ul><li><strong>表单的作用</strong>：现在主要用于收集用户输入，并通过数据绑定机制将这些输入同步到组件的状态或模型（Model）中。表单不再直接用于提交数据给服务器。</li><li><strong>按钮的作用</strong>：通常用来触发特定的行为或事件处理函数，比如验证表单、清理输入、或者发起API请求。按钮点击事件可以被监听并绑定到相应的JavaScript逻辑上，而不是默认提交整个表单。</li></ul><p>然而，就算是不使用表单默认的提交逻辑，但我们仍然不会抛弃form标签，因为z要遵顼语义化标签的原则，显示的定义这是一个表单</p><h5 id="多样式按钮"><a href="#多样式按钮" class="headerlink" title="多样式按钮"></a>多样式按钮</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 确认按钮 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;确认&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>确认<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 重置按钮 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;reset&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;重置&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;reset&quot;</span>&gt;</span>重置<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 普通按钮 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;普通按钮&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span>&gt;</span>普通按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="fieldset标签"><a href="#fieldset标签" class="headerlink" title="fieldset标签"></a>fieldset标签</h5><p><code>&lt;fieldset&gt;</code> 标签是HTML中的一个表单元素，用于将表单内的相关元素组合在一起，并可选地为这个组合添加一个标题。它通常与 <code>&lt;legend&gt;</code> 标签一起使用，以提供对字段集的描述性标题。使用 <code>fieldset</code> 可以增强表单的语义结构和可访问性，使得表单更容易理解和使用，特别是对于辅助技术（如屏幕阅读器）的用户。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">fieldset</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">legend</span>&gt;</span>标题文本<span class="hljs-tag">&lt;/<span class="hljs-name">legend</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 表单控件和其他内容 --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">fieldset</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><p><code>&lt;iframe&gt;</code> 标签（内联框架）用于在当前HTML文档中嵌入另一个HTML页面。它允许在一个网页中展示来自不同源的其他内容，例如将一个网站的部分内容嵌入到另一个网站中，或者在同一页面上显示多个不同的内容区域。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;URL&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;描述性标题&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h5 id="target联动"><a href="#target联动" class="headerlink" title="target联动"></a>target联动</h5><p><code>&lt;iframe&gt;</code> 可以通过与超链接 (<code>&lt;a&gt;</code>) 和表单 (<code>&lt;form&gt;</code>) 的 <code>target</code> 属性来实现联动效果。通过设置这些元素的 <code>target</code> 属性为 <code>&lt;iframe&gt;</code> 的 <code>name</code> 或 <code>id</code>，可以让链接或表单提交的结果在指定的 <code>&lt;iframe&gt;</code> 中显示。</p><p>类似地，你也可以让表单提交的结果显示在一个 <code>&lt;iframe&gt;</code> 中。这可以通过将表单的 <code>target</code> 属性设置为 <code>&lt;iframe&gt;</code> 的 <code>name</code> 或 <code>id</code> 来实现</p><hr><p>&#96;</p>]]></content>
    
    
    <categories>
      
      <category>JAVAWEB</category>
      
      <category>angular</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SignalR</title>
    <link href="/2024/12/08/SignalR/"/>
    <url>/2024/12/08/SignalR/</url>
    
    <content type="html"><![CDATA[<h1 id="SignalR"><a href="#SignalR" class="headerlink" title="SignalR"></a>SignalR</h1><p>SignalR 是一个开源库，最初由微软开发，用于简化在 ASP.NET 应用程序中添加实时 Web 功能的过程。它使得服务器端代码能够将内容推送到连接的客户端浏览器或其他设备上，而不需要客户端显式地请求新数据。这种能力被称为“服务器推送”，与传统的基于请求-响应模式的 HTTP 交互形成对比。</p><p>SignalR 提供了一个简单的 API 来创建从服务器端 .NET 代码调用客户端（例如浏览器中的 JavaScript 函数）上的远程过程调用 (RPC)。此外，SignalR 还包括了用于管理连接（如连接和断开事件）、分组连接以及广播消息到所有或特定客户端的功能。</p><p>SignalR 的特点之一是它会根据运行时环境自动选择最合适的通信协议来实现高效的双向通信。它支持多种传输方式，包括：</p><ul><li>WebSocket：这是 SignalR 首选的传输方式，因为它提供了全双工通信通道，并且具有较低的延迟。</li><li>Server-Sent Events (SSE)：一种允许服务器向浏览器推送更新的技术。</li><li>Long Polling：客户端发出一个 HTTP 请求并保持连接打开，直到服务器有数据返回。</li><li>Forever Frame：主要用于 Internet Explorer 浏览器，通过隐藏的 iframe 实现长连接。</li></ul><p>当 WebSocket 可用时，SignalR 会优先使用它；如果 WebSocket 不被支持或不可用，则会降级到其他传输方式以确保兼容性。</p><hr><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>对于 WebSocket 来说，在现代浏览器中，WebSocket API 是内置的，因此不需要额外导入任何库或依赖项。你可以直接使用 <code>new WebSocket(url)</code> 创建一个 WebSocket 实例，并利用其事件监听器来处理连接、消息接收和发送等操作。</p><p>然而，对于 SignalR，情况有所不同。SignalR 提供了一套更高级别的抽象和功能，它不是一个原生的浏览器 API，而是由微软开发的一个库。因此，为了在客户端使用 SignalR，你需要引入 SignalR 客户端库。</p><hr><h3 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h3><p>SignalR可以部署在WebAPI中，也可以单独部署一个独立的即时通讯服务器</p><h5 id="Program-cs"><a href="#Program-cs" class="headerlink" title="Program.cs"></a>Program.cs</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 添加signalR服务</span><br>builder.Services.AddSignalR();<br><br><span class="hljs-comment">// 添加SignalR路由</span><br>app.MapHub&lt;MsgHub&gt;(<span class="hljs-string">&quot;/ChatHub&quot;</span>); <span class="hljs-comment">// 配置管道终结点</span><br></code></pre></td></tr></table></figure><h5 id="MyHub"><a href="#MyHub" class="headerlink" title="MyHub"></a>MyHub</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> Microsoft.AspNetCore.SignalR;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">SignalR</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MsgHub</span>:<span class="hljs-title">Hub</span><br>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="触发方式"><a href="#触发方式" class="headerlink" title="触发方式"></a>触发方式</h3><p>其实总结下来，触发SignalR由服务端向客户端推送消息的方式有两种</p><h5 id="服务端调用"><a href="#服务端调用" class="headerlink" title="服务端调用"></a>服务端调用</h5><p>通过依赖注入的形式将hub上下文对象注入到控制器（其实所有层都可以的）</p><p>通过上下文对象调用Clients对象，调用其中方法就可以实现向客户端推送数据</p><p><strong>这个消息的发起人可以为任意的一个人（其实可以看作是服务端直接发起的消息）</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c#">[<span class="hljs-meta">ApiController</span>]<br>[<span class="hljs-meta">Route(<span class="hljs-string">&quot;[controller]&quot;</span>)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SignalRController</span> : <span class="hljs-title">ControllerBase</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> IHubContext&lt;MsgHub&gt; _hubContext;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SignalRController</span>(<span class="hljs-params">IHubContext&lt;MsgHub&gt; hubContext</span>)</span><br>    &#123;<br>        _hubContext = hubContext;<br>    &#125;<br><br>    [<span class="hljs-meta">HttpGet</span>]<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">Send</span>(<span class="hljs-params">[FromQuery] <span class="hljs-built_in">string</span> msg</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">await</span> _hubContext.Clients.All.SendAsync(<span class="hljs-string">&quot;ReceiveMessage&quot;</span>, msg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="从客户端调用"><a href="#从客户端调用" class="headerlink" title="从客户端调用"></a>从客户端调用</h5><p>在Client中，调用服务端的Send方法，方法内部逻辑再向Client推送信息</p><p><strong>这个消息的发起人为一个Client（可以看作是客户端发起的消息）</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MsgHub</span>:<span class="hljs-title">Hub</span><br>&#123;<br>    <span class="hljs-comment">// 这里是被客户端调用的服务端方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">Send</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// 这里是被服务端调用的客户端方法</span><br>        <span class="hljs-comment">// 所有人收到</span><br>        <span class="hljs-keyword">await</span> Clients.All.SendAsync(<span class="hljs-string">&quot;ReceiveMessage&quot;</span>, message);<br>        <br>        <span class="hljs-comment">// 除调用者外其他人能收到</span><br>        <span class="hljs-keyword">await</span> Clients.Others.SendAsync(<span class="hljs-string">&quot;ReceiveMessage&quot;</span>, message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p>用一个简单的聊天室项目来实现分组功能</p><ul><li>Context对象：SignalR 提供的一个特定上下文对象<ul><li>ConnectionId：每个连接到 SignalR Hub 的客户端都会被分配一个唯一的标识符，这是用来区分不同客户端的关键信息。</li><li>UserIdentifier：类似于HttpContext.User.Identity.Name，但它更灵活，默认会尝试使用 ClaimTypes.NameIdentifier 或 ClaimTypes.Name。如果这些声明不存在，它可能会选择其他可用的声明。</li></ul></li><li>Groups：Hub类提供的一个静态属性，它提供了对组管理功能的访问。你可以使用它来添加或移除客户端连接到组</li></ul><p>在这里，以聊天室名字作为组名，以Context.ConnectionId作客户端的唯一标识符加入组中，在发送消息时，调用Clients.Group对象中方法来实现组内消息发送</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ChatHub</span> : <span class="hljs-title">Hub</span><br>&#123;<br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> 用户加入聊天室的方法。</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;roomName&quot;&gt;</span>要加入的聊天室名称。<span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span>一个异步任务，表示操作完成。<span class="hljs-doctag">&lt;/returns&gt;</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">JoinRoom</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> roomName</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// 将当前连接的客户端添加到指定的组（即聊天室）</span><br>        <span class="hljs-keyword">await</span> Groups.AddToGroupAsync(Context.ConnectionId, roomName);<br><br>        <span class="hljs-comment">// 向该组内的所有客户端发送消息，通知某用户已加入房间</span><br>        <span class="hljs-keyword">await</span> Clients.Group(roomName).SendAsync(<span class="hljs-string">&quot;ReceiveMessage&quot;</span>, <span class="hljs-string">$&quot;<span class="hljs-subst">&#123;Context.UserIdentifier&#125;</span> has joined the room <span class="hljs-subst">&#123;roomName&#125;</span>&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> 用户离开聊天室的方法。</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;roomName&quot;&gt;</span>要离开的聊天室名称。<span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span>一个异步任务，表示操作完成。<span class="hljs-doctag">&lt;/returns&gt;</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">LeaveRoom</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> roomName</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// 从指定的组中移除当前连接的客户端</span><br>        <span class="hljs-keyword">await</span> Groups.RemoveFromGroupAsync(Context.ConnectionId, roomName);<br><br>        <span class="hljs-comment">// 向该组内的所有客户端发送消息，通知某用户已离开房间</span><br>        <span class="hljs-keyword">await</span> Clients.Group(roomName).SendAsync(<span class="hljs-string">&quot;ReceiveMessage&quot;</span>, <span class="hljs-string">$&quot;<span class="hljs-subst">&#123;Context.UserIdentifier&#125;</span> has left the room <span class="hljs-subst">&#123;roomName&#125;</span>&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> 向特定聊天室发送消息的方法。</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;roomName&quot;&gt;</span>目标聊天室名称。<span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;message&quot;&gt;</span>要发送的消息内容。<span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span>一个异步任务，表示操作完成。<span class="hljs-doctag">&lt;/returns&gt;</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">SendMessageToRoom</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> roomName, <span class="hljs-built_in">string</span> message</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// 向指定组内的所有客户端发送消息</span><br>        <span class="hljs-keyword">await</span> Clients.Group(roomName).SendAsync(<span class="hljs-string">&quot;ReceiveMessage&quot;</span>, <span class="hljs-string">$&quot;<span class="hljs-subst">&#123;Context.UserIdentifier&#125;</span>: <span class="hljs-subst">&#123;message&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="客户端代码"><a href="#客户端代码" class="headerlink" title="客户端代码"></a>客户端代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script src=<span class="hljs-string">&quot;https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/6.0.0/signalr.min.js&quot;</span>&gt;&lt;/script&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> connection = <span class="hljs-keyword">new</span> signalR.<span class="hljs-title class_">HubConnectionBuilder</span>()</span></span><br><span class="language-javascript"><span class="language-xml">        .<span class="hljs-title function_">withUrl</span>(<span class="hljs-string">&quot;/chathub&quot;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">        .<span class="hljs-title function_">build</span>();</span></span><br><span class="language-javascript"><span class="language-xml">    </span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// 客户端方法ReceiveMessage，由服务端调用</span></span></span><br><span class="language-javascript"><span class="language-xml">    connection.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;ReceiveMessage&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">message</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message); <span class="hljs-comment">// 显示收到的消息</span></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">start</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">try</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-keyword">await</span> connection.<span class="hljs-title function_">start</span>();</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Connected to SignalR hub.&quot;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">        &#125; <span class="hljs-keyword">catch</span> (err) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err.<span class="hljs-title function_">toString</span>());</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 加入房间</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">joinRoom</span>(<span class="hljs-params">roomName</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">await</span> connection.<span class="hljs-title function_">invoke</span>(<span class="hljs-string">&quot;JoinRoom&quot;</span>, roomName);</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 离开房间</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">leaveRoom</span>(<span class="hljs-params">roomName</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">await</span> connection.<span class="hljs-title function_">invoke</span>(<span class="hljs-string">&quot;LeaveRoom&quot;</span>, roomName);</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 发送消息到房间</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">sendMessageToRoom</span>(<span class="hljs-params">roomName, message</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">await</span> connection.<span class="hljs-title function_">invoke</span>(<span class="hljs-string">&quot;SendMessageToRoom&quot;</span>, roomName, message);</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 初始化连接</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">start</span>().<span class="hljs-title function_">catch</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">error</span>);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 示例：假设你想在页面加载时自动加入“general”聊天室</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">window</span>.<span class="hljs-property">onload</span> = <span class="hljs-title function_">async</span> () =&gt; &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">await</span> <span class="hljs-title function_">joinRoom</span>(<span class="hljs-string">&quot;general&quot;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>NET框架相关</category>
      
      <category>net</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SSO</title>
    <link href="/2024/12/06/SSO/"/>
    <url>/2024/12/06/SSO/</url>
    
    <content type="html"><![CDATA[<h1 id="SSO"><a href="#SSO" class="headerlink" title="SSO"></a>SSO</h1><p>SSO 仅仅是一个概念，</p><p><del>Same Sign On</del></p><p>Single Sign On</p><p>实现这个概念的方式有很多很多种，对于Same sign on而言，所有登录接口公用一个数据库就能实现Same Sign On的</p><p>Single Sign On的实现方式可以为，将所有登录逻辑的JWT放到一起做，签发的Token大家一起用，但这样做风险太大了</p><hr><p>所以说SSO仅仅是一个概念，有着很多很多的实现方式，我们公司的实现方式是通过OIDC协议的方式实现的</p><p>OIDC是OAUTH协议的进阶版，这个协议最初不是专门用来完成认证功能的，而是用来完成授权服务的</p><hr><h3 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h3><p>为用户开放一个登录接口，用户请求后API校验账号密码，是否成功登录，如果成功登录返回一个Token，Client每次请求都拿着这个Token请求</p><p>但这时仍然没完成登录，只是拿到了一个令牌（token）而已</p><p><strong>对于Client来说，拿着token请求API获取到UserInfo，这个才是真正意义上的登陆成功</strong></p><p>这里很重要，一定要明确什么才算是真正意义上的登录</p><hr><h3 id="OAUTH"><a href="#OAUTH" class="headerlink" title="OAUTH"></a>OAUTH</h3><p>在一个OAUTH服务的登录流程中分为三个模块，SSO服务器、Client、API</p><p>当用户使用浏览器请求访问Client时，Client会给用户一些信息（scope、clientId、secret等），浏览器拿着这些信息去找SSO服务器登录</p><p>SSO会校验这些信息的合法性，如果信息合法则开发登录</p><p>如果登录成功，SSO会返回给用户两个东西：access-token和cookie，同时自己存一份session（用以校验cookie）</p><p>cookie用来保存登录状态，access-token用以访问API</p><p><strong>client拿到access-token之后，请求SSO服务器获取UserInfo接口，获取用户信息，这样就实现登录功能</strong></p><p>这时Client就可以拿着access-token去访问API被保护的资源了，如果access-token为长token，API可自行校验，如果access-token为短token，则需要请求SSO的introspection接口进行校验</p><hr><h5 id="单点登录"><a href="#单点登录" class="headerlink" title="单点登录"></a>单点登录</h5><p>这时，如果浏览器继续访问Client2，仍然会被Client2带到SSO服务前，但SSO会用自己的Session验证浏览器的Cookie是否为登陆状态，如果仍然为登陆状态，<del>则询问用户是否授权</del>，公司这里的逻辑直接跳过用户授权，直接判定登陆成功，然后签发access-token，这样就真正意义上的实现了单点登录</p><hr><h3 id="OIDC"><a href="#OIDC" class="headerlink" title="OIDC"></a>OIDC</h3><p><del>Client拿到access-token之后，请求SSO服务器获取UserInfo接口，获取用户信息，这样就实现登录功能</del>，因为实现登录功能并不是OAUTH的本意，但授权本身的前提就是完成认证，所以这个UserInfo不是OAUTH协议提供的，大家实现起来没有规范，所以就出现了OIDC，OIDC是OAUTH协议的进阶版本</p><p>OIDC提供了一个额外的Token，这个Token一定为JWT类型的Token（长Token），一起返回给Client，这个Token的名字为Id-Token</p><p><strong>当client拿到Id-Token之后直接解析，就能获取到UserInfo，而无需再请求不规范的UserInfo接口来获取用户信息，完成用户登录</strong></p><hr><h3 id="scope"><a href="#scope" class="headerlink" title="scope"></a>scope</h3><p>scope定义了签发access-token的使用范围</p><p>最开始由client将浏览器带到SSO时，就会有一些信息，其中就包括scope，而这个scope本身也会由SSO服务器定义，如果两个scope相符，才会判断为合法</p><p>scope定义了OAUTH协议的授权范围，当你使用Client访问API１的时候，再去访问API2，API２会因为token需求不同而拒绝访问，scope就可以勾选上API2，从最开始请求access-token时就定义要访问的范围，这样就完成了服务间调用token权限不足的问题</p><hr><h3 id="换token"><a href="#换token" class="headerlink" title="换token"></a>换token</h3><p>门诊医生站（outp）没有访问住院医生站（emr）的权限，但门诊医生站存在访问医院信息管理系统（his）的权限，且医院信息管理系统有访问住院医生站的权限</p><p>这时，我们使用outp调用his，在his更换access-token，且更换了scope，但保留发起者是outp这一条重要信息，这样，通过间接的方式，outp就请求到了emr</p><p><em>这种方式仅限于内部环境使用，我们默认彼此之间是比较信任的，如果放在外网使用会有权限爆炸的风险</em></p><hr><h3 id="Authorization授权"><a href="#Authorization授权" class="headerlink" title="Authorization授权"></a>Authorization授权</h3><p>我们上面所说的授权，指的是使用OAUTH协议给Client授权访问SSO调取个人信息的这一过程</p><p>这样我们在其他项目中就无需维护登录模块</p><p>在这里我们引入另一种授权的概念，即角色授权：维护一套Roles角色表，将用户与角色关联起来，就可以限制某个用户能访问到的资源</p><p>这种角色授权目前一共有三种实现方式：</p><ul><li>Synyi的SSO内置了RBAC，可以在SSO维护这一套角色表，嵌入后端</li><li>在SSO之外单独建立一套ACL系统来精细化控制授权，更精准的把控用户能访问的资源和行为</li><li>在项目中，单独维护一套用户和角色，在项目中规范用户能够访问的内容、</li></ul><p>这里需要注意，一定要区分这里的授权，和前面讲到OAUTH的授权是完全不同的概念</p><hr>]]></content>
    
    
    <categories>
      
      <category>NET框架相关</category>
      
      <category>synyi</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>实战项目-笔记</title>
    <link href="/2024/12/06/%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE-%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/12/06/%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE-%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="实战项目-苍穹外卖"><a href="#实战项目-苍穹外卖" class="headerlink" title="实战项目-苍穹外卖"></a>实战项目-苍穹外卖</h3><p>这是一个基于ASP.NET Core WebAPI框架（.NET6.0）重置的苍穹外卖</p><p>我会在这里记录学习过程中的任何问题和笔记</p><h3 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h3><table><thead><tr><th>目录名</th><th>作用</th></tr></thead><tbody><tr><td>Storage</td><td>用于存放实体类和DbContext，也可以叫做EFCore</td></tr><tr><td>Dal</td><td>根据业务进一步调用DbContext，封装成具体业务方法，像是仓储模式</td></tr><tr><td>Model</td><td>存放Vo，Dto，常量和枚举类型，自定义特性</td></tr><tr><td>Bll</td><td>业务层代码</td></tr><tr><td>Commen</td><td>存放工具类</td></tr></tbody></table><hr><h1 id="EFCore"><a href="#EFCore" class="headerlink" title="EFCore"></a>EFCore</h1><p>在EFCore的DbContext做实体类和表的映射时，我们通常用实体类加s来作为属性名</p><p>这是一种约定，通常用来表示这是一组实体，一个集合</p><p>在Code First开发模式中，迁移插件会自动将这个加上s的属性作为表名来迁移（可以手动配置）</p><h3 id="isAsNoTracking"><a href="#isAsNoTracking" class="headerlink" title="isAsNoTracking"></a>isAsNoTracking</h3><p>在对Dao层方法创建时，我们可以提供一个形参isAsNoTracking &#x3D; true来决定是否进行实体跟踪</p><p>如果该Dao层方法<strong>仅用来查询</strong>，我们可以禁用实体跟踪，可以减少内存使用并提高查询性能</p><p><em>注：虽然EFCore不进行实体跟踪，但其数据库查询到的主键仍然会回显</em></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 常规查询，不禁用系统跟踪</span><br><span class="hljs-keyword">public</span> xiaobai_cangqiong_Storage.Entity.Employee? GetByUsername(<span class="hljs-built_in">string</span> username)<br>&#123;<br>    <span class="hljs-keyword">return</span> _dbContext.Employees.FirstOrDefault(e =&gt; e.Username == username);<br>&#125;<br><br><span class="hljs-comment">// 利用isAsNoTracking形参和AsNoTracking方法禁用系统跟踪</span><br><span class="hljs-keyword">public</span> xiaobai_cangqiong_Storage.Entity.Employee? GetByUsername(<span class="hljs-built_in">string</span> username, <span class="hljs-built_in">bool</span> isAsNoTracking = <span class="hljs-literal">true</span>)<br>&#123;<br>    <span class="hljs-keyword">var</span> data = _dbContext.Employees.Where(e =&gt; e.Username == username);<br>    <span class="hljs-keyword">if</span> (isAsNoTracking)<br>    &#123;<br>        <span class="hljs-keyword">return</span> data.AsNoTracking().FirstOrDefault();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> data.AsNoTracking().FirstOrDefault();<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="SaveChange"><a href="#SaveChange" class="headerlink" title="SaveChange"></a>SaveChange</h3><p>在Java中，我们通过添加过滤器的方式来实现对公共字段的填充</p><p>在DBContext中，我们可以通过重写SaveChanges方法的方式，在每次调用前进行一些操作</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">int</span> <span class="hljs-title">SaveChanges</span>()</span><br>&#123;<br>    OnBeforeSaving();<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">base</span>.SaveChanges();<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> Task&lt;<span class="hljs-built_in">int</span>&gt; <span class="hljs-title">SaveChangesAsync</span>(<span class="hljs-params"><span class="hljs-built_in">bool</span> acceptAllChangesOnSuccess,</span></span><br><span class="hljs-params"><span class="hljs-function">    CancellationToken cancellationToken = <span class="hljs-literal">default</span></span>)</span><br>&#123;<br>    OnBeforeSaving();<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">base</span>.SaveChangesAsync(acceptAllChangesOnSuccess, cancellationToken);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnBeforeSaving</span>()</span><br>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="IAuditable接口"><a href="#IAuditable接口" class="headerlink" title="IAuditable接口"></a>IAuditable接口</h5><ul><li><p>类型安全：通过实现 <code>IAuditable</code> 接口，你可以确保所有需要自动填充的实体类都具有相同的属性结构。这有助于避免在运行时出现类型不匹配的问题。</p></li><li><p>代码复用：接口提供了一种标准化的方式来定义一组公共属性，使得你在处理这些实体时可以使用统一的逻辑。</p></li><li><p>易于扩展：如果你将来需要添加更多的审计字段或修改现有的字段，只需要修改接口即可，而不需要逐一修改每个实体类。</p></li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IAuditable</span><br>&#123;<br>    DateTime CreateTime &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    DateTime UpdateTime &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-built_in">long</span> CreateUser &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-built_in">long</span> UpdateUser &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>让具有公共字段的实体类实现这个接口</p><hr><h5 id="OnBeforeSaving"><a href="#OnBeforeSaving" class="headerlink" title="OnBeforeSaving"></a>OnBeforeSaving</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnBeforeSaving</span>()</span><br>&#123;<br>    <span class="hljs-comment">// 遍历所有实现了IAuditable接口的实体条目</span><br>    <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> entry <span class="hljs-keyword">in</span> ChangeTracker.Entries&lt;IAuditable&gt;())<br>    &#123;<br>        <span class="hljs-comment">// 检查实体的状态</span><br>        <span class="hljs-keyword">if</span> (entry.State == EntityState.Added)<br>        &#123;<br>            <span class="hljs-comment">// 如果实体是新添加的</span><br>            entry.Entity.CreateTime = DateTime.Now;<br>            entry.Entity.UpdateTime = DateTime.Now;<br>            entry.Entity.CreateUser =<br>                <span class="hljs-built_in">long</span>.Parse(_httpContextAccessor.HttpContext?.Items[<span class="hljs-string">&quot;UserId&quot;</span>]?.ToString() ?? <span class="hljs-built_in">string</span>.Empty);<br>            entry.Entity.UpdateUser =<br>                <span class="hljs-built_in">long</span>.Parse(_httpContextAccessor.HttpContext?.Items[<span class="hljs-string">&quot;UserId&quot;</span>]?.ToString() ?? <span class="hljs-built_in">string</span>.Empty);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (entry.State == EntityState.Modified)<br>        &#123;<br>            <span class="hljs-comment">// 如果实体已被修改</span><br>            entry.Entity.UpdateTime = DateTime.Now;<br>            entry.Entity.UpdateUser =<br>                <span class="hljs-built_in">long</span>.Parse(_httpContextAccessor.HttpContext?.Items[<span class="hljs-string">&quot;UserId&quot;</span>]?.ToString() ?? <span class="hljs-built_in">string</span>.Empty);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="AutoMapper"><a href="#AutoMapper" class="headerlink" title="AutoMapper"></a>AutoMapper</h1><p>在调用AutoMapper时，有两种方式</p><p>将employee实体类映射到EmployeeLoginResp实体类</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 在调用方法时，实例化被映射对象</span><br><span class="hljs-keyword">var</span> employeeLoginResp = _mapper.Map&lt;EmployeeLoginResp&gt;(employee);<br><br><span class="hljs-comment">// 已经存在被映射对象，可直接映射</span><br><span class="hljs-keyword">var</span> employeeLoginResp = <span class="hljs-keyword">new</span> EmployeeLoginResp();<br>_mapper.Map(employee, employeeLoginResp);<br></code></pre></td></tr></table></figure><h3 id="奇淫巧计"><a href="#奇淫巧计" class="headerlink" title="奇淫巧计"></a><del>奇淫巧计</del></h3><p><strong>这里非常感谢雨哥和翔哥给出纠正，再正式项目中，表中一定会存在特别为其置空的字段，那么对与这种方法是完全错误的思路，还是要针对于某一个业务制定特定的接口才行</strong></p><p>我们将update更新方法通过if判断的方式写成动态的update，可以满足所有业务的更新需求</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params">xiaobai_cangqiong_Storage.Entity.Category category</span>)</span><br>&#123;<br>    <span class="hljs-keyword">var</span> single = _dbContext.Categories.Single(c =&gt; c.Id == category.Id);<br>    <br>    <span class="hljs-keyword">if</span> (category.Type != <span class="hljs-literal">null</span>)<br>    &#123;<br>        single.Type = category.Type;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (category.Name != <span class="hljs-literal">null</span>)<br>    &#123;<br>        single.Name = category.Name;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (category.Sort != <span class="hljs-literal">null</span>)<br>    &#123;<br>        single.Sort = category.Sort;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (category.Status != <span class="hljs-literal">null</span>)<br>    &#123;<br>        single.Status = category.Status;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (category.UpdateTime != <span class="hljs-literal">null</span>)<br>    &#123;<br>        single.UpdateTime = category.UpdateTime;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (category.UpdateUser != <span class="hljs-literal">null</span>)<br>    &#123;<br>        single.UpdateUser = category.UpdateUser;<br>    &#125;<br><br>    _dbContext.SaveChanges();<br>&#125;<br></code></pre></td></tr></table></figure><p>但这样写，当实体类属性（表中的列）过多时，我们需要动态判断的属性太多了，太过于麻烦</p><p><del>我们可以通过AutoMapper映射自己，做非空字段的映射</del></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#">CreateMap&lt;Category, Category&gt;()<br>    .ForAllMembers(opt =&gt;<br>        opt.Condition((src, dest, srcMember) =&gt;<br>            srcMember != <span class="hljs-literal">null</span>));<br></code></pre></td></tr></table></figure><ul><li><code>ForAllMembers</code> 方法用于为所有成员（属性）应用相同的条件。</li><li><code>opt.Condition</code> 方法定义一个条件，只有当条件满足时才进行属性映射。</li><li><code>src</code>：源对象（即要映射的对象）。</li><li><code>dest</code>：目标对象（即被映射的对象）。</li><li><code>srcMember</code>：源对象的成员（属性）。</li><li><code>srcMember != null</code>：只有当源对象的属性值不为 <code>null</code> 时，才进行映射。</li></ul><p><em>需要注意的是，自我映射的非空判断仅仅会判断引用类型的数据是否为空，但在我们数据表中，很多字段为基本数据类型，默认为0</em></p><blockquote><p>对于想要进行自我映射实现动态更新，必须保证实体类中基本类型属性，例如：int，long……这一类型数据必须为int?，long?</p><p>因为如果为基本数据类型，自我映射时进行非空判断会出现问题，基本数据类型的默认为0，但如果是int?数据类型，默认为null</p></blockquote><hr><h1 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h1><p>我们选择使用JWT来签发Token进行项目的身份验证</p><blockquote><p>依赖导入</p><p>Microsoft.AspNetCore.Authentication.JwtBearer</p></blockquote><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;Jwt&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;Key&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&lt;your_secret_key&gt;&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;Issuer&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&lt;your_issuer&gt;&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;Audience&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&lt;your_audience&gt;&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="注册服务"><a href="#注册服务" class="headerlink" title="注册服务"></a>注册服务</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-meta">#<span class="hljs-keyword">region</span> 注册JWT服务</span><br><span class="hljs-comment">// 注册JWT工具类</span><br>builder.Services.AddScoped&lt;JwtUtil&gt;();<br><span class="hljs-comment">// 配置身份验证服务</span><br>builder.Services.AddAuthentication(x =&gt;<br>    &#123;<br>        <span class="hljs-comment">// 设置默认的身份验证方案为JWT承载认证</span><br>        x.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;<br><br>        <span class="hljs-comment">// 设置默认的挑战方案为JWT承载认证</span><br>        <span class="hljs-comment">// 挑战方案用于处理未认证的请求，例如返回401状态码</span><br>        x.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;<br>    &#125;)<br>    .AddJwtBearer(x =&gt;<br>    &#123;<br>        <span class="hljs-comment">// 是否要求HTTPS元数据，默认为true。设置为false允许在非HTTPS连接下接收和验证JWT令牌</span><br>        x.RequireHttpsMetadata = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-comment">// 是否在认证过程中保存令牌，这对于调试和日志记录很有用</span><br>        x.SaveToken = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-comment">// 配置令牌验证参数</span><br>        x.TokenValidationParameters = <span class="hljs-keyword">new</span> TokenValidationParameters<br>        &#123;<br>            <span class="hljs-comment">// 是否验证签名密钥，确保令牌是由正确的密钥签名的</span><br>            ValidateIssuerSigningKey = <span class="hljs-literal">true</span>,<br><br>            <span class="hljs-comment">// 提供用于验证令牌的密钥</span><br>            <span class="hljs-comment">// 因为SymmetricSecurityKey方法需求的是一个字节数组，所以在此调用Encoding.ASCII.GetBytes将字符串转化</span><br>            IssuerSigningKey = <span class="hljs-keyword">new</span> SymmetricSecurityKey(Encoding.ASCII.GetBytes(builder.Configuration[<span class="hljs-string">&quot;Jwt:Key&quot;</span>] ?? <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InvalidOperationException())),<br><br>            <span class="hljs-comment">// 是否验证发行者</span><br>            ValidateIssuer = <span class="hljs-literal">true</span>,<br><br>            <span class="hljs-comment">// 发行者值</span><br>            ValidIssuer = builder.Configuration[<span class="hljs-string">&quot;Jwt:Issuer&quot;</span>],<br><br>            <span class="hljs-comment">// 是否验证受众</span><br>            ValidateAudience = <span class="hljs-literal">true</span>,<br><br>            <span class="hljs-comment">// 受众值</span><br>            ValidAudience = builder.Configuration[<span class="hljs-string">&quot;Jwt:Audience&quot;</span>]<br>        &#125;;<br>    <span class="hljs-comment">// 使用自定义JWT Bearer事件</span><br>    x.EventsType = <span class="hljs-keyword">typeof</span>(CustomJwtBearerEvents);<br>    &#125;);<br><span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br></code></pre></td></tr></table></figure><h3 id="注册中间件"><a href="#注册中间件" class="headerlink" title="注册中间件"></a>注册中间件</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 在授权之前添加身份验证中间件</span><br>app.UseAuthentication();<br>app.UseAuthorization();<br></code></pre></td></tr></table></figure><h3 id="JWTUtil工具类"><a href="#JWTUtil工具类" class="headerlink" title="JWTUtil工具类"></a>JWTUtil工具类</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">JwtUtil</span><br>&#123;<br>    <span class="hljs-comment">// 私有字段，用于存储JWT密钥、发行者和受众</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">string</span> _jwtKey;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">string</span> _jwtIssuer;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">string</span> _jwtAudience;<br><br>    <span class="hljs-comment">// 构造函数，通过依赖注入接收 IConfiguration 对象</span><br>    <span class="hljs-comment">// IConfiguration 对象用于从配置文件中读取JWT相关的设置</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">JwtUtil</span>(<span class="hljs-params">IConfiguration configuration</span>)</span><br>    &#123;<br>        _jwtKey = configuration[<span class="hljs-string">&quot;Jwt:Key&quot;</span>] ?? <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InvalidOperationException(); <span class="hljs-comment">// 读取JWT密钥</span><br>        _jwtIssuer = configuration[<span class="hljs-string">&quot;Jwt:Issuer&quot;</span>] ?? <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InvalidOperationException(); <span class="hljs-comment">// 读取发行者</span><br>        _jwtAudience = configuration[<span class="hljs-string">&quot;Jwt:Audience&quot;</span>] ?? <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InvalidOperationException(); <span class="hljs-comment">// 读取受众</span><br>    &#125;<br><br>    <span class="hljs-comment">// 生成JWT令牌的方法</span><br>    <span class="hljs-comment">// 参数：</span><br>    <span class="hljs-comment">// - userId: 用户ID，用于生成令牌的唯一标识</span><br>    <span class="hljs-comment">// - expirationTime: 令牌的有效期</span><br>    <span class="hljs-comment">// 返回值：</span><br>    <span class="hljs-comment">// - 生成的JWT令牌字符串</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> <span class="hljs-title">GenerateToken</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> userId, TimeSpan expirationTime</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// 创建一个新的JwtSecurityTokenHandler实例</span><br>        <span class="hljs-keyword">var</span> tokenHandler = <span class="hljs-keyword">new</span> JwtSecurityTokenHandler();<br><br>        <span class="hljs-comment">// 将JWT密钥字符串转换为字节数组</span><br>        <span class="hljs-keyword">var</span> key = Encoding.ASCII.GetBytes(_jwtKey);<br><br>        <span class="hljs-comment">// 创建一个SecurityTokenDescriptor对象，用于描述令牌的属性</span><br>        <span class="hljs-keyword">var</span> tokenDescriptor = <span class="hljs-keyword">new</span> SecurityTokenDescriptor<br>        &#123;<br>            <span class="hljs-comment">// 设置令牌的主题，包含一个Claim，表示用户的唯一标识</span><br>            Subject = <span class="hljs-keyword">new</span> ClaimsIdentity(<span class="hljs-keyword">new</span> Claim[]<br>            &#123;<br>                <span class="hljs-keyword">new</span> Claim(ClaimTypes.Name, userId)<br>            &#125;),<br><br>            <span class="hljs-comment">// 设置令牌的过期时间</span><br>            Expires = DateTime.UtcNow.Add(expirationTime),<br><br>            <span class="hljs-comment">// 设置令牌的发行者</span><br>            Issuer = _jwtIssuer,<br><br>            <span class="hljs-comment">// 设置令牌的受众</span><br>            Audience = _jwtAudience,<br><br>            <span class="hljs-comment">// 设置签名凭据，使用对称密钥和HMAC SHA256算法进行签名</span><br>            SigningCredentials = <span class="hljs-keyword">new</span> SigningCredentials(<span class="hljs-keyword">new</span> SymmetricSecurityKey(key), SecurityAlgorithms.HmacSha256Signature)<br>        &#125;;<br><br>        <span class="hljs-comment">// 使用JwtSecurityTokenHandler创建一个JwtSecurityToken对象</span><br>        <span class="hljs-keyword">var</span> token = tokenHandler.CreateToken(tokenDescriptor);<br><br>        <span class="hljs-comment">// 将JwtSecurityToken对象序列化为字符串</span><br>        <span class="hljs-keyword">return</span> tokenHandler.WriteToken(token);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>JWT签发的token为键值对Token，而JWT通过特性来验证Token时默认采用以下格式：</p><blockquote><p>Authorization: Bearer &lt;token&gt;</p></blockquote><p>但苍穹外面的前端项目的token负载采用的是以下格式：</p><blockquote><p>Token: &lt;token&gt;</p></blockquote><h5 id="CustomJwtBearerEvents"><a href="#CustomJwtBearerEvents" class="headerlink" title="CustomJwtBearerEvents"></a>CustomJwtBearerEvents</h5><p>自定义JWT处理业务方式与逻辑</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CustomJwtBearerEvents</span> : <span class="hljs-title">JwtBearerEvents</span><br>&#123;<br>    <span class="hljs-comment">// 当接收到消息时触发，用于处理自定义的令牌头</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> Task <span class="hljs-title">MessageReceived</span>(<span class="hljs-params">MessageReceivedContext context</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// 从请求头中获取 &quot;Token&quot; 字段的值</span><br>        <span class="hljs-keyword">var</span> token = context.Request.Headers[<span class="hljs-string">&quot;Token&quot;</span>].FirstOrDefault();<br>        <br>        <span class="hljs-comment">// 如果 &quot;Token&quot; 字段存在且不为空，则将其赋值给 context.Token</span><br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">string</span>.IsNullOrEmpty(token))<br>        &#123;<br>            context.Token = token;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 返回基类的实现</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">base</span>.MessageReceived(context);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="MD5工具类"><a href="#MD5工具类" class="headerlink" title="MD5工具类"></a>MD5工具类</h1><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MD5Util</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">string</span> <span class="hljs-title">GetMd5Hash</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> input</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// 使用MD5CryptoServiceProvider创建一个MD5哈希对象</span><br>        <span class="hljs-keyword">using</span> (MD5 md5 = MD5.Create())<br>        &#123;<br>            <span class="hljs-comment">// 将输入字符串转换为字节数组，并计算哈希</span><br>            <span class="hljs-built_in">byte</span>[] inputBytes = Encoding.UTF8.GetBytes(input);<br>            <span class="hljs-built_in">byte</span>[] hashBytes = md5.ComputeHash(inputBytes);<br><br>            <span class="hljs-comment">// 将字节数组转换成十六进制字符串</span><br>            StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; hashBytes.Length; i++)<br>            &#123;<br>                sb.Append(hashBytes[i].ToString(<span class="hljs-string">&quot;x2&quot;</span>));<br>            &#125;<br>            <span class="hljs-keyword">return</span> sb.ToString();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="Swagger"><a href="#Swagger" class="headerlink" title="Swagger"></a>Swagger</h1><h3 id="AddSwaggerGen"><a href="#AddSwaggerGen" class="headerlink" title="AddSwaggerGen"></a>AddSwaggerGen</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 添加Swagger生成器</span><br>builder.Services.AddSwaggerGen(options =&gt;<br>    &#123;<br>        <span class="hljs-comment">//创建一个Swagger文档，命名为&quot;v1&quot;，并提供API的基本信息</span><br>        options.SwaggerDoc(<span class="hljs-string">&quot;v1&quot;</span>,<span class="hljs-keyword">new</span> OpenApiInfo()<br>        &#123;<br>            Version = <span class="hljs-string">&quot;v1&quot;</span>,<br>            Title = <span class="hljs-string">&quot;xiaobai-cangqiong API&quot;</span>,<br>        &#125;);<br>    &#125;<br>);<br></code></pre></td></tr></table></figure><p><em>这里如果不创建Swagger文档，系统也会默认帮我们创建一个文档</em></p><hr><h3 id="AddSecurityDefinition与AddSecurityRequirement"><a href="#AddSecurityDefinition与AddSecurityRequirement" class="headerlink" title="AddSecurityDefinition与AddSecurityRequirement"></a>AddSecurityDefinition与AddSecurityRequirement</h3><p>在Swagger中添加一个可以携带token请求头的按钮，</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-meta">#<span class="hljs-keyword">region</span> MyRegion Swagger</span><br>builder.Services.AddSwaggerGen(<br>    options =&gt;<br>    &#123;<br>        <span class="hljs-comment">// 添加一个安全定义,定义名称为&quot;Token&quot;</span><br>        options.AddSecurityDefinition(<span class="hljs-string">&quot;Token&quot;</span>, <span class="hljs-keyword">new</span> OpenApiSecurityScheme<br>        &#123;<br>            <span class="hljs-comment">// 描述如何使用Token进行身份验证</span><br>            Description = <span class="hljs-string">&quot;Token: &lt;token&gt;&quot;</span>,<br>            <span class="hljs-comment">// 指定认证头的名称，这里是&quot;Token&quot;</span><br>            Name = <span class="hljs-string">&quot;Token&quot;</span>,<br>            <span class="hljs-comment">// 指定认证信息应该放置的位置，这里是HTTP头部</span><br>            In = ParameterLocation.Header,<br>            <span class="hljs-comment">// 指定安全方案的类型，这里是指API密钥类型</span><br>            Type = SecuritySchemeType.ApiKey,<br>        &#125;);<br>        <span class="hljs-comment">// 添加安全要求，这将告诉Swagger UI哪些安全方案是必需的</span><br>        options.AddSecurityRequirement(<span class="hljs-keyword">new</span> OpenApiSecurityRequirement<br>        &#123;<br>            &#123;<br>                <span class="hljs-keyword">new</span> OpenApiSecurityScheme<br>                &#123;<br>                    <span class="hljs-comment">// 引用之前定义的安全方案</span><br>                    Reference = <span class="hljs-keyword">new</span> OpenApiReference<br>                    &#123;<br>                        Type = ReferenceType.SecurityScheme,<br>                        Id = <span class="hljs-string">&quot;Token&quot;</span> <span class="hljs-comment">// 对应于上面定义的安全方案的Id</span><br>                    &#125;,<br>                &#125;,<br>                <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">string</span>&gt;() <span class="hljs-comment">// 空列表表示不需要特定的作用域</span><br>            &#125;<br>        &#125;);<br>    &#125;);<br><br><span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br></code></pre></td></tr></table></figure><hr><h1 id="HttpContext-Items"><a href="#HttpContext-Items" class="headerlink" title="HttpContext.Items"></a>HttpContext.Items</h1><p><strong>ASP.NETCore提供了非常好用的方式来获取到用户信息，而不是通过丑陋的过滤器手动将用户信息保存来实现</strong></p><p>在Java中，我们通过ThreadLocal来存储过滤器从Token中解析出来的UserId</p><p>在ASP.NETCore中，HttpContext.Items可以解决中间件、过滤器、控制器和其他组件在处理同一个请求时共享数据，而无需通过参数传递</p><hr><h3 id="TokenValidationFilter"><a href="#TokenValidationFilter" class="headerlink" title="TokenValidationFilter"></a>TokenValidationFilter</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TokenValidationFilter</span> : <span class="hljs-title">IAsyncActionFilter</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> JwtUtil _jwtUtil;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TokenValidationFilter</span>(<span class="hljs-params">JwtUtil jwtUtil</span>)</span><br>    &#123;<br>        _jwtUtil = jwtUtil;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">OnActionExecutionAsync</span>(<span class="hljs-params">ActionExecutingContext context, ActionExecutionDelegate next</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// 从请求头中获取Token</span><br>        <span class="hljs-keyword">var</span> token = context.HttpContext.Request.Headers[<span class="hljs-string">&quot;Token&quot;</span>].ToString();<br><br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">string</span>.IsNullOrEmpty(token))<br>        &#123;<br>            <span class="hljs-keyword">try</span><br>            &#123;<br>                <span class="hljs-comment">// 使用 JWTUtils 解析 Token 获取 UserId</span><br>                <span class="hljs-keyword">var</span> userId = _jwtUtil.ParseToken(token);<br><br>                <span class="hljs-comment">// 将 UserId 添加到 HttpContext.Items，以便后续处理逻辑使用</span><br>                context.HttpContext.Items[<span class="hljs-string">&quot;UserId&quot;</span>] = userId;<br>            &#125;<br>            <span class="hljs-keyword">catch</span> (System.Exception ex)<br>            &#123;<br>                <span class="hljs-comment">// 如果解析失败，返回未授权的状态码</span><br>                context.Result = <span class="hljs-keyword">new</span> UnauthorizedResult();<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">// 如果没有提供Token，也可以选择返回未授权</span><br>            context.Result = <span class="hljs-keyword">new</span> UnauthorizedResult();<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 继续执行下一个过滤器或控制器操作</span><br>        <span class="hljs-keyword">await</span> next();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="注册filter"><a href="#注册filter" class="headerlink" title="注册filter"></a>注册filter</h3><p>在需要使用UserId的请求的控制器中加入[TypeFilter(typeof(TokenValidationFilter))]特性</p><p>一般为增加和修改的业务上</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 新增员工</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;employeeSaveReq&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;token&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span><span class="hljs-doctag">&lt;/returns&gt;</span></span><br>[<span class="hljs-meta">HttpPost</span>]<br>[<span class="hljs-meta">TypeFilter(typeof(TokenValidationFilter))</span>]<br><span class="hljs-function"><span class="hljs-keyword">public</span> Result&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">Save</span>(<span class="hljs-params">[FromBody] EmployeeSaveReq employeeSaveReq</span>)</span><br>&#123;<br>    _logger.LogInformation(<span class="hljs-string">&quot;新增员工:&#123;&#125;&quot;</span>, employeeSaveReq);<br>    _employeeService.Save(employeeSaveReq);<br>    <span class="hljs-keyword">return</span> Result&lt;<span class="hljs-built_in">string</span>&gt;.Success();<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="IHttpContextAccessor"><a href="#IHttpContextAccessor" class="headerlink" title="IHttpContextAccessor"></a>IHttpContextAccessor</h3><p>在使用HttpContext.Items时，我们要注册服务之后才能在控制器&#x2F;服务层中调用，获取到存储在Items中的值</p><blockquote><p>注册服务</p><p>builder.Services.AddHttpContextAccessor();</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 注入依赖</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> IHttpContextAccessor _httpContextAccessor;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UserService</span>(<span class="hljs-params">IHttpContextAccessor httpContextAccessor</span>)</span><br>&#123;<br>    _httpContextAccessor = httpContextAccessor;<br>&#125;<br><br>employee.CreateUser = <span class="hljs-built_in">long</span>.Parse(_httpContextAccessor.HttpContext?.Items[<span class="hljs-string">&quot;UserId&quot;</span>]?.ToString() ?? <span class="hljs-built_in">string</span>.Empty);<br>employee.UpdateUser = <span class="hljs-built_in">long</span>.Parse(_httpContextAccessor.HttpContext?.Items[<span class="hljs-string">&quot;UserId&quot;</span>]?.ToString() ?? <span class="hljs-built_in">string</span>.Empty);<br></code></pre></td></tr></table></figure><p>配合OnBeforeSaving实现每次存储前自动填充字段</p><hr><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><p>默认情况下，类库项目只会引用.NET框架而不会引用ASP.NETCore框架，所以会存在在别的层无法注入依赖的情况</p><p>比如_httpContextAccessor.HttpContext对象无法注入在Bll的Service中</p><p>我们可以通过项目文件来为项目添加ASP.NETCore框架</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">ItemGroup</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">FrameworkReference</span> <span class="hljs-attr">Include</span>=<span class="hljs-string">&quot;Microsoft.AspNetCore.App&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ItemGroup</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h1 id="OSS"><a href="#OSS" class="headerlink" title="OSS"></a>OSS</h1><blockquote><p>依赖安装</p><p>Aliyun.OSS.SDK.NetCore</p></blockquote><p><em>注：依赖导入Aliyun.OSS.SDK可能会出现意料之外的问题</em></p><h3 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;OSS&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;Endpoint&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;oss-cn-qingdao.aliyuncs.com&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;AccessKeyId&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;your_access_key_id&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;AccessKeySecret&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;your_access_key_secret&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;BucketName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;your_bucket_name&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AliOssUtil</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">string</span> _endpoint;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">string</span> _accessKeyId;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">string</span> _accessKeySecret;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">string</span> _bucketName;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AliOssUtil</span>(<span class="hljs-params">IConfiguration configuration</span>)</span><br>    &#123;<br>        _endpoint = configuration[<span class="hljs-string">&quot;OSS:Endpoint&quot;</span>] ?? <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InvalidOperationException();<br>        _accessKeyId = configuration[<span class="hljs-string">&quot;OSS:AccessKeyId&quot;</span>] ?? <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InvalidOperationException();<br>        _accessKeySecret = configuration[<span class="hljs-string">&quot;OSS:AccessKeySecret&quot;</span>] ?? <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InvalidOperationException();<br>        _bucketName = configuration[<span class="hljs-string">&quot;OSS:BucketName&quot;</span>] ?? <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InvalidOperationException();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> <span class="hljs-title">Upload</span>(<span class="hljs-params">Stream fileStream, <span class="hljs-built_in">string</span> fileName</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> ossClient = <span class="hljs-keyword">new</span> OssClient(_endpoint, _accessKeyId, _accessKeySecret);<br>        <br>        <span class="hljs-comment">// 上传文件到指定的Bucket</span><br>        ossClient.PutObject(_bucketName, fileName, fileStream);<br>        <br>        <span class="hljs-comment">//返回拼接好的url</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">$&quot;https://<span class="hljs-subst">&#123;_bucketName&#125;</span>.<span class="hljs-subst">&#123;_endpoint&#125;</span>/<span class="hljs-subst">&#123;fileName&#125;</span>&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="注册服务-1"><a href="#注册服务-1" class="headerlink" title="注册服务"></a>注册服务</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">services.AddSingleton&lt;AliOssUtil&gt;();<br></code></pre></td></tr></table></figure><p><em>阿里云oss注册为单例服务即可</em></p><h3 id="使用服务"><a href="#使用服务" class="headerlink" title="使用服务"></a>使用服务</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#">[<span class="hljs-meta">HttpPost(<span class="hljs-string">&quot;upload&quot;</span>)</span>]<br><span class="hljs-function"><span class="hljs-keyword">public</span> Result&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">Upload</span>(<span class="hljs-params">[FromForm]IFormFile <span class="hljs-keyword">file</span></span>)</span><br>&#123;<br>    _logger.LogInformation(<span class="hljs-string">&quot;文件上传：&#123;&#125;&quot;</span>, <span class="hljs-keyword">file</span>);<br>    <span class="hljs-keyword">using</span> <span class="hljs-keyword">var</span> stream = <span class="hljs-keyword">file</span>.OpenReadStream();<br>    <span class="hljs-keyword">return</span> Result&lt;<span class="hljs-built_in">string</span>&gt;.Success(_aliOssUtil.Upload(stream, <span class="hljs-keyword">file</span>.FileName));<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="Settings"><a href="#Settings" class="headerlink" title="Settings"></a>Settings</h1><p>我们在Jwt和Oss一类的工具类中，直接使用了IConfiguration注入的方式来注入配置参数</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">string</span> _endpoint;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">string</span> _accessKeyId;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">string</span> _accessKeySecret;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">string</span> _bucketName;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AliOssUtil</span>(<span class="hljs-params">IConfiguration configuration</span>)</span><br>&#123;<br>    _endpoint = configuration[<span class="hljs-string">&quot;OSS:Endpoint&quot;</span>] ?? <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InvalidOperationException();<br>    _accessKeyId = configuration[<span class="hljs-string">&quot;OSS:AccessKeyId&quot;</span>] ?? <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InvalidOperationException();<br>    _accessKeySecret = configuration[<span class="hljs-string">&quot;OSS:AccessKeySecret&quot;</span>] ?? <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InvalidOperationException();<br>    _bucketName = configuration[<span class="hljs-string">&quot;OSS:BucketName&quot;</span>] ?? <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InvalidOperationException();<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以创建Settings配置类，来简化配置注入，将服务注入为强类型</p><h3 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">OssSettings</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Endpoint &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125; = <span class="hljs-literal">null</span>!;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> AccessKeyId &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125; = <span class="hljs-literal">null</span>!;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> SecretAccessKey &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125; = <span class="hljs-literal">null</span>!;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> BucketName &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125; = <span class="hljs-literal">null</span>!;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="注册服务-2"><a href="#注册服务-2" class="headerlink" title="注册服务"></a>注册服务</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">builder.Services.Configure&lt;JwtSettings&gt;(builder.Configuration.GetSection(<span class="hljs-string">&quot;Jwt&quot;</span>));<br>builder.Services.Configure&lt;OssSettings&gt;(builder.Configuration.GetSection(<span class="hljs-string">&quot;OSS&quot;</span>));<br></code></pre></td></tr></table></figure><h3 id="注入服务"><a href="#注入服务" class="headerlink" title="注入服务"></a>注入服务</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> OssSettings _ossSettings;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AliOssUtil</span>(<span class="hljs-params">IOptions&lt;OssSettings&gt; ossSettings</span>)</span><br>&#123;<br>    _ossSettings = ossSettings.Value;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>在此项目中，我们使用的是DBFirst开发模式，并且用的是逻辑外键的开发形式，不存在数据库层级的物理外键，也不存在级联关系的插入和查询</p><p>所以我们要在Service层完成对两个表的分别操作（增删改），我们就需要在Service层加入事务，来保证操作的原子性</p><p>在原Java项目中，我们可以通过Spring框架提供的Transactional注解来自动实现整个方法的事务，在ASP.NETCore中，没有类似这个注解的特性</p><p>所以我们要通过TransactionScope对象来实现事务</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> scope = <span class="hljs-keyword">new</span> TransactionScope())<br>&#123;<br>scope.Complete();<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="小贴士"><a href="#小贴士" class="headerlink" title="小贴士"></a>小贴士</h5><p>对于List&lt;T&gt;, ICollection&lt;T&gt;, IReadOnlyCollection&lt;T&gt; 等实现了 IEnumerable&lt;T&gt; 接口的集合</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#">dishFlavors!=<span class="hljs-literal">null</span> &amp;&amp; dishFlavors.Any();<br><span class="hljs-comment">// 替换</span><br>dishFlavors!=<span class="hljs-literal">null</span> &amp;&amp; dishFlavors.Length&gt;<span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>使用Any方法替换Length方法对集合做非空判断，性能更好，但数组的情况下无法使用Any方法，仍使用Length做非空判断</p><h3 id="EFCore的事务实现"><a href="#EFCore的事务实现" class="headerlink" title="EFCore的事务实现"></a>EFCore的事务实现</h3><p>EFCore的<code>SaveChanges</code> 会自动实现事务，也可以使用<code>DbContext.Database.BeginTransaction()</code> 方法开始一个事务，并且使用 <code>Commit()</code> 或 <code>Rollback()</code> 来提交或回滚事务</p><ul><li>优点：避免了TransactionScope事务的性能问题、连接池问题、外部依赖问题</li><li>缺点：需要在service层注入DbContext对象</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 异步方法的调用</span><br><span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> transaction = <span class="hljs-keyword">await</span> _dbContext.Database.BeginTransactionAsync())<br>&#123;<br>    <span class="hljs-keyword">try</span><br>    &#123;<br>        <span class="hljs-comment">// 提交事务</span><br>    <span class="hljs-keyword">await</span> transaction.CommitAsync();<br>    &#125;<br>    <span class="hljs-keyword">catch</span><br>    &#123;<br>        <span class="hljs-comment">// 回滚事务</span><br>        <span class="hljs-keyword">await</span> transaction.RollbackAsync();<br>        <span class="hljs-keyword">throw</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><blockquote><p>注入依赖</p><p>Microsoft.Extensions.Caching.StackExchangeRedis</p></blockquote><h3 id="注册服务-3"><a href="#注册服务-3" class="headerlink" title="注册服务"></a>注册服务</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#">builder.Services.AddStackExchangeRedisCache(options =&gt;<br>    &#123;<br>        options.Configuration = builder.Configuration[<span class="hljs-string">&quot;Redis:Configuration&quot;</span>];<br>        options.InstanceName = builder.Configuration[<span class="hljs-string">&quot;Redis:InstanceName&quot;</span>];<br>    &#125;);<br></code></pre></td></tr></table></figure><h3 id="注入服务-1"><a href="#注入服务-1" class="headerlink" title="注入服务"></a>注入服务</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// Redis</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> IDistributedCache _distributedCache;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ShopController</span>(<span class="hljs-params">ILogger&lt;ShopController&gt; logger, IDistributedCache distributedCache</span>)</span><br>&#123;<br>    _distributedCache = distributedCache;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Get-Set"><a href="#Get-Set" class="headerlink" title="Get&amp;Set"></a>Get&amp;Set</h3><p>_distributedCache（分布式缓存）服务常用的两个方法为Get（GetAsync）和Set（SetAsync），使用起来简单灵活</p><p>但需要注意，这两个方法的参数为字节数组，而通常我们是需要将其他数据类型存入Redis，这就涉及到了<strong>数据类型转换</strong>的问题</p><h5 id="简单数据类型"><a href="#简单数据类型" class="headerlink" title="简单数据类型"></a>简单数据类型</h5><p>对于简单的数据类型（如整数、布尔值等），可以直接使用 <code>BitConverter.GetBytes</code> 转换为 <code>byte[]</code></p><p>在反序列化时，调用<code>BitConverter.ToInt32</code></p><h5 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h5><p>通过<code>System.Text.Encoding</code>将<code>string</code>转换为<code>byte[]</code></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 序列化字符串到byte[]</span><br>Encoding.UTF8.GetBytes(str);<br><br><span class="hljs-comment">// 反序列化</span><br>Encoding.UTF8.GetString(bytes);<br></code></pre></td></tr></table></figure><h5 id="复杂类型"><a href="#复杂类型" class="headerlink" title="复杂类型"></a>复杂类型</h5><p>对于复杂类型的对象，我们通常先调用<code>JsonSerializer.Serialize()</code>将其序列化成字符串，然后再将字符串序列化为byte[]</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 序列化</span><br><span class="hljs-built_in">byte</span>[] bytes = Encoding.UTF8.GetBytes(jsonString);<br><span class="hljs-keyword">await</span> _distributedCache.SetAsync(<span class="hljs-string">&quot;SHOP_STATUS&quot;</span>, bytes, <span class="hljs-keyword">new</span> DistributedCacheEntryOptions());<br><br><span class="hljs-comment">// 反序列化</span><br><span class="hljs-built_in">string</span> jsonString = Encoding.UTF8.GetString(cachedBytes);<br><span class="hljs-keyword">var</span> deserializedStatusInfo = JsonSerializer.Deserialize&lt;YourType&gt;(jsonString);<br></code></pre></td></tr></table></figure><h3 id="SetString-GetString"><a href="#SetString-GetString" class="headerlink" title="SetString&amp;GetString"></a>SetString&amp;GetString</h3><p>在.NET6之后的版本中，_distributedCache为我们额外提供了SetString（SetStringAsync）和GetString（GetStringAsync）</p><p>简化了我们序列化和反序列化的操作，至此，我们可以将所有想要存入redis的对象都序列化为字符串直接存入</p><h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><p>在这个项目中，我们为<strong>用户端</strong>的菜品及套餐的查询操作应用了缓存，在<strong>管理端</strong>的菜品增删改中实现了清空缓存达到及时更新数据</p><p>我们使用工具类CacheUtils将增删查的操作封装，简化了代码</p><hr><h1 id="控制器命名"><a href="#控制器命名" class="headerlink" title="控制器命名"></a>控制器命名</h1><p>在spring中，如果同时存在user包的ShopController和Admin包的ShopController，在没有指定bean名称的时候，会抛出异常，因为这两个Controller都会被注入到IoC容器中，名称会冲突，但为什么ASP.NETCore中就可以存在两个相同名称的Controller呢？</p><p>在 ASP.NET Core 中，MVC 和 Razor Pages 的默认行为是基于约定来发现控制器。MVC 会扫描程序集中的所有类型，并根据命名规则（例如类名以 “Controller” 结尾）来识别控制器。当找到多个具有相同名称的控制器时，ASP.NET Core 不会直接抛出异常，而是通过<strong>路由系统</strong>来区分这些控制器。</p><ul><li><strong>路由配置</strong>：每个控制器通常有自己的路由前缀，即使两个控制器有相同的名称，它们的完整路径（包括命名空间）通常是不同的</li><li><strong>命名空间</strong>：即使没有显式的路由配置，ASP.NET Core 也会使用控制器的命名空间作为默认的路由前缀。这意味着如果两个控制器位于不同的命名空间中，它们的默认路由也将是不同的。</li></ul><p>这两种框架的不同设计哲学和实现方式导致了在处理同名控制器或 Bean 时的行为差异。ASP.NET Core 更加依赖于路由和命名空间来区分控制器，而 Spring 则要求开发者明确指定 Bean 的名称或使用限定符来避免冲突。</p><hr><h1 id="HttpClient"><a href="#HttpClient" class="headerlink" title="HttpClient"></a>HttpClient</h1><p>在.NETCore中已经内置了HttpClient</p><h3 id="注册服务-4"><a href="#注册服务-4" class="headerlink" title="注册服务"></a>注册服务</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 注册HttpClient服务</span><br>builder.Services.AddHttpClient(<span class="hljs-string">&quot;WxLogin&quot;</span>, client =&gt;<br>&#123;<br>    client.BaseAddress = <span class="hljs-keyword">new</span> Uri(<span class="hljs-string">&quot;https://api.weixin.qq.com/&quot;</span>);<br>    client.Timeout = TimeSpan.FromSeconds(<span class="hljs-number">5</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="注入依赖"><a href="#注入依赖" class="headerlink" title="注入依赖"></a>注入依赖</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 获取HttpClient对象</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> HttpClient _httpClient;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UserServiceDao</span>(<span class="hljs-params">IOptions&lt;WxSetting&gt; wxSetting, IHttpClientFactory httpClientFactory</span>)</span><br>&#123;<br>    _httpClient = httpClientFactory.CreateClient(<span class="hljs-string">&quot;WxClient&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 拼接uri参数</span><br><span class="hljs-keyword">var</span> uriBuilder = <span class="hljs-keyword">new</span> UriBuilder(_httpClient.BaseAddress);<br>uriBuilder.Query = QueryHelpers.AddQueryString(uriBuilder.Query, <span class="hljs-keyword">new</span> Dictionary&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>?&gt;<br>&#123;<br>    &#123; <span class="hljs-string">&quot;appId&quot;</span>, _wxSetting.AppId &#125;,<br>    &#123; <span class="hljs-string">&quot;secret&quot;</span>, _wxSetting.AppSecret &#125;,<br>    &#123; <span class="hljs-string">&quot;js_code&quot;</span>, code &#125;,<br>    &#123; <span class="hljs-string">&quot;grant_type&quot;</span>, _wxSetting.GrantType &#125;<br>&#125;);<br><br><span class="hljs-comment">// 发送请求</span><br><span class="hljs-keyword">var</span> response = <span class="hljs-keyword">await</span> _httpClient.GetAsync(uriBuilder.Uri);<br><span class="hljs-keyword">if</span> (response.IsSuccessStatusCode)<br>&#123;<br>    <span class="hljs-comment">// 将响应中的内容读出来</span><br>    result = <span class="hljs-keyword">await</span> response.Content.ReadAsStringAsync();<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="时间区间"><a href="#时间区间" class="headerlink" title="时间区间"></a>时间区间</h1><p>将开始时间和结束时间的日期区间中的每一天加入到集合中</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#">List&lt;DateTime&gt; dateList = <span class="hljs-keyword">new</span> List&lt;DateTime&gt;();<br><span class="hljs-keyword">while</span> (begin &lt;= end)<br>&#123;<br>    dateList.Add(begin);<br>    begin = begin.AddDays(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="集合转换字符串"><a href="#集合转换字符串" class="headerlink" title="集合转换字符串"></a>集合转换字符串</h1><p>通过string.Join的工具方法，搭配Linq的select语句可以将集合转换为字符串并指定换行符</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">DateList = <span class="hljs-built_in">string</span>.Join(<span class="hljs-string">&quot;,&quot;</span>, dateList.Select(d =&gt; d.ToString(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>))),<br>TurnoverList = <span class="hljs-built_in">string</span>.Join(<span class="hljs-string">&quot;,&quot;</span>, sum.Select(d =&gt; d.ToString(<span class="hljs-string">&quot;0.00&quot;</span>)))<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>NET框架相关</category>
      
      <category>net</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>实战项目-连接查询</title>
    <link href="/2024/12/06/%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE-%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/"/>
    <url>/2024/12/06/%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE-%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="链接查询"><a href="#链接查询" class="headerlink" title="链接查询"></a>链接查询</h1><h3 id="1-在-DAO-层进行单表查询，Service-层调用两个-DAO-并进行多表查询后封装"><a href="#1-在-DAO-层进行单表查询，Service-层调用两个-DAO-并进行多表查询后封装" class="headerlink" title="1. 在 DAO 层进行单表查询，Service 层调用两个 DAO 并进行多表查询后封装"></a>1. 在 DAO 层进行单表查询，Service 层调用两个 DAO 并进行多表查询后封装</h3><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ul><li><strong>代码复用性</strong>：单表查询的方法可以在不同的业务场景中复用。</li><li><strong>职责分离</strong>：每个 DAO 负责单一的数据表操作，保持了职责的清晰和单一。</li><li><strong>测试方便</strong>：单表查询的方法更容易进行单元测试。</li><li><strong>灵活性</strong>：可以根据需要灵活组合不同的 DAO 方法来满足复杂的业务需求。</li></ul><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ul><li><strong>多次数据库访问</strong>：可能会导致多次数据库访问，增加了网络延迟和资源消耗。</li><li><strong>事务管理复杂</strong>：如果需要跨多个 DAO 的事务管理，可能会增加复杂性。</li><li><strong>性能问题</strong>：多次查询可能会影响性能，特别是在大数据量的情况下。</li></ul><h3 id="2-直接在-DAO-层进行多表查询并封装-VO（视图对象）"><a href="#2-直接在-DAO-层进行多表查询并封装-VO（视图对象）" class="headerlink" title="2. 直接在 DAO 层进行多表查询并封装 VO（视图对象）"></a>2. 直接在 DAO 层进行多表查询并封装 VO（视图对象）</h3><h4 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h4><ul><li><strong>减少数据库访问</strong>：一次查询可以获取所有需要的数据，减少了网络延迟和资源消耗。</li><li><strong>性能优化</strong>：通过减少数据库访问次数，可以显著提高性能。</li><li><strong>事务管理简单</strong>：在一个事务中完成所有操作，简化了事务管理。</li><li><strong>封装性好</strong>：可以直接返回一个封装好的 VO 对象，减少了服务层的处理逻辑。</li></ul><h4 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h4><ul><li><strong>代码复用性较低</strong>：多表查询的方法通常更特定于某个业务场景，复用性较低。</li><li><strong>DAO 层复杂度增加</strong>：DAO 层的代码会变得更加复杂，因为需要处理多表关联和数据封装。</li><li><strong>测试难度增加</strong>：多表查询的方法可能更难进行单元测试，尤其是当涉及到复杂的 SQL 查询时。</li><li><strong>耦合性较高</strong>：DAO 层直接封装了多个表的数据，可能会导致更高的耦合性。</li></ul><hr><h3 id="LINQ-查询"><a href="#LINQ-查询" class="headerlink" title="LINQ 查询"></a>LINQ 查询</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> DishPageResp <span class="hljs-title">GetPage</span>(<span class="hljs-params">DishPageQueryReq dishPageQueryReq,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-built_in">bool</span> isAsNoTracking = <span class="hljs-literal">true</span></span>)</span><br>&#123;<br>    Queryable&lt;xiaobai_cangqiong_Storage.Entity.Dish&gt; pagedDishes = _dbContext.Dishes;<br><br>    <span class="hljs-keyword">if</span> (isAsNoTracking)<br>    &#123;<br>        pagedDishes = pagedDishes.AsNoTracking();<br>    &#125;<br><br>    <span class="hljs-comment">// 拼接查询条件</span><br>    <span class="hljs-keyword">if</span> (dishPageQueryReq.Name != <span class="hljs-literal">null</span>)<br>    &#123;<br>        pagedDishes = pagedDishes.Where(d =&gt; d.Name.Contains(dishPageQueryReq.Name));<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (dishPageQueryReq.CategoryId != <span class="hljs-number">0</span>)<br>    &#123;<br>        pagedDishes = pagedDishes.Where(d =&gt; d.CategoryId == dishPageQueryReq.CategoryId);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (dishPageQueryReq.Status != <span class="hljs-literal">null</span>)<br>    &#123;<br>        pagedDishes = pagedDishes.Where(d =&gt; d.Status == dishPageQueryReq.Status);<br>    &#125;<br><br>    <span class="hljs-keyword">var</span> total = pagedDishes.Count();<br><br>    <span class="hljs-comment">// 分页查询(以创建时间排序)</span><br>    pagedDishes = pagedDishes.OrderBy(d =&gt; d.CreateTime)<br>        .Skip((dishPageQueryReq.Page - <span class="hljs-number">1</span>) * dishPageQueryReq.PageSize)<br>        .Take(dishPageQueryReq.PageSize);<br>    <br>    <span class="hljs-comment">// 链接查询</span><br>    <span class="hljs-keyword">var</span> dishPageVos = pagedDishes.Join(_dbContext.Categories, dish =&gt; dish.CategoryId, category =&gt; category.Id,<br>        (dish, category) =&gt; <span class="hljs-keyword">new</span> DishPageVo<br>        &#123;<br>            Id = dish.Id,<br>            Name = dish.Name,<br>            CategoryId = dish.CategoryId,<br>            Price = dish.Price,<br>            Image = dish.Image,<br>            Description = dish.Description,<br>            Status = dish.Status,<br>            UpdateTime = dish.UpdateTime,<br>            CategoryName = category.Name<br>        &#125;);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DishPageResp<br>    &#123;<br>        Total = total,<br>        Records = dishPageVos.ToList(),<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="内连接查询"><a href="#内连接查询" class="headerlink" title="内连接查询"></a>内连接查询</h3><p>在这里，我们链接查询后，手动将结果集映射到VO对象中</p><p>在这种对一关系中，我们可以直接简单的进行内连接查询，因为内连接查询效率最高</p><p>当有一个菜品的分类为空时，则需要用到外连接查询，但在咱们的项目中没有分类为空的菜品，所以没有这种需求</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">var</span> dishPageVos = pagedDishes.Join(_dbContext.Categories, dish =&gt; dish.CategoryId, category =&gt; category.Id,<br>    (dish, category) =&gt; <span class="hljs-keyword">new</span> DishPageVo<br>    &#123;<br>        Id = dish.Id,<br>        Name = dish.Name,<br>        CategoryId = dish.CategoryId,<br>        Price = dish.Price,<br>        Image = dish.Image,<br>        Description = dish.Description,<br>        Status = dish.Status,<br>        UpdateTime = dish.UpdateTime,<br>        <span class="hljs-comment">// 链接查询分类名称</span><br>        CategoryName = category.Name<br>    &#125;);<br></code></pre></td></tr></table></figure><hr><h3 id="外连接查询"><a href="#外连接查询" class="headerlink" title="外连接查询"></a>外连接查询</h3><p>在这里，我们实际项目中的菜品数据是必须存在于分类的，那么使用链接查询即可完成业务需求</p><p>但如果存在菜品是没有被分类的，则需要用到外连接查询</p><p><strong>GroupJoin</strong></p><ul><li>将主表（如 <code>pagedDishes</code>）中的每个元素与从表（如 <code>_dbContext.Categories</code>）中的元素进行分组连接。</li><li>结果是一个匿名对象，其中包含主表中的每个元素和一个从表中匹配的元素集合（如果有的话）。</li></ul><p><strong>SelectMany</strong></p><ul><li>使用 <code>SelectMany</code> 对 <code>GroupJoin</code> 的结果进行展平。</li><li>如果某个主表元素在从表中没有匹配项，则使用 <code>DefaultIfEmpty()</code> 方法提供一个默认值（通常为 <code>null</code>）。</li><li>最终结果是一个扁平化的集合，包含了所有主表元素及其对应的从表元素（如果有）或默认值（如果没有匹配项）。</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">var</span> dishPageVos = pagedDishes<br>    <span class="hljs-comment">// 使用 GroupJoin 进行分组连接</span><br>    .GroupJoin(<br>        _dbContext.Categories,  <span class="hljs-comment">// 要连接的类别集合</span><br>        dish =&gt; dish.CategoryId,  <span class="hljs-comment">// 从每个 dish 中提取 CategoryId</span><br>        category =&gt; category.Id,  <span class="hljs-comment">// 从每个 category 中提取 Id</span><br>        (dish, categoriesGroup) =&gt; <span class="hljs-keyword">new</span> &#123; Dish = dish, CategoriesGroup = categoriesGroup.DefaultIfEmpty() &#125;  <span class="hljs-comment">// 结果选择器</span><br>    )<br>    <span class="hljs-comment">// 使用 SelectMany 展平结果，并处理没有匹配 Category 的情况</span><br>    .SelectMany(<br>        x =&gt; x.CategoriesGroup,  <span class="hljs-comment">// 如果没有匹配的 Category，则返回默认值（null）</span><br>        (x, c) =&gt; <span class="hljs-keyword">new</span> DishVo  <span class="hljs-comment">// 投影结果到 DishPageVo 对象</span><br>        &#123;<br>            Id = x.Dish.Id,  <span class="hljs-comment">// 设置 DishPageVo 的 Id 属性为 dish 的 Id</span><br>            Name = x.Dish.Name,  <span class="hljs-comment">// 设置 DishPageVo 的 Name 属性为 dish 的 Name</span><br>            CategoryId = x.Dish.CategoryId,  <span class="hljs-comment">// 设置 DishPageVo 的 CategoryId 属性为 dish 的 CategoryId</span><br>            Price = x.Dish.Price,  <span class="hljs-comment">// 设置 DishPageVo 的 Price 属性为 dish 的 Price</span><br>            Image = x.Dish.Image,  <span class="hljs-comment">// 设置 DishPageVo 的 Image 属性为 dish 的 Image</span><br>            Description = x.Dish.Description,  <span class="hljs-comment">// 设置 DishPageVo 的 Description 属性为 dish 的 Description</span><br>            Status = x.Dish.Status,  <span class="hljs-comment">// 设置 DishPageVo 的 Status 属性为 dish 的 Status</span><br>            UpdateTime = x.Dish.UpdateTime,  <span class="hljs-comment">// 设置 DishPageVo 的 UpdateTime 属性为 dish 的 UpdateTime</span><br>            <span class="hljs-comment">// 如果 category 为 null，则将 CategoryName 设置为 &quot;未分类&quot;，否则设置为 category 的 Name</span><br>            CategoryName = c != <span class="hljs-literal">null</span> ? c.Name : <span class="hljs-string">&quot;未分类&quot;</span><br>        &#125;<br>    ).ToList();<br></code></pre></td></tr></table></figure><p>代码详解：</p><p>在进行<code>.GroupJoin</code>分组查询之后，产生的结果集（x）为一个元素（Dish）和其关联的结果集（CategoriesGroup）的集合</p><p><code>.SelectMany</code>的第一个参数为<code>x =&gt; x.CategoriesGroup</code>，其含义是将其关联的结果集（CategoriesGroup）展平</p><p>这里的两个参数<code>(x, category)</code>，x为结果集，category为 关联的结果集（CategoriesGroup）的元素中的一个 <code>Category</code> 对象，或者 <code>null</code>（如果没有匹配的 <code>Category</code>）</p><hr><h3 id="一对多关系处理"><a href="#一对多关系处理" class="headerlink" title="一对多关系处理"></a>一对多关系处理</h3><p>在Mybatis中，我们使用resultMap和collection来完成一对多的关系处理</p><p>在使用GroupJoin方法进行外连接查询后，第一个类型中的每一个元素都包含一个第二个类型的一个元素集合</p><p><em>我们使用SelectMany的方式展开，就实现了数据库左外连接查询的结果</em></p><p>所以通过一个简单的GroupJoin配合Select，就在ASP.NETCore中完成了一对多关系的处理</p><p>在这里，我们不需要将dishFlavor结果集展平，因为我们需要的是Flavor（List&lt;DishFlavor&gt;）集合，所以直接ToList为其赋值即可</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c#">IQueryable&lt;xiaobai_cangqiong_Storage.Entity.Dish&gt; queryable = _dbContext.Dishes;<br>queryable.GroupJoin(_dbContext.DishFlavors<br>        , d =&gt; d.Id<br>        , d =&gt; d.DishId<br>        , (dish, dishFlavor) =&gt; <span class="hljs-keyword">new</span> &#123; Dish = dish, DishFlavor = dishFlavor.DefaultIfEmpty() &#125;)<br>    .Select(x =&gt; <span class="hljs-keyword">new</span> DishListResp<br>        &#123;<br>            Id = x.Dish.Id,<br>            Name = x.Dish.Name,<br>            CategoryId = x.Dish.CategoryId,<br>            Price = x.Dish.Price,<br>            Image = x.Dish.Image,<br>            Description = x.Dish.Description,<br>            Status = x.Dish.Status,<br>            UpdateTime = x.Dish.UpdateTime,<br>            Flavors = x.DishFlavor.ToList(),<br>        &#125;);<br></code></pre></td></tr></table></figure><hr><h3 id="LINQ表达式语法"><a href="#LINQ表达式语法" class="headerlink" title="LINQ表达式语法"></a>LINQ表达式语法</h3><p>我们发现，在进行多表的连接查询时，LINQ的方法语法会比表达式语法更加麻烦</p><p>再表达式语法中，如果进行外连接查询，会自动处理Flavors &#x3D; flavors.DefaultIfEmpty()，且这种写法简单，更符合SQL语义</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 使用 Join 进行内连接</span><br><span class="hljs-keyword">var</span> dishPageVos = <span class="hljs-keyword">from</span> dish <span class="hljs-keyword">in</span> pagedDishes<br>                  <span class="hljs-keyword">join</span> category <span class="hljs-keyword">in</span> _dbContext.Categories <span class="hljs-keyword">on</span> dish.CategoryId <span class="hljs-keyword">equals</span> category.Id<br>                  <span class="hljs-keyword">select</span> <span class="hljs-keyword">new</span> DishPageVo<br>                  &#123;<br>                      Id = dish.Id,<br>                      Name = dish.Name,<br>                      CategoryId = dish.CategoryId,<br>                      Price = dish.Price,<br>                      Image = dish.Image,<br>                      Description = dish.Description,<br>                      Status = dish.Status,<br>                      UpdateTime = dish.UpdateTime,<br>                      CategoryName = category.Name<br>                  &#125;;<br><br><span class="hljs-comment">// 使用Join …… into进行左外连接</span><br><span class="hljs-keyword">var</span> dishListResps = (<br>    <span class="hljs-keyword">from</span> dish <span class="hljs-keyword">in</span> _dbContext.Dishes<br>    <span class="hljs-keyword">join</span> dishFlavor <span class="hljs-keyword">in</span> _dbContext.DishFlavors <br>    <span class="hljs-keyword">on</span> dish.Id <span class="hljs-keyword">equals</span> dishFlavor.DishId <span class="hljs-keyword">into</span> dishFlavorGroup<br>    <span class="hljs-keyword">select</span> <span class="hljs-keyword">new</span> DishListResp<br>    &#123;<br>        Id = dish.Id,<br>        Name = dish.Name,<br>        CategoryId = dish.CategoryId,<br>        Price = dish.Price,<br>        Image = dish.Image,<br>        Description = dish.Description,<br>        Status = dish.Status,<br>        UpdateTime = dish.UpdateTime,<br>        Flavors = dishFlavorGroup.ToList()<br>    &#125;<br>).ToList(); <br><br><span class="hljs-comment">// 使用 from 子句展平结果，代替SelectMany</span><br><span class="hljs-keyword">var</span> dishPageVos = (<br>    <span class="hljs-keyword">from</span> dish <span class="hljs-keyword">in</span> pagedDishes<br>    <span class="hljs-comment">// 使用 join...into 进行分组连接</span><br>    <span class="hljs-keyword">join</span> category <span class="hljs-keyword">in</span> _dbContext.Categories<br>        <span class="hljs-keyword">on</span> dish.CategoryId <span class="hljs-keyword">equals</span> category.Id <span class="hljs-keyword">into</span> categoriesGroup<br>    <span class="hljs-comment">// 使用 from 子句展平结果</span><br>    <span class="hljs-keyword">from</span> c <span class="hljs-keyword">in</span> categoriesGroup.DefaultIfEmpty()<br>    <span class="hljs-comment">// 选择新的 DishVo 对象</span><br>    <span class="hljs-keyword">select</span> <span class="hljs-keyword">new</span> DishVo<br>    &#123;<br>        Id = dish.Id,<br>        Name = dish.Name,<br>        CategoryId = dish.CategoryId,<br>        Price = dish.Price,<br>        Image = dish.Image,<br>        Description = dish.Description,<br>        Status = dish.Status,<br>        UpdateTime = dish.UpdateTime,<br>        <span class="hljs-comment">// 如果 category 为 null，则将 CategoryName 设置为 &quot;未分类&quot;，否则设置为 category 的 Name</span><br>        CategoryName = c != <span class="hljs-literal">null</span> ? c.Name : <span class="hljs-string">&quot;未分类&quot;</span><br>    &#125;<br>).ToList();<br></code></pre></td></tr></table></figure><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对于数据库关系来说，对一关系使用内连接来完成，高效简单，对于有需求用到外连接的内容，使用from子句展平对象后取值即可</p><p>对多关系多用外连接处理，使用into关键字将被链接表做成集合，可调用ToList转至集合后直接赋值到VO对象的属性中</p><p>对于LINQ的语法方式选择来说，简单语句使用LINQ方法语法更简单，利用Lambda表达式合适</p><p>复杂语法，涉及到多表查询的语法要选择方法语法简单，连接写起来更类SQL</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 三表联查</span><br><span class="hljs-keyword">var</span> dishListResps = <span class="hljs-keyword">from</span> dish <span class="hljs-keyword">in</span> queryable<br>    <span class="hljs-keyword">join</span> dishFlavor <span class="hljs-keyword">in</span> _dbContext.DishFlavors<br>        <span class="hljs-keyword">on</span> dish.Id <span class="hljs-keyword">equals</span> dishFlavor.DishId <span class="hljs-keyword">into</span> dishFlavorGroup<br>    <span class="hljs-keyword">join</span> category <span class="hljs-keyword">in</span> _dbContext.Categories<br>        <span class="hljs-keyword">on</span> dish.CategoryId <span class="hljs-keyword">equals</span> category.Id<br>    <span class="hljs-keyword">select</span> <span class="hljs-keyword">new</span> DishListResp<br>    &#123;<br>        Id = dish.Id,<br>        Name = dish.Name,<br>        CategoryId = dish.CategoryId,<br>        Price = dish.Price,<br>        Image = dish.Image,<br>        Description = dish.Description,<br>        Status = dish.Status,<br>        UpdateTime = dish.UpdateTime,<br>        <span class="hljs-comment">// 来自于分类表的分类名称</span><br>        CategoryName = category.Name,<br>        <span class="hljs-comment">// 来自于口味表中的口味数据</span><br>        Flavors = dishFlavorGroup.ToList()<br>    &#125;;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>NET框架相关</category>
      
      <category>net</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>实战项目-双端验证</title>
    <link href="/2024/12/06/%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE-%E5%8F%8C%E7%AB%AF%E9%AA%8C%E8%AF%81/"/>
    <url>/2024/12/06/%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE-%E5%8F%8C%E7%AB%AF%E9%AA%8C%E8%AF%81/</url>
    
    <content type="html"><![CDATA[<h1 id="双端验证"><a href="#双端验证" class="headerlink" title="双端验证"></a>双端验证</h1><p>在此项目中，User和Admin两端是分别发送了不同格式的Token以区分登陆状态</p><blockquote><p>Admin:  Token: &lt;token&gt;</p><p>User:  Authorization:&lt;token&gt;</p></blockquote><p>所以我们在配置JWT验证规则时，应该分别为其配置验证规则</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 配置Admin的验证规则</span><br>.AddJwtBearer(<span class="hljs-string">&quot;Admin&quot;</span>, options =&gt;<br>&#123;<br>    options.RequireHttpsMetadata = <span class="hljs-literal">false</span>;<br>    options.SaveToken = <span class="hljs-literal">true</span>;<br>    options.TokenValidationParameters = <span class="hljs-keyword">new</span> TokenValidationParameters<br>    &#123;<br>        ValidateIssuerSigningKey = <span class="hljs-literal">true</span>,<br>        IssuerSigningKey = <span class="hljs-keyword">new</span> SymmetricSecurityKey(<br>            Encoding.ASCII.GetBytes(builder.Configuration[<span class="hljs-string">&quot;Jwt:Key&quot;</span>] ??<br>                                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InvalidOperationException())),<br><br>        ValidateIssuer = <span class="hljs-literal">true</span>,<br>        ValidIssuer = builder.Configuration[<span class="hljs-string">&quot;Jwt:Issuer&quot;</span>],<br>        ValidateAudience = <span class="hljs-literal">true</span>,<br>        ValidAudience = builder.Configuration[<span class="hljs-string">&quot;Jwt:Audience&quot;</span>]<br>    &#125;;<br>    <span class="hljs-comment">// 使用自定义处理请求头的方式</span><br>    options.EventsType = <span class="hljs-keyword">typeof</span>(AdminJwtBearerEvents);<br>&#125;)<br>    <br><span class="hljs-comment">// 配置User的验证规则</span><br>.AddJwtBearer(<span class="hljs-string">&quot;User&quot;</span>, options =&gt;<br>&#123;<br>    options.RequireHttpsMetadata = <span class="hljs-literal">false</span>;<br>    options.SaveToken = <span class="hljs-literal">true</span>;<br>    options.TokenValidationParameters = <span class="hljs-keyword">new</span> TokenValidationParameters<br>    &#123;<br>        ValidateIssuerSigningKey = <span class="hljs-literal">true</span>,<br>        IssuerSigningKey = <span class="hljs-keyword">new</span> SymmetricSecurityKey(<br>            Encoding.ASCII.GetBytes(builder.Configuration[<span class="hljs-string">&quot;Jwt:Key&quot;</span>] ??<br>                                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InvalidOperationException())),<br>        <br>        ValidateIssuer = <span class="hljs-literal">true</span>,<br>        ValidIssuer = builder.Configuration[<span class="hljs-string">&quot;Jwt:Issuer&quot;</span>],<br>        ValidateAudience = <span class="hljs-literal">true</span>,<br>        ValidAudience = builder.Configuration[<span class="hljs-string">&quot;Jwt:Audience&quot;</span>]<br>    &#125;;<br>    <span class="hljs-comment">// 使用自定义处理请求头的方式</span><br>    options.EventsType = <span class="hljs-keyword">typeof</span>(UserJwtBearerEvents);<br>&#125;);<br></code></pre></td></tr></table></figure><hr><h3 id="JwtBearerEvents"><a href="#JwtBearerEvents" class="headerlink" title="JwtBearerEvents"></a>JwtBearerEvents</h3><p>分别添加Admin身份认证方案和User身份认证方案</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 配置Admin身份认证方案处理请求头中Token的方式</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AdminJwtBearerEvents</span> : <span class="hljs-title">JwtBearerEvents</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> Task <span class="hljs-title">MessageReceived</span>(<span class="hljs-params">MessageReceivedContext context</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> token = context.Request.Headers[<span class="hljs-string">&quot;Token&quot;</span>].FirstOrDefault();<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">string</span>.IsNullOrEmpty(token))<br>        &#123;<br>            context.Token = token;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">base</span>.MessageReceived(context);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 配置User身份认证方案处理请求头中Token的方式</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">UserJwtBearerEvents</span> : <span class="hljs-title">JwtBearerEvents</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> Task <span class="hljs-title">MessageReceived</span>(<span class="hljs-params">MessageReceivedContext context</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> token = context.Request.Headers[<span class="hljs-string">&quot;Authorization&quot;</span>].FirstOrDefault();<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">string</span>.IsNullOrEmpty(token))<br>        &#123;<br>            context.Token = token;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">base</span>.MessageReceived(context);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="AuthenticationSchemes"><a href="#AuthenticationSchemes" class="headerlink" title="AuthenticationSchemes"></a>AuthenticationSchemes</h3><p>我们在Controller中，可以使用不同的身份认证方案来对不同的Action方法进行验证</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 员工登出</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span><span class="hljs-doctag">&lt;/returns&gt;</span></span><br>[<span class="hljs-meta">Authorize(AuthenticationSchemes = <span class="hljs-string">&quot;Admin&quot;</span>)</span>]<br>[<span class="hljs-meta">HttpPost(<span class="hljs-string">&quot;logout&quot;</span>)</span>]<br><span class="hljs-function"><span class="hljs-keyword">public</span> Result&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">Logout</span>()</span><br>&#123;<br>    <span class="hljs-keyword">return</span> Result&lt;<span class="hljs-built_in">string</span>&gt;.Success();<br>&#125;<br></code></pre></td></tr></table></figure><p>我们也可以将这个方法直接添加到控制器类上，再将登陆方法暴露出来</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c#">[<span class="hljs-meta">ApiController</span>]<br>[<span class="hljs-meta">Route(<span class="hljs-string">&quot;/admin/employee&quot;</span>)</span>]<br>[<span class="hljs-meta">Authorize(AuthenticationSchemes = <span class="hljs-string">&quot;Admin&quot;</span>)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">EmployeeController</span> : <span class="hljs-title">ControllerBase</span><br>&#123;<br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> 员工登录Action</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;employeeLoginReq&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span><span class="hljs-doctag">&lt;/returns&gt;</span></span><br>    [<span class="hljs-meta">HttpPost(<span class="hljs-string">&quot;login&quot;</span>)</span>]<br>    [<span class="hljs-meta">AllowAnonymous</span>]<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Result&lt;EmployeeLoginResp&gt; <span class="hljs-title">Login</span>(<span class="hljs-params">[FromBody] EmployeeLoginReq employeeLoginReq</span>)</span><br>    &#123;<br>    &#125;<br></code></pre></td></tr></table></figure><hr><h3 id="Swagger按钮"><a href="#Swagger按钮" class="headerlink" title="Swagger按钮"></a>Swagger按钮</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-meta">#<span class="hljs-keyword">region</span> MyRegion Swagger</span><br><br>builder.Services.AddSwaggerGen(<br>    options =&gt;<br>    &#123;<br>        <span class="hljs-comment">// 以下配置影响两个输入Token的按钮</span><br>        <span class="hljs-comment">// 添加一个安全定义,定义名称为&quot;Admin&quot;</span><br>        options.AddSecurityDefinition(<span class="hljs-string">&quot;Admin&quot;</span>, <span class="hljs-keyword">new</span> OpenApiSecurityScheme<br>        &#123;<br>            <span class="hljs-comment">// 描述如何使用Token进行身份验证</span><br>            Description = <span class="hljs-string">&quot;Token: &lt;token&gt;&quot;</span>,<br>            <span class="hljs-comment">// 指定认证头的名称，这里是&quot;Token&quot;</span><br>            Name = <span class="hljs-string">&quot;Token&quot;</span>,<br>            <span class="hljs-comment">// 指定认证信息应该放置的位置，这里是HTTP头部</span><br>            In = ParameterLocation.Header,<br>            <span class="hljs-comment">// 指定安全方案的类型，这里是指API密钥类型</span><br>            Type = SecuritySchemeType.ApiKey,<br>        &#125;);<br>        <span class="hljs-comment">// 添加安全要求，这将告诉Swagger UI哪些安全方案是必需的</span><br>        options.AddSecurityRequirement(<span class="hljs-keyword">new</span> OpenApiSecurityRequirement<br>        &#123;<br>            &#123;<br>                <span class="hljs-keyword">new</span> OpenApiSecurityScheme<br>                &#123;<br>                    <span class="hljs-comment">// 引用之前定义的安全方案</span><br>                    Reference = <span class="hljs-keyword">new</span> OpenApiReference<br>                    &#123;<br>                        Type = ReferenceType.SecurityScheme,<br>                        Id = <span class="hljs-string">&quot;Admin&quot;</span> <span class="hljs-comment">// 对应于上面定义的安全方案的Id</span><br>                    &#125;,<br>                &#125;,<br>                <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">string</span>&gt;() <span class="hljs-comment">// 空列表表示不需要特定的作用域</span><br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-comment">// 添加一个安全定义,定义名称为&quot;User&quot;</span><br>        options.AddSecurityDefinition(<span class="hljs-string">&quot;User&quot;</span>, <span class="hljs-keyword">new</span> OpenApiSecurityScheme<br>        &#123;<br>            <span class="hljs-comment">// 描述如何进行身份验证</span><br>            Description = <span class="hljs-string">&quot;Authorization: &lt;token&gt;&quot;</span>,<br>            <span class="hljs-comment">// 指定认证头的名称，这里是&quot;Authorization&quot;</span><br>            Name = <span class="hljs-string">&quot;Authorization&quot;</span>,<br>            <span class="hljs-comment">// 指定认证信息应该放置的位置，这里是HTTP头部</span><br>            In = ParameterLocation.Header,<br>            <span class="hljs-comment">// 指定安全方案的类型，这里是指API密钥类型</span><br>            Type = SecuritySchemeType.ApiKey,<br>        &#125;);<br>        <span class="hljs-comment">// 添加安全要求，这将告诉Swagger UI哪些安全方案是必需的</span><br>        options.AddSecurityRequirement(<span class="hljs-keyword">new</span> OpenApiSecurityRequirement<br>        &#123;<br>            &#123;<br>                <span class="hljs-keyword">new</span> OpenApiSecurityScheme<br>                &#123;<br>                    <span class="hljs-comment">// 引用之前定义的安全方案</span><br>                    Reference = <span class="hljs-keyword">new</span> OpenApiReference<br>                    &#123;<br>                        Type = ReferenceType.SecurityScheme,<br>                        Id = <span class="hljs-string">&quot;User&quot;</span> <span class="hljs-comment">// 对应于上面定义的安全方案的Id</span><br>                    &#125;,<br>                &#125;,<br>                <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">string</span>&gt;() <span class="hljs-comment">// 空列表表示不需要特定的作用域</span><br>            &#125;<br>        &#125;);<br>    &#125;);<br><br><span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br></code></pre></td></tr></table></figure><p><img src="/upload/Swagger.png" alt="Swagger.png"></p><h3 id="Swagger文档"><a href="#Swagger文档" class="headerlink" title="Swagger文档"></a>Swagger文档</h3><p>我们应该为Admin和User配置不同的接口文档，以方便测试使用</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c#">builder.Services.AddSwaggerGen(<br>    options =&gt;<br>    &#123;<br>        options.SwaggerDoc(<span class="hljs-string">&quot;admin&quot;</span>, <span class="hljs-keyword">new</span> OpenApiInfo &#123; Title = <span class="hljs-string">&quot;Admin API&quot;</span>, Version = <span class="hljs-string">&quot;v1&quot;</span> &#125;);<br>        options.SwaggerDoc(<span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-keyword">new</span> OpenApiInfo &#123; Title = <span class="hljs-string">&quot;User API&quot;</span>, Version = <span class="hljs-string">&quot;v1&quot;</span> &#125;);<br>        <span class="hljs-comment">//文档逻辑包含</span><br>        options.DocInclusionPredicate((docName, apiDesc) =&gt;<br>        &#123;<br>            <span class="hljs-comment">// 检查 apiDesc 的 ActionDescriptor 是否是 ControllerActionDescriptor 类型</span><br>            <span class="hljs-keyword">if</span> (apiDesc.ActionDescriptor <span class="hljs-keyword">is</span> ControllerActionDescriptor actionDescriptor)<br>            &#123;<br>                <span class="hljs-comment">// 获取控制器的命名空间</span><br>                <span class="hljs-keyword">var</span> controllerNamespace = actionDescriptor.ControllerTypeInfo.Namespace;<br><br>                <span class="hljs-comment">// 确保命名空间不为空，并且包含 &quot;Controllers&quot; 字符串</span><br>                <span class="hljs-keyword">if</span> (controllerNamespace != <span class="hljs-literal">null</span> &amp;&amp; controllerNamespace.Contains(<span class="hljs-string">&quot;Controllers&quot;</span>))<br>                &#123;<br>                    <span class="hljs-comment">// 如果文档名称是 &quot;user&quot;</span><br>                    <span class="hljs-keyword">if</span> (docName == <span class="hljs-string">&quot;user&quot;</span>)<br>                    &#123;<br>                        <span class="hljs-comment">// 只有当控制器命名空间包含 &quot;User&quot; 时才包含该 API 描述</span><br>                        <span class="hljs-keyword">return</span> controllerNamespace.Contains(<span class="hljs-string">&quot;User&quot;</span>);<br>                    &#125;<br>                    <span class="hljs-comment">// 如果文档名称是 &quot;admin&quot;</span><br><br>                    <span class="hljs-keyword">if</span> (docName == <span class="hljs-string">&quot;admin&quot;</span>)<br>                    &#123;<br>                        <span class="hljs-comment">// 只有当控制器命名空间包含 &quot;Admin&quot; 时才包含该 API 描述</span><br>                        <span class="hljs-keyword">return</span> controllerNamespace.Contains(<span class="hljs-string">&quot;Admin&quot;</span>);<br>                    &#125;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-comment">// 如果上述条件都不满足，则返回 false，表示不包含该 API 描述</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;);<br>    &#125;);<br>)<br></code></pre></td></tr></table></figure><h5 id="配置中间件"><a href="#配置中间件" class="headerlink" title="配置中间件"></a>配置中间件</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#">app.UseSwaggerUI(options =&gt;<br>    &#123;<br>        options.SwaggerEndpoint(<span class="hljs-string">&quot;/swagger/v1-user/swagger.json&quot;</span>, <span class="hljs-string">&quot;User API V1&quot;</span>);<br>        options.SwaggerEndpoint(<span class="hljs-string">&quot;/swagger/v1-admin/swagger.json&quot;</span>, <span class="hljs-string">&quot;Admin API V1&quot;</span>);<br>    &#125;<br>);<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>NET框架相关</category>
      
      <category>net</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>WebAPI-Excel</title>
    <link href="/2024/12/06/WebAPI-Excel/"/>
    <url>/2024/12/06/WebAPI-Excel/</url>
    
    <content type="html"><![CDATA[<h1 id="WebAPI-Excel"><a href="#WebAPI-Excel" class="headerlink" title="WebAPI-Excel"></a>WebAPI-Excel</h1><p>在SpringBoot中，我们可以是使用Apache POI轻松创建Excel文件并写入文件内容</p><p>在ASP.NETCore中，我们也有多种操作Excel表格的方式</p><ul><li><strong>OpenXML SDK</strong> 是最底层的技术，提供对 Office Open XML 文件的最大灵活性和控制力，但同时也增加了复杂性。</li><li><strong>EPPlus</strong> 在 OpenXML SDK 的基础上进行了抽象，提供了一套更易用的 API 来处理 Excel 文件，同时保持了良好的性能。</li><li><strong>ClosedXML</strong> 则是在 EPPlus 的基础上进一步简化了 API，特别注重于提高开发效率和用户体验，适用于那些希望快速实现功能而不需要深入了解底层细节的开发者。</li></ul><h3 id="Template"><a href="#Template" class="headerlink" title="Template"></a>Template</h3><p>可以为 ClosedXML 提供一个 Excel 模板文件，然后使用该模板来生成新的报表。这种方法不仅可以保留模板中的格式、图表和其他静态内容，还可以动态填充数据，从而创建一致且专业的报表</p><h3 id="Closed-XML"><a href="#Closed-XML" class="headerlink" title="Closed XML"></a>Closed XML</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">byte</span>[] <span class="hljs-title">ExportData</span>()</span><br>&#123;<br>    <span class="hljs-comment">// 如果需要模板文件，可以先加载模板</span><br>    <span class="hljs-built_in">string</span> templatePath = Path.Combine(_webHostEnvironment.WebRootPath, <span class="hljs-string">&quot;Resources&quot;</span>, <span class="hljs-string">&quot;运营数据报表模板.xlsx&quot;</span>);<br><br>    <span class="hljs-keyword">if</span> (!File.Exists(templatePath))<br>    &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> FileNotFoundException(<span class="hljs-string">&quot;缺少模板文件&quot;</span>, templatePath);<br>    &#125;<br><br>    <span class="hljs-built_in">byte</span>[] templateBytes = File.ReadAllBytes(templatePath);<br><br>    <span class="hljs-comment">// 使用文件流的原因：ClosedXML仅支持针对于流进行操作，而不是直接操作字节数组</span><br>    <span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> stream = <span class="hljs-keyword">new</span> MemoryStream())<br>    &#123;<br>        <span class="hljs-comment">// 将模板加载到内存流中</span><br>        stream.Write(templateBytes, <span class="hljs-number">0</span>, templateBytes.Length);<br>        stream.Position = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 打开模板文件</span><br>        <span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> workbook = <span class="hljs-keyword">new</span> XLWorkbook(stream))<br>        &#123;<br>            <span class="hljs-comment">// 获取工作表</span><br>            IXLWorksheet worksheet = workbook.Worksheet(<span class="hljs-string">&quot;Sheet1&quot;</span>);<br><br>            <span class="hljs-comment">//<span class="hljs-doctag">TODO:</span> 在这里对模板工作表进行操作</span><br><br>            <span class="hljs-comment">// 保存到内存流</span><br>            stream.Position = <span class="hljs-number">0</span>;<br>            workbook.SaveAs(stream);<br><br>            <span class="hljs-comment">// 返回字节数组</span><br>            <span class="hljs-keyword">return</span> stream.ToArray();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Controller的返回格式"><a href="#Controller的返回格式" class="headerlink" title="Controller的返回格式"></a>Controller的返回格式</h3><p>在 ASP.NET Core 中，如果你不使用 <code>IActionResult</code> 或其派生类作为控制器方法的返回类型，默认情况下，ASP.NET Core 会尝试根据返回的对象类型选择适当的格式化程序来序列化响应。对于大多数对象，默认的行为是将它们序列化为 JSON，并设置 <code>Content-Type</code> 响应头为 <code>application/json</code>。</p><p>在ASP.NETCore中，无需同SpringBoot一样在Controller获取到response对象后响应文件内容</p><p>它提供了更加便捷的响应文件的方式：</p><h5 id="返回内存中的文件"><a href="#返回内存中的文件" class="headerlink" title="返回内存中的文件"></a>返回内存中的文件</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> FileResult <span class="hljs-title">DownloadFile</span>()</span><br>&#123;<br>    <span class="hljs-comment">// 假设你已经有一个 byte[] 数组表示要下载的文件</span><br>    <span class="hljs-built_in">byte</span>[] fileBytes = GetFileBytes(); <span class="hljs-comment">// 从某个地方获取文件字节</span><br><br>    <span class="hljs-keyword">return</span> File(fileBytes, <span class="hljs-string">&quot;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet&quot;</span>, <span class="hljs-string">&quot;ExportedFile.xlsx&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="返回本地文件"><a href="#返回本地文件" class="headerlink" title="返回本地文件"></a>返回本地文件</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> FileResult <span class="hljs-title">DownloadPhysicalFile</span>()</span><br>&#123;<br>    <span class="hljs-built_in">string</span> filePath = Path.Combine(_env.WebRootPath, <span class="hljs-string">&quot;excelTemplates&quot;</span>, <span class="hljs-string">&quot;Template.xlsx&quot;</span>);<br><br>    <span class="hljs-keyword">if</span> (!System.IO.File.Exists(filePath))<br>    &#123;<br>        <span class="hljs-keyword">return</span> NotFound();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> PhysicalFile(filePath, <span class="hljs-string">&quot;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet&quot;</span>, <span class="hljs-string">&quot;Template.xlsx&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="WebAPI静态文件的存放位置"><a href="#WebAPI静态文件的存放位置" class="headerlink" title="WebAPI静态文件的存放位置"></a>WebAPI静态文件的存放位置</h3><p>我们通常将静态文件存放到启动项目中，然后通过注入IWebHostEnvironment对象来获取运行时的项目根路径，通过路径拼接就能读到我们想要的静态文件了</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> IWebHostEnvironment _webHostEnvironment;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ReportService</span>(<span class="hljs-params">IWebHostEnvironment webHostEnvironment</span>)</span><br>&#123;<br>    _webHostEnvironment = webHostEnvironment;<br>&#125;<br><br>Path.Combine(_webHostEnvironment.ContentRootPath, <span class="hljs-string">&quot;Resources&quot;</span>, <span class="hljs-string">&quot;运营数据报表模板.xlsx&quot;</span>)<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>NET框架相关</category>
      
      <category>net</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JWT-Identity</title>
    <link href="/2024/12/04/JWT-Identity/"/>
    <url>/2024/12/04/JWT-Identity/</url>
    
    <content type="html"><![CDATA[<h1 id="JWT-Identity"><a href="#JWT-Identity" class="headerlink" title="JWT-Identity"></a>JWT-Identity</h1><p>我们在签发Token时，通过SecurityTokenDescriptor对象来描述令牌的属性</p><p>其中包含属性：</p><ul><li><p><code>Expires</code>：令牌过期时间</p></li><li><p><code>Issuer</code>：令牌发行者</p></li><li><p><code>Audience</code>：令牌的受众</p></li><li><p><code>SigningCredentials</code>：令牌的签名凭据</p></li></ul><p>除了这四个属性外，还有<code>ClaimsIdentity</code>用来作为用户的标识</p><p>在这个对象中，可以包含一个<code>Claim</code>类型的数组，其中可以创建多个<code>Claim</code>对象</p><hr><h3 id="HttpContext-User-Identity-Name"><a href="#HttpContext-User-Identity-Name" class="headerlink" title="HttpContext.User.Identity.Name"></a>HttpContext.User.Identity.Name</h3><p>HttpContext.User.Identity.Name中的内容默认从ClaimTypes.Name（约定大于配置）</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#">Subject = <span class="hljs-keyword">new</span> ClaimsIdentity(<span class="hljs-keyword">new</span> Claim[]<br>&#123;<br>    <span class="hljs-keyword">new</span> Claim(ClaimTypes.Name, userId) <br>&#125;),<br></code></pre></td></tr></table></figure><h5 id="NameClaimType"><a href="#NameClaimType" class="headerlink" title="NameClaimType"></a>NameClaimType</h5><p>还有一种手动配置映射的方式，就是在JWT的验证TokenValidationParameters（配置令牌参数）中，指定HttpContext.User.Identity.Name的映射Claim</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 配置令牌验证参数</span><br>options.TokenValidationParameters = <span class="hljs-keyword">new</span> TokenValidationParameters<br>&#123;<br>    <span class="hljs-comment">// 是否验证签名密钥，确保令牌是由正确的密钥签名的</span><br>    ValidateIssuerSigningKey = <span class="hljs-literal">true</span>,<br><br>    <span class="hljs-comment">// 提供用于验证令牌的密钥</span><br>    <span class="hljs-comment">// 因为SymmetricSecurityKey方法需求的是一个字节数组，所以在此调用Encoding.ASCII.GetBytes将字符串转化</span><br>    IssuerSigningKey = <span class="hljs-keyword">new</span> SymmetricSecurityKey(<br>        Encoding.ASCII.GetBytes(builder.Configuration[<span class="hljs-string">&quot;Jwt:Key&quot;</span>] ??<br>                                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InvalidOperationException())),<br><br>    <span class="hljs-comment">// 是否验证发行者</span><br>    ValidateIssuer = <span class="hljs-literal">true</span>,<br><br>    <span class="hljs-comment">// 发行者值</span><br>    ValidIssuer = builder.Configuration[<span class="hljs-string">&quot;Jwt:Issuer&quot;</span>],<br><br>    <span class="hljs-comment">// 是否验证受众</span><br>    ValidateAudience = <span class="hljs-literal">true</span>,<br><br>    <span class="hljs-comment">// 受众值</span><br>    ValidAudience = builder.Configuration[<span class="hljs-string">&quot;Jwt:Audience&quot;</span>],<br>    <br>    <span class="hljs-comment">// 显式设置 NameClaimType 为 ClaimTypes.NameIdentifier</span><br>    NameClaimType = ClaimTypes.NameIdentifier<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h3 id="ClaimTypes"><a href="#ClaimTypes" class="headerlink" title="ClaimTypes"></a>ClaimTypes</h3><p>相同的，我们可以利用包含标准声明的常量类ClaimTypes中的一些常量来新建Claim，</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#">Subject = <span class="hljs-keyword">new</span> ClaimsIdentity(<span class="hljs-keyword">new</span> Claim[]<br>&#123;<br>    <span class="hljs-keyword">new</span> Claim(ClaimTypes.NameIdentifier, userId),<br>    <span class="hljs-keyword">new</span> Claim(ClaimTypes.Name, userName),<br>    <span class="hljs-keyword">new</span> Claim(ClaimTypes.Role, role),<br>&#125;),<br></code></pre></td></tr></table></figure><p>以下是一些常用的成员</p><ul><li><strong><code>Name</code></strong> (<code>http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name</code>):<ul><li>用户的可读名称或显示名称。</li></ul></li><li><strong><code>NameIdentifier</code></strong> (<code>http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier</code>):<ul><li>用户的唯一标识符（类似于 <code>sub</code>）。</li></ul></li><li><strong><code>Role</code></strong> (<code>http://schemas.microsoft.com/ws/2008/06/identity/claims/role</code>):<ul><li>用户的角色。</li></ul></li><li><strong><code>Email</code></strong> (<code>http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress</code>):<ul><li>用户的电子邮件地址。</li></ul></li><li><strong><code>Upn</code></strong> (<code>http://schemas.xmlsoap.org/ws/2005/05/identity/claims/upn</code>):<ul><li>用户主体名称（User Principal Name），通常用于 Windows 环境。</li></ul></li><li><strong><code>GivenName</code></strong> (<code>http://schemas.xmlsoap.org/ws/2005/05/identity/claims/givenname</code>):<ul><li>用户的名字（名）。</li></ul></li><li><strong><code>Surname</code></strong> (<code>http://schemas.xmlsoap.org/ws/2005/05/identity/claims/surname</code>):<ul><li>用户的姓氏（姓）。</li></ul></li><li><strong><code>Birthdate</code></strong> (<code>http://schemas.xmlsoap.org/ws/2005/05/identity/claims/birthdate</code>):<ul><li>用户的出生日期。</li></ul></li><li><strong><code>Country</code></strong> (<code>http://schemas.xmlsoap.org/ws/2005/05/identity/claims/country</code>):<ul><li>用户所在的国家或地区。</li></ul></li><li><strong><code>MobilePhone</code></strong> (<code>http://schemas.xmlsoap.org/ws/2005/05/identity/claims/mobilephone</code>):<ul><li>用户的手机号码。</li></ul></li></ul><hr><h3 id="HttpContext-User-Claims"><a href="#HttpContext-User-Claims" class="headerlink" title="HttpContext.User.Claims"></a>HttpContext.User.Claims</h3><p>解析成功后，我们通过HttpContext.User.Claims就可以遍历出JWT中的所有声明</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> claim <span class="hljs-keyword">in</span> HttpContext.User.Claims)<br>&#123;<br>    Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;claim.Type&#125;</span>: <span class="hljs-subst">&#123;claim.Value&#125;</span>&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="获取指定声明"><a href="#获取指定声明" class="headerlink" title="获取指定声明"></a>获取指定声明</h5><p>也可以使用Linq来获取指定的Claim声明</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">var</span> userRole = HttpContext.User.Claims.FirstOrDefault(c =&gt; c.Type == ClaimTypes.Role)?.Value;<br></code></pre></td></tr></table></figure><h5 id="FindFirstValue"><a href="#FindFirstValue" class="headerlink" title="FindFirstValue"></a>FindFirstValue</h5><p> <code>FindFirstValue</code> 是一个便捷的方法，它可以直接返回指定类型声明的值</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">string</span>? userId = HttpContext?.User?.FindFirstValue(<span class="hljs-string">&quot;sub&quot;</span>);<br></code></pre></td></tr></table></figure><hr><h3 id="IHttpContextAccessor"><a href="#IHttpContextAccessor" class="headerlink" title="IHttpContextAccessor"></a>IHttpContextAccessor</h3><p>在 ASP.NET Core 中，直接在类中调用 <code>HttpContext.User</code> 属性并不是最佳实践</p><p>如果你确实需要在非控制器类（例如服务层、业务逻辑层）中访问 <code>HttpContext.User</code> 或其他 <code>HttpContext</code> 相关的信息，推荐的方式是通过 <code>IHttpContextAccessor</code> 进行依赖注入。这样可以确保你的代码保持解耦和可测试性。</p><h5 id="注册IHttpContextAccessor"><a href="#注册IHttpContextAccessor" class="headerlink" title="注册IHttpContextAccessor"></a>注册IHttpContextAccessor</h5> <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">builder.Services.AddHttpContextAccessor();<br></code></pre></td></tr></table></figure><h5 id="注入IHttpContextAccessor"><a href="#注入IHttpContextAccessor" class="headerlink" title="注入IHttpContextAccessor"></a>注入IHttpContextAccessor</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Service</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> IHttpContextAccessor _httpContextAccessor;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">YourService</span>(<span class="hljs-params">IHttpContextAccessor httpContextAccessor</span>)</span><br>    &#123;<br>        _httpContextAccessor = httpContextAccessor;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="CurrentUser"><a href="#CurrentUser" class="headerlink" title="CurrentUser"></a>CurrentUser</h3><p>在项目中，注册一个CurrentUser服务（Scope范围），在每次HTTP请求时，将httpContextAccessor中的用户信息保存到这个服务的属性中，当需要使用CurrentUser信息时，注入此服务即可</p><hr>]]></content>
    
    
    <categories>
      
      <category>NET框架相关</category>
      
      <category>net</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>WebAPI-WebSocket</title>
    <link href="/2024/11/29/WebAPI-WebSocket/"/>
    <url>/2024/11/29/WebAPI-WebSocket/</url>
    
    <content type="html"><![CDATA[<h1 id="WebAPI-WebSocket"><a href="#WebAPI-WebSocket" class="headerlink" title="WebAPI-WebSocket"></a>WebAPI-WebSocket</h1><p>HTTP是短链接</p><p>WebSocket是长连接</p><p>HTTP通勤是单向的，基于请求响应模式</p><p>WebSocket支持双向通信</p><p>HTTP和WebSocket底层都是TCP链接</p><hr><h3 id="处理请求"><a href="#处理请求" class="headerlink" title="处理请求"></a>处理请求</h3><p>在ASP.NETCore中，我们甚至可以直接使用控制器来处理WS请求，但这并不符合设计规范，所以我们使用第二种方法——中间件处理Ws请求</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 使用 WebSocket 中间件</span><br>app.UseWebSockets();<br><br>app.MapControllers(); <span class="hljs-comment">// 映射控制器</span><br><br><br><span class="hljs-comment">// 处理 WebSocket 请求</span><br><span class="hljs-comment">// 定义一个路由 `/ws`，并处理 WebSocket 请求</span><br>app.Map(<span class="hljs-string">&quot;/ws&quot;</span>, <span class="hljs-keyword">async</span> context =&gt;<br>&#123;<br>    <span class="hljs-comment">// 检查当前请求是否是 WebSocket 请求</span><br>    <span class="hljs-keyword">if</span> (context.WebSockets.IsWebSocketRequest)<br>    &#123;<br>        <span class="hljs-comment">// 接受 WebSocket 连接</span><br>        <span class="hljs-keyword">using</span> <span class="hljs-keyword">var</span> webSocket = <span class="hljs-keyword">await</span> context.WebSockets.AcceptWebSocketAsync();<br>        <br>        <span class="hljs-comment">// 处理 WebSocket 连接</span><br>        <span class="hljs-keyword">await</span> HandleWebSocketConnection(webSocket);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">// 如果请求不是 WebSocket 请求，返回 400 Bad Request 状态码</span><br>        context.Response.StatusCode = <span class="hljs-number">400</span>;<br>    &#125;<br>&#125;);<br><br>app.Run();<br><br><span class="hljs-comment">// 处理 WebSocket 连接的方法</span><br><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">HandleWebSocketConnection</span>(<span class="hljs-params">WebSocket webSocket</span>)</span><br>&#123;<br>    <span class="hljs-comment">// 创建一个缓冲区来接收消息</span><br>    <span class="hljs-keyword">var</span> buffer = <span class="hljs-keyword">new</span> <span class="hljs-built_in">byte</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">4</span>];<br>    <br>    <span class="hljs-comment">// 只要 WebSocket 连接处于打开状态，就继续接收消息</span><br>    <span class="hljs-keyword">while</span> (webSocket.State == WebSocketState.Open)<br>    &#123;<br>        <span class="hljs-comment">// 接收消息</span><br>        <span class="hljs-keyword">var</span> result = <span class="hljs-keyword">await</span> webSocket.ReceiveAsync(<span class="hljs-keyword">new</span> ArraySegment&lt;<span class="hljs-built_in">byte</span>&gt;(buffer), CancellationToken.None);<br>        <br>        <span class="hljs-comment">// 如果收到的消息是文本类型</span><br>        <span class="hljs-keyword">if</span> (result.MessageType == WebSocketMessageType.Text)<br>        &#123;<br>            <span class="hljs-comment">// 将字节转换为字符串</span><br>            <span class="hljs-keyword">var</span> message = Encoding.UTF8.GetString(buffer, <span class="hljs-number">0</span>, result.Count);<br>            <br>            <span class="hljs-comment">// 打印收到的消息</span><br>            Console.WriteLine(<span class="hljs-string">$&quot;Received: <span class="hljs-subst">&#123;message&#125;</span>&quot;</span>);<br>            <br>            <span class="hljs-comment">// 将收到的消息发送回客户端</span><br>            <span class="hljs-keyword">await</span> webSocket.SendAsync(<span class="hljs-keyword">new</span> ArraySegment&lt;<span class="hljs-built_in">byte</span>&gt;(buffer, <span class="hljs-number">0</span>, result.Count), result.MessageType, result.EndOfMessage, CancellationToken.None);<br>        &#125;<br>        <span class="hljs-comment">// 如果收到的消息是关闭连接的类型</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (result.MessageType == WebSocketMessageType.Close)<br>        &#123;<br>            <span class="hljs-comment">// 关闭 WebSocket 连接</span><br>            <span class="hljs-keyword">await</span> webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, <span class="hljs-string">&quot;Closing&quot;</span>, CancellationToken.None);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="广播消息"><a href="#广播消息" class="headerlink" title="广播消息"></a>广播消息</h3><p>在项目中，如果有将客户端发来的消息推送给服务端，广播方式也是一种很好的选择</p><h5 id="Program-cs"><a href="#Program-cs" class="headerlink" title="Program.cs"></a>Program.cs</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 开启ws中间件支持</span><br>app.UseWebSockets();<br><br>app.MapControllers();<br><br><span class="hljs-meta">#<span class="hljs-keyword">region</span> ws</span><br><br><span class="hljs-comment">// 使用中间件管道过滤ws请求</span><br>app.Map(<span class="hljs-string">&quot;/ws/&#123;sid&#125;&quot;</span>, <span class="hljs-keyword">async</span> (context) =&gt;<br>&#123;<br>    <span class="hljs-comment">// 如果为ws请求</span><br>    <span class="hljs-keyword">if</span> (context.WebSockets.IsWebSocketRequest)<br>    &#123;<br>        <span class="hljs-comment">// 从路径中获取客户端id</span><br>        <span class="hljs-keyword">var</span> sid = context.Request.RouteValues[<span class="hljs-string">&quot;sid&quot;</span>] <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>;<br>        <br>        <span class="hljs-comment">// 从容器中获取到WebSocketService 工具类</span><br>        <span class="hljs-keyword">var</span> webSocketService = context.RequestServices.GetRequiredService&lt;WebSocketService&gt;();<br>        <br>        <span class="hljs-comment">// 允许与客户端建立ws链接</span><br>        <span class="hljs-keyword">using</span> <span class="hljs-keyword">var</span> webSocket = <span class="hljs-keyword">await</span> context.WebSockets.AcceptWebSocketAsync();<br>        <br>        <span class="hljs-comment">// 调用工具类中的HandleWebSocketConnection执行ws请求的处理逻辑</span><br>        <span class="hljs-keyword">await</span> webSocketService.HandleWebSocketConnection(webSocket, sid, context.RequestAborted);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">// 返回请求失败</span><br>        context.Response.StatusCode = <span class="hljs-number">400</span>; <span class="hljs-comment">// Bad Request</span><br>    &#125;<br>&#125;);<br><br><span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>app.Run();<br></code></pre></td></tr></table></figure><h5 id="webSocketService工具类"><a href="#webSocketService工具类" class="headerlink" title="webSocketService工具类"></a>webSocketService工具类</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">WebSocketService</span><br>&#123;<br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> 存放会话对象</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ConcurrentDictionary&lt;<span class="hljs-built_in">string</span>, WebSocket&gt; sessionMap = <span class="hljs-keyword">new</span> ConcurrentDictionary&lt;<span class="hljs-built_in">string</span>, WebSocket&gt;();<br><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> 连接建立成功调用的方法</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;webSocket&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;sid&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">OnOpen</span>(<span class="hljs-params">WebSocket webSocket, <span class="hljs-built_in">string</span> sid</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;客户端：<span class="hljs-subst">&#123;sid&#125;</span> 建立连接&quot;</span>);<br>        sessionMap.TryAdd(sid, webSocket); <span class="hljs-comment">// 将客户端和请求保存到集合中</span><br>    &#125;<br><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> 收到客户端消息后调用的方法</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;webSocket&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;message&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;sid&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">OnMessage</span>(<span class="hljs-params">WebSocket webSocket, <span class="hljs-built_in">string</span> message, <span class="hljs-built_in">string</span> sid</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;收到来自客户端：<span class="hljs-subst">&#123;sid&#125;</span> 的信息: <span class="hljs-subst">&#123;message&#125;</span>&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> 连接关闭调用的方法</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;sid&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnClose</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> sid</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// 如果成功的将客户端从集合中移除</span><br>        <span class="hljs-keyword">if</span> (sessionMap.TryRemove(sid, <span class="hljs-keyword">out</span> _))<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">$&quot;连接断开: <span class="hljs-subst">&#123;sid&#125;</span>&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> 群发消息</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;message&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">SendToAllClients</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> buffer = Encoding.UTF8.GetBytes(message);<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> webSocket <span class="hljs-keyword">in</span> sessionMap.Values)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (webSocket.State == WebSocketState.Open)<br>            &#123;<br>                <span class="hljs-keyword">await</span> webSocket.SendAsync(<span class="hljs-keyword">new</span> ArraySegment&lt;<span class="hljs-built_in">byte</span>&gt;(buffer), WebSocketMessageType.Text, <span class="hljs-literal">true</span>,<br>                    CancellationToken.None);<br>            &#125;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> 处理 WebSocket 连接</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;webSocket&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;sid&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;cancellationToken&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">HandleWebSocketConnection</span>(<span class="hljs-params">WebSocket webSocket, <span class="hljs-built_in">string</span> sid, CancellationToken cancellationToken</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">await</span> OnOpen(webSocket, sid);<br><br>        <span class="hljs-keyword">var</span> buffer = <span class="hljs-keyword">new</span> <span class="hljs-built_in">byte</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">4</span>];<br>        <span class="hljs-keyword">while</span> (webSocket.State == WebSocketState.Open)<br>        &#123;<br>            <span class="hljs-keyword">var</span> result = <span class="hljs-keyword">await</span> webSocket.ReceiveAsync(<span class="hljs-keyword">new</span> ArraySegment&lt;<span class="hljs-built_in">byte</span>&gt;(buffer), cancellationToken);<br>            <span class="hljs-keyword">if</span> (result.MessageType == WebSocketMessageType.Text)<br>            &#123;<br>                <span class="hljs-keyword">var</span> message = Encoding.UTF8.GetString(buffer, <span class="hljs-number">0</span>, result.Count);<br>                <span class="hljs-keyword">await</span> OnMessage(webSocket, message, sid);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (result.MessageType == WebSocketMessageType.Close)<br>            &#123;<br>                OnClose(sid);<br>                <span class="hljs-keyword">await</span> webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, <span class="hljs-string">&quot;Closing&quot;</span>, cancellationToken);<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>NET框架相关</category>
      
      <category>net</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>WebAPI-定时任务</title>
    <link href="/2024/11/29/WebAPI-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    <url>/2024/11/29/WebAPI-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="WebAPI-定时任务"><a href="#WebAPI-定时任务" class="headerlink" title="WebAPI-定时任务"></a>WebAPI-定时任务</h1><h3 id="Hosted-Services"><a href="#Hosted-Services" class="headerlink" title="Hosted Services"></a>Hosted Services</h3><h5 id="IHostedService接口"><a href="#IHostedService接口" class="headerlink" title="IHostedService接口"></a>IHostedService接口</h5><p><code>IHostedService</code> 是一个接口，它定义了两个方法：<code>StartAsync(CancellationToken)</code> 和 <code>StopAsync(CancellationToken)</code>。这两个方法分别用于启动和停止后台服务。当你实现这个接口时，你需要自己处理所有的逻辑，包括如何开始、执行任务以及优雅地关闭服务</p><h5 id="BackgroundService抽象类"><a href="#BackgroundService抽象类" class="headerlink" title="BackgroundService抽象类"></a>BackgroundService抽象类</h5><p><code>BackgroundService</code> 是一个抽象类，它实现了 <code>IHostedService</code> 接口，并且提供了一个默认的实现来简化开发过程。它引入了一个名为 <code>ExecuteAsync(CancellationToken)</code> 的虚方法，你可以在子类中重写这个方法来实现具体的业务逻辑。<code>BackgroundService</code> 会自动处理一些常见的任务，比如在应用程序关闭时正确地停止服务。</p><h5 id="自动触发"><a href="#自动触发" class="headerlink" title="自动触发"></a>自动触发</h5><p><code>BackgroundService</code> 中定义的任务是自动触发的，无需手动触发。当你将一个实现了 <code>IHostedService</code> 接口（或继承自 <code>BackgroundService</code>）的服务注册到 ASP.NET Core 的依赖注入容器中时，ASP.NET Core 会在应用程序启动时自动调用该服务的 <code>StartAsync</code> 方法，并在应用程序关闭时调用 <code>StopAsync</code> 方法</p><h5 id="program"><a href="#program" class="headerlink" title="program"></a>program</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 注册定时任务类</span><br>builder.Services.AddHostedService&lt;MyTask&gt;();<br></code></pre></td></tr></table></figure><h5 id="MyTask"><a href="#MyTask" class="headerlink" title="MyTask"></a>MyTask</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyTask</span>: <span class="hljs-title">BackgroundService</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">ExecuteAsync</span>(<span class="hljs-params">CancellationToken stoppingToken</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">while</span> (!stoppingToken.IsCancellationRequested)<br>        &#123;<br>            <span class="hljs-comment">// 执行你的任务逻辑</span><br>            Console.WriteLine(<span class="hljs-string">&quot;执行定时任务: &quot;</span> + DateTime.Now);<br><br>            <span class="hljs-comment">// 等待一段时间再执行下一次</span><br>            <span class="hljs-keyword">await</span> Task.Delay(TimeSpan.FromSeconds(<span class="hljs-number">30</span>), stoppingToken);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> 如果存在需要释放的资源可以填写到这里</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Dispose</span>()</span><br>        &#123;<br>            <span class="hljs-comment">// 释放资源</span><br>            <span class="hljs-keyword">base</span>.Dispose();<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h3><p>在 .NET 中，<code>System.Threading.Timer</code> 类提供了一种简单的方式来执行定时任务。它允许你指定一个回调方法，在经过一段指定的时间后调用该方法。<code>Timer</code> 类非常适合用于需要定期或延时执行的任务</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Timer</span>(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">    TimerCallback callback,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-built_in">object</span> state,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-built_in">int</span> dueTime,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-built_in">int</span> period</span></span><br><span class="hljs-params"><span class="hljs-function"></span>)</span><br></code></pre></td></tr></table></figure><ul><li><strong>callback</strong>：一个 <code>TimerCallback</code> 委托，指向当定时器触发时要调用的方法。</li><li><strong>state</strong>：传递给回调方法的任意对象。这个参数可以用来传递数据到回调方法中。</li><li><strong>dueTime</strong>：定时器启动前的初始延迟时间（以毫秒为单位）。</li><li><strong>period</strong>：定时器触发之间的间隔时间（以毫秒为单位）。如果设置为 -1 或 <code>Timeout.Infinite</code>，则定时器仅触发一次。</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyTask</span> : <span class="hljs-title">BackgroundService</span><br>&#123;<br>    <span class="hljs-keyword">private</span> Timer _timer;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> Task <span class="hljs-title">ExecuteAsync</span>(<span class="hljs-params">CancellationToken stoppingToken</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// 设置定时器，每30秒触发一次</span><br>        _timer = <span class="hljs-keyword">new</span> Timer(DoWork, <span class="hljs-literal">null</span>, TimeSpan.Zero, TimeSpan.FromSeconds(<span class="hljs-number">30</span>));<br><br>        <span class="hljs-comment">// 返回一个永远不会完成的任务（已经完成的任务），以保持服务运行</span><br>        <span class="hljs-comment">// 替代了使用while循环来保持服务运行</span><br>        <span class="hljs-keyword">return</span> Task.CompletedTask;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoWork</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> state</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// 执行任务逻辑</span><br>        Console.WriteLine(<span class="hljs-string">&quot;执行定时任务: &quot;</span> + DateTime.Now);<br><br>        <span class="hljs-comment">// 检查是否需要停止</span><br>        <span class="hljs-keyword">if</span> (stoppingToken.IsCancellationRequested)<br>        &#123;<br>            _timer.Dispose();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Dispose</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 释放资源</span><br>        _timer?.Dispose();<br>        <span class="hljs-keyword">base</span>.Dispose();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="Cron表达式"><a href="#Cron表达式" class="headerlink" title="Cron表达式"></a>Cron表达式</h3><p>cron表达式是一个字符串，通过crom表达式可以定义任务触发的时间</p><p>构成规则：分为6或者个域，由空格分开，每个域代表一个含义</p><table><thead><tr><th>秒</th><th>分钟</th><th>小时</th><th>日</th><th>月</th><th>周</th><th>年（可为空）</th></tr></thead></table><p><em>注：周和日应该只有一个出现，而为空的时候填写<code>？</code></em></p><p><a href="https://cron.ciding.cc/">Cron - 在线Cron表达式生成器</a></p><hr><h3 id="NCrontab"><a href="#NCrontab" class="headerlink" title="NCrontab"></a>NCrontab</h3><p>如果想要实现指定规则去执行定时任务的话，仅仅通过Hosted Services是不行的</p><p>通过导入第三方库NCrontab，解析cron表达式，通过Timer来配置循环执行的定时任务，再通过Hosted Services来配置好后台任务</p><p><em>注： 因为Dal层是scope注入范围，而定时任务是单例，直接注入会出现异常，使用IServiceScopeFactory获取scope的Dal层对象</em></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyTask</span> : <span class="hljs-title">BackgroundService</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> CrontabSchedule _schedule;<br>    <span class="hljs-keyword">private</span> Timer? _timer;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> ILogger&lt;MyTask&gt; _logger;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyTask</span>(<span class="hljs-params">ILogger&lt;MyTask&gt; logger</span>)</span><br>    &#123;<br>        _logger = logger;<br>        <span class="hljs-comment">// 解析 CRON 表达式（使得NCrontab支持秒级定时）</span><br>        _schedule = CrontabSchedule.Parse(<span class="hljs-string">&quot;5/5 * * * * *&quot;</span>, <span class="hljs-keyword">new</span> CrontabSchedule.ParseOptions &#123; IncludingSeconds = <span class="hljs-literal">true</span> &#125;);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> Task <span class="hljs-title">ExecuteAsync</span>(<span class="hljs-params">CancellationToken stoppingToken</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// 获取下一次执行的时间，并设置定时器</span><br>        _timer = <span class="hljs-keyword">new</span> Timer(DoWork, <span class="hljs-literal">null</span>, _schedule.GetNextOccurrence(DateTime.Now) - DateTime.Now, TimeSpan.FromMilliseconds(<span class="hljs-number">-1</span>));<br><br>        <span class="hljs-keyword">return</span> Task.CompletedTask;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoWork</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> state</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// 执行任务</span><br>        Console.WriteLine(<span class="hljs-string">&quot;执行每日任务: &quot;</span> + DateTime.Now);<br>        <br>        <span class="hljs-comment">// 重新计算下次执行时间，并重新设置定时器</span><br>        <span class="hljs-comment">// 通过不断设置定时器的方式替代Timer的period参数来实现循环</span><br>        _timer.Change(_schedule.GetNextOccurrence(DateTime.Now) - DateTime.Now, TimeSpan.FromMilliseconds(<span class="hljs-number">-1</span>));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Dispose</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">base</span>.Dispose();<br>        _timer?.Dispose();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>NET框架相关</category>
      
      <category>net</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>WebAPI-程序集</title>
    <link href="/2024/11/16/WebAPI-%E7%A8%8B%E5%BA%8F%E9%9B%86/"/>
    <url>/2024/11/16/WebAPI-%E7%A8%8B%E5%BA%8F%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h1 id="WebAPI-程序集"><a href="#WebAPI-程序集" class="headerlink" title="WebAPI-程序集"></a>WebAPI-程序集</h1><p>在Program中，我们注册Service层和Dao层服务过于麻烦，每次添加新的Dao和Service都要注册相应的接口和实现类</p><p>可以通过程序集反射的方式，批量注册Service层和Dao层的服务</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ServiceCollectionExtensions</span><br>&#123;<br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> 自动注册服务层中的所有服务。</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;services&quot;&gt;</span>服务集合。<span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;assembly&quot;&gt;</span>包含服务类的程序集。<span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span>配置后的服务集合。<span class="hljs-doctag">&lt;/returns&gt;</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IServiceCollection <span class="hljs-title">AddServices</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> IServiceCollection services, Assembly assembly</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// 获取程序集中的所有命名空间</span><br>        <span class="hljs-keyword">var</span> namespaces = GetNamespaces(assembly);<br><br>        <span class="hljs-comment">// 遍历每个命名空间</span><br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> namespaceName <span class="hljs-keyword">in</span> namespaces)<br>        &#123;<br>            <span class="hljs-comment">// 获取当前命名空间下的所有类型</span><br>            <span class="hljs-keyword">var</span> typesInNamespace = assembly.GetTypes()<br>                .Where(type =&gt; type.Namespace == namespaceName);<br><br>            <span class="hljs-comment">// 遍历每个类型</span><br>            <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> type <span class="hljs-keyword">in</span> typesInNamespace)<br>            &#123;<br>                <span class="hljs-comment">// 查找类型实现的接口</span><br>                <span class="hljs-keyword">var</span> interfaceType = type.GetInterfaces()<br>                    .FirstOrDefault(i =&gt; i.Name == <span class="hljs-string">$&quot;I<span class="hljs-subst">&#123;type.Name&#125;</span>&quot;</span>);<br><br>                <span class="hljs-comment">// 如果找到了匹配的接口</span><br>                <span class="hljs-keyword">if</span> (interfaceType != <span class="hljs-literal">null</span>)<br>                &#123;<br>                    <span class="hljs-comment">// 将接口和实现类注册为 scoped 服务</span><br>                    services.AddScoped(interfaceType, type);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> services;<br>    &#125;<br><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> 自动注册 DAO 层中的所有服务。</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;services&quot;&gt;</span>服务集合。<span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;assembly&quot;&gt;</span>包含 DAO 类的程序集。<span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span>配置后的服务集合。<span class="hljs-doctag">&lt;/returns&gt;</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IServiceCollection <span class="hljs-title">AddDaoServices</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> IServiceCollection services, Assembly assembly</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// 获取程序集中的所有命名空间</span><br>        <span class="hljs-keyword">var</span> namespaces = GetNamespaces(assembly);<br><br>        <span class="hljs-comment">// 遍历每个命名空间</span><br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> namespaceName <span class="hljs-keyword">in</span> namespaces)<br>        &#123;<br>            <span class="hljs-comment">// 获取当前命名空间下的所有类型</span><br>            <span class="hljs-keyword">var</span> typesInNamespace = assembly.GetTypes()<br>                .Where(type =&gt; type.Namespace == namespaceName);<br><br>            <span class="hljs-comment">// 遍历每个类型</span><br>            <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> type <span class="hljs-keyword">in</span> typesInNamespace)<br>            &#123;<br>                <span class="hljs-comment">// 查找类型实现的接口</span><br>                <span class="hljs-keyword">var</span> interfaceType = type.GetInterfaces()<br>                    .FirstOrDefault(i =&gt; i.Name == <span class="hljs-string">$&quot;I<span class="hljs-subst">&#123;type.Name&#125;</span>&quot;</span>);<br><br>                <span class="hljs-comment">// 如果找到了匹配的接口</span><br>                <span class="hljs-keyword">if</span> (interfaceType != <span class="hljs-literal">null</span>)<br>                &#123;<br>                    <span class="hljs-comment">// 将接口和实现类注册为 scoped 服务</span><br>                    services.AddScoped(interfaceType, type);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> services;<br>    &#125;<br><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> 获取程序集中的所有命名空间。</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;assembly&quot;&gt;</span>要检查的程序集。<span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span>包含所有命名空间的集合。<span class="hljs-doctag">&lt;/returns&gt;</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> IEnumerable&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">GetNamespaces</span>(<span class="hljs-params">Assembly assembly</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> namespaces = <span class="hljs-keyword">new</span> HashSet&lt;<span class="hljs-built_in">string</span>&gt;();<br><br>        <span class="hljs-comment">// 遍历程序集中的所有类型</span><br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> type <span class="hljs-keyword">in</span> assembly.GetTypes())<br>        &#123;<br>            <span class="hljs-comment">// 添加类型所属的命名空间</span><br>            namespaces.Add(type.Namespace);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> namespaces;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="Program-cs"><a href="#Program-cs" class="headerlink" title="Program.cs"></a>Program.cs</h3><p>将Service层和Dao层的程序集作为参数传入到扩展方法</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">builder.Services.AddServices(<span class="hljs-keyword">typeof</span>(EmployeeService).Assembly);<br>builder.Services.AddDaoServices(<span class="hljs-keyword">typeof</span>(EmployeeDaoService).Assembly);<br></code></pre></td></tr></table></figure><hr><h3 id="EntityConfig"><a href="#EntityConfig" class="headerlink" title="EntityConfig"></a>EntityConfig</h3><p>在EFCore中，我们在OnModelCreating方法中会以FluentAPI的方式配置实体类属性和数据表的关系</p><p>如果实体类过多，在DBContext文件中代码会过长的问题</p><p>在之前讲过，我们可以通过继承IEntityTypeConfiguration&lt;&gt;的方式来为实体类编写配置文件解决这个问题</p><p>在OnModelCreating方法中，我们仍然可以通过程序集的方式直接批量注册FluentAPI的配置文件</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">modelBuilder.ApplyConfigurationsFromAssembly(<span class="hljs-keyword">this</span>.GetType().Assembly);<br></code></pre></td></tr></table></figure><hr><h3 id="DbSet注册"><a href="#DbSet注册" class="headerlink" title="DbSet注册"></a>DbSet注册</h3><p>我们需要在DbContext中注册每一个实体类，从而可以通过DbContext操作表</p><p>通过程序集反射，可以实现批量注册DbSet的操作</p><h5 id="IEntityBase"><a href="#IEntityBase" class="headerlink" title="IEntityBase"></a>IEntityBase</h5><p>定义一个接口，让所有的实体类实现这个接口</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 实体基类，方便程序集反射使用</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IEntityBase</span><br>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="OnModelCreatingPartial"><a href="#OnModelCreatingPartial" class="headerlink" title="OnModelCreatingPartial"></a>OnModelCreatingPartial</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnModelCreatingPartial</span>(<span class="hljs-params">ModelBuilder modelBuilder</span>)</span><br>&#123;<br>    <span class="hljs-comment">// 获取当前程序集</span><br>    <span class="hljs-keyword">var</span> assembly = Assembly.GetExecutingAssembly();<br><br>    <span class="hljs-comment">// 查找所有实现了 IEntity 接口的类型</span><br>    <span class="hljs-keyword">var</span> entityTypes = assembly.GetTypes()<br>        .Where(t =&gt; t.IsClass &amp;&amp; !t.IsAbstract &amp;&amp; <span class="hljs-keyword">typeof</span>(IEntityBase).IsAssignableFrom(t));<br><br>    <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> entityType <span class="hljs-keyword">in</span> entityTypes)<br>    &#123;<br>        <span class="hljs-comment">// 注册 DbSet</span><br>        modelBuilder.Entity(entityType);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="GetDbSet"><a href="#GetDbSet" class="headerlink" title="GetDbSet"></a>GetDbSet</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 泛型方法，用于动态获取 DbSet</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DbSet</span>&lt;<span class="hljs-title">TEntity</span>&gt; <span class="hljs-title">GetDbSet</span>&lt;<span class="hljs-title">TEntity</span>&gt;() <span class="hljs-keyword">where</span> TEntity : <span class="hljs-keyword">class</span>, IEntityBase</span><br>&#123;<br>    <span class="hljs-keyword">return</span> Set&lt;TEntity&gt;();<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h5><p>至此，我们就实现好了DbSet的注册和获取流程，在Dao层直接通过DBContext对象调用GetDbSet()方法即可</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">var</span> data = _dbContext.GetDbSet&lt;xiaobai_cangqiong_Storage.Entity.User&gt;().Where(u =&gt; u.Openid == openid);<br><span class="hljs-comment">// var data = _dbContext.User.Where(u =&gt; u.Openid == openid);</span><br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>NET框架相关</category>
      
      <category>net</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>WebAPI-中间件</title>
    <link href="/2024/10/11/WebAPI-%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    <url>/2024/10/11/WebAPI-%E4%B8%AD%E9%97%B4%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="WebAPI-中间件"><a href="#WebAPI-中间件" class="headerlink" title="WebAPI-中间件"></a>WebAPI-中间件</h1><p>ASP.NETCore中，filter的概念更像是一个面向AOP编程的增强类</p><p>而ASP.NETCore中间件的概念，更像是JavaWeb的Filter或者是SpringMVC中的拦截器一样</p><p>需要注意的是，Java中也有中间件的概念，不过更多指的是Tomcat或Redis这一类的应用服务</p><p>大部分时间，我们极少需要自己定义中间件，一般都使用框架定义好的中间件，所以对框架提供的中间件要熟悉，另外要熟悉HttpContext对象的常用成员</p><hr><h3 id="Map管道"><a href="#Map管道" class="headerlink" title="Map管道"></a>Map管道</h3><p>在启动类中，我们可以见到很多app.Use方法来定义的中间件</p><p>在这里，我们可以使用Map来自定义<code>管道</code>，实现不同的http请求路径而使用不同的中间件</p><p>定义在Map管道之外的中间件，则应用于所有请求</p><p>除了Map方法之外，还有MapGet、MapPost、MapWhen等指定管道的方法，但实际项目中，如果不是开发框架，比较少用到Map</p><p><strong>中间件的注册顺序很重要</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] <span class="hljs-keyword">args</span></span>)</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> builder = WebApplication.CreateBuilder(<span class="hljs-keyword">args</span>);<br>        <span class="hljs-keyword">var</span> app = builder.Build();<br><br>        <span class="hljs-comment">// 指定处理“/test”路径请求的管道 </span><br>        app.Map(<span class="hljs-string">&quot;/test&quot;</span>, <span class="hljs-keyword">async</span> testBuilder =&gt;<br>        &#123;<br>            <span class="hljs-comment">// 第一个中间件</span><br>            testBuilder.Use(<span class="hljs-keyword">async</span> (context, next) =&gt;<br>            &#123;<br>                context.Response.ContentType = <span class="hljs-string">&quot;text/html&quot;</span>;<br>                <span class="hljs-keyword">await</span> context.Response.WriteAsync(<span class="hljs-string">&quot;1 Start&lt;br/&gt;&quot;</span>);<br>                <span class="hljs-keyword">await</span> next.Invoke();<br>                <span class="hljs-keyword">await</span> context.Response.WriteAsync(<span class="hljs-string">&quot;1 End&lt;br/&gt;&quot;</span>);<br>            &#125;);<br>            <span class="hljs-comment">// 第二个中间件</span><br>            testBuilder.Use(<span class="hljs-keyword">async</span> (context, next) =&gt;<br>            &#123;<br>                <span class="hljs-keyword">await</span> context.Response.WriteAsync(<span class="hljs-string">&quot;2 Start&lt;br/&gt;&quot;</span>);<br>                <span class="hljs-keyword">await</span> next.Invoke();<br>                <span class="hljs-keyword">await</span> context.Response.WriteAsync(<span class="hljs-string">&quot;2 End&lt;br/&gt;&quot;</span>);<br>            &#125;);<br>            <span class="hljs-comment">//Run终点</span><br>            testBuilder.Run(<span class="hljs-keyword">async</span> ctx =&gt; &#123; <span class="hljs-keyword">await</span> ctx.Response.WriteAsync(<span class="hljs-string">&quot;hello,it is run&lt;br/&gt;&quot;</span>); &#125;);<br>        &#125;);<br><br>        app.Run();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h5><p>每一次HTTP请求，框架会自动生成一个HttpContext类型的对象，称之为上下文，可以记录了请求路径、请求参数、请求客户端、响应报文、响应流、用户、自定义Items等信息。在中间件的前后逻辑和控制器中，均可以对HttpContext对象进行读写操作</p><hr><h5 id="Next"><a href="#Next" class="headerlink" title="Next"></a>Next</h5><p>在一个中间件中，有三部分组织，①前逻辑；②next方法；③后逻辑</p><p>HTTP请求到达服务器后，先由框架进行请求解析，然后进入第一个中间件，先执行前逻辑，然后由中间件自己决定是否执行next.Invoke()，如不执行，则请求中断，如执行，则请求进入下一个中间件</p><p>当Controller控制器方法执行之后，再逆向执行中间件进行响应处理</p><hr><h3 id="中间件类"><a href="#中间件类" class="headerlink" title="中间件类"></a>中间件类</h3><p>同样的，我们可以自定义中间件类，将中间件代码放入其中</p><p>中间件类是一个很普通的类，他不需要继承任何父类方法或实现任何接口，但这个类需要有一个构造方法，构造方法至少有一个RequestDelegate类型的参数</p><p>这个类型的参数对象（next）用来放行中间件，让其到达下一个中间件</p><p>这个类需要定义一个名字为Invoke或InvokeAsync的方法，方法至少有一个HttpContext类型的参数（context），其方法的返回值必须是Task类型</p><p>注：无论是中间件类还是Invoke方法，都可以通过DI来注入其他对象</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> Microsoft.AspNetCore.Http;<br><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Threading.Tasks;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">LoggingMiddleware</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> RequestDelegate _next;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LoggingMiddleware</span>(<span class="hljs-params">RequestDelegate next</span>)</span><br>    &#123;<br>        _next = next;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">InvokeAsync</span>(<span class="hljs-params">HttpContext context</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// 请求前的日志记录</span><br>        Console.WriteLine(<span class="hljs-string">$&quot;Request started: <span class="hljs-subst">&#123;context.Request.Method&#125;</span> <span class="hljs-subst">&#123;context.Request.Path&#125;</span>&quot;</span>);<br><br>        <span class="hljs-comment">// 调用下一个中间件</span><br>        <span class="hljs-keyword">await</span> _next(context);<br><br>        <span class="hljs-comment">// 响应后的日志记录</span><br>        Console.WriteLine(<span class="hljs-string">$&quot;Request completed with status code: <span class="hljs-subst">&#123;context.Response.StatusCode&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="注册中间件"><a href="#注册中间件" class="headerlink" title="注册中间件"></a>注册中间件</h5><p>需要注意的是，通过UseMiddleware&lt;&gt;方法注册自定义中间件，而不是Use方法</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] <span class="hljs-keyword">args</span></span>)</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> builder = WebApplication.CreateBuilder(<span class="hljs-keyword">args</span>);<br>        <span class="hljs-keyword">var</span> app = builder.Build();<br>       <br>        <span class="hljs-comment">// 通过UseMiddleware方法注册自定义中间件</span><br>        app.UseMiddleware&lt;TestMiddleware&gt;();<br><br>        app.Run();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="深度理解"><a href="#深度理解" class="headerlink" title="深度理解"></a>深度理解</h3><p>ASP.NETCore框架内置很多中间件，通过这些内置的中间件，我们可以快速的构建一个WebAPI甚至是MVC的架构</p><p>对于Filter（筛选器）而言，他们有一些相同点和不同点：</p><ul><li>中间件可以处理所有的请求，而Filter只能处理对控制器的请求</li><li>中间件运行在一个更底层、更抽象的级别</li><li>中间件和Filter可以完成很多相似的功能，例如：<ul><li>未处理异常中间件和未处理异常Filter</li><li>请求限流中间件和请求限流Filter</li></ul></li><li>优先选择使用中间件</li></ul><hr>]]></content>
    
    
    <categories>
      
      <category>NET框架相关</category>
      
      <category>net</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>WebAPI-Filter</title>
    <link href="/2024/10/10/WebAPI-Filter/"/>
    <url>/2024/10/10/WebAPI-Filter/</url>
    
    <content type="html"><![CDATA[<h1 id="WebAPI-Filter"><a href="#WebAPI-Filter" class="headerlink" title="WebAPI-Filter"></a>WebAPI-Filter</h1><h3 id="内置过滤器"><a href="#内置过滤器" class="headerlink" title="内置过滤器"></a>内置过滤器</h3><p>在ASP.NET Core中，过滤器（Filters）用于在执行控制器操作之前或之后执行特定的逻辑。它们是MVC管道的一部分，可以帮助开发者处理诸如验证请求、日志记录、异常处理等跨切面关注点。ASP.NET Core支持多种类型的过滤器，每种都有其特定的作用场景。以下是一些主要的过滤器类型及其用途：</p><ul><li><p>授权过滤器（Authorization Filters）</p><ul><li><p><strong>作用</strong>：这类过滤器最早运行，主要用于检查用户是否有权限访问给定的操作。</p></li><li><p><strong>示例</strong>：使用<code>[Authorize]</code>属性来确保只有经过身份验证的用户才能访问某个控制器或动作方法。</p></li></ul></li><li><p>资源过滤器（Resource Filters）</p><ul><li><p><strong>作用</strong>：这些过滤器在模型绑定之前运行，并且可以取消操作的执行。如果资源过滤器决定阻止请求，则不会执行模型绑定、操作过滤器或结果过滤器。</p></li><li><p><strong>示例</strong>：可以用来实现缓存逻辑，例如检查缓存中是否存在请求的数据，如果存在则直接返回缓存数据，不再执行后续操作。</p></li></ul></li><li><p>操作过滤器（Action Filters）</p></li><li><p><strong>作用</strong>：这类过滤器允许你在操作方法执行前或执行后进行干预。它们可以用来修改输入或输出参数。</p></li><li><p><strong>示例</strong>：验证模型状态，如果模型状态无效，则返回错误信息而不调用操作方法。</p></li><li><p>异常过滤器（Exception Filters）</p><ul><li><p><strong>作用</strong>：用于捕获并处理在整个MVC管道中发生的未处理异常。</p></li><li><p><strong>示例</strong>：可以用来记录异常信息，并向客户端返回友好的错误响应。</p></li></ul></li><li><p>结果过滤器（Result Filters）</p><ul><li><p><strong>作用</strong>：在操作执行完毕后，但在结果执行前后运行。它们可以用来修改操作的结果，比如修改视图或格式化响应。</p></li><li><p><strong>示例</strong>：压缩响应内容，或者添加特定的HTTP头信息。</p></li></ul></li></ul><hr><h3 id="自定义过滤器"><a href="#自定义过滤器" class="headerlink" title="自定义过滤器"></a>自定义过滤器</h3><p>自定义过滤器可以通过实现 <code>IFilterMetadata</code> 接口或继承预定义的过滤器类（如 <code>ActionFilterAttribute</code>、<code>ResultFilterAttribute</code>、<code>ExceptionFilterAttribute</code> 等）来创建</p><hr><h5 id="自定义操作过滤器"><a href="#自定义操作过滤器" class="headerlink" title="自定义操作过滤器"></a>自定义操作过滤器</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> Microsoft.AspNetCore.Mvc.Filters;<br><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SampleActionFilter</span> : <span class="hljs-title">ActionFilterAttribute</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnActionExecuting</span>(<span class="hljs-params">ActionExecutingContext context</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;SampleActionFilter: Action is about to execute.&quot;</span>);<br>        <span class="hljs-keyword">base</span>.OnActionExecuting(context);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnActionExecuted</span>(<span class="hljs-params">ActionExecutedContext context</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;SampleActionFilter: Action has executed.&quot;</span>);<br>        <span class="hljs-keyword">base</span>.OnActionExecuted(context);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码可以通过OnActionExecutionAsync方法实现</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> Microsoft.AspNetCore.Mvc.Filters;<br><span class="hljs-keyword">using</span> System.Threading.Tasks;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SampleActionFilter</span> : <span class="hljs-title">IAsyncActionFilter</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">OnActionExecutionAsync</span>(<span class="hljs-params">ActionExecutingContext context, ActionExecutionDelegate next</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// 在动作方法执行前执行的逻辑</span><br>        Console.WriteLine(<span class="hljs-string">&quot;SampleActionFilter: Action is about to execute.&quot;</span>);<br><br>        <span class="hljs-comment">// 调用下一个过滤器或动作方法</span><br>        <span class="hljs-keyword">var</span> resultContext = <span class="hljs-keyword">await</span> next();<br><br>        <span class="hljs-comment">// 在动作方法执行后执行的逻辑</span><br>        Console.WriteLine(<span class="hljs-string">&quot;SampleActionFilter: Action has executed.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="自定义异常过滤器"><a href="#自定义异常过滤器" class="headerlink" title="自定义异常过滤器"></a>自定义异常过滤器</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> Microsoft.AspNetCore.Mvc.Filters;<br><span class="hljs-keyword">using</span> Microsoft.AspNetCore.Mvc;<br><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SampleExceptionFilter</span> : <span class="hljs-title">ExceptionFilterAttribute</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnException</span>(<span class="hljs-params">ExceptionContext context</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;SampleExceptionFilter: Exception caught: <span class="hljs-subst">&#123;context.Exception.Message&#125;</span>&quot;</span>);<br><br>        context.Result = <span class="hljs-keyword">new</span> ObjectResult(<span class="hljs-keyword">new</span> &#123; error = <span class="hljs-string">&quot;An unexpected error occurred&quot;</span> &#125;)<br>        &#123;<br>            StatusCode = <span class="hljs-number">500</span><br>        &#125;;<br><br>        <span class="hljs-keyword">base</span>.OnException(context);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="注册过滤器"><a href="#注册过滤器" class="headerlink" title="注册过滤器"></a>注册过滤器</h3><p>无论是内置过滤器或自定义过滤器都可以通过 <code>services.AddMvc</code> 或 <code>services.AddControllersWithViews</code> 方法中的 <code>options.Filters</code> 属性进行注册</p><ul><li><p><strong>全局注册</strong>：在 <code>Startup.cs</code> 或 <code>Program.cs</code> 中全局注册过滤器。</p></li><li><p><strong>控制器级别注册</strong>：在控制器类上使用属性来注册过滤器。</p></li><li><p><strong>动作级别注册</strong>：在控制器的动作方法上使用属性来注册过滤器。</p></li></ul><p>有三种添加全局过滤器的方式</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// AddMvc方式</span><br>builder.Services.AddMvc(options =&gt;<br>&#123;<br>    options.Filters.Add&lt;SampleActionFilter&gt;();<br>&#125;);<br><br><span class="hljs-comment">// AddControllersWithViews方式</span><br>builder.Services.AddControllersWithViews(options =&gt;<br>&#123;<br>    options.Filters.Add&lt;SampleActionFilter&gt;();<br>&#125;);<br><br><span class="hljs-comment">// Configure&lt;MvcOptions&gt;方式</span><br>builder.Services.Configure&lt;MvcOptions&gt;(options =&gt;<br>&#123;<br>    options.Filters.Add&lt;SampleActionFilter&gt;();<br>&#125;);<br></code></pre></td></tr></table></figure><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>ASP.NET Core 和JavaWeb项目中的过滤器不同，这里的过滤器更像是一个跟生命周期钩子有关的AOP（面向切面编程）的一个增强类，通过不同的注册方式来服务于Controller层的日志记录、异常处理、权限验证等功能</p><p>例如，我们可以通过操作过滤器（Action Filters）来实现SpringAOP的功能，在具体实现代码的前后做一些切面操作</p><hr>]]></content>
    
    
    <categories>
      
      <category>NET框架相关</category>
      
      <category>net</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>WebAPI-配置</title>
    <link href="/2024/10/09/WebAPI-%E9%85%8D%E7%BD%AE/"/>
    <url>/2024/10/09/WebAPI-%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="WebAPI-配置"><a href="#WebAPI-配置" class="headerlink" title="WebAPI-配置"></a>WebAPI-配置</h1><p>ASP.NET Core 按照以下顺序加载配置源，后面的配置源可以覆盖前面的配置源：</p><ul><li><p><strong><code>appsettings.json</code></strong></p></li><li><p><strong><code>appsettings.&#123;Environment&#125;.json</code></strong></p></li><li><p><strong><code>secrets.json</code></strong>（仅限开发环境）</p></li><li><p><strong>环境变量</strong></p></li><li><p><strong>命令行参数</strong></p></li></ul><hr><h3 id="ASPNETCORE-ENVIRONMENT"><a href="#ASPNETCORE-ENVIRONMENT" class="headerlink" title="ASPNETCORE_ENVIRONMENT"></a>ASPNETCORE_ENVIRONMENT</h3><p>运行环境：ASP.NET Core会从环境变量中读取名字为ASPNETCORE_ENVIRONMENT的值，从而读取相应的配置文件（appsetting.json）</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">Environment.GetEnvironmentVariable(<span class="hljs-string">&quot;ASPNETCORE_ENVIRONMENT&quot;</span>)<br></code></pre></td></tr></table></figure><p>除了可以在系统的环境变量中配置此项之外，还可以直接在ide中配置启动时的环境变量</p><p>而ide会从launchSettings.json文件中读取来定义项目在开发环境中的启动配置，其中就包含了<code>environmentVariables</code>一项</p><p>此项定义的环境变量，会被ide加载，在启动时应用</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;WebAPI&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;commandName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Project&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;dotnetRunMessages&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;launchBrowser&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;launchUrl&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;swagger&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;applicationUrl&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;https://localhost:7066;http://localhost:5117&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;environmentVariables&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;ASPNETCORE_ENVIRONMENT&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Development&quot;</span> <span class="hljs-comment">// 启动时使用Development配置文件启动</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>综上，我总结了三种配置环境变量的方式</p><ul><li>系统中配置环境变量</li><li>在开发时，通过ide配置环境变量（会读取launchSettings.json中的内容）</li><li>在Gitlab的CI中，配置项目启动的环境变量</li></ul><hr><h3 id="IWebHostEnvironment"><a href="#IWebHostEnvironment" class="headerlink" title="IWebHostEnvironment"></a>IWebHostEnvironment</h3><p><code>IWebHostEnvironment</code> 接口在 ASP.NET Core 中用于提供有关当前托管环境的信息，例如环境名称（如开发、生产、测试等）</p><ul><li><p><strong>获取环境名称</strong>：通过 <code>EnvironmentName</code> 属性获取当前环境的名称。</p></li><li><p><strong>访问内容根目录</strong>：通过 <code>ContentRootPath</code> 属性获取应用的内容根目录路径。</p></li><li><p><strong>访问 Web 根目录</strong>：通过 <code>WebRootPath</code> 属性获取应用的 Web 根目录路径</p></li></ul><p>无论是在Program还是其他文件中，我们只需要将IWebHostEnvironment注入，即可直接获取想要的内容</p><p>IHostEnvironment 是 ASP.NET Core 3.0 及之后版本中引入的接口，用于替代 IWebHostEnvironment</p><hr><h3 id="secrets-json"><a href="#secrets-json" class="headerlink" title="secrets.json"></a>secrets.json</h3><p>在开发过程中，如果使用appsetting.json的文件配置方式来配置一些应用的账号和密码，然后上传到github上，会导致非常严重的安全问题</p><p>这时我们可以使用secrets.json来保存我们的文件配置</p><hr><h3 id="数据库配置"><a href="#数据库配置" class="headerlink" title="数据库配置"></a>数据库配置</h3><p>在之前的项目中，数据库服务的配置方式是通过DbContext文件中，直接使用明文字符串进行配置</p><p>我们可以在Program.cs文件中，利用配置文件的方式直接进行配置</p><h5 id="program-cs"><a href="#program-cs" class="headerlink" title="program.cs"></a>program.cs</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#">builder.Services.AddDbContext&lt;DBContext&gt;(option =&gt;<br>&#123;<br>    <span class="hljs-keyword">var</span> str = builder.Configuration.GetValue&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-string">&quot;ConnectionStrings:DefaultConnection&quot;</span>);<br>    option.UseNpgsql(str);<br>&#125;);<br></code></pre></td></tr></table></figure><hr><h5 id="DbContext"><a href="#DbContext" class="headerlink" title="DbContext"></a>DbContext</h5><p>需要注入的是，必须将DbContextOptions作为构造函数的形参注入到DBContext中，并将对象options传给父类DbContext的构造函数中调用</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DBContext</span>:<span class="hljs-title">DbContext</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DBContext</span>(<span class="hljs-params">DbContextOptions options</span>) : <span class="hljs-title">base</span>(<span class="hljs-params">options</span>)</span><br>    &#123;<br>    &#125;<br><br>    DbSet&lt;Person&gt; Persons &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>配置好后，就可以直接在服务层注入DBContext依赖，并直接调用</p><hr>]]></content>
    
    
    <categories>
      
      <category>NET框架相关</category>
      
      <category>net</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>WebAPI-Program</title>
    <link href="/2024/10/09/WebAPI-Program/"/>
    <url>/2024/10/09/WebAPI-Program/</url>
    
    <content type="html"><![CDATA[<h1 id="WebAPI-Program"><a href="#WebAPI-Program" class="headerlink" title="WebAPI-Program"></a>WebAPI-Program</h1><p>在 ASP.NET Core 中，程序的入口点通常是在 <code>Program.cs</code> 文件中定义的，这个文件负责配置和启动 Web 应用程序</p><p><code>Program.cs</code> 文件中的主要对象是 <code>WebApplicationBuilder</code> 和 <code>WebApplication</code>，这两个对象分别用于配置和构建应用程序</p><hr><h3 id="WebApplicationBuilder"><a href="#WebApplicationBuilder" class="headerlink" title="WebApplicationBuilder"></a>WebApplicationBuilder</h3><p><code>WebApplicationBuilder</code> 是用于配置应用程序的构建器对象。它提供了一种集中配置应用程序的方式，包括配置服务、中间件、主机和环境等。</p><ul><li><strong><code>Configuration</code></strong>：获取或设置配置提供程序。</li><li><strong><code>Environment</code></strong>：获取当前的 <code>IWebHostEnvironment</code> 对象，用于访问环境信息。</li><li><strong><code>Services</code></strong>：获取 <code>IServiceCollection</code>，用于注册服务。</li><li><strong><code>Build()</code></strong>：构建 <code>WebApplication</code> 实例。</li></ul><hr><h3 id="WebApplication"><a href="#WebApplication" class="headerlink" title="WebApplication"></a>WebApplication</h3><p><code>WebApplication</code> 是实际运行的应用程序实例。它负责配置和执行中间件管道，并处理 HTTP 请求。</p><h4 id="主要方法和属性"><a href="#主要方法和属性" class="headerlink" title="主要方法和属性"></a>主要方法和属性</h4><ul><li><strong><code>Environment</code></strong>：获取当前的 <code>IWebHostEnvironment</code> 对象。</li><li><strong><code>Use*</code> 方法</strong>：用于配置中间件，例如 <code>UseRouting</code>、<code>UseEndpoints</code>、<code>UseAuthentication</code> 等。</li><li><strong><code>Run()</code></strong>：启动应用程序并开始监听传入的请求。</li></ul><hr><h3 id="NET不同版本"><a href="#NET不同版本" class="headerlink" title=".NET不同版本"></a>.NET不同版本</h3><p>需要注意的是，在.NET 6和.NET Core 3.1中，程序的入口（Program）是调用了不同的方法来启动ASP.NET项目</p><h5 id="NET-Core-3-1"><a href="#NET-Core-3-1" class="headerlink" title=".NET Core 3.1"></a>.NET Core 3.1</h5><p>.NET Core 3.1调用了CreateHostBuilder方法来初始化项目</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c#"> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] <span class="hljs-keyword">args</span></span>)</span><br>&#123;<br>    CreateHostBuilder(<span class="hljs-keyword">args</span>).Build().Run();<br>&#125;<br><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 创建Host</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;args&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span><span class="hljs-doctag">&lt;/returns&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IHostBuilder <span class="hljs-title">CreateHostBuilder</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] <span class="hljs-keyword">args</span></span>)</span> =&gt;<br>    Host.CreateDefaultBuilder(<span class="hljs-keyword">args</span>)<br>        .ConfigureAppConfiguration((builder, config) =&gt; &#123; GetSMSelectConfiguration(config, Configuration); &#125;)<br>        .ConfigureWebHostDefaults(webBuilder =&gt; &#123; webBuilder.UseStartup&lt;Startup&gt;(); &#125;)<br>        .ConfigureDynamicInterceptor()<br>        .UseNLog();<br></code></pre></td></tr></table></figure><hr><h5 id="NET-6"><a href="#NET-6" class="headerlink" title=".NET 6"></a>.NET 6</h5><p>.NET 6调用了WebApplication</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] <span class="hljs-keyword">args</span></span>)</span><br>&#123;<br>    <span class="hljs-keyword">var</span> builder = WebApplication.CreateBuilder(<span class="hljs-keyword">args</span>);<br>    builder.Configuration.AddJsonFile(<span class="hljs-string">$&quot;appsettings.<span class="hljs-subst">&#123;builder.Environment.EnvironmentName&#125;</span>.json&quot;</span>, <span class="hljs-literal">true</span>)<br>                         .AddEnvironmentVariables();<br>    AddSmSelectConfiguration(builder.Configuration, builder.Configuration);<br><br>    <span class="hljs-keyword">var</span> startUp = <span class="hljs-keyword">new</span> Startup(builder.Configuration, builder.Environment);<br>    <span class="hljs-comment">//注入服务</span><br>    startUp.ConfigureServices(builder.Services);<br><br>    <span class="hljs-comment">// 在创建 Host 之前设置</span><br>    AppContext.SetSwitch(<span class="hljs-string">&quot;Npgsql.EnableLegacyTimestampBehavior&quot;</span>, <span class="hljs-literal">true</span>);<br><br>    <span class="hljs-comment">//配置nlog</span><br>    builder.WebHost.UseNLog();<br><br>    <span class="hljs-comment">//构建WebApplication</span><br>    <span class="hljs-keyword">var</span> app = builder.Build();<br><br>    <span class="hljs-comment">//配置管道</span><br>    startUp.Configure(app);<br><br>    <span class="hljs-comment">//运行WebApplication</span><br>    app.Run();<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="Startup-cs"><a href="#Startup-cs" class="headerlink" title="Startup.cs"></a>Startup.cs</h3><p>在ASP.NET Core中，<code>Startup.cs</code> 文件是一个非常重要的文件，它用于配置应用程序的启动过程。<code>Startup.cs</code> 文件中的 <code>Startup</code> 类包含两个主要方法：<code>ConfigureServices</code> 和 <code>Configure</code>。这两个方法分别用于配置应用程序的服务和中间件。</p><p>在 .NET 6.0 中，ASP.NET Core 引入了一种新的简化启动模式，称为“最小API”（Minimal API）。这种新模式旨在减少样板代码，使应用程序的启动配置更加简洁和直观。因此，传统的 <code>Startup.cs</code> 文件在 .NET 6.0 中被取消了，取而代之的是在 <code>Program.cs</code> 文件中直接配置服务和中间件</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Startup</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Startup</span>(<span class="hljs-params">IConfiguration configuration</span>)</span><br>    &#123;<br>        Configuration = configuration;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> IConfiguration Configuration &#123; <span class="hljs-keyword">get</span>; &#125;<br><br>    <span class="hljs-comment">// This method gets called by the runtime. Use this method to add services to the container.</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ConfigureServices</span>(<span class="hljs-params">IServiceCollection services</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// Register services here</span><br>    &#125;<br><br>    <span class="hljs-comment">// This method gets called by the runtime. Use this method to configure the HTTP request pipeline.</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Configure</span>(<span class="hljs-params">IApplicationBuilder app, IWebHostEnvironment env</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// Configure the HTTP request pipeline here</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="ConfigureServices"><a href="#ConfigureServices" class="headerlink" title="ConfigureServices"></a>ConfigureServices</h5><p><code>ConfigureServices</code> 方法用于配置应用程序的服务。这些服务可以是任何需要通过依赖注入（Dependency Injection, DI）容器管理的对象，包括数据库上下文、业务逻辑类、第三方库等。</p><ul><li><p><strong>注册服务</strong>：将服务注册到DI容器中，以便在应用程序的其他部分通过构造函数、属性或方法注入使用。</p></li><li><p><strong>配置选项</strong>：设置应用程序的各种配置选项，如数据库连接字符串、日志记录配置等。</p></li><li><p><strong>添加框架服务</strong>：注册MVC、身份验证、信号R等框架服务。</p></li></ul><hr><h5 id="Configure"><a href="#Configure" class="headerlink" title="Configure"></a>Configure</h5><p><code>Configure</code> 方法用于配置应用程序的请求处理管道。通过在这个方法中注册中间件，你可以定义HTTP请求如何被处理。</p><ol><li><strong>注册中间件</strong>：将中间件组件添加到请求处理管道中，以便它们可以在请求到达最终处理程序（如控制器）之前或之后执行特定的逻辑。</li><li><strong>配置中间件顺序</strong>：中间件的执行顺序由它们在 <code>Configure</code> 方法中的注册顺序决定。先注册的中间件会先处理请求，后注册的中间件会后处理请求。</li><li><strong>设置路由</strong>：定义应用程序的路由规则，以便将请求映射到相应的控制器和动作。</li></ol><hr><h3 id="MapControllers"><a href="#MapControllers" class="headerlink" title="MapControllers"></a>MapControllers</h3><p>在 .NET 6.0 及更高版本中，ASP.NET Core 的中间件配置有所简化。特别是，UseRouting 和 UseEndpoints 方法被合并到了 MapControllers 和其他 Map 方法中。这使得配置更加简洁和直观。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 这是.NetCore 3.1的写法</span><br><br>app.UseRouting(); <span class="hljs-comment">// 配置路由</span><br><br>app.UseAuthentication(); <span class="hljs-comment">// 配置身份验证</span><br>app.UseAuthorization(); <span class="hljs-comment">// 配置授权</span><br><br>app.UseEndpoints(endpoints =&gt;<br>&#123;<br>    endpoints.MapControllerRoute(<br>        name: <span class="hljs-string">&quot;default&quot;</span>,<br>        pattern: <span class="hljs-string">&quot;&#123;controller=Home&#125;/&#123;action=Index&#125;/&#123;id?&#125;&quot;</span>);<br>&#125;);<br><br><br><span class="hljs-comment">// 这是.NET 6.0的写法</span><br><br>app.UseAuthentication();<br>app.UseAuthorization();<br><br>app.MapControllers();<br></code></pre></td></tr></table></figure><p>在 .NET 6.0 及更高版本中，MapControllers 方法不仅映射了控制器路由，还隐式地包含了路由和终结点的配置。这意味着你不再需要显式调用 UseRouting 和 UseEndpoints，因为 MapControllers 会自动处理这些步骤</p>]]></content>
    
    
    <categories>
      
      <category>NET框架相关</category>
      
      <category>net</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>WebAPI-缓存</title>
    <link href="/2024/10/09/WebAPI-%E7%BC%93%E5%AD%98/"/>
    <url>/2024/10/09/WebAPI-%E7%BC%93%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h1 id="WebAPI-缓存"><a href="#WebAPI-缓存" class="headerlink" title="WebAPI-缓存"></a>WebAPI-缓存</h1><h3 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h3><p>使用[ResponseCache(Duration &#x3D; 60)]特性允许浏览器缓存服务器响应的页面信息60s</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#">[<span class="hljs-meta">HttpGet</span>]<br>[<span class="hljs-meta">ResponseCache(Duration = 60)</span>]<br><span class="hljs-function"><span class="hljs-keyword">public</span> IActionResult <span class="hljs-title">GetWeatherForecast</span>()</span><br>&#123;<br>    <span class="hljs-keyword">return</span> Ok();<br>&#125;<br></code></pre></td></tr></table></figure><p>除了允许在客户端缓存页面，我们可以通过使用<code>响应缓存中间件</code>来配置服务端的缓存</p><p>需要在program.cs文件中配置响应缓存中间件</p><p>*这个中间件比较鸡肋，实际开发中也几乎用不上，更多的是采用内存缓存或分布式缓存等*</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#">app.UseAuthorization();<br><br><span class="hljs-comment">// 启动服务器端缓存，需要在MapControllers之前完成配置</span><br>app.UseResponseCaching();<br><br>app.MapControllers();<br><br>app.Run();<br></code></pre></td></tr></table></figure><hr><h3 id="内存缓存"><a href="#内存缓存" class="headerlink" title="内存缓存"></a>内存缓存</h3><p>在program.cs文件中添加内存缓存服务</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">builder.Services.AddMemoryCache();<br></code></pre></td></tr></table></figure><p>在控制器中注册服务，并使用缓存</p><p>通过调用GetOrCreate方法从缓存中获取数据，如果数据不存在则生成数据并缓存</p><p>当我们对数据库的数据进行操作时，我们可以选择调用Remove或者Set方法来操作或删除缓存中的数据</p><p>也可以配置缓存的过期时间，只要过期时间短，缓存数据不一致的情况不会持续很长时间</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c#">[<span class="hljs-meta">ApiController</span>]<br>[<span class="hljs-meta">Route(<span class="hljs-string">&quot;api/[controller]&quot;</span>)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">WeatherForecastController</span> : <span class="hljs-title">ControllerBase</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> IMemoryCache _memoryCache;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WeatherForecastController</span>(<span class="hljs-params">IMemoryCache memoryCache</span>)</span><br>    &#123;<br>        _memoryCache = memoryCache;<br>    &#125;<br><br>    [<span class="hljs-meta">HttpGet</span>]<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task&lt;IActionResult&gt; <span class="hljs-title">Get</span>(<span class="hljs-params"><span class="hljs-built_in">long</span> id</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// 缓存键</span><br>        <span class="hljs-built_in">string</span> cacheKey = <span class="hljs-string">&quot;WeatherForecast&quot;</span> + id;<br><br>        <span class="hljs-comment">// 使用 GetOrCreate 方法从缓存中获取数据，如果不存在则生成数据并缓存</span><br>        <span class="hljs-keyword">var</span> weatherForecasts = <span class="hljs-keyword">await</span> _memoryCache.GetOrCreateAsync(cacheKey, <span class="hljs-keyword">async</span> entry =&gt;<br>        &#123;<br>            <span class="hljs-comment">// 设置缓存项的过期策略</span><br>            entry.SlidingExpiration = TimeSpan.FromMinutes(<span class="hljs-number">5</span>);<br><br>            <span class="hljs-comment">// 从数据源获取数据</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> FetchWeatherForecastsFromDataSource();<br>        &#125;);<br><br>        <span class="hljs-keyword">return</span> Ok(weatherForecasts);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>对于恶意用户，访问一个不存在的缓存key，内存缓存会一直查询数据库，会给数据库造成很大的压力，这种现象被称之为缓存穿透</p><p>解决方案就是将数据查不到（null）也作为缓存结果存放在缓存中</p><p>调用GetOrCreateAsync方法，即可避免缓存穿透的问题</p><hr><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>如果在请求频繁的时，缓存过期，会造成同一时间对数据库大量查询，造成缓存雪崩</p><p>解决方案就是在基础的过期时间之上，加入随机过期时间，让缓存不在统一时间内被清空，这样就不会一瞬间对数据库发送大量的查询请求</p><hr><h3 id="缓存数据混乱"><a href="#缓存数据混乱" class="headerlink" title="缓存数据混乱"></a>缓存数据混乱</h3><p>当缓存中的Key冲突时，缓存中的value就会出现数据混乱</p><p>所以将Key设置为唯一值，即可解决这个问题，通常我们将key+唯一Id命名</p><hr><h3 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h3><p>当Web服务被部署到多个服务器中，我们需要统一的调配同一个缓存，这时，继续使用内存缓存就不是最好的选择了</p><p>我们将缓存独立出来，放到一台单独的服务器中，所有的Web服务都来调配这台服务器的缓存，即可完成分布式缓存服务器</p><p>.NET Core提供了统一的分布式缓存服务器的操作接口IDistributedCache，用法和内存缓存类似</p><p>微软官方发布了针对于Redis数据库支持的包，在实际项目中我们也是使用Redis进行数据缓存</p><p><em>在实际开发中，公司已经将相关框架封装完成</em></p><hr><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><blockquote><p>安装依赖：Microsoft.Extensions.Caching.StackExchangeRedis</p></blockquote><hr><h5 id="注册服务"><a href="#注册服务" class="headerlink" title="注册服务"></a>注册服务</h5><p>在program.cs中注册服务，并使用系统环境变量的方式配置Redis链接字符串</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#">builder.Services.AddStackExchangeRedisCache(option =&gt;<br>&#123;<br>    option.Configuration = Environment.GetEnvironmentVariable(<span class="hljs-string">&quot;REDIS_CONNECTION_STRING&quot;</span>);<br>    <span class="hljs-comment">// 设置Redis中Key的前缀</span><br>    option.InstanceName = <span class="hljs-string">&quot;cache1_&quot;</span>;<br>&#125;);<br></code></pre></td></tr></table></figure><hr><h5 id="注入依赖"><a href="#注入依赖" class="headerlink" title="注入依赖"></a>注入依赖</h5><p>在控制器或Service中注入依赖，直接使用即可</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c#">[<span class="hljs-meta">ApiController</span>]<br>[<span class="hljs-meta">Route(<span class="hljs-string">&quot;[controller]&quot;</span>)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">WeatherForecastController</span> : <span class="hljs-title">ControllerBase</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> IDistributedCache _distributedCache;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WeatherForecastController</span>(<span class="hljs-params">IDistributedCache distributedCache</span>)</span><br>    &#123;<br>        _distributedCache = distributedCache;<br>    &#125;<br><br>    [<span class="hljs-meta">HttpGet</span>]<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task&lt;IActionResult&gt; <span class="hljs-title">Get</span>(<span class="hljs-params"><span class="hljs-built_in">long</span> id</span>)</span><br>    &#123;<br>        Person? person;<br>        <span class="hljs-comment">// 在Redis中查询</span><br>        <span class="hljs-built_in">string</span>? s = <span class="hljs-keyword">await</span> _distributedCache.GetStringAsync(<span class="hljs-string">&quot;Person&quot;</span> + id);<br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span>)<br>        &#123;<br>            <span class="hljs-comment">// 查询数据库</span><br>            person = <span class="hljs-keyword">new</span> Person(); <span class="hljs-comment">// 实际上这个person储存数据库查询的结果</span><br>            <span class="hljs-comment">// 将查到的结果缓存并放到数据库中，因为Redis存放的数据类型为bite[] 所以将对象序列化为Json串存放</span><br>            _distributedCache.SetStringAsync(<span class="hljs-string">&quot;Person&quot;</span> + id, JsonSerializer.Serialize(person));<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">//如果缓存中查到，则将Json串反序列化为对象</span><br>            person = JsonSerializer.Deserialize&lt;Person?&gt;(s);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (person == <span class="hljs-literal">null</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span> NotFound(<span class="hljs-string">&quot;Person not found&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> Ok();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>NET框架相关</category>
      
      <category>net</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ASP.NET Core-WebAPI</title>
    <link href="/2024/10/08/ASP.NET%20Core-WebAPI/"/>
    <url>/2024/10/08/ASP.NET%20Core-WebAPI/</url>
    
    <content type="html"><![CDATA[<h1 id="ASP-NET-Core-WebAPI"><a href="#ASP-NET-Core-WebAPI" class="headerlink" title="ASP.NET Core-WebAPI"></a>ASP.NET Core-WebAPI</h1><h3 id="Swagger"><a href="#Swagger" class="headerlink" title="Swagger"></a>Swagger</h3><p><a href="https://learn.microsoft.com/zh-cn/aspnet/core/tutorials/getting-started-with-swashbuckle?view=aspnetcore-8.0&tabs=visual-studio">Swashbuckle 和 ASP.NET Core 入门 | Microsoft Learn</a></p><p>当我们创建好web API项目时，我们可以看到，项目默认存在一个软件包，其中就内置了Swagger的功能</p><hr><h3 id="Logging"><a href="#Logging" class="headerlink" title="Logging"></a>Logging</h3><p>ASP.NET Core 自带了一个日志记录框架，这个框架通过 <code>Microsoft.Extensions.Logging</code> 命名空间提供</p><p>这个命名空间包含了各种日志记录相关的接口和类，如 <code>ILogger</code> 和 <code>ILoggerFactory</code></p><hr><h3 id="DependencyInjection依赖注入"><a href="#DependencyInjection依赖注入" class="headerlink" title="DependencyInjection依赖注入"></a>DependencyInjection依赖注入</h3><p>DI的依赖也被框架所包含</p><p>Microsoft.Extensions.DependencyInjection</p><p>在Action方法中，我们可以单独为某一个方法注入存在于DI中的依赖，而不通过构造函数的方式来注入服务</p><p>这种方式适用于某一个服务的执行过程很漫长，在构造函数中，对象实例化都会执行，所以不放在构造函数中</p><p>通过[FromService]特性，在Action方法的参数中实现注入</p><p>这样操作后，只有在调用此方法时才会将依赖实例化的对象注入，而不是在构造方法执行时就进行实例化注入</p><hr><h5 id="构造方法注入"><a href="#构造方法注入" class="headerlink" title="构造方法注入"></a>构造方法注入</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> ILogger&lt;WeatherForecastController&gt; _logger;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WeatherForecastController</span>(<span class="hljs-params">ILogger&lt;WeatherForecastController&gt; logger</span>)</span><br>&#123;<br>    _logger = logger;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="参数注入"><a href="#参数注入" class="headerlink" title="参数注入"></a>参数注入</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#">[<span class="hljs-meta">HttpGet</span>]<br><span class="hljs-function"><span class="hljs-keyword">public</span> IActionResult <span class="hljs-title">GetWeatherForecast</span>(<span class="hljs-params">[FromServices] ILogger&lt;WeatherForecastController&gt; logger</span>)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> Ok();<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="Program-cs"><a href="#Program-cs" class="headerlink" title="Program.cs"></a>Program.cs</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">namespace</span> <span class="hljs-title">WebAPI</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] <span class="hljs-keyword">args</span></span>)</span><br>    &#123;<br>        <span class="hljs-comment">// 创建一个WebApplicationBuilder实例，用于配置应用程序。这个实例使用命令行参数初始化。</span><br>        <span class="hljs-keyword">var</span> builder = WebApplication.CreateBuilder(<span class="hljs-keyword">args</span>);<br><br>        <span class="hljs-comment">// 注册MVC控制器服务，使应用程序能够处理HTTP请求。</span><br>        builder.Services.AddControllers();<br><br>        <span class="hljs-comment">// 注册端点API探索器服务，用于生成API元数据，这些元数据可以被Swagger等工具使用。</span><br>        builder.Services.AddEndpointsApiExplorer();<br><br>        <span class="hljs-comment">// 注册Swagger生成器服务，用于生成Swagger文档，这些文档可以用来生成API文档和交互式API测试界面。</span><br>        builder.Services.AddSwaggerGen();<br><br>        <span class="hljs-comment">// 使用构建器创建一个配置好的WebApplication实例。</span><br>        <span class="hljs-keyword">var</span> app = builder.Build();<br><br>        <span class="hljs-comment">// 配置HTTP请求管道</span><br>        <span class="hljs-comment">// 如果应用程序处于开发环境，则启用Swagger和Swagger UI</span><br>        <span class="hljs-keyword">if</span> (app.Environment.IsDevelopment())<br>        &#123;<br>            app.UseSwagger();  <span class="hljs-comment">// 启用Swagger中间件，生成API文档</span><br>            app.UseSwaggerUI();  <span class="hljs-comment">// 启用Swagger UI界面，提供交互式API测试</span><br>        &#125;<br><br>        <span class="hljs-comment">// 启用HTTPS重定向中间件，将所有HTTP请求重定向到HTTPS</span><br>        app.UseHttpsRedirection();<br><br>        <span class="hljs-comment">// 启用授权中间件，处理授权逻辑，确保只有经过身份验证和授权的用户才能访问受保护的资源</span><br>        app.UseAuthorization();<br><br>        <span class="hljs-comment">// 注册MVC控制器路由，告诉应用程序如何处理控制器中的路由</span><br>        app.MapControllers();<br><br>        <span class="hljs-comment">// 启动应用程序，开始监听HTTP请求并处理它们</span><br>        app.Run();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><p>在Java中，一般返回值为集合时使用带泛型的List集合封装，但C#中使用IEnumerable进行封装</p><p><em>和MVC不同的是，WebAPI的Controller继承自ControllerBase，而不是Controller，因为Controller是基于ControllerBase增加了视图相关</em></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> Microsoft.AspNetCore.Mvc;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">WebAPI.Controllers</span>;<br><br>[<span class="hljs-meta">ApiController</span>]<br>[<span class="hljs-meta">Route(<span class="hljs-string">&quot;[controller]&quot;</span>)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">WeatherForecastController</span> : <span class="hljs-title">ControllerBase</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">string</span>[] Summaries = <span class="hljs-keyword">new</span>[]<br>    &#123;<br>        <span class="hljs-string">&quot;Freezing&quot;</span>, <span class="hljs-string">&quot;Bracing&quot;</span>, <span class="hljs-string">&quot;Chilly&quot;</span>, <span class="hljs-string">&quot;Cool&quot;</span>, <span class="hljs-string">&quot;Mild&quot;</span>, <span class="hljs-string">&quot;Warm&quot;</span>, <span class="hljs-string">&quot;Balmy&quot;</span>, <span class="hljs-string">&quot;Hot&quot;</span>, <span class="hljs-string">&quot;Sweltering&quot;</span>, <span class="hljs-string">&quot;Scorching&quot;</span><br>    &#125;;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> ILogger&lt;WeatherForecastController&gt; _logger;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WeatherForecastController</span>(<span class="hljs-params">ILogger&lt;WeatherForecastController&gt; logger</span>)</span><br>    &#123;<br>        _logger = logger;<br>    &#125;<br><br>    <span class="hljs-comment">// 在Java中，一般返回值为集合时使用带泛型的List集合封装，但C#中使用IEnumerable进行封装</span><br>    [<span class="hljs-meta">HttpGet(Name = <span class="hljs-string">&quot;GetWeatherForecast&quot;</span>)</span>]<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> IEnumerable&lt;WeatherForecast&gt; <span class="hljs-title">Get</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> Enumerable.Range(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>).Select(index =&gt; <span class="hljs-keyword">new</span> WeatherForecast<br>            &#123;<br>                Date = DateTime.Now.AddDays(index),<br>                TemperatureC = Random.Shared.Next(<span class="hljs-number">-20</span>, <span class="hljs-number">55</span>),<br>                Summary = Summaries[Random.Shared.Next(Summaries.Length)]<br>            &#125;)<br>            .ToArray();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>特性（Attributes）解释</p><ol><li><p><strong><code>[ApiController]</code></strong></p><ul><li><strong>含义</strong>：<code>[ApiController]</code> 是一个特性，用于标记控制器类，表明该控制器是用于处理Web API请求的。这个特性会启用一些特定的行为，例如：<ul><li><strong>模型验证</strong>：如果模型验证失败，会自动返回400 Bad Request响应。</li><li><strong>绑定源参数</strong>：自动处理绑定源参数，例如查询字符串、表单数据等。</li><li><strong>问题详细信息对象</strong>：在模型验证失败时，返回更详细的错误信息。</li><li><strong>异步支持</strong>：支持异步操作方法。</li></ul></li></ul></li><li><p><strong><code>[Route(&quot;[controller]&quot;)]</code></strong></p><ul><li><strong>含义</strong>：<code>[Route]</code> 特性用于定义路由模板。<code>[controller]</code> 是一个占位符，会被替换为控制器的名称（去掉“Controller”后缀）。例如，<code>WeatherForecastController</code> 的路由路径将是 <code>/weatherforecast</code>。</li><li><strong>用途</strong>：用于定义控制器的基路径，使得URL更加清晰和可预测。</li></ul></li><li><p><strong><code>[HttpGet(Name = &quot;GetWeatherForecast&quot;)]</code></strong></p><ul><li><p><strong>含义</strong>：<code>[HttpGet]</code> 特性用于标记一个方法，表示该方法处理HTTP GET请求。<code>Name</code> 参数用于给该路由起一个名字，可以在其他地方引用这个路由。</p></li><li><p><strong>用途</strong>：</p><ul><li><strong>HTTP动词</strong>：指定该方法只处理GET请求。</li><li><strong>命名路由</strong>：通过 <code>Name</code> 参数，可以在其他地方（如链接生成）引用这个路由</li></ul></li></ul></li></ol><hr><h5 id="Swagger的500错误"><a href="#Swagger的500错误" class="headerlink" title="Swagger的500错误"></a>Swagger的500错误</h5><p>当控制器存在一个没有特性修饰的public方法时，Swagger会报500错误</p><p>只需要将方法私有化，或者加上请求方式的特性修饰即可</p><hr><h3 id="Action方法"><a href="#Action方法" class="headerlink" title="Action方法"></a>Action方法</h3><ul><li><p>无论是MVC还是WebAPI中，Action方法既可以是同步，也可以是异步（异步的Action方法一般不需要以Async结尾）</p></li><li><p>Action方法的返回值如果为引用类型，则会被默认序列化为JSON格式</p></li><li><p>Action方法的返回值也可以是IActionResult类型</p></li><li><p>在WebAPI中，推荐使用IActionResult&lt;&gt;泛型方法，这个方法支持引用类型的序列化转换</p></li></ul><p><em>注：IActionResult使用起来和在Java中我们自封装的Result结果集很相似，但返回方法由ControllerBase提供</em></p><hr><h5 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h5><p>与Java相同，ASP.NET Core也有三种请求参数的方式</p><ul><li>路径参数</li><li>键值对参数</li><li>请求体参数</li></ul><p>如果是请求体参数，则框架会自动帮忙结构并赋值到对象，不需要使用@RequestBody类似的注解</p><p>如果是路径参数，[FromRoute]特性与@PathVariable注解功能相同</p><p>如果是键值对参数，[FromQuery]特性与@RequestParam注解功能相同</p><p>如果是请求体参数，[FromBody]特性与@RequestBody注解功能相同</p><p><em>除了FromRoute、FromQuery、FromBody之外，还有FromForm、FromHeader等</em></p><hr><h3 id="WebAPI的请求风格"><a href="#WebAPI的请求风格" class="headerlink" title="WebAPI的请求风格"></a>WebAPI的请求风格</h3><p>和SpringMVC相同，ASP.NET Core WebAPI也有两种请求风格：</p><ul><li>RPC</li><li>REST</li></ul><hr><h5 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h5><p>如果想强制实现RPC的URL风格，即让URL包含调用的具体方法名字，则需要在路由上加入action</p><p>这样在调用时，就需要使用控制器名&#x2F;方法名的方式来调用方法</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#">[<span class="hljs-meta">ApiController</span>]<br>[<span class="hljs-meta">Route(<span class="hljs-string">&quot;[controller]/[action]&quot;</span>)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">WeatherForecastController</span> : <span class="hljs-title">ControllerBase</span><br>&#123;<br>    ……<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h5><p>具体实现流程和SpringMVC相同，具体可以翻看前面的笔记，需要注意的就是其特别的<strong>路径传参</strong>的方式</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// PUT: api/WeatherForecast/5</span><br><span class="hljs-comment">// 路径传参方式</span><br>[<span class="hljs-meta">HttpPut(<span class="hljs-string">&quot;&#123;id&#125;&quot;</span>)</span>]<br><span class="hljs-function"><span class="hljs-keyword">public</span> IActionResult <span class="hljs-title">Put</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> id, WeatherForecast forecast</span>)</span><br>&#123;<br>    <span class="hljs-comment">// 处理PUT请求，更新现有的WeatherForecast对象</span><br>    <span class="hljs-keyword">return</span> NoContent();<br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>NET框架相关</category>
      
      <category>net</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ASP.NET Core</title>
    <link href="/2024/10/08/ASP.NET%20Core/"/>
    <url>/2024/10/08/ASP.NET%20Core/</url>
    
    <content type="html"><![CDATA[<h1 id="ASP-NET-Core"><a href="#ASP-NET-Core" class="headerlink" title="ASP.NET Core"></a>ASP.NET Core</h1><p>ASP 的全称是 <strong>Active Server Pages</strong></p><p>ASP.NET 是 Microsoft 开发的一个用于构建 Web 应用程序和 Web 服务的框架</p><p>它建立在 .NET 平台上，提供了丰富的工具和库，使得开发者可以更高效地创建高性能、可扩展和安全的 Web 应用程序</p><ul><li>ASP.NET Core时.NET中做Web开发的框架</li><li>ASP.NET Core MVC</li><li>ASP.NET Core Web API</li></ul><p>实质上MVC指的是前后端不分离的Web项目，而WebApI指的是前后端分离的MVC项目</p><hr><h3 id="Program和Startup"><a href="#Program和Startup" class="headerlink" title="Program和Startup"></a>Program和Startup</h3><h5 id="Program-类"><a href="#Program-类" class="headerlink" title="Program 类"></a><code>Program</code> 类</h5><ol><li><strong><code>Main</code> 方法</strong>：<ul><li>这是应用程序的入口点。</li><li>调用 <code>CreateHostBuilder</code> 方法创建主机构建器，然后构建并运行主机。</li></ul></li><li><strong><code>CreateHostBuilder</code> 方法</strong>：<ul><li>使用 <code>Host.CreateDefaultBuilder</code> 创建默认的主机构建器。</li><li>调用 <code>ConfigureWebHostDefaults</code> 方法配置 Web 主机。</li><li>使用 <code>UseStartup&lt;Startup&gt;</code> 指定 <code>Startup</code> 类作为配置类。</li></ul></li></ol><h5 id="Startup-类"><a href="#Startup-类" class="headerlink" title="Startup 类"></a><code>Startup</code> 类</h5><ol><li><strong><code>ConfigureServices</code> 方法</strong>：<ul><li>配置应用程序的服务。</li><li>使用 <code>IServiceCollection</code> 参数来注册服务。</li><li>例如，注册 MVC 服务、数据库上下文、身份验证服务等。</li></ul></li><li><strong><code>Configure</code> 方法</strong>：<ul><li>配置应用程序的请求管道。</li><li>使用 <code>IApplicationBuilder</code> 参数来添加中间件。</li><li>例如，添加开发者异常页面、静态文件服务、路由、身份验证、授权和终结点映射等。</li></ul></li></ol><hr><h1 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h1><h3 id="cshtml"><a href="#cshtml" class="headerlink" title="cshtml"></a>cshtml</h3><p>在ASP.NET Core MVC中，视图文件的后缀是.cshtml，这种文件不是纯粹的html文件，而是需要被框架渲染成为html文件后呈现给客户端</p><p>类似于Java中的JSP技术</p><p>在视图层，将控制器名作为目录名，将控制器方法名作为文件名</p><h5 id="Demo01-cshtml"><a href="#Demo01-cshtml" class="headerlink" title="Demo01.cshtml"></a>Demo01.cshtml</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 指定模型类型为Person，这样在页面中就可以直接使用@Model访问该模型 --&gt;</span><br>@model Person<br><br>@&#123;<br>    Layout = null;<br>&#125;<br><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 显示模型中的Name属性值 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>姓名：@Model.Name<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 显示模型中的Age属性值 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>年龄：@Model.Age<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><p>在ASP.NET Core MVC中，所有用户自定义Controller要继承Controller类，然后在Action（操作方法）中实现具体功能</p><h5 id="TestController-cs"><a href="#TestController-cs" class="headerlink" title="TestController.cs"></a>TestController.cs</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TestController</span> : <span class="hljs-title">Controller</span><br>&#123;<br>    <span class="hljs-comment">// GET</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> IActionResult <span class="hljs-title">Demo1</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Xiaobai&quot;</span>, <span class="hljs-number">18</span>);<br>        <br>        <span class="hljs-comment">// 将对象丢给视图，在和方法名字相同的模型中渲染这个对象</span><br>        <span class="hljs-keyword">return</span> View(person);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>NET框架相关</category>
      
      <category>net</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Csharp-新语法</title>
    <link href="/2024/10/08/Csharp-%E6%96%B0%E8%AF%AD%E6%B3%95/"/>
    <url>/2024/10/08/Csharp-%E6%96%B0%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Csharp-新语法"><a href="#Csharp-新语法" class="headerlink" title="Csharp-新语法"></a>Csharp-新语法</h1><h3 id="顶级语句"><a href="#顶级语句" class="headerlink" title="顶级语句"></a>顶级语句</h3><p>在 C# 9.0 及更高版本中，引入了顶级语句（Top-Level Statements）的概念</p><p>这使得编写简单的控制台应用程序变得更加简洁</p><p>顶级语句允许你在程序的入口点（通常是 <code>Main</code> 方法）中直接编写代码，而不需要显式地定义 <code>Main</code> 方法</p><p><em>注：在一个项目中只能有一个文件有顶级语句</em></p><p><em>注：在顶级语句中可以直接使用await关键字调用异步方法</em></p><hr><h3 id="全局using"><a href="#全局using" class="headerlink" title="全局using"></a>全局using</h3><p>在 C# 10.0 及更高版本中，引入了全局 <code>using</code> 指令</p><p>这使得你可以在一个项目文件中声明所有常用的命名空间，而无需在每个文件中重复这些 <code>using</code> 指令</p><p>这不仅可以减少代码冗余，还可以提高代码的可读性和维护性</p><hr><h5 id="GlobalUsings-cs"><a href="#GlobalUsings-cs" class="headerlink" title="GlobalUsings.cs"></a>GlobalUsings.cs</h5><p>通常我们单独编辑一个文件用来全局using命名空间</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">global</span> <span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">global</span> <span class="hljs-keyword">using</span> System.Threading.Tasks;<br><span class="hljs-keyword">global</span> <span class="hljs-keyword">using</span> Microsoft.EntityFrameworkCore;<br></code></pre></td></tr></table></figure><hr><h5 id="ImplicitUsings"><a href="#ImplicitUsings" class="headerlink" title="ImplicitUsings"></a>ImplicitUsings</h5><p>当我们在csproj中启用了隐式增加命名空间后，则System、System.Linq等常用命名空间的引用将会被隐藏</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Project</span> <span class="hljs-attr">Sdk</span>=<span class="hljs-string">&quot;Microsoft.NET.Sdk&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">PropertyGroup</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">OutputType</span>&gt;</span>Exe<span class="hljs-tag">&lt;/<span class="hljs-name">OutputType</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">TargetFramework</span>&gt;</span>net6.0<span class="hljs-tag">&lt;/<span class="hljs-name">TargetFramework</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">ImplicitUsings</span>&gt;</span>enable<span class="hljs-tag">&lt;/<span class="hljs-name">ImplicitUsings</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Nullable</span>&gt;</span>enable<span class="hljs-tag">&lt;/<span class="hljs-name">Nullable</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">PropertyGroup</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">Project</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h3 id="资源释放"><a href="#资源释放" class="headerlink" title="资源释放"></a>资源释放</h3><p>在 C# 中，<code>using</code> 声明是一种方便的方式，用于在代码块结束时自动释放资源</p><p><code>using</code> 声明通常用于那些实现了 <code>IDisposable</code> 接口的对象，如数据库连接、文件流等</p><p>这可以确保即使在发生异常的情况下，资源也能被正确释放</p><p>从 C# 8.0 开始，<code>using</code> 声明有了一个新的语法形式，允许你在没有大括号的情况下声明变量</p><p>这种新的 <code>using</code> 声明语法使得代码更加简洁和易读，尤其是在单行操作或简单的资源管理场景中</p><p>新的 <code>using</code> 声明语法允许你在没有大括号的情况下声明变量，<strong>资源的生命周期会持续到当前作用域结束</strong></p><hr><h3 id="文件级命名空间"><a href="#文件级命名空间" class="headerlink" title="文件级命名空间"></a>文件级命名空间</h3><p>从 C# 10.0 开始，你可以在单个文件中使用文件级命名空间（File-level namespaces）</p><p>这使得你可以在文件的顶部声明命名空间，而无需使用大括号 <code>&#123;&#125;</code> 包围整个文件的内容</p><p><em>注意使用分号结束</em></p><hr><h3 id="可空的引用类型"><a href="#可空的引用类型" class="headerlink" title="可空的引用类型"></a>可空的引用类型</h3><p>从 C# 8.0 开始，引入了可空的引用类型（Nullable Reference Types, NRTs）这一特性</p><p>可空的引用类型允许你在编译时捕获潜在的 <code>null</code> 引用问题，从而减少运行时的 <code>NullReferenceException</code> 异常</p><p>这一特性通过在编译器层面提供更多的静态分析来帮助开发者编写更安全的代码</p><p>实体类的默认属性是不可以为null的，可以使用?标识此属性为可以为null</p><p>标识后的属性在后面使用时，编译器会提醒你做非空检查</p><hr><h5 id="Nullable"><a href="#Nullable" class="headerlink" title="Nullable"></a>Nullable</h5><p>当我们在csproj中启用了可空引用类型检查后</p><p>对于没有添加<code>?</code>的引用类型变量，如果编译器发现存在为这个变量赋值为null的可能性，则编译器会给出警告信息</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Nullable</span>&gt;</span>enable<span class="hljs-tag">&lt;/<span class="hljs-name">Nullable</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h3 id="Record"><a href="#Record" class="headerlink" title="Record"></a>Record</h3><p>从 C# 9.0 开始，引入了 <code>record</code> 类型，这是一种不可变的引用类型，特别适合用于表示不可变数据</p><p><code>record</code> 类型具有许多内置的功能，使得它们在某些场景下比传统的类更加方便和安全</p><p>进行ToString方法输出对象时，我们也只能输出对象的类名</p><p>在进行对象的比较时，我们不能简单地使用<code>==</code>进行判断</p><p>如果我们想要实现这些功能，需要重写ToString和Equals等方法</p><p>而record中，编译器帮我们重写了这些方法</p><hr><h5 id="定义方法"><a href="#定义方法" class="headerlink" title="定义方法"></a>定义方法</h5><p>在 C# 中，<code>record</code> 类型的定义方法可以使用小括号（<code>()</code>）或大括号（<code>&#123;&#125;</code>）</p><p>这是因为 C# 9.0 引入了两种不同的记录声明方式：</p><ul><li>位置记录（Positional Records）</li><li>普通记录（Regular Records）</li></ul><p>这两种方式各有特点，适用于不同的场景</p><p>但无论是位置记录的属性，还是普通记录的属性，都会被生成在ToString和Equals等方法中</p><p>但需要注意的是，普通记录的属性不会被默认生成在构造函数中，但普通记录的属性可以控制读写性</p><hr><h5 id="作为普通类使用"><a href="#作为普通类使用" class="headerlink" title="作为普通类使用"></a>作为普通类使用</h5><p>当不使用位置记录时，record和class无明显区别，且默认生成这些方法</p><hr><h5 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h5><p>record的编译结果仍然是一个class，即引用类型</p><p>结构体在拷贝时直接拷贝，而引用类型在拷贝时仅仅改变了引用指向，而不是复制一个新的对象</p><p>我们可以通过with关键字，完全拷贝一个对象出来</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title">Person</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> FirstName &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> LastName &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Person person = <span class="hljs-keyword">new</span> Person &#123; FirstName = <span class="hljs-string">&quot;John&quot;</span>, LastName = <span class="hljs-string">&quot;Doe&quot;</span> &#125;;<br>        <span class="hljs-comment">// 完全拷贝</span><br>        Person person1 = person <span class="hljs-keyword">with</span> &#123; &#125;;<br>        <span class="hljs-comment">// 拷贝的同时将FirstName更改为Jane</span><br>        Person person2 = person <span class="hljs-keyword">with</span> &#123; FirstName = <span class="hljs-string">&quot;Jane&quot;</span> &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>NET框架相关</category>
      
      <category>c#</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>EFCore-并发</title>
    <link href="/2024/10/08/EFCore-%E5%B9%B6%E5%8F%91/"/>
    <url>/2024/10/08/EFCore-%E5%B9%B6%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<h1 id="EFCore-并发"><a href="#EFCore-并发" class="headerlink" title="EFCore-并发"></a>EFCore-并发</h1><p>最好的解决并发的方案是使用非数据库解决方案来解决并发问题</p><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>在操作数据之前，给被操作数据加锁，如果数据已经存在锁，则一直等待</p><p><em>如数据库锁，行锁，表锁</em></p><p>EFCore没有封装悲观并发控制的使用，需要开发人员编写原生的SQL语句来使用悲观并发控制</p><p>不同数据库的语法不同，如MySQL中，使用select …… for update来实现</p><p>在.NET中实现数据库层面的锁，需要通过原生SQL的方式实现，并且锁是跟事务有关，所以需要先调用BeginTransaction方法开启事务，在操作完成后调用commit方法提交事务</p><hr><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>EFCore提供了一个<code>并发修改令牌</code>的概念，在进行映射时，将列通过IsConcurrencyToken方法设置为并发修改令牌</p><p>在每次更新数据库中的数据时，EFCore都会先读取并发修改令牌，并且作为update语句的where条件</p><p>这时，老数据被作为更新条件，当出现并发问题时，受影响行数将为0，则EFCore会抛出DbUpdateConcurrencyException（并发冲突）异常</p><hr><h3 id="RowVersion"><a href="#RowVersion" class="headerlink" title="RowVersion"></a>RowVersion</h3><p><em>相当于MyBatisPlus的乐观锁中的version列</em></p><p>在配置映射时，使用方法IsRowVersion将列配置成版本列</p><p>当数据被改变时，该列数据都会自动被框架改变</p><p>在 Entity Framework Core (EF Core) 中，如果你定义了一个 <code>byte[]</code> 类型的属性并标记它为 <code>IsRowVersion()</code>，EF Core 会默认将该字段映射到 PostgreSQL 数据库中的 <code>bytea</code></p><p>当然，RowVersion的根本作用也是为了解决并发问题，所以其原理也是乐观锁，每次修改数据之前也会取RowVersion的数据作为查询条件，当受影响行数为0时，抛出异常</p><hr><h3 id="并发修改令牌和RowVersion"><a href="#并发修改令牌和RowVersion" class="headerlink" title="并发修改令牌和RowVersion"></a>并发修改令牌和RowVersion</h3><p>同样是在EFCore中解决并发问题，并发修改令牌只在单列数据被影响时修改，也就是修改本身时做并发处理</p><p>而RowVersion是针对整个表中数据做并发处理</p><hr>]]></content>
    
    
    <categories>
      
      <category>NET框架相关</category>
      
      <category>net</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>EFCore-实体跟踪</title>
    <link href="/2024/09/26/EFCore-%E5%AE%9E%E4%BD%93%E8%B7%9F%E8%B8%AA/"/>
    <url>/2024/09/26/EFCore-%E5%AE%9E%E4%BD%93%E8%B7%9F%E8%B8%AA/</url>
    
    <content type="html"><![CDATA[<h1 id="EFCore-实体跟踪"><a href="#EFCore-实体跟踪" class="headerlink" title="EFCore-实体跟踪"></a>EFCore-实体跟踪</h1><p>EFCore实现了直接对实体类对象进行操作可以直接影响表中数据</p><p>将实体类和数据表绑定的更加紧密了</p><hr><h3 id="实体跟踪"><a href="#实体跟踪" class="headerlink" title="实体跟踪"></a>实体跟踪</h3><p>在实体类和数据表建立关系那一刻，EFCore就会将该实体标记并且<code>跟踪</code>实体类</p><p>在DbContext中注册的DbSet在调用时有五种状态</p><ul><li>已添加（Added）：DbContext正在跟踪此实体，但数据库中还没存在</li><li>未改变（Unchanged）：DbContext正在跟踪此实体，该实体存在于数据库中，其属性值和从数据库中得到的值一致，未发生改变</li><li>已修改（Modified）：DbContext正在跟踪此实体，并存在与数据库中，并且其部分或全部属性值已修改</li><li>已删除（Deleted）:DbContext正在跟踪此实体，并存在与数据库中，但下次调用SaveChanges时要从数据库中删除对应数据</li><li>已分离（Detached）：DbContext未跟踪该实体</li></ul><p>在SaveChanges()的时候，根据实体状态的不同，生成Update、Delete、Insert等SQL语句，来将内存中实体的变化推送到数据库中</p><hr><h3 id="AsNoTracking"><a href="#AsNoTracking" class="headerlink" title="AsNoTracking"></a>AsNoTracking</h3><p>基于这种跟踪机制，微软会使用内存来持续跟踪，这无疑是占用了一部分内存的</p><p>我们可以手动让其不跟踪实体，在进行查询的时候，这种方式是一种对资源不错的优化</p><p>但要进行增删改操作，就不能让其不跟踪，否则实体类修改后表中数据不会改变</p><hr><h3 id="批量的增删改"><a href="#批量的增删改" class="headerlink" title="批量的增删改"></a>批量的增删改</h3><p>模型驱动的EFCore的LINQ语法更适合去进行数据库查询，而面对批量增删改的时候并不是很好用</p><p>但EFCore7.0版本之后已经增加了高效批量操作的方法：</p><ul><li>ExecuteUpdateAsync</li><li>ExecuteDeleteAsync</li></ul><p>需要注意的是，执行这两个方法的时候，EFCore是不会对实体进行状态跟踪的</p><p><em>杨中科提供了一个自己写的框架，可以用EFCore对数据进行批量操作</em></p><blockquote><p>导入依赖</p><p>Zack.EFCore.Batch.Npgsql_NET6</p></blockquote><hr><h3 id="软删除"><a href="#软删除" class="headerlink" title="软删除"></a>软删除</h3><p>在之前的Java项目中，已经接触过很多次软删除的概念了</p><p>在EFCore中，我们可以通过全局查询筛选器来添加一个查询条件</p><p>在每次查询的时候，都将这个查询条件加在SQL中，就能筛选掉“被删除”的数据库</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DBContext</span> : <span class="hljs-title">DbContext</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DbSet</span>&lt;<span class="hljs-title">Article</span>&gt; Articles</span> &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnModelCreating</span>(<span class="hljs-params">ModelBuilder modelBuilder</span>)</span><br>    &#123;<br>        modelBuilder.Entity&lt;Article&gt;(entity =&gt;<br>        &#123;<br>            entity.ToTable(<span class="hljs-string">&quot;Articles&quot;</span>);<br>            <span class="hljs-comment">// 配置全局查询过滤器，将Is_Deleted == 0 作为查询条件</span><br>            entity.HasQueryFilter(a =&gt; a.Is_Deleted == <span class="hljs-number">0</span>);<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="查看已删除的数据"><a href="#查看已删除的数据" class="headerlink" title="查看已删除的数据"></a>查看已删除的数据</h5><p>调用IgnoreQueryFilters忽略掉全局过滤器，在手动添加条件为Is_Deleted &#x3D;&#x3D; 0的查询条件</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> dbContext = <span class="hljs-keyword">new</span> DBContext())<br>&#123;<br>    dbContext.Articles.IgnoreQueryFilters().Where(a =&gt; a.Is_Deleted == <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>NET框架相关</category>
      
      <category>net</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>EFCore-SQL</title>
    <link href="/2024/09/25/EFCore-SQL/"/>
    <url>/2024/09/25/EFCore-SQL/</url>
    
    <content type="html"><![CDATA[<h1 id="EFCore-SQL"><a href="#EFCore-SQL" class="headerlink" title="EFCore-SQL"></a>EFCore-SQL</h1><p>需要执行复杂的 SQL 查询或存储过程时，或者当 LINQ 查询无法满足需求时，可以直接执行原始 SQL 查询或命令</p><h3 id="非查询语句"><a href="#非查询语句" class="headerlink" title="非查询语句"></a>非查询语句</h3><p>使用dbContext对象直接调用Database.ExecuteSqlInterpolated来执行SQL的插入操作，通过$和@字符串修饰符完成对SQL条件的拼接</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> dbContext = <span class="hljs-keyword">new</span> DBContext())<br>&#123;<br>    <span class="hljs-comment">//ExecuteSqlInterpolated：执行SQL插值</span><br>    dbContext.Database.ExecuteSqlInterpolated(<br>        <span class="hljs-string">$@&quot;insert into T Articles (Title, Content, Author) values (@Title, @Content, @Author);&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>使用内插字符串来完成SQL条件的拼接，不会存在SQL注入的攻击</p><hr><h3 id="实体相关查询"><a href="#实体相关查询" class="headerlink" title="实体相关查询"></a>实体相关查询</h3><p>使用注册的DbSet属性调用FromSqlInterpolated方法来执行SQL 的查询操作</p><p>这个方法的返回值为IQueryable，所以也有延迟执行的特性</p><p>同样的，查询语句也可以通过$和@字符串修饰符完成对SQL条件的拼接</p><p>也可以通过IQueryable调用相关API对查询进行二次处理</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> dbContext = <span class="hljs-keyword">new</span> DBContext())<br>&#123;<br>    dbContext.Articles.FromSqlInterpolated(<span class="hljs-string">$@&quot;select * from Articles&quot;</span>).ToList();<br>&#125;<br></code></pre></td></tr></table></figure><p>局限性：</p><ul><li><p>SQL查询必须返回实体类型对应数据库表的所有列</p></li><li><p>结果集中的列名必须与属性映射到的列名匹配</p></li><li><p>只能进行单表查询，不能进行连接查询，但可以在结果后调用Include进行关联数据的获取</p></li></ul><hr><h3 id="任意SQL查询"><a href="#任意SQL查询" class="headerlink" title="任意SQL查询"></a>任意SQL查询</h3><p>EFCore中允许把试图或存储过程映射为实体，因此可以把复杂的查询语句写成试图或存储过程，然后再声明对应的实体类，在DbContext中注册对应的DbSet</p><p>这种方式不推荐使用，因这种类型会混淆实体类</p><h5 id="ADO-NET"><a href="#ADO-NET" class="headerlink" title="ADO.NET"></a>ADO.NET</h5><p>因为EFCore是基于ADO.NET封装，所以我们可以直接调用其方法获取数据库连接对象</p><p>然后使用原始ADO.NET的方法对数据库发送原始SQL语句</p><h5 id="Dapper"><a href="#Dapper" class="headerlink" title="Dapper"></a>Dapper</h5><p>推荐使用Dapper执行复杂的数据库查询操作</p><hr>]]></content>
    
    
    <categories>
      
      <category>NET框架相关</category>
      
      <category>net</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>EFCore-分页查询</title>
    <link href="/2024/09/25/EFCore-%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2/"/>
    <url>/2024/09/25/EFCore-%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="EFCore-分页查询"><a href="#EFCore-分页查询" class="headerlink" title="EFCore-分页查询"></a>EFCore-分页查询</h1><p>在之前我们了解到，在IQuryable和IEnumerable中，where的方法是在不同的接口实现的</p><p>IEnumerable是在内存中过滤（客户端评估）</p><p>IQuryable是把操作翻译成SQL语句（服务端评估）</p><p>所以在实际开发中，我们不会使用到IEnumerable接口来接受数据库查询的数据</p><hr><h3 id="延迟执行"><a href="#延迟执行" class="headerlink" title="延迟执行"></a>延迟执行</h3><p>IQuryable支持延迟执行，即不立即执行</p><p>它只是一个“可以放到数据库服务器去执行的查询”，他没有立即执行，只是“可以被执行”而已</p><p>对于IQueryable接口调用非终结方法的时候不会执行查询，调用终结方法的时候会立即执行查询</p><p>这样延迟查询的好处，可以动态拼接查询条件，根据不同的查询条件编译不同的SQL语句</p><p>因为这种延迟查询的缘故，所以不能将IQueryable对象传到DbContext销毁外执行</p><table><thead><tr><th>非终结方法</th><th>终结方法</th></tr></thead><tbody><tr><td>GroupBy()</td><td>遍历</td></tr><tr><td>OrderBy()</td><td>ToArray()</td></tr><tr><td>Include()</td><td>ToList()</td></tr><tr><td>Skip()</td><td>Min()&#x2F;Max()</td></tr><tr><td>Take()</td><td>Count()</td></tr></tbody></table><p><em>一个方法的返回值类型如果是IQueryable类型，则为非终结方法，反之则为终结方法</em></p><p>需要注意的是：非终结方法没有异步方法，而终结方法普遍都存在异步方法<br>但一般来讲，遍历和ToList，ToArray方法没必要使用异步方法</p><hr><h3 id="对象复用"><a href="#对象复用" class="headerlink" title="对象复用"></a>对象复用</h3><p>通过非终结方法生成的IQuryable对象可以通过不同的终结方法来编译成不同的SQL语句</p><hr><h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><p>通过对IQuryable的复用和非终结方法Skip()以及Take()来实现分页查询功能</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 此方法用于返回一页数据和总页数</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;pageIndex&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;pageSize&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrintPage</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> pageIndex, <span class="hljs-built_in">int</span> pageSize</span>)</span><br>&#123;<br>    <span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> dbContext = <span class="hljs-keyword">new</span> DBContext())<br>    &#123;<br>        <span class="hljs-comment">// 这时，程序还未向数据库发送SQL</span><br>        <span class="hljs-keyword">var</span> queryable = dbContext.Articles.Select(a =&gt; a);<br><br>        <span class="hljs-comment">// 跳过 当前页码-1 *每页条数（跳过的数据总条数）再拿一页数据</span><br>        <span class="hljs-keyword">var</span> data = queryable.Skip((pageIndex - <span class="hljs-number">1</span>) * pageSize).Take(pageSize).ToList();<br><br>        <span class="hljs-comment">// queryable的复用，在用一次计算总条数</span><br>        <span class="hljs-built_in">long</span> count = queryable.LongCount();<br>        <br>        <span class="hljs-comment">// 计算总页数 使用Math.Ceiling方法向上取整</span><br>        <span class="hljs-built_in">long</span> pageCount = (<span class="hljs-built_in">long</span>)Math.Ceiling(count / (<span class="hljs-built_in">double</span>)pageSize);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，拿到分页五大件</p><hr><h3 id="IQuryable底层"><a href="#IQuryable底层" class="headerlink" title="IQuryable底层"></a>IQuryable底层</h3><p>EFCore可以理解为是针对与ADO.NET的封装</p><p>在ADO.NET中，存在DataReader和DataTable对象</p><ul><li>DataReader：分批从数据库读取数据，内存占用小，DB链接占用时间长</li><li>DataTable：把所有数据一次性的从数据库中加载到内存中，内存占用大，DB占用链接短</li></ul><p>而IQueryable则实现了DataReader，节省了客户端内存，如果处理的慢，就会长时间占用数据库连接</p><p>如果想要一次性的将数据加载到内存，则使用IQueryable的ToArray()、ToArrayAsync()、ToList()、ToListAsync()方法</p><p>而因为DataReader的特性，是不允许多个DataReader同时执行的，所以不能对IQueryable进行嵌套遍历</p><hr><p>​</p>]]></content>
    
    
    <categories>
      
      <category>NET框架相关</category>
      
      <category>net</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>EFCore-关系配置</title>
    <link href="/2024/09/25/EFCore-%E5%85%B3%E7%B3%BB%E9%85%8D%E7%BD%AE/"/>
    <url>/2024/09/25/EFCore-%E5%85%B3%E7%B3%BB%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="EFCore-关系配置"><a href="#EFCore-关系配置" class="headerlink" title="EFCore-关系配置"></a>EFCore-关系配置</h1><p>数据库表的关系分为一对一，一对多，多对多的映射关系</p><p>在项目中，现在很少使用外键的形式来建表，都是使用逻辑外键的形式建表，并且大部分都是数据库优先</p><p>如果在实体中实现关系之后，再使用代码优先的方式推送到数据库，则会出现数据库外键的关系</p><hr><h3 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h3><h5 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Article</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">long</span> Id &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Title &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Content &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> List&lt;Comment&gt; Comments &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125; = <span class="hljs-keyword">new</span> List&lt;Comment&gt;();<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="评论"><a href="#评论" class="headerlink" title="评论"></a>评论</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">namespace</span> 关系配置;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Comment</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">long</span> Id &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> Article Article &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Message &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="映射关系"><a href="#映射关系" class="headerlink" title="映射关系"></a>映射关系</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DBContext</span> : <span class="hljs-title">DbContext</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DbSet</span>&lt;<span class="hljs-title">Article</span>&gt; Articles</span> &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DbSet</span>&lt;<span class="hljs-title">Comment</span>&gt; Comments</span> &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnConfiguring</span>(<span class="hljs-params">DbContextOptionsBuilder optionsBuilder</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">base</span>.OnConfiguring(optionsBuilder);<br>        optionsBuilder.UseNpgsql(<span class="hljs-string">@&quot;数据库链接字符串&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnModelCreating</span>(<span class="hljs-params">ModelBuilder modelBuilder</span>)</span><br>    &#123;<br>        modelBuilder.Entity&lt;Article&gt;(entity =&gt;<br>        &#123;<br>            entity.ToTable(<span class="hljs-string">&quot;Articles&quot;</span>);<br>            entity.Property(a =&gt; a.Title).HasMaxLength(<span class="hljs-number">100</span>).IsUnicode().IsRequired();<br>            entity.Property(a =&gt; a.Content).IsUnicode().IsRequired();<br>        &#125;);<br><br>        modelBuilder.Entity&lt;Comment&gt;(entity =&gt;<br>        &#123;<br>            entity.ToTable(<span class="hljs-string">&quot;Comments&quot;</span>);<br>            entity.Property(c =&gt; c.Message).IsUnicode().IsRequired();<br>            <span class="hljs-comment">// 使用HasOne和WithMany来建立一对多的关系</span><br>            entity.HasOne&lt;Article&gt;(c =&gt; c.Article).WithMany(a =&gt; a.Comments);<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>这种是包含数据库外键的，代码优先的形式，使用工具Migrate将实体类推送到数据库后，数据库会根据实体类关系自动创建外键</p><p>在对数据库中的表进行插入操作的时候，也就是插入评论的时候，直接插入到文章的评论List集合，EF会直接根据其关系将评论插入到评论表中，无需单独将评论插入评论表中</p><p>在对数据库中的表进行查询操作的时候，在EFCore也不会自动查询的文章中的评论的数据，也就是不会进行多表联查，但可以使用Include语句，EFCore就会将关联的对象通过连接查询的方式查到数据</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">var</span> queryable = dbContext.Articles.Include(a =&gt; a.Comments).Select(a =&gt; a);<br></code></pre></td></tr></table></figure><p>但实际项目中，很少会用这种深度耦合的关系，即数据库外键的功能，大多会在文章表中储存一个评论id，然后进行多表联查后封装为Vo将数据打包返回                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   </p><hr><h3 id="对一和对多"><a href="#对一和对多" class="headerlink" title="对一和对多"></a>对一和对多</h3><p>在学习MyBatis的时候，将实体类和数据库表的关系分开来算，对于数据库来说，才有一对一，一对多，多对多的关系</p><p>而对于实体类来说，则只存在对一和对多的关系，即本身对应多个，或本身对应一个的关系</p><p>在.NET中，这种关系叫做单项导航，在建立关系时，withMany的参数不填写即可</p><p><em>需要注意的是，EFCore中，实体类和数据库表的关系更加的密切，在进行关系配置的时候，则不像是MyBatis那样分的清楚了</em></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 在“多”的这边建立关系，即在Comments中建立关系</span><br>entity.HasOne&lt;Article&gt;(c =&gt; c.Article).WithMany(); <span class="hljs-comment">// 单项导航属性，即一个文章对应多个评论</span><br></code></pre></td></tr></table></figure><hr><h3 id="多对一"><a href="#多对一" class="headerlink" title="多对一"></a>多对一</h3><p>一对多的关系同样可以转换为多对一的关系</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DBContext</span> : <span class="hljs-title">DbContext</span><br>&#123;<br>    <span class="hljs-keyword">public</span> DbSet&lt;Article&gt; Articles &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> DbSet&lt;Comment&gt; Comments &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnConfiguring</span>(<span class="hljs-params">DbContextOptionsBuilder optionsBuilder</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">base</span>.OnConfiguring(optionsBuilder);<br>        optionsBuilder.UseNpgsql(<span class="hljs-string">@&quot;Host=172.16.22.222;Username=postgres;Password=synyi;Database=bai_study&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnModelCreating</span>(<span class="hljs-params">ModelBuilder modelBuilder</span>)</span><br>    &#123;<br>        modelBuilder.Entity&lt;Article&gt;(entity =&gt;<br>        &#123;<br>            entity.ToTable(<span class="hljs-string">&quot;Articles&quot;</span>);<br>            entity.Property(a =&gt; a.Title).HasMaxLength(<span class="hljs-number">100</span>).IsUnicode().IsRequired();<br>            entity.Property(a =&gt; a.Content).IsUnicode().IsRequired();<br>            <span class="hljs-comment">// 使用HasMany和WithOne来建立多对一的关系</span><br>            entity.HasMany(a =&gt; Comments).WithOne(c =&gt; c.Article);<br>        &#125;);<br><br>        modelBuilder.Entity&lt;Comment&gt;(entity =&gt;<br>        &#123;<br>            entity.ToTable(<span class="hljs-string">&quot;Comments&quot;</span>);<br>            entity.Property(c =&gt; c.Message).IsUnicode().IsRequired();<br>        &#125;);<br>    &#125;<br>&#125;  <br></code></pre></td></tr></table></figure><p><em>注：单项导航时，需要将配置写在有导航属性那一端</em></p><hr><h3 id="一对一和多对多"><a href="#一对一和多对多" class="headerlink" title="一对一和多对多"></a>一对一和多对多</h3><p>和一对多的关系配置方法没有什么明显的差别</p><p>在一对一中，我们需要显示的配一个外键</p><p>在多对多中，我们需要一个关系表来反映两表之中的关系</p><hr>]]></content>
    
    
    <categories>
      
      <category>NET框架相关</category>
      
      <category>net</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>EFCore-扩展</title>
    <link href="/2024/09/24/EFCore-%E6%89%A9%E5%B1%95/"/>
    <url>/2024/09/24/EFCore-%E6%89%A9%E5%B1%95/</url>
    
    <content type="html"><![CDATA[<h1 id="EFCore-扩展"><a href="#EFCore-扩展" class="headerlink" title="EFCore-扩展"></a>EFCore-扩展</h1><h3 id="EF-Core-主键"><a href="#EF-Core-主键" class="headerlink" title="EF Core-主键"></a>EF Core-主键</h3><p>EF Core来实现主键回显十分简单，甚至开发者什么都不需要做，在提交完操作之后，数据库会自动将实体类的主键赋值，即完成主键回显</p><hr><h5 id="Guid"><a href="#Guid" class="headerlink" title="Guid"></a>Guid</h5><p>UID（Globally Unique Identifier）是一种由算法生成的唯一标识符，通常用于在分布式系统中确保不同实体之间的唯一性。GUID通常是一个128位数，可以以多种格式表示，但最常见的形式是32个十六进制数字，分为5组，形式如下：8-4-4-4-12的数字组合，例如：<code>550e8400-e29b-41d4-a716-446655440000</code></p><p>GUID的主要用途包括但不限于：</p><ul><li>数据库中的主键：当需要确保数据记录的唯一性时，可以使用GUID作为主键。</li><li>软件开发：在软件开发过程中，特别是在跨平台或多用户环境中，GUID可以用来保证对象或组件的唯一性。</li><li>分布式系统：在分布式计算环境中，GUID可以用来唯一地标识不同的节点或事务，从而避免冲突。</li></ul><p>生成GUID的方法有很多，大多数现代编程语言都提供了生成GUID的功能。例如，在.NET框架中，可以通过<code>System.Guid</code>类来生成一个新的GUID；而在Python中，则可以使用<code>uuid</code>模块来创建GUID</p><p><em>注：不要把Guid主键设置为聚集索引，在MySQL中，插入频繁的表不要使用GUID作为主键</em></p><p>如果是一般的主键，由数据库生成，EFCore会在提交操作之后将主键回填到对象的属性中</p><p>EFCore在将数据插入数据库之前，会生成一个GUID主键，然后再执行插入操作，这个操作并不是由数据库来完成的</p><p>GUID.NewGuid，这一个API可以手动生成一个GUID</p><hr><h3 id="EF-Code-逆向工程"><a href="#EF-Code-逆向工程" class="headerlink" title="EF Code-逆向工程"></a>EF Code-逆向工程</h3><p>DBFirst 是一种开发模式，它代表了一种“数据库优先”的开发策略</p><p>在这种模式下，开发者首先设计和创建数据库结构（如表、视图、存储过程等）</p><p>然后基于这个现有的数据库来生成数据模型类和上下文类</p><p>这种方式特别适合那些已经有现成数据库或者需要严格遵循已定义数据库结构的应用程序</p><p>在Java中，MyBatisX插件就是一个强大的逆向工程插件</p><blockquote><p>依赖安装：</p><p>Npgsql.EntityFrameworkCore.PostgreSQL</p><p>Microsoft.EntityFrameworkCore.Tools</p></blockquote><h5 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h5><blockquote><p>Scaffold- DBContext “字符串链接四大件”<br>dotnet ef dbcontext scaffold “Your Connection String” Npgsql.EntityFrameworkCore.PostgreSQL [options]</p></blockquote><p>推荐这种逆向工程工具只有在建项时候使用，后期手动更新</p><hr><h3 id="打印SQL语句"><a href="#打印SQL语句" class="headerlink" title="打印SQL语句"></a>打印SQL语句</h3><h5 id="标准日志形式（引入日志框架）"><a href="#标准日志形式（引入日志框架）" class="headerlink" title="标准日志形式（引入日志框架）"></a>标准日志形式（引入日志框架）</h5><p>在正常的注册Logging之后，在DBContext中的OnConfiguring方法中添加optionsBuilder.UseLoggerFactory(LoggerFactory);</p><p>LoggerFactory对象被注入到DBContext</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> ILoggerFactory LoggerFactory &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnConfiguring</span>(<span class="hljs-params">DbContextOptionsBuilder optionsBuilder</span>)</span><br>&#123;<br>    <span class="hljs-keyword">base</span>.OnConfiguring(optionsBuilder);<br>    <br>    optionsBuilder.UseLoggerFactory(LoggerFactory);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="LogTo（简单日志）"><a href="#LogTo（简单日志）" class="headerlink" title="LogTo（简单日志）"></a>LogTo（简单日志）</h5><p>在DBContext中的OnConfiguring方法中调用LogTo方法完成打印日志</p><p>LogTo会反映出EFCore的工作流程展示出来</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnConfiguring</span>(<span class="hljs-params">DbContextOptionsBuilder optionsBuilder</span>)</span><br>&#123;<br>    <span class="hljs-keyword">base</span>.OnConfiguring(optionsBuilder);<br>    <br>    optionsBuilder.LogTo(msg =&gt; Console.WriteLine(msg));<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="TOQUERYSTRING"><a href="#TOQUERYSTRING" class="headerlink" title="TOQUERYSTRING"></a>TOQUERYSTRING</h5><p>以上两种方法都无法纯粹的显示出EFCore编译的SQL语句</p><p>在对DbSet的对象（也就是表）进行LINQ查询后，会得到一个IQueryable对象</p><p>这个对象有一个EFCore提供的API，ToQueryString</p><p>这个API可以将IQueryable对象直接打印成SQL语句</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">var</span> persons = myDbContext.Persons.Select(p =&gt; p);<br><span class="hljs-keyword">var</span> queryString = persons.ToQueryString();<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>NET框架相关</category>
      
      <category>net</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>EF Code-逆向工程</title>
    <link href="/2024/09/24/EFCode-%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
    <url>/2024/09/24/EFCode-%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="EF-Code-逆向工程"><a href="#EF-Code-逆向工程" class="headerlink" title="EF Code-逆向工程"></a>EF Code-逆向工程</h1><p>DBFirst 是一种开发模式，它代表了一种“数据库优先”的开发策略</p><p>在这种模式下，开发者首先设计和创建数据库结构（如表、视图、存储过程等）</p><p>然后基于这个现有的数据库来生成数据模型类和上下文类</p><p>这种方式特别适合那些已经有现成数据库或者需要严格遵循已定义数据库结构的应用程序</p><p>在Java中，MyBatisX插件就是一个强大的逆向工程插件</p><blockquote><p>依赖安装：</p><p>Npgsql.EntityFrameworkCore.PostgreSQL</p><p>Microsoft.EntityFrameworkCore.Tools</p></blockquote><p><em>可以发现，无论是Migrate工具还是scaffold工具，都在tools包下</em></p><h5 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h5><blockquote><p>Scaffold- DBContext “字符串链接四大件”<br>dotnet ef dbcontext scaffold “Your Connection String” Npgsql.EntityFrameworkCore.PostgreSQL [options]</p></blockquote><p>推荐这种逆向工程工具只有在建项时候使用，后期手动更新</p><hr>]]></content>
    
    
    <categories>
      
      <category>NET框架相关</category>
      
      <category>net</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>EF Core-主键</title>
    <link href="/2024/09/24/EF%20Core-%E4%B8%BB%E9%94%AE/"/>
    <url>/2024/09/24/EF%20Core-%E4%B8%BB%E9%94%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="EF-Core-主键"><a href="#EF-Core-主键" class="headerlink" title="EF Core-主键"></a>EF Core-主键</h1><h3 id="主键回显"><a href="#主键回显" class="headerlink" title="主键回显"></a>主键回显</h3><p>EF Core来实现主键回显十分简单，甚至开发者什么都不需要做，在提交完操作之后，数据库会自动将实体类的主键赋值，即完成主键回显</p><hr><h3 id="Guid"><a href="#Guid" class="headerlink" title="Guid"></a>Guid</h3><p>UID（Globally Unique Identifier）是一种由算法生成的唯一标识符，通常用于在分布式系统中确保不同实体之间的唯一性。GUID通常是一个128位数，可以以多种格式表示，但最常见的形式是32个十六进制数字，分为5组，形式如下：8-4-4-4-12的数字组合，例如：<code>550e8400-e29b-41d4-a716-446655440000</code></p><p>GUID的主要用途包括但不限于：</p><ul><li>数据库中的主键：当需要确保数据记录的唯一性时，可以使用GUID作为主键。</li><li>软件开发：在软件开发过程中，特别是在跨平台或多用户环境中，GUID可以用来保证对象或组件的唯一性。</li><li>分布式系统：在分布式计算环境中，GUID可以用来唯一地标识不同的节点或事务，从而避免冲突。</li></ul><p>生成GUID的方法有很多，大多数现代编程语言都提供了生成GUID的功能。例如，在.NET框架中，可以通过<code>System.Guid</code>类来生成一个新的GUID；而在Python中，则可以使用<code>uuid</code>模块来创建GUID</p><p><em>注：不要把Guid主键设置为聚集索引，在MySQL中，插入频繁的表不要使用GUID作为主键</em></p><h3 id="EFCore"><a href="#EFCore" class="headerlink" title="EFCore"></a>EFCore</h3><p>如果是一般的主键，由数据库生成，EFCore会在提交操作之后将主键回填到对象的属性中</p><p>EFCore在将数据插入数据库之前，会生成一个GUID主键，然后再执行插入操作，这个操作并不是由数据库来完成的</p><p>GUID.NewGuid，这一个API可以手动生成一个GUID</p><hr>]]></content>
    
    
    <categories>
      
      <category>NET框架相关</category>
      
      <category>net</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>EFCore-FluentAPI</title>
    <link href="/2024/09/23/EFCore-FluentAPI/"/>
    <url>/2024/09/23/EFCore-FluentAPI/</url>
    
    <content type="html"><![CDATA[<h1 id="EF-Core-FluentAPI"><a href="#EF-Core-FluentAPI" class="headerlink" title="EF Core-FluentAPI"></a>EF Core-FluentAPI</h1><p>在约定大于配置这一规则下，EF Core提供了一些约定配置</p><ul><li>表明采用DbContext中对应的DbSet的属性名</li><li>数据表列的名字采用实体类的属性名字，列的数据类型采用实体类属性中最兼容的类型</li><li>数据表列的可空性取决于对应实体类属性的可空性（通过属性类型的？来调整是否为可空）</li><li>名字为Id的属性为主键，如果主键为short，int或者long类型，则默认采用自增字段</li><li>如果主键为Guid类型，则默认采用默认的Guid生成机制生成主键值</li></ul><hr><h3 id="FluentAPI"><a href="#FluentAPI" class="headerlink" title="FluentAPI"></a>FluentAPI</h3><p>这种方式就是创建一个配置类以实现IEntityTypeConfiguration接口后对实体类（表）进行配置</p><p>这种方法配置起来更麻烦，但能解耦合</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>Ignore()</td><td>忽略表中某一属性</td></tr><tr><td>HasColumnName()</td><td><strong>配置列名</strong>*（需要先获取属性）</td></tr><tr><td>HasColumnType()</td><td>配置列的类型</td></tr><tr><td>HasKey()</td><td><strong>配置主键</strong>*（需要先获取属性）</td></tr></tbody></table><p><strong>FluentAPI并不只是可以使用在配置类中，也可以在DbContext的OnModelCreating方法中直接使用</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnModelCreating</span>(<span class="hljs-params">ModelBuilder modelBuilder</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">base</span>.OnModelCreating(modelBuilder);<br><br>        modelBuilder.Entity&lt;Book&gt;(b =&gt;<br>        &#123;<br>            <span class="hljs-comment">// 忽略Book实体类中的Title属性</span><br>            b.Ignore(b =&gt; b.Title);<br>        &#125;);<br>        <br>        <span class="hljs-comment">// 使用这种方法对书实体类中的属性和表中列名做映射（ResultMapping）</span><br>        modelBuilder.Entity&lt;Book&gt;(b =&gt;<br>        &#123;                              <br>            b.Property(b =&gt; b.Title).HasColumnName(<span class="hljs-string">&quot;b_title&quot;</span>);<br>        &#125;);<br>        <br>        <span class="hljs-comment">// 使用这种方法对表中列的类型进行指定</span><br>        modelBuilder.Entity&lt;Book&gt;(b =&gt;<br>        &#123;<br>            b.Property(b =&gt; b.Title).HasColumnType(<span class="hljs-string">&quot;varchar(8)&quot;</span>);<br>        &#125;);<br>        <br>        <span class="hljs-comment">// 配置主键</span><br>        modelBuilder.Entity&lt;Book&gt;().HasKey(b =&gt; b.Id);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="Data-Annotation"><a href="#Data-Annotation" class="headerlink" title="Data Annotation"></a>Data Annotation</h3><p>使用特性（Java中的注解）这一方式来配置实体类和表</p><p><em>不推荐使用这种方式，因为耦合度高</em></p><h5 id="Table"><a href="#Table" class="headerlink" title="Table"></a>Table</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#">[<span class="hljs-meta">Table(<span class="hljs-string">&quot;Books&quot;</span>)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Book</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">long</span> Id &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Title &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> DateTime PubTime &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> Price &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Required-MaxLength"><a href="#Required-MaxLength" class="headerlink" title="Required&amp;&amp;MaxLength"></a>Required&amp;&amp;MaxLength</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#">[<span class="hljs-meta">Required</span>]<br>[<span class="hljs-meta">MaxLength(50)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Title &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>NET框架相关</category>
      
      <category>net</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>EFCore-CRUD</title>
    <link href="/2024/09/23/EFCore-CRUD/"/>
    <url>/2024/09/23/EFCore-CRUD/</url>
    
    <content type="html"><![CDATA[<h1 id="EF-Core-CRUD"><a href="#EF-Core-CRUD" class="headerlink" title="EF Core-CRUD"></a>EF Core-CRUD</h1><p>在DbContext中注册之后的表，使用其对象直接.后进行操作即可</p><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] <span class="hljs-keyword">args</span></span>)</span><br>&#123;<br>    <span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> myDbContext = <span class="hljs-keyword">new</span> MyDbContext())<br>    &#123;<br>        <span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> Person();<br>        person.Age = <span class="hljs-number">18</span>;<br>        person.Address = <span class="hljs-string">&quot;JiLin&quot;</span>;<br>        person.Name = <span class="hljs-string">&quot;Xiaobai&quot;</span>;<br><br>        <span class="hljs-comment">// 将对象添加到数据库中</span><br>        myDbContext.Persons.Add(person);<br>        <span class="hljs-comment">// 提交更改(调用异步的提交方法)</span><br>        <span class="hljs-keyword">await</span> myDbContext.SaveChangesAsync();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="查询（LINQ）"><a href="#查询（LINQ）" class="headerlink" title="查询（LINQ）"></a>查询（LINQ）</h3><p>DbSet实现了IEnumerable&lt;T&gt;接口，所以我们可以使用LINQ语句直接对数据库进行查询</p><p>但其实，LINQ在EF Core中的方法和他在.NET框架中的方法不是一个方法，但用法完全相同</p><p><em>注：查询操作不需要调用SaveChanges方法提交操作</em></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] <span class="hljs-keyword">args</span></span>)</span><br>    &#123;<br>        <span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> myDbContext = <span class="hljs-keyword">new</span> MyDbContext())<br>        &#123;<br>            <span class="hljs-keyword">var</span> persons = myDbContext.Persons.Select(p =&gt; p);<br>            <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> person <span class="hljs-keyword">in</span> persons)<br>            &#123;<br>                Console.WriteLine(<span class="hljs-string">$&quot;Name: <span class="hljs-subst">&#123;person?.Name&#125;</span>, Age: <span class="hljs-subst">&#123;person?.Age&#125;</span>,Address: <span class="hljs-subst">&#123;person?.Address&#125;</span>&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><p>在修改之前，我们需要先使用LINQ把目标数据查询出来，才能对其进行修改操作</p><p>当查到这条对象时，我们直接对其属性进行就该，最后提交到表中即可</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] <span class="hljs-keyword">args</span></span>)</span><br>&#123;<br>    <span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> myDbContext = <span class="hljs-keyword">new</span> MyDbContext())<br>    &#123;<br>        <span class="hljs-keyword">var</span> person = myDbContext.Persons.Single(p =&gt; p.Name == <span class="hljs-string">&quot;小白&quot;</span>);<br>        person.Name = <span class="hljs-string">&quot;xiaobai&quot;</span>;<br><br>        <span class="hljs-keyword">await</span> myDbContext.SaveChangesAsync();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>在删除之前，我们需要先使用LINQ把目标数据查询出来，然后调用DbSet或者DbContext中的Remove方法将对象删除，最后提交到表中即可</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] <span class="hljs-keyword">args</span></span>)</span><br>&#123;<br>    <span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> myDbContext = <span class="hljs-keyword">new</span> MyDbContext())<br>    &#123;<br>        <span class="hljs-keyword">var</span> person = myDbContext.Persons.Single(p =&gt; p.Id == <span class="hljs-number">3</span>);<br><br>        myDbContext.Persons.Remove(person);<br><br>        <span class="hljs-keyword">await</span> myDbContext.SaveChangesAsync();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这种模型驱动开发思想的ORM框架，学习更复杂，但使用起来更加方便</p><p>它将类和表绑定在一起，查询时使用LINQ语句，当查到对象之后就将数据库记录和类的对象绑定到一起，直接对对象进行操作，之后推送到表中记录即可</p><p>EF Core 7中新增了对数据进行批量操作的方法</p><hr>]]></content>
    
    
    <categories>
      
      <category>NET框架相关</category>
      
      <category>net</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Csharp-运算符重载</title>
    <link href="/2024/09/18/Csharp-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
    <url>/2024/09/18/Csharp-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<h1 id="Csharp-运算符重载"><a href="#Csharp-运算符重载" class="headerlink" title="Csharp-运算符重载"></a>Csharp-运算符重载</h1><p>运算符重载是将运算符看作方法，在类中重新定义其方法功能</p><p><em>注：Java中不存在此功能，如果想实现此功能则直接编写方法</em></p><hr><h3 id="双目运算符"><a href="#双目运算符" class="headerlink" title="双目运算符"></a>双目运算符</h3><blockquote><p>public static <code>返回值类型</code> operator <code>运算符号</code>(<code>参数类型</code> <code>参数1</code>, <code>参数类型</code> <code> 参数2</code>)</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">namespace</span> <span class="hljs-title">Demo05</span><br>&#123;<br>    <span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] <span class="hljs-keyword">args</span></span>)</span><br>        &#123;<br>            <span class="hljs-keyword">var</span> left = <span class="hljs-keyword">new</span> Box();<br>            left.width = <span class="hljs-number">10</span>;<br>            left.height = <span class="hljs-number">10</span>;<br>            left.depth = <span class="hljs-number">10</span>;<br><br>            <span class="hljs-keyword">var</span> right = <span class="hljs-keyword">new</span> Box();<br>            right.width = <span class="hljs-number">10</span>;<br>            right.height = <span class="hljs-number">10</span>;<br>            right.depth = <span class="hljs-number">10</span>;<br><br>            <span class="hljs-keyword">var</span> box = right + left;<br>            Console.WriteLine(<span class="hljs-string">$&quot;新图形的长<span class="hljs-subst">&#123;box.height&#125;</span>、宽<span class="hljs-subst">&#123;box.width&#125;</span>、高<span class="hljs-subst">&#123;box.depth&#125;</span>&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">class</span> <span class="hljs-title">Box</span><br>        &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> width = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> height = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> depth = <span class="hljs-number">0</span>;<br><br>            <span class="hljs-comment">// 重载Box类的运算符+ ，使得运算符+作用于box对象时功能变换为长宽高相加</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Box <span class="hljs-keyword">operator</span> +(Box left, Box right)<br>            &#123;<br>                <span class="hljs-keyword">var</span> box = <span class="hljs-keyword">new</span> Box();<br>                box.width = left.width + right.width;<br>                box.depth = left.depth + right.depth;<br>                box.height = left.height + right.height;<br>                <span class="hljs-keyword">return</span> box;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="单目运算符"><a href="#单目运算符" class="headerlink" title="单目运算符"></a>单目运算符</h3><blockquote><p> public static <code>返回值类型</code> operator <code>运算符号</code>(<code>参数类型</code> <code>参数1</code>)</p></blockquote><p>在c#中，<code>-</code>不止可以作为双目运算符的减号使用，同时可以作为单目运算符取相反数</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">namespace</span> <span class="hljs-title">Demo05</span><br>&#123;<br>    <span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Demo01</span><br>    &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> x;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> y;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Demo01 <span class="hljs-keyword">operator</span> -(Demo01 demo01)<br>        &#123;<br>            <span class="hljs-keyword">var</span> demo = <span class="hljs-keyword">new</span> Demo01();<br>            demo.x = demo01.x = -demo01.x;<br>            demo.y = demo01.y = -demo01.y;<br>            <span class="hljs-keyword">return</span> demo;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] <span class="hljs-keyword">args</span></span>)</span><br>        &#123;<br>            <span class="hljs-keyword">var</span> demo01 = <span class="hljs-keyword">new</span> Demo01();<br>            demo01.x = <span class="hljs-number">1</span>;<br>            demo01.y = <span class="hljs-number">2</span>;<br><br>            <span class="hljs-keyword">var</span> demo02 = -demo01;<br>            Console.WriteLine(<span class="hljs-string">$&quot;x的相反数为：<span class="hljs-subst">&#123;demo02.x&#125;</span>,y的相反数为：<span class="hljs-subst">&#123;demo02.y&#125;</span>&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>注：一个程序可以同时存在与单目运算符-和双目运算符-，因为其参数不同，所以是重载到不同的运算符中</em></p><hr><h3 id="类型转换运算符"><a href="#类型转换运算符" class="headerlink" title="类型转换运算符"></a>类型转换运算符</h3><p>C#允许将显式类型转换和隐式类型转换看作运算符，并且得到重载功能</p><h5 id="重载隐式类型转换"><a href="#重载隐式类型转换" class="headerlink" title="重载隐式类型转换"></a>重载隐式类型转换</h5><blockquote><p>public static implicit operator <code>目标类型</code> (<code>类型</code> <code>待转换对象</code>)</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">namespace</span> <span class="hljs-title">Demo05</span><br>&#123;<br>    <span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Demo02</span><br>    &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> age = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> name = <span class="hljs-string">&quot;&quot;</span>;<br><br>        <span class="hljs-comment">// 重载隐式类型转换，当对象被直接赋值整型变量时执行此方法</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">Demo02</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> age</span>)</span><br>        &#123;<br>            Demo02 d = <span class="hljs-keyword">new</span> Demo02();<br>            d.age = age;<br>            <span class="hljs-keyword">return</span> d;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] <span class="hljs-keyword">args</span></span>)</span><br>        &#123;<br>            <span class="hljs-keyword">var</span> demo02 = <span class="hljs-keyword">new</span> Demo02();<br>            demo02 = <span class="hljs-number">18</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="重载显式类型转换"><a href="#重载显式类型转换" class="headerlink" title="重载显式类型转换"></a>重载显式类型转换</h5><blockquote><p>public static explicit operator <code>目标类型</code> (<code>类型</code> <code>待转换对象</code>)</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">namespace</span> <span class="hljs-title">Demo05</span><br>&#123;<br>    <span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Demo02</span><br>    &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> age = <span class="hljs-number">18</span>;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> name = <span class="hljs-string">&quot;&quot;</span>;<br><br>        <span class="hljs-comment">// 重载显式类型转换，当对象被强转为int型变量时调用此方法</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">explicit</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">int</span>(<span class="hljs-params">Demo02 d</span>)</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> d.age;<br>        &#125;<br><br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] <span class="hljs-keyword">args</span></span>)</span><br>        &#123;<br>            <span class="hljs-keyword">var</span> demo02 = <span class="hljs-keyword">new</span> Demo02();<br>            <span class="hljs-built_in">int</span> a = (<span class="hljs-built_in">int</span>)demo02;<br><br>            Console.WriteLine(a);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>NET框架相关</category>
      
      <category>c#</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Csharp-事件</title>
    <link href="/2024/09/14/Csharp-%E4%BA%8B%E4%BB%B6/"/>
    <url>/2024/09/14/Csharp-%E4%BA%8B%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="Csharp-事件"><a href="#Csharp-事件" class="headerlink" title="Csharp-事件"></a>Csharp-事件</h1><p>事件是C#馈赠给我们的礼物，是将委托的多播功能进行封装后的工具类</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">EventHandler</span>(<span class="hljs-params"><span class="hljs-built_in">object</span>? sender, EventArgs e</span>)</span>;<br></code></pre></td></tr></table></figure><ul><li>事件对应的委托，不应该被类外界调用，只能由某个操作触发</li><li>事件对应的委托，不应该被类外直接赋值，只能够通过+、-增减委托方法</li></ul><p><strong>Event事件规则</strong></p><ul><li>加event关键字修饰的委托，只能够定义在某个类中</li><li>加event关键字修饰的委托，只能够被当前类内方法触发执行；类外不触发执行</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">namespace</span> <span class="hljs-title">Demo03</span><br>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Player</span><br>    &#123;<br>        <span class="hljs-comment">// 定义Player内部会被触发的事件委托</span><br>        <span class="hljs-comment">// 使用微软定义好的委托EventHandler</span><br>        <span class="hljs-comment">// 使用event修饰委托引用，则类外无法直接调用OnAttach，只能进行方法加减的操作</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> EventHandler OnAttach = <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoAOE</span>()</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (OnAttach != <span class="hljs-literal">null</span>)<br>            &#123;<br>                OnAttach(<span class="hljs-keyword">this</span>, EventArgs.Empty);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Enemy</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AttackMe</span>(<span class="hljs-params"><span class="hljs-built_in">object</span>? sender, EventArgs e</span>)</span><br>        &#123;<br>            Console.Write(<span class="hljs-string">&quot;我被攻击了&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] <span class="hljs-keyword">args</span></span>)</span><br>        &#123;<br>            <span class="hljs-keyword">var</span> player = <span class="hljs-keyword">new</span> Player();<br>            <span class="hljs-keyword">var</span> enemy = <span class="hljs-keyword">new</span> Enemy();<br><br>            <span class="hljs-comment">// 将AttachMe方法注入到OnAttach委托引用中</span><br>            player.OnAttach += enemy.AttackMe;<br><br>            player.DoAOE();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="事件参数EventArgs"><a href="#事件参数EventArgs" class="headerlink" title="事件参数EventArgs"></a>事件参数EventArgs</h3><p>系统提供了封装好的多播委托（事件）EventHandler，并可通过event关键字将其保护起来</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">EventHandler</span>(<span class="hljs-params"><span class="hljs-built_in">object</span>? sender, EventArgs e</span>)</span>;<br></code></pre></td></tr></table></figure><p>但这个方法的参数是object? sender：方法发起者</p><p>还有EventArgs e：事件参数</p><p>可以看到，这个事件参数的类型是一个被定义好的类型，但实际开发过程中，我们应该使用的是自定义参的参数类型</p><hr><h5 id="定义自己的事件参数包class"><a href="#定义自己的事件参数包class" class="headerlink" title="定义自己的事件参数包class"></a>定义自己的事件参数包class</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">MyArgs</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> attack = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> poisoned = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> headache = <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="将事件参数包类型作为委托的泛型传递"><a href="#将事件参数包类型作为委托的泛型传递" class="headerlink" title="将事件参数包类型作为委托的泛型传递"></a>将事件参数包类型作为委托的泛型传递</h5><p>可以看到源码中由此定义</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">EventHandler</span>&lt;<span class="hljs-title">TEventArgs</span>&gt;(<span class="hljs-params"><span class="hljs-built_in">object</span>? sender, TEventArgs e</span>)</span>;<br></code></pre></td></tr></table></figure><p>其中，我们可以自定义事件参数类型，通过泛型来实现</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> EventHandler&lt;MyArgs&gt; OnAttach;<br></code></pre></td></tr></table></figure><hr><h5 id="响应方法中，将事件参数包替换成自定义参数包类型"><a href="#响应方法中，将事件参数包替换成自定义参数包类型" class="headerlink" title="响应方法中，将事件参数包替换成自定义参数包类型"></a>响应方法中，将事件参数包替换成自定义参数包类型</h5><p>在事件发起者中，将事件参数包的参数写好</p><p>被加入到事件中的方法的参数也要使用参数包类型</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Player</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> EventHandler&lt;MyArgs&gt; OnAttach;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoAOE</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (OnAttach != <span class="hljs-literal">null</span>)<br>        &#123;<br>            <span class="hljs-keyword">var</span> myArgs = <span class="hljs-keyword">new</span> MyArgs();<br>            myArgs.attack = <span class="hljs-number">10</span>;<br>            myArgs.poisoned = <span class="hljs-literal">true</span>;<br>            myArgs.headache = <span class="hljs-literal">true</span>;<br><br>            OnAttach(<span class="hljs-keyword">this</span>, myArgs);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Enemy</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AttackMe</span>(<span class="hljs-params"><span class="hljs-built_in">object</span>? sender, MyArgs e</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;sender&#125;</span>发起了攻击&quot;</span>); <span class="hljs-comment">// Demo04.Player发起了攻击</span><br>        Console.WriteLine(<span class="hljs-string">$&quot;受到了<span class="hljs-subst">&#123;e.attack&#125;</span>点伤害&quot;</span>); <span class="hljs-comment">// 受到了10点伤害</span><br>        Console.WriteLine(<span class="hljs-string">$&quot;是否中毒：<span class="hljs-subst">&#123;e.poisoned&#125;</span>&quot;</span>); <span class="hljs-comment">// 是否中毒：True</span><br>        Console.WriteLine(<span class="hljs-string">$&quot;是否眩晕：<span class="hljs-subst">&#123;e.headache&#125;</span>&quot;</span>); <span class="hljs-comment">// 是否眩晕：True</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="事件总结"><a href="#事件总结" class="headerlink" title="事件总结"></a>事件总结</h3><p>事件是一个public类型的字段，由开发者在类中使用event关键字定义此字段</p><p>通常我们使用系统封装的EventHandler多播委托作为事件的字段定义，这个字段拥有两个参数，分别是事件发起者和事件参数包</p><p>通常我们使用自定义事件参数包（class）并通过泛型的方式使用它</p><p>在调用事件时，我们加入到此字段的方法的返回值和参数应该与事件字段的定义相同</p><p>然后将方法使用+&#x3D;加入到这个字段中，再通过封装好的方法调用字段（其本质是调用加入的方法）</p><p>需要注意的是：如果使用event关键字保护了字段，这里不能直接使用调用字段的方式调用方法，需要额外的封装一个方法（例如（OnClick）来调用字段（也就是方法））</p><p>发布-订阅模式通过引入中间件（消息代理）来实现发布者和订阅者之间的解耦，使得系统更加灵活和可扩展。这种模式在许多领域都有广泛的应用，包括消息队列、<strong>事件驱动架构</strong>和分布式系统等。</p><hr>]]></content>
    
    
    <categories>
      
      <category>NET框架相关</category>
      
      <category>c#</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Csharp-委托</title>
    <link href="/2024/09/14/Csharp-%E5%A7%94%E6%89%98/"/>
    <url>/2024/09/14/Csharp-%E5%A7%94%E6%89%98/</url>
    
    <content type="html"><![CDATA[<h1 id="Csharp-委托"><a href="#Csharp-委托" class="headerlink" title="Csharp-委托"></a>Csharp-委托</h1><p>委托（Delegate）：是一种<code>引用类型</code>的变量，用于存储某个方法的引用地址</p><ul><li>定义委托</li><li>声明委托变量</li><li>关联方法</li><li>调用委托</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">namespace</span> <span class="hljs-title">HelloWorld</span><br>&#123;<br>    <span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>    &#123;<br>        <span class="hljs-comment">// 定义一个委托</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Calculate</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y</span>)</span>;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Add</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y</span>)</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> x + y;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Multiply</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y</span>)</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> x * y;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] <span class="hljs-keyword">args</span></span>)</span><br>        &#123;<br>            <br>            <span class="hljs-comment">// 定义委托的同时关联方法 </span><br>            <span class="hljs-keyword">var</span> <span class="hljs-keyword">add</span> = <span class="hljs-keyword">new</span> Calculate(Add);<br>            <span class="hljs-keyword">var</span> multiply = <span class="hljs-keyword">new</span> Calculate(Multiply);<br><br>            <span class="hljs-comment">// 执行方式1：通过Calculate变量名.Invoke执行方法</span><br>            Console.WriteLine(<span class="hljs-keyword">add</span>.Invoke(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));<br><br>            <span class="hljs-comment">// 执行方式2：通过Calculate变量名()执行方法</span><br>            Console.WriteLine(multiply(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>简而言之，委托定义了可以由其引用的方法的类型。这意味着你可以通过使用委托来创建指向函数的引用，并可以在运行时调用该函数</p><p>这样会使项目解耦合，使类之间的关系不那么密切，大幅提升了代码的复用率</p><hr><h3 id="委托的多播"><a href="#委托的多播" class="headerlink" title="委托的多播"></a>委托的多播</h3><p>委托并不是只能够绑定唯一的方法去执行，我们可以通过多播委托的方式让一条委托的调用去执行多个方法</p><p>多播委托的返回值是最后一个子委托执行方法的返回值</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">namespace</span> <span class="hljs-title">Demo02</span><br>&#123;<br>    <span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>    &#123;<br>        <span class="hljs-comment">// 声明一个委托</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Calculate</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y</span>)</span>;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Add</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y</span>)</span><br>        &#123;<br>            Console.WriteLine(x + y);<br>            <span class="hljs-keyword">return</span> x + y;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Multiply</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y</span>)</span><br>        &#123;<br>            Console.WriteLine(x * y);<br>            <span class="hljs-keyword">return</span> x * y;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] <span class="hljs-keyword">args</span></span>)</span><br>        &#123;<br>            <span class="hljs-comment">// 声明多个cal 作为子委托对象</span><br>            <span class="hljs-keyword">var</span> cal1 = <span class="hljs-keyword">new</span> Calculate(Add);<br>            <span class="hljs-keyword">var</span> cal2 = <span class="hljs-keyword">new</span> Calculate(Multiply);<br>            <span class="hljs-keyword">var</span> cal3 = <span class="hljs-keyword">new</span> Calculate(Add);<br><br>            <span class="hljs-comment">// 声明一个cal作为主委托对象</span><br>            Calculate cal = <span class="hljs-literal">null</span>;<br>            <span class="hljs-comment">// 通过+=号将子委托对象累加到主委托对象中</span><br>            cal += cal1;<br>            cal += cal2;<br>            cal += cal3;<br>            <span class="hljs-comment">// 通过主委托对象调用方法，其子委托依次调用其关联方法</span><br>            cal(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>还有一些其他的多播委托的创建方式</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">Calculate cal = cal1 + cal2 + cal3;<br></code></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#">Calculate cal = cal1;<br>cal += cal2;<br>cal += cal3;<br></code></pre></td></tr></table></figure><hr><p>相同的，我们可以通过<code>-=</code>符号对子委托进行删减</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 声明多个cal 作为子委托对象</span><br><span class="hljs-keyword">var</span> cal1 = <span class="hljs-keyword">new</span> Calculate(Add);<br><span class="hljs-keyword">var</span> cal2 = <span class="hljs-keyword">new</span> Calculate(Multiply);<br><span class="hljs-keyword">var</span> cal3 = <span class="hljs-keyword">new</span> Calculate(Add);<br><br><span class="hljs-comment">// 声明一个cal作为主委托对象</span><br>Calculate cal = <span class="hljs-literal">null</span>;<br><span class="hljs-comment">// 通过+=号将子委托对象累加到主委托对象中</span><br>cal += cal1;<br>cal += cal2;<br>cal += cal3;<br><span class="hljs-comment">// 通过-=号将子委托对象从主委托对象中删减</span><br>cal -= cal3;<br></code></pre></td></tr></table></figure><hr><h5 id="直接添加方法到委托"><a href="#直接添加方法到委托" class="headerlink" title="直接添加方法到委托"></a>直接添加方法到委托</h5><p>我们除了声明子委托添加到主委托的方式，还可以直接将方法添加到主委托中</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] <span class="hljs-keyword">args</span></span>)</span><br>&#123;<br><br>    <span class="hljs-comment">// 声明一个cal作为主委托对象</span><br>    Calculate? cal = <span class="hljs-literal">null</span>;<br>    cal += Program.Add;<br>    cal += Program.Multiply;<br>    cal += Program.Add;<br><br>    cal(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="遍历委托"><a href="#遍历委托" class="headerlink" title="遍历委托"></a>遍历委托</h3><p>委托的Api：GetInvocationList可以查看主委托中包含的所有子委托，其返回值是一个委托数组</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#">Calculate? cal = cal1 + cal2 + cal3;<br><br><span class="hljs-keyword">foreach</span> (Calculate c <span class="hljs-keyword">in</span> cal.GetInvocationList())<br>&#123;<br>    <span class="hljs-comment">// 循环遍历每一个cal执行方法，就可以打印每一个委托方法的返回值了</span><br>    <span class="hljs-built_in">int</span> result = c(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>    Console.WriteLine(result);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>委托定义好了一个方法的返回值和参数列表，通过Lambda可以快速的实现其中的方法执行逻辑，将Lambda表达式赋值给这个委托引用类型定义的变量，即可完成一次对方法的逻辑的定义</p>]]></content>
    
    
    <categories>
      
      <category>NET框架相关</category>
      
      <category>c#</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Csharp高级面向对象</title>
    <link href="/2024/09/14/Csharp%E9%AB%98%E7%BA%A7%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <url>/2024/09/14/Csharp%E9%AB%98%E7%BA%A7%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="Csharp高级面向对象"><a href="#Csharp高级面向对象" class="headerlink" title="Csharp高级面向对象"></a>Csharp高级面向对象</h1><h3 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a>Object类型</h3><p>对于C# 中所有Class，默认的最终基类都是Object类（System命名空间下，简写为object）</p><p>同Java一样，C#的Object同样提供了一些方法</p><hr><h5 id="ToString方法"><a href="#ToString方法" class="headerlink" title="ToString方法"></a>ToString方法</h5><p>用于“打印”当前对象信息，即将当前对象的字段们都转化为字符串，以一定格式打印输出</p><p>默认情况打印当前对象的全类名</p><p>我们需要在类中重写此方法，以完成对对象中内容的输出</p><hr><h5 id="GetType方法"><a href="#GetType方法" class="headerlink" title="GetType方法"></a>GetType方法</h5><p>此方法会返回一个Type类型的对象（System命名空间提供的类型），这个对象提供了一些方法</p><p>这些方法可以获取对象的运行时类信息，常常用于反射</p><ul><li>FullName方法：获取当前对象的类全名</li><li>Name方法：获取当前对象的类名</li><li>IsValueType方法：判断当前对象是否为值类型</li><li>IsClass方法：判断当前对象是否为引用类型</li></ul><hr><h5 id="Equals方法"><a href="#Equals方法" class="headerlink" title="Equals方法"></a>Equals方法</h5><p>判断两个对象是否相等</p><blockquote><p><code>==</code>用于判断值类型的值相同、引用类型的地址相同、字符串的字符相同</p></blockquote><p>Equals方法如果不被重写，那么他的运行逻辑和<code>==</code>是一样的</p><p>我们需要在类中重写此方法，以完成对对象中内容的相等判断</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span>? Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Age &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">Equals</span>(<span class="hljs-params"><span class="hljs-built_in">object</span>? obj</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// 使用as关键字判断传入的对象是否为User对象</span><br>        <span class="hljs-keyword">var</span> user = obj <span class="hljs-keyword">as</span> User;<br>        <span class="hljs-comment">// 如果不为User对象，则返回不相等</span><br>        <span class="hljs-keyword">if</span> (user == <span class="hljs-literal">null</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 判断传入对象的属性是否相等</span><br>        <span class="hljs-keyword">return</span> user.Name == Name &amp;&amp; user.Age == Age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="AS-IS关键字"><a href="#AS-IS关键字" class="headerlink" title="AS&amp;IS关键字"></a>AS&amp;IS关键字</h3><p>在C#中，<code>as</code> 关键字用于尝试将一个对象转换为其基类或接口类型，这是一种安全的向下转型（downcast）的方式。如果转换成功，<code>as</code> 将返回转换后的对象；如果失败，则返回 <code>null</code>（对于引用类型）或默认值（对于值类型）。这种方法不会抛出异常，因此是一种较为安全的类型转换方式。</p><p><code>is</code> 关键字用于测试一个对象是否是某个类型的实例，或者是否可以转换为某个接口类型</p><p><code>as</code> 关键字提供了一种安全的方式来执行类型转换，特别适用于需要向下转型的场景。与 <code>is</code> 结合使用时，可以进一步提高代码的安全性和可读性。使用 <code>as</code> 进行转换不会抛出异常，而是返回 <code>null</code> 或默认值，这使得它成为处理不确定类型的对象时的一个好选择</p><hr><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>C#的泛型与Java并没有显著区别，所以具体可以参考笔记中的Java中的泛型知识点</p><p>当使用泛型方法在方法内部做数据处理时，我们会遇到意料之外的报错</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> T <span class="hljs-title">Add</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">T a, T b</span>)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<span class="hljs-comment">// 这样写会报错</span><br>&#125;<br></code></pre></td></tr></table></figure><p>通过<code>dynamic</code>关键字来将类型校验推迟到运行时，而不是在编译时进行类型校验</p><p><em>dynamic中文释义：动态</em></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> T <span class="hljs-title">Add</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">T a, T b</span>)</span><br>&#123;<br>    <span class="hljs-built_in">dynamic</span>? da = a;<br>    <span class="hljs-built_in">dynamic</span>? db = b;<br>    <span class="hljs-comment">// 这时，当传入的参数类型违法时，会在运行时报错，而不是编译时报错</span><br>    <span class="hljs-keyword">return</span> da + db;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>泛型类可以被继承，在继承时，可以选择对泛型的特化与不特化（子类同时继承泛型类状态），同时，子类可以在父类的基础上添加更多个泛型类型</strong></p><hr><h3 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h3><h5 id="接口约束"><a href="#接口约束" class="headerlink" title="接口约束"></a>接口约束</h5><p>使用where关键字对泛型类型加以约束，使用接口的形式规定这个泛型类型必须包含某些可以执行的方法</p><p><em>接口约束可以同时存在多个，以逗号分隔</em></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IHello</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SayHello</span>()</span>;<br>&#125;<br><br><span class="hljs-comment">// 对泛型类型加以约束，确保该类型的对象中存在此方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorld</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">where</span> <span class="hljs-title">T</span> : <span class="hljs-title">IHello</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Hello</span>(<span class="hljs-params">T t</span>)</span><br>    &#123;<br>        t.SayHello();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="class约束"><a href="#class约束" class="headerlink" title="class约束"></a>class约束</h5><p>使用where关键字配合class关键字来约束泛型的类型必须为引用类型</p><p><em>在C#中，class的关键字的含义即为引用类型</em></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorld</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">where</span> <span class="hljs-title">T</span> : <span class="hljs-keyword">class</span><br>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="struct约束"><a href="#struct约束" class="headerlink" title="struct约束"></a>struct约束</h5><p>使用where关键字配合struct关键字来约束泛型的类型必须为值类型</p><p><em>注：在C#中，结构体类型为值类型数据</em></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorld</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">where</span> <span class="hljs-title">T</span> : <span class="hljs-title">struct</span><br>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="new-约束"><a href="#new-约束" class="headerlink" title="new()约束"></a>new()约束</h5><p>使用where关键字配合new()关键字来约束泛型类型中必须存在无参构造方法</p><p><em>既然必须存在无参构造方法，那么该类型也一定是引用类型（class）</em></p><p><em>如果存在多个泛型约束，那么new()约束必须放到最后才能成立</em></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorld</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">where</span> <span class="hljs-title">T</span> : <span class="hljs-title">new</span>()<br>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="类名约束"><a href="#类名约束" class="headerlink" title="类名约束"></a>类名约束</h5><p>使用where关键字配合类名来约束泛型类型中必须为该类或该类的子类</p><p><em>可以与接口约束同时存在，但是必须写在最前面且唯一（有点像类的继承）</em></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorld</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">where</span> <span class="hljs-title">T</span> : <span class="hljs-title">User</span><br>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="多泛型约束"><a href="#多泛型约束" class="headerlink" title="多泛型约束"></a>多泛型约束</h5><p>使用where关键字对多个占位符进行分别的约束</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorld</span>&lt;<span class="hljs-title">T</span>,<span class="hljs-title">R</span>&gt; <span class="hljs-keyword">where</span> <span class="hljs-title">T</span> : <span class="hljs-title">struct</span> <span class="hljs-keyword">where</span> <span class="hljs-title">R</span> : <span class="hljs-keyword">class</span><br>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>NET框架相关</category>
      
      <category>c#</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Csharp面向对象</title>
    <link href="/2024/09/13/Csharp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <url>/2024/09/13/Csharp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="Csharp面向对象"><a href="#Csharp面向对象" class="headerlink" title="Csharp面向对象"></a>Csharp面向对象</h1><h3 id="封装（get-set）"><a href="#封装（get-set）" class="headerlink" title="封装（get&#x2F;set）"></a>封装（get&#x2F;set）</h3><p>与Java不同，C#的get和set写法很特别</p><p>并且，我们可以在set和get方法中加以对数据的处理</p><p><strong>注：在C#中，我们严格区分了属性和字段的概念</strong></p><ul><li>字段：私有的，通常以下划线+小写字母开头</li><li>属性：公共的，通常以大写字母开头</li></ul><p>通过使用属性，我们可以在不暴露实际字段的情况下，提供对类内部状态的访问</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">namespace</span> <span class="hljs-title">HelloWorld</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span><br>&#123;<br>    <span class="hljs-comment">// 字段name</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> name;<br>    <br>    <span class="hljs-comment">// 属性Name</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name<br>    &#123;<br>        <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> name; &#125;<br>        <span class="hljs-comment">// value 就是调用Name时传入的参数</span><br>        <span class="hljs-keyword">set</span> &#123; name = <span class="hljs-keyword">value</span>; &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] <span class="hljs-keyword">args</span></span>)</span><br>    &#123;<br>        Hello hello = <span class="hljs-keyword">new</span> Hello();<br>        <span class="hljs-comment">// 调用属性Name中的set方法</span><br>        hello.Name = <span class="hljs-string">&quot;xiaobai&quot;</span>;<br>        <br>        <span class="hljs-comment">//调用属性Name中的get方法</span><br>        <span class="hljs-keyword">var</span> rectangleName = hello.Name;<br>        <br>        Console.WriteLine(rectangleName);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="自动实现的属性"><a href="#自动实现的属性" class="headerlink" title="自动实现的属性"></a>自动实现的属性</h5><p>C# 还支持自动实现的属性（Auto-Implemented Properties），这是一种简化的属性定义方式，编译器会自动为你创建一个私有字段来支持该属性</p><p><em>注：这个字段由编译器自动生成的一个内部名称。这种方式使得代码更加简洁，并且易于维护</em></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">namespace</span> <span class="hljs-title">HelloWorld</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] <span class="hljs-keyword">args</span></span>)</span><br>    &#123;<br>        Hello hello = <span class="hljs-keyword">new</span> Hello();<br>        <span class="hljs-comment">// 调用属性Name中的set方法</span><br>        hello.Name = <span class="hljs-string">&quot;xiaobai&quot;</span>;<br><br>        <span class="hljs-comment">//调用属性Name中的get方法</span><br>        <span class="hljs-keyword">var</span> rectangleName = hello.Name;<br><br>        Console.WriteLine(rectangleName);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="属性访问器注意事项"><a href="#属性访问器注意事项" class="headerlink" title="属性访问器注意事项"></a>属性访问器注意事项</h5><ul><li><p>get方法不可以被省略</p></li><li><p>set方法可以被省略</p><ul><li>构造方法可以对省略set的属性进行赋初值</li><li><strong>类中其他方法不可以对省略set的属性进行操作</strong></li></ul></li><li><p>在set前使用private修饰后，则可以实现只有本类能对属性进行set操作</p></li><li><p>不能在set和get上同时使用private修饰</p></li><li><p>属性的访问限定符可以同时对set和get上进行修饰（get和set继承属性的访问修饰符）</p></li></ul><hr><h3 id="继承-实现"><a href="#继承-实现" class="headerlink" title="继承&amp;实现"></a>继承&amp;实现</h3><p>在Java中，继承与实现是不同的关键字</p><p>在C# 中，继承与实现都是<code>:</code>来实现的</p><p>并且在C# 中，也是可以同时实现多个接口的</p><p><em>注：私有成员（方法、属性、事件）是无法被继承和实现的</em></p><p>在Java中，我们调用父类中的属性（方法）时，使用关键字super</p><p>而在C#中，使用关键字base调用</p><hr><h5 id="显式调用父类构造方法"><a href="#显式调用父类构造方法" class="headerlink" title="显式调用父类构造方法"></a>显式调用父类构造方法</h5><p>当父类只有一个带参构造时，需要其子类显式调用其父类构造方法</p><p><em>但如果存在一个带参构造时，基本上都要单独声明一个无参构造方法</em></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Father</span><br>&#123;<br>    <span class="hljs-keyword">public</span> String Xing;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Father</span>(<span class="hljs-params">String xing</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">this</span>.Xing = xing;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> : <span class="hljs-title">Father</span><br>&#123;<br>    <span class="hljs-comment">// 显式调用父类的构造方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Son</span>(<span class="hljs-params">String xing</span>) : <span class="hljs-title">base</span>(<span class="hljs-params">xing</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">this</span>.Xing = xing;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="多态-重写"><a href="#多态-重写" class="headerlink" title="多态&amp;重写"></a>多态&amp;重写</h3><p>当子类存在与父类相同名字相同参数的方法时，父类方法并没有被重写覆盖，而是对父类方法进行一个隐藏（与Java不同点）</p><p><em>注：当写同名同参方法时（隐藏父方法而非重写），子方法被C#推荐要加上new关键字</em></p><p>可以通过base关键字调用到被隐藏的父类方法</p><ul><li><p>virtual关键字，用以修饰父类方法，将其标记成虚拟方法</p></li><li><p>override重写关键字，用以重写父类方法</p></li></ul><p>使用这一对关键字，就可以构成方法的重写</p><p>而C#同时存在abstract关键字，用以修饰父类方法，将其标记成抽象方法</p><p><strong><code>abstract</code>和<code>virtual</code>的明显区别是，abstract强制要求其子类重写此方法，而virtual不强制重写</strong></p><p><em>注：当父类方法被virtual标记而子类没有重写此方法时，在方法调用时还是调用父类方法</em></p><hr><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>抽象类存在自己的构造方法，供子类实例化时调用，但抽象类无法被用户实例化</p><p>在C# 中，类中字段如果没有访问修饰符，则默认为private（在Java中，必须存在访问修饰符）</p><p>抽象类中可以存在抽象方法与非抽象方法，如果存在抽象方法，则其子类必须重写该抽象方法</p><p>对比接口来说，抽象类可以存在非抽象方法（即具体的方法实现），而且C#也是单继承语言，所以只能继承一个类，而可以实现多个接口</p><p><em>注：抽象方法只能存在于抽象类中，而不能存在于非抽象类中</em></p><p><em>在C#中，abstract修饰的方法在重写是需要使用override关键字</em></p><hr><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>在接口中，方法默认的修饰符是public，这意味着接口中的所有成员（包括方法、属性、事件等）默认都是公开的，即任何实现了该接口的类都必须公开实现这些成员</p><p><em>在类中，属性默认的修饰符为private</em></p><p>在C#的命名规则中，接口多以<code>I</code>开头</p><p><strong>子类可以同时继承父类和实现多个接口，但继承需要写在最前面，以逗号分割</strong></p><hr>]]></content>
    
    
    <categories>
      
      <category>NET框架相关</category>
      
      <category>c#</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Csharp基础入门</title>
    <link href="/2024/09/13/Csharp%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    <url>/2024/09/13/Csharp%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Csharp基础入门"><a href="#Csharp基础入门" class="headerlink" title="Csharp基础入门"></a>Csharp基础入门</h1><p>C#的文件后缀是.cs</p><p>在一个解决方案中会有N个项目文件夹</p><p>在C#中，控制台输出的方式是调用System命名空间中的console类中的WriteLine()方法</p><p>System命名空间由.Net提供，有很多程序的基础功能</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#">System.Console.WriteLine();<span class="hljs-comment">// 在控制台中输出内容</span><br>System.Console.ReadLine();<span class="hljs-comment">// 在控制台中输入内容</span><br>System.Console.ReadKey();<span class="hljs-comment">// 从控制台读取用户输入的一个按键</span><br></code></pre></td></tr></table></figure><p><em>在Rider中，输出内容的快捷键从sout变成cw了</em>  😊</p><hr><h3 id="命名空间概念"><a href="#命名空间概念" class="headerlink" title="命名空间概念"></a>命名空间概念</h3><p>在Java中，管理多个类的目录结构是<code>包</code>，以package关键字声明</p><p>在C#中，管理多个类的目录结构是<code>命名空间</code>，以namespace关键字声明</p><p>而在导入的过程中，Java使用import关键字导包</p><p>而C#使用using关键字导入命名空间</p><p><strong>以类名作为文件名，以命名空间名作为目录结构名</strong></p><hr><h3 id="命名规则差异"><a href="#命名规则差异" class="headerlink" title="命名规则差异"></a>命名规则差异</h3><ol><li><strong>类名和接口名</strong>：<ul><li>C# 中的类名和接口名同样使用大写的首字母（PascalCase），例如：<code>MyClass</code>。</li><li>C# 的类名通常以 <code>.cs</code> 扩展名保存。</li></ul></li><li><strong>命名空间</strong>：<ul><li>C# 中的命名空间（Namespace）通常使用大写的首字母，例如：<code>MyCompany.MyApp</code>。</li><li>命名空间通常反映了公司或产品的名称结构。</li></ul></li><li><strong>常量名</strong>：<ul><li>C# 中的常量名通常使用全大写，单词间用下划线分隔，例如：<code>MY_CONSTANT</code>。</li></ul></li><li><strong>字段名</strong>：<ul><li>私有字段通常以下划线开头加驼峰命名法，例如：<code>_myField</code>。</li><li>公共属性（Property）通常使用驼峰命名法，首字母大写，例如：<code>MyProperty</code>。</li></ul></li><li><strong>方法名</strong>：<ul><li>在C#中方法名通常使用大写开头的驼峰命名方法，例如：<code>MyMethodName</code>。</li></ul></li></ol><h5 id="一些其他差异"><a href="#一些其他差异" class="headerlink" title="一些其他差异"></a>一些其他差异</h5><ol><li><strong>包&#x2F;命名空间的大小写</strong>：<ul><li>Java 中的包名通常全部小写，而 C# 中的命名空间可以使用大小写混合。</li></ul></li><li><strong>文件扩展名</strong>：<ul><li>Java 文件扩展名为 <code>.java</code>，而 C# 文件扩展名为 <code>.cs</code>。</li></ul></li><li><strong>方法参数</strong>：<ul><li>参数名通常使用小写字母开始的驼峰命名法，例如：<code>myParameter</code>。</li></ul></li></ol><hr><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>在C#中，<code>var</code> 关键字是一个类型推断关键字，它允许你在声明变量时省略变量的具体类型</p><p>编译器会根据变量的初始值自动推断出变量的类型</p><p>这使得代码更加简洁，尤其是在类型显而易见的情况下</p><p><em>注：在使用var进行变量声明时，不能不初始化改变量（延迟初始化）</em></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">var</span> message = <span class="hljs-string">&quot;Hello, World!&quot;</span>;  <span class="hljs-comment">// 类型为 string</span><br><span class="hljs-keyword">var</span> number = <span class="hljs-number">42</span>;               <span class="hljs-comment">// 类型为 int</span><br><span class="hljs-keyword">var</span> collection = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;();  <span class="hljs-comment">// 类型为 List&lt;int&gt;</span><br><br><span class="hljs-keyword">var</span> x;  <span class="hljs-comment">// 编译错误</span><br>x = <span class="hljs-number">10</span>; <span class="hljs-comment">// 也不能这样写</span><br></code></pre></td></tr></table></figure><hr><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>与Java的数据类型基本相同，C#也有基本数据类型与其包装类型</p><p>在C# 中多一个decimal类型，他比double的精度更高，更适用于金融类型数据的处理</p><p><em>decimal中文释义：十进制</em></p><p>需要注意的是，在不同的数据进行运算时，会默认进行隐式转换（有低类型到高类型的转换）</p><h5 id="nullable（可空类型）"><a href="#nullable（可空类型）" class="headerlink" title="nullable（可空类型）"></a>nullable（可空类型）</h5><p>C# 提供了一个特殊的数据类型，<strong>nullable</strong> 类型（可空类型），可空类型可以表示其基础值类型正常范围内的值，再加上一个 null 值</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">int</span>? num1 = <span class="hljs-literal">null</span>;<br><span class="hljs-built_in">int</span>? num2 = <span class="hljs-number">45</span>;<br><span class="hljs-built_in">double</span>? num3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">double</span>?();<br><span class="hljs-built_in">double</span>? num4 = <span class="hljs-number">3.14157</span>;<br><br><span class="hljs-built_in">bool</span>? boolval = <span class="hljs-keyword">new</span> <span class="hljs-built_in">bool</span>?();<br></code></pre></td></tr></table></figure><h5 id="Null-合并运算符（-）"><a href="#Null-合并运算符（-）" class="headerlink" title="Null 合并运算符（ ?? ）"></a>Null 合并运算符（ ?? ）</h5><p>C# 中两个问号的作用是判断<code>??</code>左边的对象是否为 null，如果不为 null 则使用<code>??</code> 左边的对象，如果为 null 则使用 <code>??</code> 右边的对象</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">num3 = num1 ?? <span class="hljs-number">5.34</span>;<br>num3 = (num1 == <span class="hljs-literal">null</span>) ? <span class="hljs-number">5.34</span> : num1;<br></code></pre></td></tr></table></figure><hr><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p>在C# 中，字符串类是string，而Java是String</p><p>与Java相同，C#提供了很多有关于字符串操作的方法，而且这些常用方法的重载十分有用，在合适的场景填写合适的参数</p><hr><h5 id="插值字符串"><a href="#插值字符串" class="headerlink" title="插值字符串"></a>插值字符串</h5><p>这是C#提供的一个语法糖，其语法为：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;xiaobai&quot;</span>;<br><span class="hljs-keyword">var</span> str = <span class="hljs-string">$&quot;hello, my name is <span class="hljs-subst">&#123;name&#125;</span>&quot;</span>;<br></code></pre></td></tr></table></figure><hr><h5 id="Split方法"><a href="#Split方法" class="headerlink" title="Split方法"></a>Split方法</h5><p>选用分隔符，对字符串进行分割</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">var</span> message = <span class="hljs-string">&quot;Hello world&quot;</span>;<br><span class="hljs-built_in">string</span>[] strings = message.Split(<span class="hljs-string">&quot; &quot;</span>);<br></code></pre></td></tr></table></figure><hr><h5 id="IndexOf方法"><a href="#IndexOf方法" class="headerlink" title="IndexOf方法"></a>IndexOf方法</h5><p>输出指定字符在字符串中的索引值</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">var</span> message = <span class="hljs-string">&quot;Hello world&quot;</span>;<br><span class="hljs-keyword">var</span> indexOf = message.IndexOf(<span class="hljs-string">&quot; &quot;</span>); <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure><hr><h5 id="Join方法"><a href="#Join方法" class="headerlink" title="Join方法"></a>Join方法</h5><p>我们可以使用Join方法对字符串数组进行拼接操作</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 示例 1: 使用逗号作为分隔符</span><br><span class="hljs-built_in">string</span>[] fruits = &#123; <span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-string">&quot;Cherry&quot;</span> &#125;;<br><span class="hljs-built_in">string</span> result = <span class="hljs-built_in">string</span>.Join(<span class="hljs-string">&quot;, &quot;</span>, fruits);<br>Console.WriteLine(result);  <span class="hljs-comment">// 输出 &quot;Apple, Banana, Cherry&quot;</span><br><br><span class="hljs-comment">// 示例 2: 使用换行符作为分隔符</span><br><span class="hljs-built_in">string</span> result2 = <span class="hljs-built_in">string</span>.Join(<span class="hljs-string">&quot;\n&quot;</span>, fruits);<br>Console.WriteLine(result2);<br><span class="hljs-comment">// 输出</span><br><span class="hljs-comment">// Apple</span><br><span class="hljs-comment">// Banana</span><br><span class="hljs-comment">// Cherry</span><br>    <br><span class="hljs-comment">// 示例 3: 使用自定义分隔符</span><br><span class="hljs-built_in">string</span> customSeparator = <span class="hljs-string">&quot; | &quot;</span>;<br><span class="hljs-built_in">string</span> result3 = <span class="hljs-built_in">string</span>.Join(customSeparator, fruits);<br>Console.WriteLine(result3);  <span class="hljs-comment">// 输出 &quot;Apple | Banana | Cherry&quot;</span><br></code></pre></td></tr></table></figure><p>然而，在不同的操作系统中，换行符是不同的，所以我们可以使用System.Enviroment提供的只读属性（并非一个方法）NewLine来作为换行符使用</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">string</span> result2 = <span class="hljs-built_in">string</span>.Join(Environment.NewLine, fruits);<br></code></pre></td></tr></table></figure><hr><h5 id="路径拼接"><a href="#路径拼接" class="headerlink" title="路径拼接"></a>路径拼接</h5><p>在开发过程中，我们需要对文件路径的字符串变量进行路径拼接，而在不同系统情况下，路径拼接的连接符是不一样的</p><p>为了解决这个问题，我们使用Path.Combine方法进行路径拼接</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">var</span> dir1 = <span class="hljs-string">&quot;Folder&quot;</span>;<br><span class="hljs-keyword">var</span> dir2 = <span class="hljs-string">&quot;SubFolder&quot;</span>;<br><span class="hljs-keyword">var</span> fn = <span class="hljs-string">&quot;readme.md&quot;</span>;<br><br>Path.Combine(dir1,dir2,fn);<br></code></pre></td></tr></table></figure><hr><h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><p>通过构造函数，填写指定的参数可以实现一些意想不到的功能</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-built_in">string</span> sep = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;=&quot;</span> , <span class="hljs-number">20</span>); <span class="hljs-comment">// 打印20个=以完成换行符功能</span><br><br><span class="hljs-built_in">char</span>[] chars = [<span class="hljs-string">&#x27;h&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;l&#x27;</span>,<span class="hljs-string">&#x27;l&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>];<br><span class="hljs-built_in">string</span> str = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(chars); <span class="hljs-comment">// 以字符数组作为参数可实现字符串的拼接</span><br></code></pre></td></tr></table></figure><hr><h5 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">string</span> message1 = <span class="hljs-string">&quot;hellow world!&quot;</span>;<br><span class="hljs-built_in">string</span> message2 = <span class="hljs-string">&quot;hellow world?&quot;</span>;<br><br>message1.CompareTo(message2); <span class="hljs-comment">// 比较出大小，判断ASCII码</span><br>message1.Equals(message2); <span class="hljs-comment">// 单纯判断是否相等，性能更好</span><br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>NET框架相关</category>
      
      <category>c#</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>苍穹外卖-微信支付</title>
    <link href="/2024/08/17/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96-%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98/"/>
    <url>/2024/08/17/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96-%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98/</url>
    
    <content type="html"><![CDATA[<h1 id="苍穹外卖-微信支付"><a href="#苍穹外卖-微信支付" class="headerlink" title="苍穹外卖-微信支付"></a>苍穹外卖-微信支付</h1><p><a href="https://pay.weixin.qq.com/static/applyment_guide/applyment_index.shtml">微信支付接入指引 - 微信支付商户平台 (qq.com)</a></p><p>实现微信支付的流程，我们在这里选择JSAPI</p><p><img src="/upload/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98.JPG" alt="微信支付.JPG"></p><p><a href="https://pay.weixin.qq.com/docs/merchant/apis/jsapi-payment/direct-jsons/jsapi-prepay.html">JSAPI下单 - JSAPI支付 | 微信支付商户文档中心 (qq.com)</a></p><p>需要准备微信支付平台证书和商户私钥文件，因为微信需要请求回调接口，所以就算是测试阶段，我们的项目也需要暴露在公网上，这里可以使用内网穿透解决</p><p>但我们没有以上的条件，所以这个微信支付无法真实的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用户支付</span><br><span class="hljs-comment"> *  <span class="hljs-doctag">TODO:</span> 正常情况下，在这里应该调用微信支付的正常流程完成微信支付，但我们没有商户号，所以当点击支付按钮之后直接更改数据库的支付状态为已支付</span><br><span class="hljs-comment"> *  <span class="hljs-doctag">TODO:</span> 所以，我们并没有调用weChatPayUtil工具类和PayNotifyController的回调业务接口</span><br><span class="hljs-comment"> *  <span class="hljs-doctag">TODO:</span> 也没有用到WeChatProperties配置属性类和有关的配置文件</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> ordersPaymentDTO</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> OrderPaymentVO <span class="hljs-title function_">payment</span><span class="hljs-params">(OrdersPaymentDTO ordersPaymentDTO)</span> &#123;<br>    <span class="hljs-comment">// 当前登录用户id</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> BaseContext.getCurrentId();<br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userMapper.getById(userId);<br><br>    <span class="hljs-comment">//调用微信支付接口，生成预支付交易单</span><br><span class="hljs-comment">//    JSONObject jsonObject = weChatPayUtil.pay(</span><br><span class="hljs-comment">//            ordersPaymentDTO.getOrderNumber(), //商户订单号</span><br><span class="hljs-comment">//            new BigDecimal(0.01), //支付金额，单位 元</span><br><span class="hljs-comment">//            &quot;苍穹外卖订单&quot;, //商品描述</span><br><span class="hljs-comment">//            user.getOpenid() //微信用户的openid</span><br><span class="hljs-comment">//    );</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//        if (jsonObject.getString(&quot;code&quot;) != null &amp;&amp; jsonObject.getString(&quot;code&quot;).equals(&quot;ORDERPAID&quot;)) &#123;</span><br><span class="hljs-comment">//        throw new OrderBusinessException(&quot;该订单已支付&quot;);</span><br><span class="hljs-comment">//    &#125;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//    OrderPaymentVO vo = jsonObject.toJavaObject(OrderPaymentVO.class);</span><br><span class="hljs-comment">//        vo.setPackageStr(jsonObject.getString(&quot;package&quot;));</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//        return vo;</span><br>    paySuccess(ordersPaymentDTO.getOrderNumber()); <span class="hljs-comment">// 直接修改订单状态为支付成功</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderPaymentVO</span>();<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 支付成功，修改订单状态</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> outTradeNo</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">paySuccess</span><span class="hljs-params">(String outTradeNo)</span> &#123;<br><br>    <span class="hljs-comment">// 根据订单号查询订单</span><br>    <span class="hljs-type">Orders</span> <span class="hljs-variable">ordersDB</span> <span class="hljs-operator">=</span> orderMapper.getByNumber(outTradeNo);<br><br>    <span class="hljs-comment">// 根据订单id更新订单的状态、支付方式、支付状态、结账时间</span><br>    <span class="hljs-type">Orders</span> <span class="hljs-variable">orders</span> <span class="hljs-operator">=</span> Orders.builder()<br>            .id(ordersDB.getId())<br>            .status(Orders.TO_BE_CONFIRMED)<br>            .payStatus(Orders.PAID)<br>            .checkoutTime(LocalDateTime.now())<br>            .build();<br><br>    orderMapper.update(orders);<br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>SSM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>苍穹外卖-缓存和购物车</title>
    <link href="/2024/08/06/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96-%E7%BC%93%E5%AD%98%E5%92%8C%E8%B4%AD%E7%89%A9%E8%BD%A6/"/>
    <url>/2024/08/06/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96-%E7%BC%93%E5%AD%98%E5%92%8C%E8%B4%AD%E7%89%A9%E8%BD%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="苍穹外卖-缓存"><a href="#苍穹外卖-缓存" class="headerlink" title="苍穹外卖-缓存"></a>苍穹外卖-缓存</h1><p>用户端小程序展示的菜品数据都是通过查询数据库获得，如果用户端访问量比较大，数据库访问压力随之增大</p><p>为了解决这个问题，我们通过Redis来缓存菜品数据，减少数据库的查询操作</p><p>当用户查询数据时，先找缓存中，如果没有再将数据库中数据查找到放入缓存中</p><p>当其他用户查询时，缓存中已经存在数据了</p><h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><p>每一个分类的菜品保存在一个缓存数据中（存在一个key中），使用分类id作为缓存的key </p><p>当数据库中的菜品发生变更时清理缓存数据</p><hr><h3 id="业务代码"><a href="#业务代码" class="headerlink" title="业务代码"></a>业务代码</h3><p>Redis中的String类型并不是Java意义上的String字符串类型</p><p>我们使用Java对Redis的String类型数据进行存放，可以直接存放对象类型的数据，怎么存进去怎么取出来即可</p><p>其中的原理就是将对象数据进行一个<strong>序列化</strong>，然后存储，取出来的时候进行反序列化的过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 根据分类id查询菜品</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> categoryId</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@GetMapping(&quot;/list&quot;)</span><br><span class="hljs-meta">@ApiOperation(&quot;根据分类id查询菜品&quot;)</span><br><span class="hljs-keyword">public</span> Result&lt;List&lt;DishVO&gt;&gt; <span class="hljs-title function_">list</span><span class="hljs-params">(Long categoryId)</span> &#123;<br>    <br>    <span class="hljs-comment">// 构造redis中的key，规则：dish_分类id</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;dish_&quot;</span> + categoryId;<br>    List&lt;DishVO&gt; list = (List&lt;DishVO&gt;) redisTemplate.opsForValue().get(key);<br>    <span class="hljs-keyword">if</span> (list != <span class="hljs-literal">null</span> &amp;&amp; list.size() &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 查询到直接返回</span><br>        <span class="hljs-keyword">return</span> Result.success(list);<br>    &#125;<br><br>    <span class="hljs-comment">// 如果不存在，则查询数据库</span><br>    <span class="hljs-type">Dish</span> <span class="hljs-variable">dish</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dish</span>();<br>    dish.setCategoryId(categoryId);<br>    dish.setStatus(StatusConstant.ENABLE);<span class="hljs-comment">//查询起售中的菜品</span><br>    list = dishService.listWithFlavor(dish);<br><br>    <span class="hljs-comment">// 将数据放入redis中缓存</span><br>    redisTemplate.opsForValue().set(key, list);<br>    <span class="hljs-keyword">return</span> Result.success(list);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="数据变更"><a href="#数据变更" class="headerlink" title="数据变更"></a>数据变更</h3><p>在对数据库中的菜品进行增删改的操作时，需要清理缓存数据</p><p>但无需清理掉所有的缓存数据，对哪个分类（Key）进行操作，就清理掉这个Key的缓存数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 清理缓存数据</span><br><span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;dish_&quot;</span> + dishDTO.getCategoryId();<br>redisTemplate.delete(key);<br></code></pre></td></tr></table></figure><p><em>注：在存放缓存数据时，我们在Service层操作，而清空返回数据我们在Controller层操作（感觉在Service层操作也可以）</em></p><h5 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h5><p>在进行删除操作时，我们需要根据分类id清除缓存数据，但是我们删除时拿不到分类id，还要进行数据库查询之后再拿id就十分麻烦</p><p>所以我们在进行删除操作时，直接删除所有缓存数据即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 清理所有缓存数据</span><br><span class="hljs-type">Set</span> <span class="hljs-variable">keys</span> <span class="hljs-operator">=</span> redisTemplate.keys(<span class="hljs-string">&quot;dish_*&quot;</span>); <span class="hljs-comment">// 查询以dish_开头的key</span><br>redisTemplate.delete(keys); <span class="hljs-comment">// 以set集合作为参数批量删除缓存数据</span><br></code></pre></td></tr></table></figure><h5 id="修改操作"><a href="#修改操作" class="headerlink" title="修改操作"></a>修改操作</h5><p>当修改一些菜品信息时，删除缓存数据就会很简单</p><p>但如果修改分类时，会影响到缓存中两个分类中的菜品数据</p><p>所以我们也是干掉所有的缓存数据</p><hr><h5 id="cleanCache"><a href="#cleanCache" class="headerlink" title="cleanCache()"></a>cleanCache()</h5><p>抽取成为cleanCache方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cleanCache</span><span class="hljs-params">(String pattern)</span> &#123;<br>    <span class="hljs-type">Set</span> <span class="hljs-variable">keys</span> <span class="hljs-operator">=</span> redisTemplate.keys(pattern);<br>    redisTemplate.delete(keys);<br>&#125;<br><br><span class="hljs-comment">// 清理所有缓存数据</span><br>cleanCache(<span class="hljs-string">&quot;dish_*&quot;</span>);<br><br><span class="hljs-comment">// 清理缓存数据</span><br><span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;dish_&quot;</span> + dishDTO.getCategoryId();<br>cleanCache(key);<br></code></pre></td></tr></table></figure><hr><h1 id="Spring-Cache"><a href="#Spring-Cache" class="headerlink" title="Spring Cache"></a>Spring Cache</h1><p>Spring提供了缓存功能的框架实现，只需要简单实用注解，就能实现缓存功能</p><p>Spring Cache底层可以切换不同的缓存实现：</p><ul><li>EHCache</li><li>Caffeine</li><li><strong>Redis</strong></li></ul><p>有趣的是，我们并不需要针对不同的底层而具体编写配置文件，只需要导入Redis的Java依赖就会被SpringCache自动识别并应用</p><hr><h3 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h3 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h3><table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td>@EnableCaching</td><td>加在启动类上，用以开启注解功能</td></tr><tr><td>@Cacheable</td><td>在方法执行前先查询缓存中是否有数据，如果有数据，则直接返回缓存数据；如果没有缓存数据，调用方法并将方法的返回值放到缓存中</td></tr><tr><td>@CachePut</td><td>将方法的返回值放到缓存中</td></tr><tr><td>@CacheEvict</td><td>将一条或多条数据从缓存中删除</td></tr></tbody></table><hr><h3 id="key的生成"><a href="#key的生成" class="headerlink" title="key的生成"></a>key的生成</h3><p>如果使用SpringCache缓存数据，key的生成与注解的属性<code>cacheNames</code>、<code>key</code>有关</p><blockquote><p>cacheNames::key</p></blockquote><p><em>在redis中，冒号分隔的字符会被逻辑分层</em></p><p>而key的值不可以是唯一的，否则所有缓存都会放到同一个key中</p><p>所以使用spEL（Spring表达式语言）来动态获取key</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@CachePut(cacheNames = &quot;userCache&quot; , key = &quot;#user.id&quot;)</span> <span class="hljs-comment">// 使用spEL获取形参对象user的id属性</span><br></code></pre></td></tr></table></figure><p><em>直接使用参数对象的id也是没有问题的，操作缓存数据是等到方法执行玩才会操作，这样主键值会回显回来</em></p><h5 id="spEL"><a href="#spEL" class="headerlink" title="spEL"></a>spEL</h5><table><thead><tr><th><strong>表达式</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>#result</strong></td><td>当前方法的返回值</td></tr><tr><td><strong>#形参</strong></td><td>获取方法的参数</td></tr><tr><td>#p0</td><td>获取方法的第一个参数</td></tr><tr><td>#a0</td><td>获取方法的第一个参数</td></tr><tr><td>#root.arg[0]</td><td>获取方法的第一个参数</td></tr></tbody></table><hr><h3 id="代理对象"><a href="#代理对象" class="headerlink" title="代理对象"></a>代理对象</h3><p>Spring Cache的本质是为加入注解的方法生成一个代理，在执行具体的方法前，先对Redis中的缓存进行一些操作</p><hr><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>除了使用@CacheEvict注解删除单个缓存数据之外，还能删除所有缓存数据</p><p>使用allEntries &#x3D; true属性来控制是否删除所有key</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">CacheEvict(cacheNames = <span class="hljs-string">&quot;userCache&quot;</span> , allEntries = <span class="hljs-literal">true</span>) <span class="hljs-comment">// 删除userCache的所有key</span><br></code></pre></td></tr></table></figure><hr><h1 id="苍穹外卖-购物车功能"><a href="#苍穹外卖-购物车功能" class="headerlink" title="苍穹外卖-购物车功能"></a>苍穹外卖-购物车功能</h1><p>在购物车表中设计冗余字段，可以增加查询的效率</p><ul><li>判断新增菜品&#x2F;套餐在购物车是否存在<ul><li>存在，则数量加一</li><li>不存在，则判断是套餐还是菜品<ul><li>是套餐，则根据套餐查询信息，将套餐插入到购物车中</li><li>是菜品，则根据菜品查询信息，将菜品插入到购物车中</li></ul></li></ul></li></ul><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>SSM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>苍穹外卖-微信小程序开发（前端开发）</title>
    <link href="/2024/08/02/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96-%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%EF%BC%88%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%EF%BC%89/"/>
    <url>/2024/08/02/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96-%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%EF%BC%88%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="苍穹外卖-微信小程序开发（前端开发）"><a href="#苍穹外卖-微信小程序开发（前端开发）" class="headerlink" title="苍穹外卖-微信小程序开发（前端开发）"></a>苍穹外卖-微信小程序开发（前端开发）</h1><p><a href="https://mp.weixin.qq.com/cgi-bin/wx">公众号 (qq.com)</a></p><p>微信小程序有自己的开发工具——微信开发者工具</p><p><a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html">微信开发者工具</a></p><p>微信小程序也是一种前端项目的选择，他和vue一样都是响应式编程，声明式框架</p><hr><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><ul><li><p>app.js：小程序的逻辑，是必须的</p></li><li><p>app.json：小程序的公共配置，是必须的</p></li><li><p>app.wxss：小程序的公共样式表，不是必须的</p></li><li><p>pages：存放当前小程序存放的页面</p><ul><li>index：具体页面</li></ul></li></ul><hr><h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><p>html+css+js的传统前端三大件，在vue中，我们也整合到3大件到每一个.vue的组件中，模块化编程前端页面</p><p>而在微信小程序中，也同样存在这样的框架结构，但变成了四大件</p><ul><li><p>.js：</p><ul><li>这些文件包含了页面的逻辑层代码，使用 JavaScript 编写。</li><li>在这里，你可以定义数据模型、事件处理函数以及页面生命周期方法。</li><li>例如，<code>index.js</code> 文件会包含 <code>index</code> 页面的所有逻辑。</li></ul></li><li><p>.wxml：</p><ul><li>这是微信小程序的模板语言文件，类似于 HTML。</li><li>它用于描述页面的结构和布局，可以使用数据绑定、循环、条件等语法。</li><li>例如，<code>index.wxml</code> 文件会包含 <code>index</code> 页面的用户界面结构。</li></ul></li><li><p>.wxss</p><ul><li>这是一种样式表语言，类似于 CSS，但专为微信小程序设计。</li><li>它用于定义页面的样式和外观，包括颜色、字体、布局等。</li><li>例如，<code>index.wxss</code> 文件会包含 <code>index</code> 页面的样式规则。</li></ul></li><li><p>.json</p><ul><li>这些文件用于配置页面或整个小程序的行为。</li><li><code>app.json</code> 文件是小程序的全局配置文件，可以设置窗口样式、页面路由等。</li><li>页面级别的 <code>.json</code> 文件（如 <code>index.json</code>）则用于特定页面的配置，如导航栏标题、是否启用下拉刷新等。</li></ul></li></ul><p>对比传统的前端项目，微信小程序更加轻量化，结构更简单、清晰，更令人容易理解</p><hr><h3 id="微信授权码"><a href="#微信授权码" class="headerlink" title="微信授权码"></a>微信授权码</h3><p>想要真正意义上的实现微信的登录功能，需要使用内置函数wx调用login获得授权码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 微信登陆，获取微信用户的授权码</span><br><span class="hljs-title class_">Page</span>(&#123;<br>    <span class="hljs-attr">data</span>: &#123;<br>        <span class="hljs-attr">code</span>: <span class="hljs-string">&quot;&quot;</span>,<br>    &#125;,<br>    <span class="hljs-title function_">wxLogin</span>(<span class="hljs-params"></span>) &#123;<br>        wx.<span class="hljs-title function_">login</span>(&#123;<br>            <span class="hljs-attr">success</span>: <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res.<span class="hljs-property">code</span>)<br>                <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setData</span>(&#123;<br>                    <span class="hljs-attr">code</span>: res.<span class="hljs-property">code</span><br>                &#125;)<br>            &#125;<br>        &#125;)<br>    &#125;，<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h3><p>同传统前端的Ajax和Vue中的Axios一样，微信小程序也提供发送异步请求的功能</p><p>通过内置函数wx调用request发送请求</p><p><em>需要注意的是，在项目调试阶段，我们应该勾选微信开发者工具的不校验域名，否则将不会请求成功</em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 发送请求</span><br><span class="hljs-title function_">sendRequest</span>(<span class="hljs-params"></span>) &#123;<br>    wx.<span class="hljs-title function_">request</span>(&#123;<br>        <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;http://localhost:8080/user/shop/status&#x27;</span>,<br>        <span class="hljs-attr">method</span>: <span class="hljs-string">&quot;get&quot;</span>,<br>        <span class="hljs-attr">success</span>: <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res.<span class="hljs-property">data</span>)<br>        &#125;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="微信登陆"><a href="#微信登陆" class="headerlink" title="微信登陆"></a>微信登陆</h3><p><img src="/upload/api-login.2fcc9f35.jpg" alt="api-login.2fcc9f35.jpg"></p><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>SSM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>实战项目-苍穹外卖</title>
    <link href="/2024/07/31/%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE-%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96/"/>
    <url>/2024/07/31/%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE-%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96/</url>
    
    <content type="html"><![CDATA[<h1 id="实战项目-苍穹外卖"><a href="#实战项目-苍穹外卖" class="headerlink" title="实战项目-苍穹外卖"></a>实战项目-苍穹外卖</h1><p>此项目由黑马程序员提供，此笔记用以记录在此实战项目中的知识点欠缺部分</p><h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><p>Nginx的功能其实有很多很多，我们在此项目中就简单应用于部署前端工程项目</p><p>我们在以前的JavaWeb学习中，前端工程项目是使用npm run dev功能直接测试运行</p><p>但是在实际生产环境中，前端项目和后端项目一样，需要扔进一个类似于Tomcat的容器中运行，这个容器就是Nginx</p><p>使用npm run build 命令即可将项目打包，将打包好的项目扔进nginx的html目录（静态资源目录）下，直接启动即可</p><hr><h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>前端的请求路径为：<a href="http://localhost/api/employee/login">http://localhost/api/employee/login</a></p><p>而后端实际的业务路径为：<a href="http://localhost:8080/admin/employee/login">http://localhost:8080/admin/employee/login</a></p><p>请求路径并不一致，但却能成功请求，这里就用到了Nginx的重要功能之一——反向代理</p><ul><li>提高访问速度</li><li>进行负载均衡</li><li>保证后端服务的安全</li></ul><hr><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># 使用权重方式配置负载均衡服务器</span><br>upstream webservers&#123;<br>  server 127.0.0.1:8080 <span class="hljs-attr">weight</span>=<span class="hljs-number">90</span> <span class="hljs-comment">;</span><br>  <span class="hljs-comment">#server 127.0.0.1:8088 weight=10 ;</span><br>&#125;<br><br><span class="hljs-comment"># 反向代理到负载均衡服务器</span><br>  location /user/ &#123;<br>      proxy_pass   http://webservers/user/<span class="hljs-comment">;</span><br>  &#125;<br></code></pre></td></tr></table></figure><h5 id="负载均衡的策略"><a href="#负载均衡的策略" class="headerlink" title="负载均衡的策略"></a>负载均衡的策略</h5><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>轮询</td><td>默认方式</td></tr><tr><td>weight</td><td>权重方式，默认为1，权重越高，被分配的客户端请求越多</td></tr><tr><td>ip_hash</td><td>依据ip分配方式，这样每个访客可以固定访问一个后端服务</td></tr><tr><td>least_conn</td><td>依据最少连接方式，把请求优先分配给连接数少的后端服务</td></tr><tr><td>url_hash</td><td>依据url分配方式，这样相同的url会被分配到同一个后端服务</td></tr><tr><td>fair</td><td>依据响应时间方式，响应时间短的服务将会被优先分配</td></tr></tbody></table><hr><h1 id="分模块设计"><a href="#分模块设计" class="headerlink" title="分模块设计"></a>分模块设计</h1><p>我们之前都是一个模块下用包结构来区分功能层级，但包多了就容易混淆</p><p>这个项目使用模块来区分功能层级，使用maven的聚合功能（modules）来实现子模块的统一构建</p><p>在父工程中，使用dependencyManagement进行版本管理</p><ul><li>common：用以存放工具类</li><li>pojo：存放实体类</li><li>server：用于存放三层架构，做web业务处理</li></ul><p>这样使用模块分层后，每一个模块根据需求单独导入依赖，结构清晰，更容易理解</p><hr><h1 id="POJO"><a href="#POJO" class="headerlink" title="POJO"></a>POJO</h1><p>在之前的学习中，我们也学到Vo的作用，其实pojo分为三种实体类型</p><ul><li>Entity：实体，通常跟数据库中表对应</li><li>DTO：数据传输对象，通常用于程序中各层之间的数据传输，比如接收前端传过来的JSON</li><li>VO：视图对象，为前端展示数据提供的对象，通常用于封装数据库查询结果</li></ul><p>我们在之前接收请求的参数，是直接使用实体类来接收</p><p>但如果前端提交的数据和实体类中对应的属性差别比较大时，建议采用DTO来封装数据</p><p>但在Service层交给mapper层处理数据的时候，应该将DTO转换为实体类对象</p><h3 id="BeanUtils"><a href="#BeanUtils" class="headerlink" title="BeanUtils"></a>BeanUtils</h3><p>SpringBoot提供了此工具类，可调用copyProperties()方法对对象进行属性拷贝</p><p><em>要求对象中属性名完全一致</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">BeanUtils.copyProperties(employeeDTO,employee);<span class="hljs-comment">// 由employeeDTO拷贝到employee</span><br></code></pre></td></tr></table></figure><hr><h1 id="Lombok"><a href="#Lombok" class="headerlink" title="Lombok"></a>Lombok</h1><p>@Builder，lombok提供的实体类中注解，让我们可以通过链式调用给对象中的属性进行赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">EmployeeLoginVO.builder()<br>        .id(employee.getId())<br>        .userName(employee.getUsername())<br>        .name(employee.getName())<br>        .token(token)<br>        .build();<br></code></pre></td></tr></table></figure><hr><h1 id="MD5加密"><a href="#MD5加密" class="headerlink" title="MD5加密"></a>MD5加密</h1><p>我们在之前一直使用自己提供的MD5Util对明文密码进行加密后存入数据库</p><p>SPring给我们提供了此工具类——DigestUtils，其中的md5DigestAsHex()可以将一个字符数组转换成为md5加密后的字符串</p><p><em>digest中文释义：消化</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">password = DigestUtils.md5DigestAsHex(password.getBytes());<br></code></pre></td></tr></table></figure><hr><h1 id="接口管理工具"><a href="#接口管理工具" class="headerlink" title="接口管理工具"></a>接口管理工具</h1><p><a href="https://yapi.pro/">YApi Pro-高效、易用、功能强大的可视化接口管理平台</a></p><p><a href="https://apifox.com/">Apifox - API 文档、调试、Mock、测试一体化协作平台。拥有接口文档管理、接口调试、Mock、自动化测试等功能，接口开发、测试、联调效率，提升 10 倍。最好用的接口文档管理工具，接口自动化测试工具。</a></p><h3 id="Swagger-knife4j"><a href="#Swagger-knife4j" class="headerlink" title="Swagger&amp;knife4j"></a>Swagger&amp;knife4j</h3><blockquote><p>早期，swagger-boostrap-ui是1.x版本，如今swagger-bootsrap-ui到2.x，同时也更改名字Knife4j，适用于单体和微服务项目</p></blockquote><p>knife4j就相当于一个项目内置的postman，它可以生成接口文档，生成接口所需参数，直接在项目内对后端接口做测试</p><p><a href="https://doc.xiaominfo.com/docs/quick-start">快速开始 | Knife4j (xiaominfo.com)</a></p><ul><li><p>Yapi和Apifox是设计阶段使用的工具，管理和维护接口</p></li><li><p>Swagger在开发阶段使用的框架，帮助后端开发人员做后端的接口测试</p></li></ul><hr><h5 id="WebConfig配置类"><a href="#WebConfig配置类" class="headerlink" title="WebConfig配置类"></a>WebConfig配置类</h5><p>在配置类中注入Bean，将配置好的knife4j注入到IoC容器中</p><p>通过配置静态资源映射的方式，可以直接通过url访问到接口文档</p><blockquote><p><a href="http://localhost:8080/doc.html">http://localhost:8080/doc.html</a></p></blockquote><p><em>我们可以通过.groupName对用户端和管理端接口分组</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 通过knife4j生成接口文档</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Docket <span class="hljs-title function_">docket1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ApiInfo</span> <span class="hljs-variable">apiInfo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApiInfoBuilder</span>()<br>                .title(<span class="hljs-string">&quot;苍穹外卖项目接口文档&quot;</span>)<br>                .version(<span class="hljs-string">&quot;2.0&quot;</span>)<br>                .description(<span class="hljs-string">&quot;苍穹外卖项目接口文档&quot;</span>)<br>                .build();<br>        <span class="hljs-type">Docket</span> <span class="hljs-variable">docket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Docket</span>(DocumentationType.SWAGGER_2)<br>                .groupName(<span class="hljs-string">&quot;管理端接口&quot;</span>)<br>                .apiInfo(apiInfo)<br>                .select()<br>                .apis(RequestHandlerSelectors.basePackage(<span class="hljs-string">&quot;com.sky.controller.admin&quot;</span>))<br>                .paths(PathSelectors.any())<br>                .build();<br>        <span class="hljs-keyword">return</span> docket;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 通过knife4j生成接口文档</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Docket <span class="hljs-title function_">docket2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ApiInfo</span> <span class="hljs-variable">apiInfo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApiInfoBuilder</span>()<br>                .title(<span class="hljs-string">&quot;苍穹外卖项目接口文档&quot;</span>)<br>                .version(<span class="hljs-string">&quot;2.0&quot;</span>)<br>                .description(<span class="hljs-string">&quot;苍穹外卖项目接口文档&quot;</span>)<br>                .build();<br>        <span class="hljs-type">Docket</span> <span class="hljs-variable">docket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Docket</span>(DocumentationType.SWAGGER_2)<br>                .groupName(<span class="hljs-string">&quot;用户端接口&quot;</span>)<br>                .apiInfo(apiInfo)<br>                .select()<br>                .apis(RequestHandlerSelectors.basePackage(<span class="hljs-string">&quot;com.sky.controller.user&quot;</span>))<br>                .paths(PathSelectors.any())<br>                .build();<br>        <span class="hljs-keyword">return</span> docket;<br>    &#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 设置静态资源映射</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> registry</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addResourceHandlers</span><span class="hljs-params">(ResourceHandlerRegistry registry)</span> &#123;<br>    registry.addResourceHandler(<span class="hljs-string">&quot;/doc.html&quot;</span>).addResourceLocations(<span class="hljs-string">&quot;classpath:/META-INF/resources/&quot;</span>);<br>    registry.addResourceHandler(<span class="hljs-string">&quot;/webjars/**&quot;</span>).addResourceLocations(<span class="hljs-string">&quot;classpath:/META-INF/resources/webjars/&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h5><table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td>@Api</td><td>用在类上，例如Controller，表示对类的说明</td></tr><tr><td>@ApiOperation</td><td>用在方法上，例如Controller的方法，说明方法的用途和作用</td></tr><tr><td>@ApiModel</td><td>用在实体类上，例如entity、DTO、VO</td></tr><tr><td>@ApiModelProperty</td><td>用在实体类的属性上，描述属性信息</td></tr></tbody></table><p>通过这些注解，就可以在接口文档中丰富内容和参数，让接口文档有更好的可读性</p><hr><h5 id="token问题"><a href="#token问题" class="headerlink" title="token问题"></a>token问题</h5><p>再进行业务功能测试的时候，有一些业务需要在登陆的状态下进行，需要验证你的token</p><p>获取登录的token后，在全局参数设置中添加token请求头，这样每次请求都会带着token去测试业务接口了</p><hr><h1 id="LogBack"><a href="#LogBack" class="headerlink" title="LogBack"></a>LogBack</h1><p>SpringBoot内置了LogBack，所以直接使用slf4j进行日志处理即可</p><p>使用@Slf4j注解标识要使用打印日志功能的类</p><p>我们一般都会在controller层，使用log.info来打印一下接收到的参数是否为正确参数</p><p><em>在log.info处添加断点，可更直观的观测变量的变化</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">log.info(<span class="hljs-string">&quot;新增员工：&#123;&#125;&quot;</span>, employeeDTO);<br></code></pre></td></tr></table></figure><hr><h1 id="主键值获取"><a href="#主键值获取" class="headerlink" title="主键值获取"></a>主键值获取</h1><p>我们在之前的学习中，从token中获取主键值，是通过在请求头中获取token值，使用工具类反向解密token获取主键值</p><p>现在，我们在拦截其中，直接通过token拿到了id值，现在思考如何将id值传到service层即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Claims</span> <span class="hljs-variable">claims</span> <span class="hljs-operator">=</span> JwtUtil.parseJWT(jwtProperties.getAdminSecretKey(), token);<br><span class="hljs-type">Long</span> <span class="hljs-variable">empId</span> <span class="hljs-operator">=</span> Long.valueOf(claims.get(JwtClaimsConstant.EMP_ID).toString());<br>log.info(<span class="hljs-string">&quot;当前员工id：&quot;</span>, empId);<br></code></pre></td></tr></table></figure><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>Thread的局部变量，每个线程都有自己单独的线程空间，具有线程隔离的效果</p><p>然而，Tomcat针对一次业务请求，分配的是同一个线程</p><p>在这个项目中，我们将对ThreadLocal局部变量的存取封装成一个工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseContext</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;Long&gt; threadLocal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCurrentId</span><span class="hljs-params">(Long id)</span> &#123;<br>        threadLocal.set(id);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Long <span class="hljs-title function_">getCurrentId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> threadLocal.get();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeCurrentId</span><span class="hljs-params">()</span> &#123;<br>        threadLocal.remove();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>将拦截器中解析出来的id存放到ThreadLocal中，在service中取出使用即可</p><p><em>ThreadLocal在此就可以看作在一次请求中传递数据的变量即可，具有请求隔离（线程隔离）的效果</em></p><hr><h1 id="日期格式问题"><a href="#日期格式问题" class="headerlink" title="日期格式问题"></a>日期格式问题</h1><p>在实现员工的分页查询功能时，我们从数据库中查找到的<code>创建时间</code>和<code>修改时间</code>的值不太正确</p><p>这是因为LocalDateTime类型数据直接放到json中返回给前端，达不到想要的日期格式效果</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;createTime&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>  <span class="hljs-number">2022</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-number">2</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-number">15</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-number">15</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-number">51</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-number">20</span><br><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;updateTime&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>  <span class="hljs-number">2022</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-number">2</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-number">17</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-number">9</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-number">16</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-number">20</span><br><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><p>有两种方法解决此问题</p><hr><h3 id="JsonFormat"><a href="#JsonFormat" class="headerlink" title="@JsonFormat"></a>@JsonFormat</h3><p>在属性上加入@JsonFormat注解，对日期进行格式化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)</span><br><span class="hljs-keyword">private</span> LocalDateTime createTime;<br><br><span class="hljs-meta">@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)</span><br><span class="hljs-keyword">private</span> LocalDateTime updateTime;<br></code></pre></td></tr></table></figure><p><em>这种方式处理的不够彻底，只能针对于单个类中的单个属性做格式化处理</em></p><hr><h3 id="扩展消息转换器"><a href="#扩展消息转换器" class="headerlink" title="扩展消息转换器"></a>扩展消息转换器</h3><p>在配置类中扩展SpringMVC的消息转换器，统一对日期类型进行格式化处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 配置扩展消息转换器，对后端返回给前端的数据进行统一格式处理</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> converters</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">extendMessageConverters</span><span class="hljs-params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> &#123;<br>    <span class="hljs-comment">// 创建一个消息转换器对象</span><br>    <span class="hljs-type">MappingJackson2HttpMessageConverter</span> <span class="hljs-variable">converter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MappingJackson2HttpMessageConverter</span>();<br>    <span class="hljs-comment">// 需要为消息转换器设置一个对象转换器，对象转换器可以将Java对象序列化为Json数据（或反序列化）</span><br>    converter.setObjectMapper(jacksonObjectMapper);<br>    <span class="hljs-comment">// 将消息转换器存放入容器集合中（将自定义消息转换器设置为优先级最高）</span><br>    converters.add(<span class="hljs-number">0</span>,converter);<br>&#125;<br></code></pre></td></tr></table></figure><p><em>其中，对象转换器由项目本身提供，其中定义了一些序列化和反序列化的规则，比如jacksonObjectMapper对象中提供了日期格式转换的规则</em></p><hr><h1 id="公共字段自动填充"><a href="#公共字段自动填充" class="headerlink" title="公共字段自动填充"></a>公共字段自动填充</h1><p>表中数据有一些字段是公共字段，比如创建人，创建时间，修改人，修改时间等</p><p>这些字段每次由我们手动填写就很麻烦，也可以将其利用AOP的思路抽取出来</p><blockquote><p>当我们执行更新操作的时候，需要设置修改人，修改时间</p><p>当我们执行插入操作的时候，需要设置创建时间，创建人，修改时间，修改人四条属性</p></blockquote><h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><p>使用枚举类型标注正在进行的操作是什么 （UPDATE，INSERT）</p><p>通过注解@AutoFill表示需要进行公共字段填充的方法（Mapper层）</p><p>自定义切面类AutoFillAspect，统一拦截加入注解的方法，通过反射为公共字段赋值</p><hr><h5 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 自定义注解，用于公共字段的填充</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> AutoFillAspect &#123;<br>    <span class="hljs-comment">// 数据库操作类型</span><br>    OperationType <span class="hljs-title function_">value</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="自定义切面"><a href="#自定义切面" class="headerlink" title="自定义切面"></a>自定义切面</h5><p>在我们利用反射来获取具体方法时，不再手写字符串，而是通过常量类的方式来填写，这样做有两个好处：</p><ul><li>不容易写错</li><li>代码书写更加规范</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 自动填充切面类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AutoFillAspect</span> &#123;<br>    <span class="hljs-comment">// 指定切入点</span><br>    <span class="hljs-meta">@Pointcut(&quot;execution(* com.sky.mapper.*.*(..)) &amp;&amp; @annotation(com.sky.annotation.AutoFillAspect)&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">autoFillPointCut</span><span class="hljs-params">()</span>&#123;<br><br>    &#125;<br>    <span class="hljs-comment">// 通知方法（增强方法）</span><br>    <span class="hljs-meta">@Before(&quot;autoFillPointCut()&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">autoFill</span><span class="hljs-params">(JoinPoint joinPoint)</span>&#123;<br>        log.info(<span class="hljs-string">&quot;开始进行公共字段的自动填充……&quot;</span>);<br>        <span class="hljs-comment">// 获得注解的值，Insert/Update</span><br>        <span class="hljs-type">MethodSignature</span> <span class="hljs-variable">signature</span> <span class="hljs-operator">=</span> (MethodSignature) joinPoint.getSignature(); <span class="hljs-comment">// 获得方法签名对象</span><br>        com.sky.annotation.<span class="hljs-type">AutoFillAspect</span> <span class="hljs-variable">autoFillAspect</span> <span class="hljs-operator">=</span> signature.getMethod().getAnnotation(com.sky.annotation.AutoFillAspect.class); <span class="hljs-comment">// 获得方法注解对象</span><br>        <span class="hljs-type">OperationType</span> <span class="hljs-variable">operationType</span> <span class="hljs-operator">=</span> autoFillAspect.value(); <span class="hljs-comment">// 获得注解中的内容（操作类型）</span><br><br>        <span class="hljs-comment">// 获得方法的参数（实体类）</span><br>        Object[] args = joinPoint.getArgs();<br>        <span class="hljs-keyword">if</span> (args == <span class="hljs-literal">null</span> || args.length == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">entity</span> <span class="hljs-operator">=</span> args[<span class="hljs-number">0</span>];<br><br>        <span class="hljs-comment">// 准备数据</span><br>        <span class="hljs-type">LocalDateTime</span>  <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> LocalDateTime.now();<br>        <span class="hljs-type">Long</span> <span class="hljs-variable">currentId</span> <span class="hljs-operator">=</span> BaseContext.getCurrentId();<br><br>        <span class="hljs-comment">// 判断操作类型，为公共字段赋值</span><br>        <span class="hljs-keyword">if</span> (operationType == OperationType.INSERT)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 通过反射获取到set方法</span><br>                <span class="hljs-type">Method</span> <span class="hljs-variable">setCreateTime</span> <span class="hljs-operator">=</span> entity.getClass().getDeclaredMethod(AutoFillConstant.SET_CREATE_TIME, LocalDateTime.class);<br>                <span class="hljs-type">Method</span> <span class="hljs-variable">setCreateUser</span> <span class="hljs-operator">=</span> entity.getClass().getDeclaredMethod(AutoFillConstant.SET_CREATE_USER, Long.class);<br>                <span class="hljs-type">Method</span> <span class="hljs-variable">setUpdateTime</span> <span class="hljs-operator">=</span> entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME, LocalDateTime.class);<br>                <span class="hljs-type">Method</span> <span class="hljs-variable">setUpdateUser</span> <span class="hljs-operator">=</span> entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_USER, Long.class);<br>                <br>                <span class="hljs-comment">// 执行set方法，为实体entity的属性赋值</span><br>                setCreateTime.invoke(entity,now);<br>                setCreateUser.invoke(entity,currentId);<br>                setUpdateTime.invoke(entity,now);<br>                setUpdateUser.invoke(entity,currentId);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 通过反射获取到set方法</span><br>                <span class="hljs-type">Method</span> <span class="hljs-variable">setUpdateTime</span> <span class="hljs-operator">=</span> entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME, LocalDateTime.class);<br>                <span class="hljs-type">Method</span> <span class="hljs-variable">setUpdateUser</span> <span class="hljs-operator">=</span> entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_USER, Long.class);<br><br>                <span class="hljs-comment">// 执行set方法，为实体entity的属性赋值</span><br>                setUpdateTime.invoke(entity,now);<br>                setUpdateUser.invoke(entity,currentId);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="阿里云对象存储服务OSS"><a href="#阿里云对象存储服务OSS" class="headerlink" title="阿里云对象存储服务OSS"></a>阿里云对象存储服务OSS</h1><p><a href="https://help.aliyun.com/zh/oss/developer-reference/java/?spm=a2c4g.11186623.0.i52">Java_对象存储(OSS)-阿里云帮助中心 (aliyun.com)</a></p><p>用户在前端上传文件后，由前端将文件内容放在请求体中发送到后端</p><ul><li>配置文件：配置OSS所需的配置文件</li><li>工具类：OSS具体操作的工具类</li><li>配置类：使用配置文件创建OSS工具类的对象，注入到IoC容器</li><li>Controller：注入对象，使用对象进行文件上传业务</li></ul><hr><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>和JWT的处理方式一样，我们通过配置属性类的方式读取配置文件中的字段，对配置进行封装成类的操作</p><p><em>在yaml中的-分割和类中驼峰命名的字段在SpringBoot中可以得到自动转换</em></p><h5 id="配置属性类"><a href="#配置属性类" class="headerlink" title="配置属性类"></a>配置属性类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;sky.alioss&quot;)</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AliOssProperties</span> &#123;<br>    <span class="hljs-keyword">private</span> String endpoint;<br>    <span class="hljs-keyword">private</span> String accessKeyId;<br>    <span class="hljs-keyword">private</span> String accessKeySecret;<br>    <span class="hljs-keyword">private</span> String bucketName;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">alioss:</span><br>  <span class="hljs-attr">endpoint:</span> <span class="hljs-string">$&#123;sky.alioss.endpoint&#125;</span><br>  <span class="hljs-attr">access-key-id:</span> <span class="hljs-string">$&#123;sky.alioss.access-key-id&#125;</span><br>  <span class="hljs-attr">access-key-secret:</span> <span class="hljs-string">$&#123;sky.alioss.access-key-secret&#125;</span><br>  <span class="hljs-attr">bucket-name:</span> <span class="hljs-string">$&#123;sky.alioss.bucket-name&#125;</span><br></code></pre></td></tr></table></figure><hr><h3 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h3><p>使用配置类的方式，将AliOssUtil工具类的对象注入到IoC容器中</p><p>@ConditionalOnMissingBean注解来保证IoC容器中只存在一个此工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OssConfiguration</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@ConditionalOnMissingBean</span><br>    <span class="hljs-keyword">public</span> AliOssUtil <span class="hljs-title function_">aliOssUtil</span><span class="hljs-params">(AliOssProperties aliOssProperties)</span> &#123;<br>        log.info(<span class="hljs-string">&quot;开始创建阿里云文件上传工具类对象：&#123;&#125;&quot;</span>, aliOssProperties);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AliOssUtil</span>(aliOssProperties.getEndpoint(),<br>                aliOssProperties.getAccessKeyId(),<br>                aliOssProperties.getAccessKeySecret(),<br>                aliOssProperties.getBucketName());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="业务代码"><a href="#业务代码" class="headerlink" title="业务代码"></a>业务代码</h3><p>在controller中，使用@RequestPart MultipartFile file来接收文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> AliOssUtil aliOssUtil;<br><br><span class="hljs-meta">@PostMapping</span><br><span class="hljs-meta">@ApiOperation(&quot;文件上传&quot;)</span><br><span class="hljs-keyword">public</span> Result&lt;String&gt; <span class="hljs-title function_">upload</span><span class="hljs-params">(<span class="hljs-meta">@RequestPart</span> MultipartFile file)</span> &#123;<br>    log.info(<span class="hljs-string">&quot;文件上传：&#123;&#125;&quot;</span>, file);<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 获取文件的原始文件名</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">originalFilename</span> <span class="hljs-operator">=</span> file.getOriginalFilename();<br>        <span class="hljs-comment">// 获取文件的后缀</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">substring</span> <span class="hljs-operator">=</span> originalFilename.substring(originalFilename.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>));<br>        <span class="hljs-comment">// 构造文件名称</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">objectName</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString() + substring;<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">filePath</span> <span class="hljs-operator">=</span> aliOssUtil.upload(file.getBytes(), objectName);<br>        <span class="hljs-keyword">return</span> Result.success(filePath);<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        log.error(<span class="hljs-string">&quot;文件上传失败：&#123;&#125;&quot;</span>, e.getMessage());<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h1><p>学到这里，我们发现每一个插件的配置都是使用配置文件来配置</p><p>但生产环境与开发环境不同，为了解决这个问题，我们使用application-dev.yaml的方式，在主配置文件中激活</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span><br></code></pre></td></tr></table></figure><hr><p>我们发现配置文件直接使用到类中十分麻烦，就创建配置属性类来封装配置文件中的字段</p><p>使用@ConfigurationProperties(prefix &#x3D; “sky.***”)注解来读取配置文件中的字段，填充到类中属性</p><hr><p>对于工具类和其他框架的使用，不再实例化工具类直接使用，而是通过配置类将其配置好后注入IoC容器中，再由IoC中的其他组件调用</p><hr><p>我们发现，很多自定义的字符串内容都使用常量或者枚举来提前定义，这样减少了书写错误，增加代码规范</p><hr><p>我们发现，在进行数据库操作时，如果数据库表有存在自己的mapper（逻辑外键），则可以在Service中对两个mapper进行单独的sql操作，最后返回到service封装（涉及到多表查询，要在service上面加上事务）</p><p>如果使用联合查询，就写resultMap来映射数据库的表中列和实体类的属性对应，还有相同属性名的别名问题</p><hr><p>当更新操作使用动态sql语句操作时，我们所有的更新操作都可以使用update这一条mapper，它会根据不同的参数而生成不同的sql进行数据更新</p><hr><p>杨老师说，一张表的VO尽量只有一个，返回数据的时候可以一起返回空key，前端只需要用什么拿什么就好，这个VO中的其他表属性使用对象的形式存储在VO的属性中，这样就需要写resultMap来进行数据库列明——类中属性名的多层次映射</p><hr><p>当controller层的用户端和管理端有相同的业务接口时，我们可以在@RestController注解后设置值的方式区分开</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController(&quot;userShopController&quot;)</span><br></code></pre></td></tr></table></figure><hr><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><p>在Java中使用Redis：</p><ul><li>Jedis</li><li>Lettuce</li><li>Spring Data Redis</li></ul><p>Spring Data Redis就是对Jedis和Lettuce进行高度的封装，我们直接使用即可</p><hr><h3 id="Spring-Data-Redis"><a href="#Spring-Data-Redis" class="headerlink" title="Spring Data Redis"></a>Spring Data Redis</h3><h5 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="配置Redis"><a href="#配置Redis" class="headerlink" title="配置Redis"></a>配置Redis</h5><p>在application.yaml中配置Redis</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.2</span><span class="hljs-number">.2</span> <span class="hljs-comment"># 配置主机地址</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">Zhuwenxue2002</span> <span class="hljs-comment"># 配置Redis密码</span><br>    <span class="hljs-attr">database:</span> <span class="hljs-number">0</span> <span class="hljs-comment"># 配置使用数据库</span><br></code></pre></td></tr></table></figure><h5 id="编写配置类，创建RedisTemplate对象"><a href="#编写配置类，创建RedisTemplate对象" class="headerlink" title="编写配置类，创建RedisTemplate对象*"></a>编写配置类，创建RedisTemplate对象*</h5><p><em>如果不编写配置类的话，Redis也能按照默认配置运行</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sky.config;<br><br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.core.RedisTemplate;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisConfiguration</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RedisTemplate <span class="hljs-title function_">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory factory)</span> &#123;<br>        log.info(<span class="hljs-string">&quot;开始创建redis模板对象&quot;</span>);<br>        <span class="hljs-type">RedisTemplate</span> <span class="hljs-variable">redisTemplate</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisTemplate</span>();<br>        <span class="hljs-comment">// 设置redis连接工厂对象</span><br>        redisTemplate.setConnectionFactory(factory);<br>        <span class="hljs-comment">// 设置redis key的序列化器</span><br>        redisTemplate.setKeySerializer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringRedisSerializer</span>());<br>        <span class="hljs-keyword">return</span> redisTemplate;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="通过RedisTemplate对象操作Redis"><a href="#通过RedisTemplate对象操作Redis" class="headerlink" title="通过RedisTemplate对象操作Redis"></a>通过RedisTemplate对象操作Redis</h5><p>需要注意的是，使用spring框架去进行redis操作会对数据进行序列化操作之后再存储，直接查看redis中的数据会有乱码情况出现</p><p>测试了String和hash类型的数据，其他类型的数据在使用上也大同小异</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testRedisTemplate</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ValueOperations</span> <span class="hljs-variable">valueOperations</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue();<br>        <span class="hljs-type">HashOperations</span> <span class="hljs-variable">hashOperations</span> <span class="hljs-operator">=</span> redisTemplate.opsForHash();<br>        <span class="hljs-type">ListOperations</span> <span class="hljs-variable">listOperations</span> <span class="hljs-operator">=</span> redisTemplate.opsForList();<br>        <span class="hljs-type">SetOperations</span> <span class="hljs-variable">setOperations</span> <span class="hljs-operator">=</span> redisTemplate.opsForSet();<br>        <span class="hljs-type">ZSetOperations</span> <span class="hljs-variable">zSetOperations</span> <span class="hljs-operator">=</span> redisTemplate.opsForZSet();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 操作字符串类型的数据</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// set get</span><br>        redisTemplate.opsForValue().set(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;value&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> (String) redisTemplate.opsForValue().get(<span class="hljs-string">&quot;key&quot;</span>);<br>        System.out.println(key);<br><br>        <span class="hljs-comment">// setex（插入数据并设置有效期）使用枚举类型设置时间单位</span><br>        redisTemplate.opsForValue().set(<span class="hljs-string">&quot;key2&quot;</span>, <span class="hljs-string">&quot;value2&quot;</span>, <span class="hljs-number">3</span>, TimeUnit.MINUTES);<br><br>        <span class="hljs-comment">// setnx(在插入前检查数据是否存在)</span><br>        redisTemplate.opsForValue().setIfAbsent(<span class="hljs-string">&quot;key3&quot;</span>, <span class="hljs-string">&quot;value3&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 操作哈希类型的数据</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testHash</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// hset</span><br>        redisTemplate.opsForHash().put(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;xiaobai&quot;</span>);<br>        redisTemplate.opsForHash().put(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-string">&quot;20&quot;</span>);<br><br>        <span class="hljs-comment">// hget</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> (String) redisTemplate.opsForHash().get(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;name&quot;</span>);<br><br>        System.out.println(name);<br><br>        <span class="hljs-comment">// hkeys</span><br>        <span class="hljs-type">Set</span> <span class="hljs-variable">keys</span> <span class="hljs-operator">=</span> redisTemplate.opsForHash().keys(<span class="hljs-string">&quot;1&quot;</span>);<br>        System.out.println(keys);<br><br>        <span class="hljs-comment">// hvals</span><br>        <span class="hljs-type">List</span> <span class="hljs-variable">values</span> <span class="hljs-operator">=</span> redisTemplate.opsForHash().values(<span class="hljs-string">&quot;1&quot;</span>);<br>        System.out.println(values);<br><br>        <span class="hljs-comment">// hdels</span><br>        redisTemplate.opsForHash().delete(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="HttpClient"><a href="#HttpClient" class="headerlink" title="HttpClient"></a>HttpClient</h1><p>我们在后端使用HttpClient来发送请求实现微信登陆功能</p><p>正常在使用HttpClient时，我们应该导入依赖，但阿里云OSS的依赖传递了此依赖，所以在此项目中无需额外导入</p><p><img src="/upload/httpclient.png" alt="httpclient.png"></p><ul><li><p>创建HttpClient对象</p></li><li><p>创建Http请求对象</p></li><li><p>调用HttpClient的execute方法发送请求</p></li></ul><p><em>execute中文释义：执行</em></p><hr><h3 id="发送GET请求"><a href="#发送GET请求" class="headerlink" title="发送GET请求"></a>发送GET请求</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testGet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 创建HttpClient对象</span><br>    <span class="hljs-type">CloseableHttpClient</span> <span class="hljs-variable">httpClient</span> <span class="hljs-operator">=</span> HttpClients.createDefault();<br><br>    <span class="hljs-comment">// 创建请求对象</span><br>    <span class="hljs-type">HttpGet</span> <span class="hljs-variable">httpGet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpGet</span>(<span class="hljs-string">&quot;http://localhost:8080/user/shop/status&quot;</span>);<br><br>    <span class="hljs-comment">// 发送请求</span><br>    <span class="hljs-type">CloseableHttpResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> httpClient.execute(httpGet);<br><br>    <span class="hljs-comment">// 获取服务端返回的响应状态码</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">statusCode</span> <span class="hljs-operator">=</span> response.getStatusLine().getStatusCode();<br>    System.out.println(statusCode);<br><br>    <span class="hljs-comment">// 获取响应体中的内容</span><br>    <span class="hljs-type">HttpEntity</span> <span class="hljs-variable">entity</span> <span class="hljs-operator">=</span> response.getEntity();<br>                                   <br>    <span class="hljs-comment">// 使用EntityUtils工具类解析响应体中的内容，转成字符串</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">string</span> <span class="hljs-operator">=</span> EntityUtils.toString(entity);<br>    System.out.println(<span class="hljs-string">&quot;string = &quot;</span> + string);<br><br>    <span class="hljs-comment">// 关闭资源</span><br>    response.close();<br>    httpClient.close();<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="发送Post请求"><a href="#发送Post请求" class="headerlink" title="发送Post请求"></a>发送Post请求</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testPost</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 创建httpclient对象</span><br>    <span class="hljs-type">CloseableHttpClient</span> <span class="hljs-variable">httpClient</span> <span class="hljs-operator">=</span> HttpClients.createDefault();<br>    <span class="hljs-comment">// 创建请求对象</span><br>    <span class="hljs-type">HttpPost</span> <span class="hljs-variable">httpPost</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpPost</span>(<span class="hljs-string">&quot;http://localhost:8080/admin/employee/login&quot;</span>);<br><br>    <span class="hljs-comment">//使用阿里提供的工具类生成JSON对象 com.alibaba.fastjson.JSONObject;</span><br>    <span class="hljs-type">JSONObject</span> <span class="hljs-variable">jsonObject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONObject</span>();<br>    jsonObject.put(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;admin&quot;</span>);<br>    jsonObject.put(<span class="hljs-string">&quot;password&quot;</span>, <span class="hljs-string">&quot;123456&quot;</span>);<br>    <span class="hljs-type">StringEntity</span> <span class="hljs-variable">entity</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringEntity</span>(jsonObject.toString());<br>    <span class="hljs-comment">// 指定编码方式和数据格式</span><br>    entity.setContentType(<span class="hljs-string">&quot;application/json&quot;</span>);<br>    entity.setContentEncoding(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br><br>    httpPost.setEntity(entity);<br>    <span class="hljs-comment">// 发送请求</span><br>    <span class="hljs-type">CloseableHttpResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> httpClient.execute(httpPost);<br>    <span class="hljs-comment">// 解析返回结果</span><br>    System.out.println(response.getStatusLine().getStatusCode());<br><br>    <span class="hljs-type">HttpEntity</span> <span class="hljs-variable">entity1</span> <span class="hljs-operator">=</span> response.getEntity();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">string</span> <span class="hljs-operator">=</span> EntityUtils.toString(entity1);<br>    System.out.println(string);<br>    <span class="hljs-comment">// 关闭资源</span><br>    response.close();<br>    httpClient.close();<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h3><p>和其他依赖框架的使用思路一样，我们将HttpClient封装为工具类，想要使用的时候直接使用工具类即可</p><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>SSM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis-常用命令</title>
    <link href="/2024/07/07/Redis-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2024/07/07/Redis-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis-常用命令"><a href="#Redis-常用命令" class="headerlink" title="Redis-常用命令"></a>Redis-常用命令</h1><p><a href="https://www.redis.net.cn/order/">redis命令手册</a></p><p><a href="https://redis.io/docs/latest/commands/">Commands | Docs (redis.io)</a></p><p>Redis的命令也是不区分大小写的，但key是区分大小写的，例如<code>k1</code>和<code>K1</code>是两个不同的键</p><p>使用help @<code>类型</code> 命令，获取帮助文档</p><p><strong>注：在一般的编程语言中，例如python和java，字符串的截取一般都用于<code>左闭右开</code>原则，而Redis采用<code>左闭右闭</code>原则</strong></p><p><em>注2：如果存在中文乱码，则在客户端连接时加入参数<code>--raw</code></em></p><hr><h3 id="Key相关命令"><a href="#Key相关命令" class="headerlink" title="Key相关命令"></a>Key相关命令</h3><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>keys *</td><td>查看当前库中的所有key</td></tr><tr><td>exists key</td><td>判断某个key是否存在</td></tr><tr><td>type key</td><td>查看你的key是什么类型</td></tr><tr><td>del key</td><td>删除指定的key</td></tr><tr><td>unlink key</td><td>非阻塞删除，仅仅将keys从keyspace元数据中删除，真正的删除会在后续异步中操作</td></tr><tr><td>ttl key</td><td>查看还有多少秒过期，-1为永不过期，-2表示已经过期</td></tr><tr><td>expire key <code>时间（s）</code></td><td>为给定的key设置过期时间</td></tr><tr><td>move key <code>dbindex</code></td><td>将当前数据库的key移动到给定的数据库db当中，默认有16个数据库</td></tr><tr><td>select <code>dbindex</code></td><td>切换数据库到 [0-15]</td></tr><tr><td>dbsize</td><td>查看当前数据库key的数量</td></tr><tr><td>flushdb</td><td>清空当前库</td></tr><tr><td>flushall</td><td>通杀数据库（16个库）</td></tr></tbody></table><hr><h1 id="十大数据类型的常用命令"><a href="#十大数据类型的常用命令" class="headerlink" title="十大数据类型的常用命令"></a>十大数据类型的常用命令</h1><h3 id="String相关命令"><a href="#String相关命令" class="headerlink" title="String相关命令"></a>String相关命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">SET key value [NX | XX] [GET] [EX seconds | PX milliseconds |<br>  EXAT unix-time-seconds | PXAT unix-time-milliseconds | KEEPTTL]<br></code></pre></td></tr></table></figure><ul><li><code>NX</code>– 仅设置尚不存在的key，当key已存在，返回nil**（分布式锁能用到）**</li><li><code>XX</code>– 仅设置已存在的key，当key不存在，返回nil</li><li><code>EX</code> <em>seconds</em> – 设置指定的到期时间，以秒为单位（正整数）<strong>（分布式锁能用到）</strong></li><li><code>PX</code> <em>milliseconds</em> – 设置指定的过期时间，以毫秒为单位（正整数）</li><li><code>EXAT</code> <em>timestamp-seconds</em> – 设置key过期的指定 Unix 时间，以秒为单位（正整数）</li><li><code>PXAT</code> <em>timestamp-milliseconds</em> – 设置key过期的指定 Unix 时间，以毫秒为单位（正整数）</li><li><code>KEEPTTL</code>– 修改时，保留与key关联的生存时间</li><li><code>GET</code>– 返回存储在 key 中的旧字符串，如果 key 不存在，则返回 nil。如果存储在 key 的值不是字符串，则返回并中止错误</li></ul><h5 id="UNIX时间戳"><a href="#UNIX时间戳" class="headerlink" title="UNIX时间戳"></a>UNIX时间戳</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java">Long.toString(System.currentTimeMills()/<span class="hljs-number">1000L</span>) <span class="hljs-comment">// 获取Unix时间戳，以秒为单位</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>MSET key value [key value …]</td><td>批量添加</td></tr><tr><td>MGET key [key …]</td><td>批量获取</td></tr><tr><td>MSETNX key value [key value …]</td><td>批量添加，如果有任何一个元素已经存在，则执行失败</td></tr><tr><td>GETRANGE key start end</td><td>遍历字符串（下标从0开始）<em>类似java的SubString字符串截取</em></td></tr><tr><td>SETRANGE key offset value</td><td>选取字符串覆盖（下标从0开始）</td></tr><tr><td>INCR key</td><td>将存储的数字递增 1</td></tr><tr><td>INCRBY key increment</td><td>将储存的数字递增，步长为<code>increment</code></td></tr><tr><td>DECR key</td><td>将存储的数字递减 1</td></tr><tr><td>INCRBY key increment</td><td>将储存的数字递减，步长为<code>increment</code></td></tr><tr><td>STRLEN key</td><td>获取字符串长度</td></tr><tr><td>APPEND key value</td><td>字符串追加</td></tr><tr><td>SETEX key seconds value</td><td>添加数据的同时设置过期时间（被set参数实现了）</td></tr><tr><td>SETNX key value</td><td>添加数据的同时检测数据是否存在，若不存在则添加成功（被set参数实现了）</td></tr><tr><td>GETSET key value</td><td>set新值的同时返回老值（被set参数实现了）</td></tr></tbody></table><hr><h3 id="List相关命令"><a href="#List相关命令" class="headerlink" title="List相关命令"></a>List相关命令</h3><p><em>List的实现就是单Key多Value</em></p><p>一个双端链表的结构，容量是2的32次方减1个元素，大概40多亿</p><p>主要功能有push&#x2F;pop等，一般用在栈、队列、消息队列等场景</p><p>left、right都可以插入添加</p><ul><li><p>如果键不存在，创建新的链表</p></li><li><p>如果键已存在，新增内容</p></li><li><p>如果值全移除，对应的键也就消失了</p></li></ul><p><em>它的底层实际是个<strong>双向链表，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差</strong></em></p><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>LPUSH key element [element …]</td><td>头部插入</td></tr><tr><td>RPUSH key element [element …]</td><td>尾部插入</td></tr><tr><td>LRANGE key start stop</td><td>遍历链表（如果参数是<code>0</code>和<code>-1</code>，就遍历此表）</td></tr><tr><td>LPOP key [count]</td><td>头部删除</td></tr><tr><td>RPOP key [count]</td><td>尾部删除</td></tr><tr><td>LINDEX key index</td><td>查找元素（以0为第一个元素）</td></tr><tr><td>LLEN key</td><td>获取List长度</td></tr><tr><td>LREM key count element</td><td>删除List中<code>count</code>数量的<code>element</code>元素</td></tr><tr><td>LTRIM key start stop</td><td>截取List中<code>strat</code>到<code>stop</code>的元素，其余元素删除</td></tr><tr><td>RPOPLPUSH source destinatin</td><td>删除<code>source</code>的尾部元素，将此元素添加到<code>destination</code>的头部</td></tr><tr><td>LSET key index element</td><td>修改元素</td></tr><tr><td>LINSERT key &lt;BEFORE | AFTER&gt; pivot element</td><td>插入元素，<code>pivot</code>为被插入元素而不是<code>index</code></td></tr></tbody></table><p><em>尾部插入，正向遍历，就会得到正序的结果</em></p><p><em>很多命令的start参数可以为-1，从尾部开始操作</em></p><hr><h3 id="Hash相关命令"><a href="#Hash相关命令" class="headerlink" title="Hash相关命令"></a>Hash相关命令</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;String,Map&lt;Object,Object&gt;&gt;<br></code></pre></td></tr></table></figure><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>HSET key field value [field value …]</td><td>创建Hash元素</td></tr><tr><td>HGET key field</td><td>获取键中指定属性的值</td></tr><tr><td>HGETALL key</td><td>获取键中所有的键值对（属性和值）</td></tr><tr><td>HMSET key field value [field value …]</td><td>创建Hash元素（貌似看起来和set一摸一样呢）</td></tr><tr><td>HMGET key field [field …]</td><td>获取键中指定多个属性的值</td></tr><tr><td>HDEL key field [field …]</td><td>删除键中属性</td></tr><tr><td>HLEN key</td><td>获取键中属性的数量</td></tr><tr><td>HEXISTS key field</td><td>判断键中是否存在属性（存在返回1，不存在返回0）</td></tr><tr><td>HKEYS key</td><td>遍历键中所有属性（只有属性）</td></tr><tr><td>HVALS key</td><td>遍历键中所有属性的值（只有值）</td></tr><tr><td>HINCRBY key field increment</td><td>将键中整形属性的数字递增<code>increment</code></td></tr><tr><td>HINCRBYFLOAT key field increment</td><td>将键中浮点型属性的数字递增<code>increment</code></td></tr><tr><td>HSETNX key field value</td><td>添加数据的同时检测数据是否存在，若不存在则添加成功</td></tr></tbody></table><hr><h3 id="Set相关命令"><a href="#Set相关命令" class="headerlink" title="Set相关命令"></a>Set相关命令</h3><p>Set是一个无序无重复的列表，也同样实现了一个Key多个Value</p><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>SADD key member [member …]</td><td>添加元素，当元素重复时则只添加一个</td></tr><tr><td>SMEMBERS key</td><td>遍历set</td></tr><tr><td>SISMEMBER key member</td><td>判断集合中是否存在该元素</td></tr><tr><td>SREM key member [member …]</td><td>删除元素（成功返回1，失败返回0）</td></tr><tr><td>SCARD key</td><td>统计集合中有多少个元素</td></tr><tr><td>SRANDMEMBER key [count]</td><td>随机显示<code>count</code>个set元素，不会改变原有set</td></tr><tr><td>SPOP key [count]</td><td>随机删除<code>count</code>个set元素，并显示删除的元素</td></tr><tr><td>SMOVE source destination member</td><td>将<code>source</code>集合中的<code>member</code>元素移到<code>destination</code> 集合中</td></tr></tbody></table><h5 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h5><blockquote><p>现存在以下集合：</p><p>A：abc12</p><p>B：123ax</p></blockquote><p>SDIFF A B的结果是”b” “c”</p><p>SDIFF B A的结果是”3” “x”</p><p>SUNION A B的结果是：”a” “b” “c” “1” “2” “3” “x”</p><p>SINTER A B 的结果是：”a” “1” “2”</p><table><thead><tr><th align="left">命令</th><th>功能</th></tr></thead><tbody><tr><td align="left">SDIFF key [key …]</td><td>求两个集合中的差集</td></tr><tr><td align="left">SUNION key [key …]</td><td>求两个集合的并集</td></tr><tr><td align="left">SINTER key [key …]</td><td>求两个集合的交集</td></tr><tr><td align="left">SINTERCARD numkeys key [key …] [LIMIT limit]</td><td>返回交集的结果集个数，limit控制返回的个数为 &lt; 结果</td></tr></tbody></table><hr><h3 id="ZSet相关命令"><a href="#ZSet相关命令" class="headerlink" title="ZSet相关命令"></a>ZSet相关命令</h3><p>Zset是有序的set集合，其实现方法是在每一个value前加上字段score，根据字段score可进行排序</p><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>ZADD key [NX | XX] [GT | LT] [CH] [INCR] score member [score member   …]</td><td>添加元素</td></tr><tr><td>ZRANGE key start stop [BYSCORE | BYLEX] [REV] [LIMIT offset count]   [WITHSCORES]</td><td>遍历元素*<code>WITHSCORES</code>带有分数遍历*</td></tr><tr><td>ZREVRANGE key start stop [WITHSCORES]</td><td>反向遍历元素*<code>WITHSCORES</code>带有分数遍历*</td></tr><tr><td>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</td><td>以分数筛选*默认范围是包含min和max，如果不想包含，则使用<code>()</code>*修饰</td></tr><tr><td>ZCARD key</td><td>返回元素数量</td></tr><tr><td>ZREM key member [member …]</td><td>删除元素</td></tr><tr><td>ZINCRBY key increment member</td><td>将键中元素递增<code>increment</code></td></tr><tr><td>ZCOUNT key min max</td><td>返回以分数<code>min</code>到<code>max</code>范围内的元素数量</td></tr><tr><td>ZMPOP numkeys key [key …] &lt;MIN | MAX&gt; [COUNT count]</td><td>从分数<code>min</code>或<code>max</code>弹出<code>COUNT</code>个元素，可以从多个key中弹出，<code>numkeys</code>标识要多少个key</td></tr><tr><td>ZRANK key member [WITHSCORE]</td><td>正序获得元素的下标<em>不是分数</em></td></tr><tr><td>ZREVRANK key member [WITHSCORE]</td><td>逆序获得元素的下标<em>不是分数</em></td></tr></tbody></table><p><em>在查询中，Limit的作用是添加返回的条件，类似于MySql中的Limit来分页</em></p><hr><h3 id="BitMap相关命令"><a href="#BitMap相关命令" class="headerlink" title="BitMap相关命令"></a>BitMap相关命令</h3><p>由0和1状态表现得二进制位的bit数组，其底层实现也是String类型</p><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>SETBIT key offset value</td><td>在键中的<code>offset</code>设置<code>value</code></td></tr><tr><td>GETBIT key offset</td><td>通过<code>key</code>中的<code>offset</code>获取到<code>value</code></td></tr><tr><td>STRLEN key</td><td>此命令是String的命令，获取到BitMap类型的键所占用内存字节数</td></tr><tr><td>BITCOUNT key [start end [BYTE | BIT]]</td><td>统计键中<code>value</code>为1的数量</td></tr><tr><td>BITOP &lt;AND | OR | XOR | NOT&gt; destkey key [key …]</td><td>对数据进行按位运算，将运算结果储存到<code>destkey</code>中</td></tr></tbody></table><p><em>实际场景应用于标记签到打卡信息</em></p><h5 id="将日期作为key"><a href="#将日期作为key" class="headerlink" title="将日期作为key"></a>将日期作为key</h5><p>我们可以将偏移量设为用户id，也就是用户标识，将value设置为是否签到，key则为当天的具体日期</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">SETBIT 20240707 0 1  # 2024年7月7日，0号用户签到<br>SETBIT 20240708 0 1  # 2024年7月8日，0号用户签到<br></code></pre></td></tr></table></figure><p>将这两条BitMap进行与运算，即可获得这两天连续签到的用户</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">BITOP AND k1 20240707 20240708 # 将与运算的结果储存到k1<br></code></pre></td></tr></table></figure><h5 id="将用户作为key"><a href="#将用户作为key" class="headerlink" title="将用户作为key"></a>将用户作为key</h5><p>我们将key设为用户，将偏移量设为日期，将value设置为是否签到</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">SETBIT xiaobai:202407 0 1 # 用户小白在六月份的第0天签到<br>SETBIT xiaobai:202407 1 1 # 用户小白在六月份的第1天签到<br></code></pre></td></tr></table></figure><p>使用BITCOUNT命令对该用户的这一月份签到信息进行统计</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">BITCOUNT xiaobai:202407 # 看看小白这个月来了多少天<br></code></pre></td></tr></table></figure><hr><h3 id="HyperLogLog相关命令"><a href="#HyperLogLog相关命令" class="headerlink" title="HyperLogLog相关命令"></a>HyperLogLog相关命令</h3><p> 去重复统计功能的基数估计算法</p><p><em>HyperLogLog只会根据输入元素计算基数，而不会储存输入元素的本身，底层使用String类型</em></p><h5 id="UV"><a href="#UV" class="headerlink" title="UV"></a>UV</h5><p>UV是一个全新的概念，Unique Visitor 独立访客</p><p>可以理解为同一个Ip的多次访问，视作一个用户的访问</p><p>所以统计UV需要考虑去重问题</p><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>PFADD key [element [element …]]</td><td>添加指定元素</td></tr><tr><td>PFCOUNT key [key …]</td><td>统计基数</td></tr><tr><td>PFMERGE destkey [sourcekey [sourcekey …]]</td><td>合并key到目标key中</td></tr></tbody></table><hr><h3 id="GEO相关命令"><a href="#GEO相关命令" class="headerlink" title="GEO相关命令"></a>GEO相关命令</h3><p>GEO的底层是基于ZSet，坐标就是score</p><p>通过GEOHASH 将经纬度的二维数据转换为Base32加密</p><p><a href="https://lbs.amap.com/tools/picker">坐标拾取器 | 高德地图API (amap.com)</a></p><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>GEOADD key [NX | XX] [CH] longitude latitude member [longitude   latitude member …]</td><td>将坐标添加到key中</td></tr><tr><td>ZRANGE key start stop [BYSCORE |BYLEX] [REV] [LIMIT offset count]   [WITHSCORES]</td><td>因为底层实现是ZSet，所以仍然可以使用ZSet的方式进行遍历</td></tr><tr><td>GEOPOS key [member [member …]]</td><td>通过元素获得坐标</td></tr><tr><td>GEOHASH key [member [member …]]</td><td>通过元素获得Base32加密的坐标，<em>实际开发用这个</em></td></tr><tr><td>GEODIST key member1 member2 [M | KM | FT | MI]</td><td>返回两个元素之间的距离，可选择单位</td></tr><tr><td>GEORADIUS key longitude latitude radius &lt;M | KM | FT | MI&gt;   [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count [ANY]] [ASC | DESC]   [STORE key | STOREDIST key]</td><td>以<code>longitude latitude</code>为坐标发起点，寻找包含在<code>key</code>中，以半径为<code>radius</code>的所有元素坐标。<code>count</code>可配置显示数量，&#96;ASC</td></tr><tr><td>GEORADIUSBYMEMBER key member radius &lt;M | KM | FT | MI&gt; [WITHCOORD]   [WITHDIST] [WITHHASH] [COUNT count [ANY]] [ASC | DESC] [STORE key   | STOREDIST key]</td><td>以元素<code>member</code>为发起点，其余参数与上一条相同</td></tr></tbody></table><hr><h3 id="Stream相关命令"><a href="#Stream相关命令" class="headerlink" title="Stream相关命令"></a>Stream相关命令</h3><p>Redis-Stream就是Redis版本的MQ（消息中间件）的处理模型</p><p>在5.0版本之前，Redis处理消息队列有两种方案</p><ul><li>List处理消息队列，使用LPUSH和RPOP</li><li>Pub&#x2F;Sub实现，但无法持久化数据</li></ul><p>所以，Redis提供了Stream数据类型，用以解决这两个处理方式的痛点</p><ul><li>实现消息队列</li><li>支持消息持久化</li><li>支持自动生成全局唯一ID</li><li>支持ack确认消息的模式</li><li>支持消费组模式</li></ul><hr><h5 id="消息队列相关命令"><a href="#消息队列相关命令" class="headerlink" title="消息队列相关命令"></a>消息队列相关命令</h5><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>XADD key [NOMKSTREAM] [&lt;MAXLEN | MINID&gt; [&#x3D; | ~] threshold   [LIMIT count]] &lt;* | id&gt; field value [field value …]</td><td>在队列尾部插入一条消息，消息的内容为Hash多键值对属性，使用*作为<code>id</code>（主键），则会根据算法自动生成一个<code>id</code></td></tr><tr><td>XRANGE key start end [COUNT count]</td><td>升序遍历队列中<code>count</code>条消息，<code>start</code>和<code>end</code>为<code>-</code>(最小)和<code>+</code>（最大）时，遍历所有消息</td></tr><tr><td>XREVRANGE key end start [COUNT count]</td><td>降序遍历队列中<code>count</code>条消息，<code>start</code>和<code>end</code>为<code>-</code>(最小)和<code>+</code>（最大）时，遍历所有消息</td></tr><tr><td>XDEL key id [id …]</td><td>根据主键删除消息</td></tr><tr><td>XLEN key</td><td>获取队列中消息的个数</td></tr><tr><td>XTRIM key &lt;MAXLEN | MINID&gt; [&#x3D; | ~] threshold [LIMIT count]</td><td>使用<code>maxlen</code>参数，则为保留最新的<code>count</code>条参数，使用<code>minid</code>参数，删除掉低于<code>id</code>的所有条目（删除比他老的）</td></tr><tr><td>XREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key …] id   [id …]</td><td>当不使用<code>BLOCK</code>时，使用非阻塞模式，<code>id</code>的值可以为三种：主键值、<code>0-0</code>和<code>$</code>，表示从<code>id</code>开始读取<code>count</code>条数据。</td></tr><tr><td>XREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key …] id   [id …]</td><td>当使用<code>BLOCK</code>时，使用阻塞模式，<code>id</code>的值使用<code>$</code>，则监听消息队列的新消息产生</td></tr></tbody></table><p><em>$代表最新消息，最大值；0-0代表着最初消息，id最小值</em></p><hr><h5 id="消费者组相关命令"><a href="#消费者组相关命令" class="headerlink" title="消费者组相关命令"></a>消费者组相关命令</h5><p>Stream消息队列中的消息一旦被消费组里的一个消费者读取过了，同组内的其他消费者就不能再读取这个消息了</p><p>但是，这条消息仍然可以被其他消费组的消费者读取</p><p>消费组的设定，是为了实现负载均衡</p><p>一个消费者读过，其他人就不能读取，每人读一点，不会出现重复读取数据的问题，又能把任务分发到众多消费者身上</p><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>XGROUP CREATE key group &lt;id | $&gt; [MKSTREAM]   [ENTRIESREAD entries-read]</td><td>用于创建消费者组，指定<code>id</code>为<code>0</code>表示从头开始消费，指定<code>id</code>为<code>$</code>表示从尾部开始消费（消费新消息）</td></tr><tr><td>XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds]   [NOACK] STREAMS key [key …] id [id …]</td><td>让消费组中的消费者读取消息队列里面的信息<code>id</code>为<code>&gt;</code>时，意味读取指针指向的当前消息</td></tr><tr><td>XPENDING key group [[IDLE min-idle-time] start end count [consumer]]</td><td>查询消费组中已读取但未确认的消息，通过<code>consumer</code>参数可以获得具体消费者读取的具体消息</td></tr><tr><td>XACK key group id [id …]</td><td>确认具体消息</td></tr><tr><td>XINFO STREAM key [FULL [COUNT count]]</td><td>返回有关流的信息</td></tr></tbody></table><p><strong>专业的事情专业的人来做，Redis就不是用来做消息中间件的，所以等到时候学MQ之后再用</strong></p><hr><h3 id="BitField相关命令"><a href="#BitField相关命令" class="headerlink" title="BitField相关命令"></a>BitField相关命令</h3><p>没用，这玩意不用，跳过</p><hr>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
      <category>Redis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis-十大数据类型</title>
    <link href="/2024/07/06/Redis-%E5%8D%81%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2024/07/06/Redis-%E5%8D%81%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis-十大数据类型"><a href="#Redis-十大数据类型" class="headerlink" title="Redis-十大数据类型"></a>Redis-十大数据类型</h1><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>string是redis最基本的类型，一个key对应一个value</p><p>string类型是二进制安全的，意思是redis的string可以包含任何数据，比如jpg图片或者序列化的对象 </p><p>string类型是Redis最基本的数据类型，一个redis中字符串value最多可以是512M</p><hr><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）</p><p>它的底层实际是个<strong>双端链表</strong>，最多可以包含 2^32 - 1 个元素 (4294967295, 每个列表超过40亿个元素)</p><hr><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>Redis hash 是一个 string 类型的 field（字段） 和 value（值） 的映射表，hash 特别适合用于存储对象</p><p>Redis 中每个 hash 可以存储 2^32 - 1 键值对（40多亿）</p><hr><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据，集合对象的编码可以是 intset 或者 hashtable</p><p>Redis 中Set集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)</p><p>集合中最大的成员数为 2^32 - 1 (494967295, 每个集合可存储40多亿个成员)</p><hr><h3 id="Zset"><a href="#Zset" class="headerlink" title="Zset"></a>Zset</h3><p>Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员</p><p>不同的是每个元素都会关联一个double类型的分数，redis正是通过分数来为集合中的成员进行从小到大的排序</p><p>zset的成员是唯一的,但分数(score)却可以重复</p><p>zset集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。 集合中最大的成员数为 2^32 - 1</p><hr><h3 id="GEO"><a href="#GEO" class="headerlink" title="GEO"></a>GEO</h3><p>Redis GEO 主要用于存储地理位置信息，并对存储的信息进行操作，包括：</p><ul><li><p>添加地理位置的坐标</p></li><li><p>获取地理位置的坐标</p></li><li><p>计算两个位置之间的距离</p></li></ul><p>根据用户给定的经纬度坐标来获取指定范围内的地理位置集合</p><hr><h3 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h3><p>HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定且是很小的</p><p>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基 数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比</p><p>但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素</p><hr><h3 id="BitMap"><a href="#BitMap" class="headerlink" title="BitMap"></a>BitMap</h3><p>Bit arrays(or simple bitmaps) 我们称之为位图</p><p><em>字节数组是以B为单位的，而位图以bit为单位</em></p><p>由0和1状态表现的二进制位的bit数组</p><hr><h3 id="BitField"><a href="#BitField" class="headerlink" title="BitField"></a>BitField</h3><p>通过bitfield命令可以一次性操作多个比特位域(指的是连续的多个比特位)，它会执行一系列操作并返回一个响应数组，这个数组中的元素对应参数列表中的相应操作的执行结果</p><p>说白了就是通过bitfield命令我们可以一次性对多个比特位域进行操作</p><hr><h3 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h3><p>Redis Stream 主要用于消息队列（MQ，Message Queue），Redis 本身是有一个 Redis 发布订阅 (pub&#x2F;sub) 来实现消息队列的功能，但它有个缺点就是消息无法持久化，如果出现网络断开、Redis 宕机等，消息就会被丢弃。</p><p>简单来说发布订阅 (pub&#x2F;sub) 可以分发消息，但无法记录历史消息。</p><p>而 Redis Stream 提供了消息的持久化和主备复制功能，可以让任何客户端访问任何时刻的数据，并且能记住每一个客户端的访问位置，还能保证消息不丢失</p><p><em>然而，专业的事情交给专业的人来干，我们在MQ功能上使用的仍然不是redis</em></p><hr>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
      <category>Redis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis</title>
    <link href="/2024/07/06/Redis/"/>
    <url>/2024/07/06/Redis/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><p><a href="https://www.redis.net.cn/">Redis中文网</a></p><p>REmote DIctionary Server(Redis) 是一个由 Salvatore Sanfilippo 写的 key-value 存储系统，是跨平台的非关系型数据库</p><p>Redis 是一个开源的使用 ANSI C 语言编写、遵守 BSD 协议、支持网络、可基于内存、分布式、可选持久性的键值对(Key-Value)存储数据库，并提供多种语言的 API</p><p>Redis 通常被称为数据结构服务器，因为值（value）可以是字符串(String)、哈希(Hash)、列表(list)、集合(sets)和有序集合(sorted sets)等类型</p><p><a href="http://doc.redisfans.com/">Redis 命令参考 — Redis 命令参考 (redisfans.com)</a></p><hr><h3 id="Redis安装"><a href="#Redis安装" class="headerlink" title="Redis安装"></a>Redis安装</h3><p>LInux环境安装Redis必须具备gcc编译环境</p><ul><li>将压缩包放在opt（第三方软件目录）根目录下，解压缩</li><li>在redis目录中，执行<code>make &amp;&amp; make install</code>命令安装</li><li>默认安装路径为：user&#x2F;local&#x2F;bin</li></ul><hr><h5 id="redis-conf"><a href="#redis-conf" class="headerlink" title="redis.conf"></a>redis.conf</h5><p><a href="https://github.com/redis/redis/blob/unstable/redis.conf">https://github.com/redis/redis/blob/unstable/redis.conf</a></p><ul><li>daemonize yes：配置后台守护运行redis</li><li>protected-mode no：关闭安全保护模式</li><li>bind 0.0.0.0：允许外部IP连接</li><li>requirepass：设置redis密码</li></ul><hr><h3 id="启动和关闭"><a href="#启动和关闭" class="headerlink" title="启动和关闭"></a>启动和关闭</h3><ul><li>redis-server &#x2F;xxx&#x2F;redis.conf：使用指定配置文件启动服务端</li><li>redis-cli -a <code>密码</code> -p <code>端口</code>：使用客户端连接redis</li><li>在进入redis后，使用shutdown命令关闭服务端</li></ul><hr><h3 id="使用docker-compose安装"><a href="#使用docker-compose安装" class="headerlink" title="使用docker-compose安装"></a>使用docker-compose安装</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3.3&#x27;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">redis:latest</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">redis</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;6379:6379&#x27;</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/home/redis/data:/data</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/home/redis/conf:/usr/local/etc/redis/conf</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/home/redis/logs:/logs</span><br>    <span class="hljs-comment"># 配置文件启动</span><br>    <span class="hljs-attr">command:</span> <span class="hljs-string">redis-server</span> <span class="hljs-string">/usr/local/etc/redis/conf/redis.conf</span><br></code></pre></td></tr></table></figure><h2 id="将https-github-com-redis-redis-blob-unstable-redis-conf-的配置文件放到conf文件夹下，即可使用配置文件启动redis"><a href="#将https-github-com-redis-redis-blob-unstable-redis-conf-的配置文件放到conf文件夹下，即可使用配置文件启动redis" class="headerlink" title="将https://github.com/redis/redis/blob/unstable/redis.conf 的配置文件放到conf文件夹下，即可使用配置文件启动redis"></a>将<a href="https://github.com/redis/redis/blob/unstable/redis.conf">https://github.com/redis/redis/blob/unstable/redis.conf</a> 的配置文件放到conf文件夹下，即可使用配置文件启动redis</h2>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
      <category>Redis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot-微头条项目实战</title>
    <link href="/2024/07/05/SpringBoot-%E5%BE%AE%E5%A4%B4%E6%9D%A1%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"/>
    <url>/2024/07/05/SpringBoot-%E5%BE%AE%E5%A4%B4%E6%9D%A1%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot-微头条项目实战"><a href="#SpringBoot-微头条项目实战" class="headerlink" title="SpringBoot-微头条项目实战"></a>SpringBoot-微头条项目实战</h1><h3 id="application-yaml文件"><a href="#application-yaml文件" class="headerlink" title="application.yaml文件"></a>application.yaml文件</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span><br>    <span class="hljs-comment"># JDBC四大件</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/mybatis-example</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">Zhuwenxue2002</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br><br><span class="hljs-attr">mybatis-plus:</span><br>  <span class="hljs-attr">type-aliases-package:</span> <span class="hljs-string">com.xiaobai.pojo</span> <span class="hljs-comment"># 给实体类起别名</span><br>  <span class="hljs-attr">global-config:</span><br>    <span class="hljs-attr">db-config:</span><br>      <span class="hljs-attr">logic-delete-field:</span> <span class="hljs-string">deleted</span> <span class="hljs-comment"># 为所有表配置逻辑删除属性</span><br>      <span class="hljs-attr">id-type:</span> <span class="hljs-string">auto</span> <span class="hljs-comment"># 配置主键由MySql自增长</span><br>      <span class="hljs-attr">table-prefix:</span> <span class="hljs-string">news_</span> <span class="hljs-comment"># 配置表前缀为news_</span><br></code></pre></td></tr></table></figure><h3 id="pom-xml-maven依赖导入文件"><a href="#pom-xml-maven依赖导入文件" class="headerlink" title="pom.xml maven依赖导入文件"></a>pom.xml maven依赖导入文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span> <span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.xiaobai<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-headline<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>spring-headline<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>spring-headline<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">licenses</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">license</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">licenses</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">developers</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">developer</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">developers</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scm</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">connection</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">developerConnection</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tag</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">scm</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>17<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/com.baomidou/mybatis-plus-spring-boot3-starter --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-spring-boot3-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.23<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">excludes</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">exclude</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">exclude</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">excludes</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h3 id="配置SpringBoot启动类"><a href="#配置SpringBoot启动类" class="headerlink" title="配置SpringBoot启动类"></a>配置SpringBoot启动类</h3><p>为MyBatisPlus添加插件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringHeadlineApplication</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(SpringHeadlineApplication.class, args);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> MybatisPlusInterceptor <span class="hljs-title function_">mybatisPlusInterceptor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">MybatisPlusInterceptor</span> <span class="hljs-variable">interceptor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MybatisPlusInterceptor</span>();<br>        interceptor.addInnerInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PaginationInnerInterceptor</span>(DbType.MYSQL)); <span class="hljs-comment">// 添加分页插件，配置数据库类型为MySQL</span><br>        interceptor.addInnerInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OptimisticLockerInnerInterceptor</span>()); <span class="hljs-comment">// 添加乐观锁插件</span><br>        interceptor.addInnerInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BlockAttackInnerInterceptor</span>()); <span class="hljs-comment">// 防止全表更新或删除插件</span><br>        <span class="hljs-keyword">return</span> interceptor;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h3><h5 id="结果封装类"><a href="#结果封装类" class="headerlink" title="结果封装类"></a>结果封装类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 全局统一返回结果类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Result</span>&lt;T&gt; &#123;<br>    <span class="hljs-comment">// 返回码</span><br>    <span class="hljs-keyword">private</span> Integer code;<br>    <span class="hljs-comment">// 返回消息</span><br>    <span class="hljs-keyword">private</span> String message;<br>    <span class="hljs-comment">// 返回数据</span><br>    <span class="hljs-keyword">private</span> T data;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Result</span><span class="hljs-params">()</span>&#123;&#125;<br>    <span class="hljs-comment">// 返回数据</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> &lt;T&gt; Result&lt;T&gt; <span class="hljs-title function_">build</span><span class="hljs-params">(T data)</span> &#123;<br>        Result&lt;T&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Result</span>&lt;T&gt;();<br>        <span class="hljs-keyword">if</span> (data != <span class="hljs-literal">null</span>)<br>            result.setData(data);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Result&lt;T&gt; <span class="hljs-title function_">build</span><span class="hljs-params">(T body, Integer code, String message)</span> &#123;<br>        Result&lt;T&gt; result = build(body);<br>        result.setCode(code);<br>        result.setMessage(message);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Result&lt;T&gt; <span class="hljs-title function_">build</span><span class="hljs-params">(T body, ResultCodeEnum resultCodeEnum)</span> &#123;<br>        Result&lt;T&gt; result = build(body);<br>        result.setCode(resultCodeEnum.getCode());<br>        result.setMessage(resultCodeEnum.getMessage());<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 操作成功</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> data  baseCategory1List</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &lt;T&gt;</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>&lt;T&gt; Result&lt;T&gt; <span class="hljs-title function_">ok</span><span class="hljs-params">(T data)</span>&#123;<br>        Result&lt;T&gt; result = build(data);<br>        <span class="hljs-keyword">return</span> build(data, ResultCodeEnum.SUCCESS);<br>    &#125;<br>    <span class="hljs-keyword">public</span> Result&lt;T&gt; <span class="hljs-title function_">message</span><span class="hljs-params">(String msg)</span>&#123;<br>        <span class="hljs-built_in">this</span>.setMessage(msg);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> Result&lt;T&gt; <span class="hljs-title function_">code</span><span class="hljs-params">(Integer code)</span>&#123;<br>        <span class="hljs-built_in">this</span>.setCode(code);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">getCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> code;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCode</span><span class="hljs-params">(Integer code)</span> &#123;<br>        <span class="hljs-built_in">this</span>.code = code;<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getMessage</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> message;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMessage</span><span class="hljs-params">(String message)</span> &#123;<br>        <span class="hljs-built_in">this</span>.message = message;<br>    &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getData</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> data;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setData</span><span class="hljs-params">(T data)</span> &#123;<br>        <span class="hljs-built_in">this</span>.data = data;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="结果枚举类"><a href="#结果枚举类" class="headerlink" title="结果枚举类"></a>结果枚举类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 统一返回结果状态信息类</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">ResultCodeEnum</span> &#123;<br><br>    SUCCESS(<span class="hljs-number">200</span>,<span class="hljs-string">&quot;success&quot;</span>),<br>    USERNAME_ERROR(<span class="hljs-number">501</span>,<span class="hljs-string">&quot;usernameError&quot;</span>),<br>    PASSWORD_ERROR(<span class="hljs-number">503</span>,<span class="hljs-string">&quot;passwordError&quot;</span>),<br>    NOTLOGIN(<span class="hljs-number">504</span>,<span class="hljs-string">&quot;notLogin&quot;</span>),<br>    USERNAME_USED(<span class="hljs-number">505</span>,<span class="hljs-string">&quot;userNameUsed&quot;</span>);<br><br>    <span class="hljs-keyword">private</span> Integer code;<br>    <span class="hljs-keyword">private</span> String message;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">ResultCodeEnum</span><span class="hljs-params">(Integer code, String message)</span> &#123;<br>        <span class="hljs-built_in">this</span>.code = code;<br>        <span class="hljs-built_in">this</span>.message = message;<br>    &#125;<br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">getCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> code;<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getMessage</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> message;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><h5 id="MD5加密工具类"><a href="#MD5加密工具类" class="headerlink" title="MD5加密工具类"></a>MD5加密工具类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.security.MessageDigest;<br><span class="hljs-keyword">import</span> java.security.NoSuchAlgorithmException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MD5Util</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">encrypt</span><span class="hljs-params">(String strSrc)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">char</span> hexChars[] = &#123; <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span>,<br>                    <span class="hljs-string">&#x27;9&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span> &#125;;<br>            <span class="hljs-type">byte</span>[] bytes = strSrc.getBytes();<br>            <span class="hljs-type">MessageDigest</span> <span class="hljs-variable">md</span> <span class="hljs-operator">=</span> MessageDigest.getInstance(<span class="hljs-string">&quot;MD5&quot;</span>);<br>            md.update(bytes);<br>            bytes = md.digest();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> bytes.length;<br>            <span class="hljs-type">char</span>[] chars = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[j * <span class="hljs-number">2</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; bytes.length; i++) &#123;<br>                <span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> bytes[i];<br>                chars[k++] = hexChars[b &gt;&gt;&gt; <span class="hljs-number">4</span> &amp; <span class="hljs-number">0xf</span>];<br>                chars[k++] = hexChars[b &amp; <span class="hljs-number">0xf</span>];<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(chars);<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchAlgorithmException e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;MD5加密出错！！+&quot;</span> + e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h3><p>Token是一项技术，可以理解为接口</p><p>JWT（Json Web Token）时具体生成校验，解析等动作，可以理解为Token的实现类</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/io.jsonwebtoken/jjwt --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.jsonwebtoken<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jjwt<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;jjwt.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/javax.xml.bind/jaxb-api --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.xml.bind<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jaxb-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;jaxb.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h5 id="application-yaml"><a href="#application-yaml" class="headerlink" title="application.yaml"></a>application.yaml</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">jwt:</span><br>  <span class="hljs-attr">token:</span><br>    <span class="hljs-attr">tokenExpiration:</span> <span class="hljs-number">120</span> <span class="hljs-comment"># Token有效时间，单位（分钟）</span><br>    <span class="hljs-attr">tokenSignKey:</span> <span class="hljs-string">headline123456</span> <span class="hljs-comment"># 当前程序签名密钥，自定义</span><br></code></pre></td></tr></table></figure><hr><h5 id="Token工具类"><a href="#Token工具类" class="headerlink" title="Token工具类"></a>Token工具类</h5><p><em>注：这个工具类由尚硅谷提供，支持JJWT版本为0.9.1，必须导入2.3.1版本的jaxb才可正常使用</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xiaobai.util;<br><br><span class="hljs-keyword">import</span> com.alibaba.druid.util.StringUtils;<br><span class="hljs-keyword">import</span> io.jsonwebtoken.*;<br><span class="hljs-keyword">import</span> lombok.Data;<br><span class="hljs-keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-keyword">import</span> java.util.Date;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;jwt.token&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JwtHelper</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> tokenExpiration; <span class="hljs-comment">//有效时间,单位毫秒 1000毫秒 == 1秒</span><br>    <span class="hljs-keyword">private</span> String tokenSignKey;  <span class="hljs-comment">//当前程序签名秘钥</span><br><br>    <span class="hljs-comment">//生成token字符串</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">createToken</span><span class="hljs-params">(Long userId)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;tokenExpiration = &quot;</span> + tokenExpiration);<br>        System.out.println(<span class="hljs-string">&quot;tokenSignKey = &quot;</span> + tokenSignKey);<br>        <span class="hljs-keyword">return</span> Jwts.builder()<br><br>                .setSubject(<span class="hljs-string">&quot;YYGH-USER&quot;</span>)<br>                .setExpiration(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(System.currentTimeMillis() + tokenExpiration * <span class="hljs-number">1000</span> * <span class="hljs-number">60</span>)) <span class="hljs-comment">//单位分钟</span><br>                .claim(<span class="hljs-string">&quot;userId&quot;</span>, userId)<br>                .signWith(SignatureAlgorithm.HS512, tokenSignKey)<br>                .compressWith(CompressionCodecs.GZIP)<br>                .compact();<br>    &#125;<br><br>    <span class="hljs-comment">//从token字符串获取userid</span><br>    <span class="hljs-keyword">public</span> Long <span class="hljs-title function_">getUserId</span><span class="hljs-params">(String token)</span> &#123;<br>        <span class="hljs-keyword">if</span> (StringUtils.isEmpty(token)) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        Jws&lt;Claims&gt; claimsJws = Jwts.parser().setSigningKey(tokenSignKey).parseClaimsJws(token);<br>        <span class="hljs-type">Claims</span> <span class="hljs-variable">claims</span> <span class="hljs-operator">=</span> claimsJws.getBody();<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> (Integer) claims.get(<span class="hljs-string">&quot;userId&quot;</span>);<br>        <span class="hljs-keyword">return</span> userId.longValue();<br>    &#125;<br><br><br>    <span class="hljs-comment">//判断token是否有效</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isExpiration</span><span class="hljs-params">(String token)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//没有过期，有效，返回false</span><br>            <span class="hljs-keyword">return</span> Jwts.parser()<br>                    .setSigningKey(tokenSignKey)<br>                    .parseClaimsJws(token)<br>                    .getBody()<br>                    .getExpiration().before(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-comment">//过期出现异常，返回true</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="拦截器检查Token"><a href="#拦截器检查Token" class="headerlink" title="拦截器检查Token"></a>拦截器检查Token</h3><p>在用户登录之后，就有权限对数据进行增删改操作了</p><p>而我们需要在每次进行这种操作之前都要检查他的Token是否过期，是否仍然处于登陆状态</p><p>这种动作时重复冗余的，我们使用拦截器将其提取出来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xiaobai.interceptor;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 登录保护拦截器，在对数据进行操作前检测token是否有效</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginProtectedInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> JwtHelper jwtHelper;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> request.getHeader(<span class="hljs-string">&quot;token&quot;</span>);<br><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">expiration</span> <span class="hljs-operator">=</span> jwtHelper.isExpiration(token);<br>        <span class="hljs-keyword">if</span> (expiration) &#123;<br>            <span class="hljs-comment">// 通过手动封装一个Json，再通过response写回</span><br>            Result&lt;Object&gt; result = Result.build(<span class="hljs-literal">null</span>, ResultCodeEnum.NOTLOGIN);<br>            <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">objectMapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> objectMapper.writeValueAsString(result);<br>            response.getWriter().write(json);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 拦截</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 放行</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后我们需要创建MVC配置类，配置开启拦截器及其生效路径</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xiaobai.config;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebMVCConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> LoginProtectedInterceptor  loginProtectedInterceptor;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br>        registry.addInterceptor(loginProtectedInterceptor).addPathPatterns(<span class="hljs-string">&quot;/headline/**&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="遇到的错误"><a href="#遇到的错误" class="headerlink" title="遇到的错误"></a>遇到的错误</h3><p>org.apache.ibatis.binding.BindingException: Invalid bound statement (not found): com.xiaobai.mapper.UserMapper.selectById</p><p>在使用BaseMapper提供的方法时，遇到报错</p><p>使用@TableId注解标识主键，给MyBatisPlus底层指向主键位置，ById才会找到主键</p><hr><h3 id="IPage的Map泛型"><a href="#IPage的Map泛型" class="headerlink" title="IPage的Map泛型"></a>IPage的Map泛型</h3><p>IPage的泛型一般为实体类类型，但我们要求返回的数据类型为键值对的map类型</p><p>IPage的泛型怎么可以使用Map类型呢？ 这令我十分震惊。</p><p>但万能的神奇海螺还是给我了最终的解释：</p><p>在 MyBatis Plus 中，<code>IPage&lt;T&gt;</code> 接口是一个泛型接口，通常被用来处理分页查询的结果。<code>T</code> 是这个接口的泛型参数，它代表了分页数据中的元素类型。当我们在使用 <code>IPage</code> 进行分页查询时，<code>T</code> 通常会被设置为具体的实体类类型，这样我们就能直接获取到符合实体模型的数据。</p><p>然而，在某些情况下，你可能会看到 <code>IPage&lt;Map&lt;String, Object&gt;&gt;</code> 的用法。这是因为：</p><ol><li><strong>灵活性</strong>： 使用 <code>Map&lt;String, Object&gt;</code> 能够提供更大的灵活性。当你不确定查询结果的具体结构，或者需要返回多个不同类型的字段时，<code>Map</code> 可以方便地存储这些异构数据。这在处理复杂的SQL查询或联表查询时尤其有用，因为查询结果可能包含多个表的字段，而这些字段可能没有直接映射到单一的实体类。</li><li><strong>动态查询</strong>： 当你需要进行动态SQL查询时，使用 <code>Map</code> 可以更方便地构造和解析查询结果。例如，你可能需要根据不同的条件组合查询不同的字段，这时 <code>Map</code> 提供了一种灵活的方式来处理这种情况。</li><li><strong>避免实体类映射问题</strong>： 如果你的查询结果包含了额外的计算字段或聚合函数结果，这些字段可能无法直接映射到已有的实体类属性上。使用 <code>Map</code> 可以避免这种映射上的困难。</li></ol><p>然而，使用 <code>Map</code> 也有其缺点：</p><ul><li><strong>类型安全</strong>： 使用 <code>Map</code> 会牺牲类型安全性，因为你不再能够从编译器那里获得类型检查的好处。这意味着在运行时，你必须手动进行类型转换，这可能会引入潜在的 <code>ClassCastException</code> 错误。</li><li><strong>可读性和维护性</strong>： 使用实体类通常会让代码更加清晰和易于维护，因为实体类封装了业务逻辑和属性，而 <code>Map</code> 则可能需要额外的注释来解释字段的意义。</li></ul><p>因此，虽然 <code>IPage&lt;Map&lt;String, Object&gt;&gt;</code> 可以在某些场景下提供灵活性，但在大多数情况下，使用具体的实体类作为泛型参数将更加推荐，因为它提供了更好的类型安全性和代码可读性。如果需要复杂查询结果的灵活性，你可以考虑创建一个专门的 DTO（Data Transfer Object）类来承载这些数据，这样既能保持类型安全，又能提高代码的可读性和可维护性。</p><h5 id="csdn告诉我的！！！"><a href="#csdn告诉我的！！！" class="headerlink" title="csdn告诉我的！！！"></a>csdn告诉我的！！！</h5><p>  MyBatis 查询 MySQL 数据库，返回结果可以是具体的类、Map、List&lt;Map&gt; 等等。将查询结果返回 Map 类型的优点是，不需要为本次查询额外创建类。如果只查询某几个特定的列，且不想额外创建类的话，就可以将结果返回 Map 或 List&lt;Map&gt;<br>  如果能明确查询结果只有一条记录时，返回 Map；如果查询结果可能有多条记录，返回 List&lt;Map&gt;<br>  实现方式较为简单，只要在 DAO 层 XML 文件中，设定 resultType 而不设定 resultMap 就可以了</p><hr><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>乐观锁的实现通常包括以下步骤：</p><ol><li>读取记录时，获取当前的版本号（version）。</li><li>在更新记录时，将这个版本号一同传递。</li><li>执行更新操作时，设置 <code>version = newVersion</code> 的条件为 <code>version = oldVersion</code>。</li><li>如果版本号不匹配，则更新失败</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 根据Hid查询头条详情</span><br><span class="hljs-comment"> * 1. 修改浏览量+1</span><br><span class="hljs-comment"> * 2. 多表查询</span><br><span class="hljs-comment"> * 注：因为乐观锁版本号问题，我们应该先查询，再修改</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> hid 头条id</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 多表属性Vo类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">showHeadlineDetail</span><span class="hljs-params">(Integer hid)</span> &#123;<br>    <span class="hljs-comment">// 查询到头条详情</span><br>    <span class="hljs-type">Map</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> headlineMapper.queryDetailMap(hid);<br>    <span class="hljs-type">Map</span> <span class="hljs-variable">headlineMap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>    headlineMap.put(<span class="hljs-string">&quot;headline&quot;</span>, data);<br><br>    <span class="hljs-comment">// 修改浏览量+1</span><br>    <span class="hljs-type">Headline</span> <span class="hljs-variable">headline</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Headline</span>();<br>    headline.setHid((Integer) data.get(<span class="hljs-string">&quot;hid&quot;</span>));<br>    <span class="hljs-comment">// 将拿到的版本号设置为要update的版本号，如果不一致则更新失败</span><br>    headline.setVersion((Integer) data.get(<span class="hljs-string">&quot;version&quot;</span>)); <br>    headline.setPageViews((Integer) data.get(<span class="hljs-string">&quot;pageViews&quot;</span>) + <span class="hljs-number">1</span>);<br>    headlineMapper.updateById(headline); <span class="hljs-comment">// 修改执行语句</span><br><br>    <span class="hljs-keyword">return</span> Result.ok(headlineMap);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="IService"><a href="#IService" class="headerlink" title="IService"></a>IService</h3><p>我们在之前的学习中，一直都是认为controller层不做业务处理，而将业务处理全部交给service层</p><p>这与IService的理念背道而驰，我们现在可以让controller直接调用service中IService提供的一些简单的增删改方法</p><p>直接在controller层将业务处理完毕，无需一直向下调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;removeByHid&quot;)</span> <span class="hljs-comment">// 根据头条id删除该头条</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">removeByHid</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> Integer hid)</span> &#123;<br>    headlineService.removeById(hid);<br>    <span class="hljs-keyword">return</span> Result.ok(<span class="hljs-literal">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>SSM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MyBatisPlus-MyBatisX</title>
    <link href="/2024/07/05/MyBatisPlus-MyBatisX/"/>
    <url>/2024/07/05/MyBatisPlus-MyBatisX/</url>
    
    <content type="html"><![CDATA[<h1 id="MyBatisPlus-MyBatisX"><a href="#MyBatisPlus-MyBatisX" class="headerlink" title="MyBatisPlus-MyBatisX"></a>MyBatisPlus-MyBatisX</h1><p><a href="https://baomidou.com/guides/mybatis-x/">Mybatis X 插件 | MyBatis-Plus (baomidou.com)</a></p><p>使用MyBatisX插件可以直接根据数据库生成pojo实体类，和符合MyBatisPlus规范的框架结构</p><p><img src="/upload/MyBatisPlus-MyBatisX.png" alt="MyBatisPlus-MyBatisX.png"></p><p><img src="/upload/MyBatisPlus-MyBatisX2.png" alt="MyBatisPlus-MyBatisX2.png"></p><hr><p>同时，我们可以让MyBatisX插件帮助我们生成单表的crud</p><p>我们只需要在mapper接口中，使用MyBatisX提供的命名方法，就可以直接利用插件生成出对应接口方法和mapper.xml的具体Sql实现，具体的操作流程请查看官方文档（国人做的中文文档一看就懂）😊</p><p>但是，MyBatisX生成的也仅是自定义的单表的crud业务，只是直接显示Sql语句，把ORM思想变成半自动ORM，有Sql语句的情况下，我们可以做更自由的自定义操作</p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>SSM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MyBatisPlus-高级扩展</title>
    <link href="/2024/07/04/MyBatisPlus-%E9%AB%98%E7%BA%A7%E6%89%A9%E5%B1%95/"/>
    <url>/2024/07/04/MyBatisPlus-%E9%AB%98%E7%BA%A7%E6%89%A9%E5%B1%95/</url>
    
    <content type="html"><![CDATA[<h1 id="MyBatisPlus-逻辑删除"><a href="#MyBatisPlus-逻辑删除" class="headerlink" title="MyBatisPlus-逻辑删除"></a>MyBatisPlus-逻辑删除</h1><p>在JavaWeb阶段的微头条项目中，我们配置了is_delete字段来标记是否为逻辑删除，从而替代物理删除</p><p>而MyBatisPlus提供了一个注解，这个注解标记的实体类属性，就是这个逻辑删除的字段</p><p>当用户使用delete接口删除字段时，就默认使用逻辑删除了</p><p>当用户使用select接口查询数据时，会将此字段等于0作为被查询条件，这样就忽略掉此字段查询</p><p><em>在微头条项目中，我们使用update的方式替代delete，而MyBatisPlus只是在底层调用update，但用户操作还是delete，所以用户侧友好</em></p><hr><h3 id="为表添加一个逻辑删除字段"><a href="#为表添加一个逻辑删除字段" class="headerlink" title="为表添加一个逻辑删除字段"></a>为表添加一个逻辑删除字段</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER TABLE</span> <span class="hljs-keyword">USER</span> <span class="hljs-keyword">ADD</span> deleted <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span> ;  # <span class="hljs-type">int</span> 类型 <span class="hljs-number">1</span> 逻辑删除 <span class="hljs-number">0</span> 未逻辑删除<br></code></pre></td></tr></table></figure><hr><h3 id="为实体类配置逻辑删除属性"><a href="#为实体类配置逻辑删除属性" class="headerlink" title="为实体类配置逻辑删除属性"></a>为实体类配置逻辑删除属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> String email;<br>    <span class="hljs-meta">@TableLogic</span><br>    <span class="hljs-keyword">private</span> Integer deleted; <span class="hljs-comment">// 逻辑删除属性</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="全局配置逻辑删除"><a href="#全局配置逻辑删除" class="headerlink" title="全局配置逻辑删除"></a>全局配置逻辑删除</h3><p>使用mybatis-plus-global-config-db-config-logic-delete-field配置全局逻辑删除属性</p><p><em>一般logic-delete-value和logic-not-delete-value项都会使用默认值，无需更改</em></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">mybatis-plus:</span><br><span class="hljs-attr">configuration:</span><br>  <span class="hljs-attr">log-impl:</span> <span class="hljs-string">org.apache.ibatis.logging.stdout.StdOutImpl</span> <span class="hljs-comment"># 以控制台输出Sql语句</span><br><span class="hljs-attr">type-aliases-package:</span> <span class="hljs-string">com.xiaobai.pojo</span> <span class="hljs-comment"># 给实体类起别名</span><br><span class="hljs-attr">global-config:</span><br>  <span class="hljs-attr">db-config:</span><br>    <span class="hljs-attr">logic-delete-field:</span> <span class="hljs-string">deleted</span> <span class="hljs-comment"># 为所有表配置逻辑删除属性</span><br>    <span class="hljs-attr">logic-delete-value:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 设置被删除时的属性默认值为1 ，默认值也为1 </span><br>    <span class="hljs-attr">logic-not-delete-value:</span> <span class="hljs-number">0</span> <span class="hljs-comment"># 设置设置未被删除时的属性默认值为0 ，默认值也为0</span><br></code></pre></td></tr></table></figure><hr><h1 id="MyBatisPlus-乐观锁"><a href="#MyBatisPlus-乐观锁" class="headerlink" title="MyBatisPlus-乐观锁"></a>MyBatisPlus-乐观锁</h1><p>悲观锁可以通过数据库的读写锁来解决，这样是彻底根除并发问题，但并发高后，会存在效率低的问题</p><p>乐观锁就是通过增加版本号，每次确定写入数据之前确定数据版本，如果手里拿的是最新数据则更新，如果不是则回滚</p><p>MyBatisPlus会帮我们在每次修改数据的时候，Version会增加1，也会在修改之前核对Version</p><p>我们只需要配置好启动插件，就可以使用乐观锁来解决并发问题</p><hr><h3 id="添加插件"><a href="#添加插件" class="headerlink" title="添加插件"></a>添加插件</h3><p>MyBatiesPlus插件库中添加OptimisticLockerInnerInterceptor插件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> MybatisPlusInterceptor <span class="hljs-title function_">mybatisPlusInterceptor</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">MybatisPlusInterceptor</span> <span class="hljs-variable">interceptor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MybatisPlusInterceptor</span>();<br>    interceptor.addInnerInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PaginationInnerInterceptor</span>(DbType.MYSQL)); <span class="hljs-comment">// 添加分页插件，配置数据库类型为MySQL</span><br>    interceptor.addInnerInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OptimisticLockerInnerInterceptor</span>()); <span class="hljs-comment">// 添加乐观锁插件</span><br>    <span class="hljs-keyword">return</span> interceptor;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="为表添加一个Version字段"><a href="#为表添加一个Version字段" class="headerlink" title="为表添加一个Version字段"></a>为表添加一个Version字段</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER TABLE</span> <span class="hljs-keyword">USER</span> <span class="hljs-keyword">ADD</span> VERSION <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">1</span> ;  # <span class="hljs-type">int</span> 类型 乐观锁字段<br></code></pre></td></tr></table></figure><hr><h3 id="为实体类配置Version属性"><a href="#为实体类配置Version属性" class="headerlink" title="为实体类配置Version属性"></a>为实体类配置Version属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> String email;<br>    <span class="hljs-keyword">private</span> Integer deleted;<br>    <span class="hljs-meta">@com</span>.baomidou.mybatisplus.annotation.Version<br>    <span class="hljs-keyword">private</span> Integer Version;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="MyBatisPlus-阻断攻击Sql解析器"><a href="#MyBatisPlus-阻断攻击Sql解析器" class="headerlink" title="MyBatisPlus-阻断攻击Sql解析器"></a>MyBatisPlus-阻断攻击Sql解析器</h1><p>防止误操作或注入操作删除全表或更新，我们使用BlockAttackInnerInterceptor插件即可</p><h3 id="添加插件-1"><a href="#添加插件-1" class="headerlink" title="添加插件"></a>添加插件</h3><p>MyBatiesPlus插件库中添加BlockAttackInnerInterceptor插件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> MybatisPlusInterceptor <span class="hljs-title function_">mybatisPlusInterceptor</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">MybatisPlusInterceptor</span> <span class="hljs-variable">interceptor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MybatisPlusInterceptor</span>();<br>    interceptor.addInnerInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PaginationInnerInterceptor</span>(DbType.MYSQL)); <span class="hljs-comment">// 添加分页插件，配置数据库类型为MySQL</span><br>    interceptor.addInnerInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OptimisticLockerInnerInterceptor</span>()); <span class="hljs-comment">// 添加乐观锁插件</span><br>    interceptor.addInnerInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BlockAttackInnerInterceptor</span>()); <span class="hljs-comment">// 防止全表更新或删除插件</span><br>    <span class="hljs-keyword">return</span> interceptor;<br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>SSM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MyBatisPlus-核心注解</title>
    <link href="/2024/07/04/MyBatisPlus-%E6%A0%B8%E5%BF%83%E6%B3%A8%E8%A7%A3/"/>
    <url>/2024/07/04/MyBatisPlus-%E6%A0%B8%E5%BF%83%E6%B3%A8%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="MyBatisPlus-核心注解"><a href="#MyBatisPlus-核心注解" class="headerlink" title="MyBatisPlus-核心注解"></a>MyBatisPlus-核心注解</h1><h3 id="TableName"><a href="#TableName" class="headerlink" title="@TableName"></a>@TableName</h3><p>如果不使用@TableName注解，实体类的名字就是表名（忽略大小写）</p><p>当表名和实体类名不同时，使用@TableName注解，手动指定实体类对应的表名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@TableName(&quot;t_user&quot;)</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> String email;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="mybatis-plus-global-config-db-config-table-prefix"><a href="#mybatis-plus-global-config-db-config-table-prefix" class="headerlink" title="mybatis-plus-global-config-db-config-table-prefix"></a>mybatis-plus-global-config-db-config-table-prefix</h5><p>通过SpringBoot配置文件为所有表添加前缀，这样就不用给每一个实体类配置@TableName注解了</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">mybatis-plus:</span><br>  <span class="hljs-attr">configuration:</span><br>    <span class="hljs-attr">log-impl:</span> <span class="hljs-string">org.apache.ibatis.logging.stdout.StdOutImpl</span> <span class="hljs-comment"># 以控制台输出Sql语句</span><br>  <span class="hljs-attr">type-aliases-package:</span> <span class="hljs-string">com.xiaobai.pojo</span> <span class="hljs-comment"># 给实体类起别名</span><br>  <span class="hljs-attr">global-config:</span><br>    <span class="hljs-attr">db-config:</span><br>      <span class="hljs-attr">table-prefix:</span> <span class="hljs-string">t_</span> <span class="hljs-comment"># 为所有表名前添加前缀</span><br></code></pre></td></tr></table></figure><hr><h3 id="TableId"><a href="#TableId" class="headerlink" title="@TableId"></a>@TableId</h3><p>当主键的列名和属性名不一致时，我们需要@TableId注解来配置映射</p><p>当需要主键策略为MySQL接管时，我们也需要@TableId注解来配置映射（默认是MyBatisPlus接管）</p><p><em>需要注意的是，如果使用雪花算法来生成主键时，主键类型必须为String或者Long类型！！！</em></p><ul><li>value属性：配置主键列名</li><li>type属性：配置主键策略<ul><li>AUTO值：由数据库接管配置主键自增长</li><li>ASSIGN_ID值：默认值，由MyBatisPlus接管主键的生成（雪花算法）</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-meta">@TableId(type = IdType.AUTO)</span><br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> String email;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="mybatis-plus-global-config-db-config-id-type"><a href="#mybatis-plus-global-config-db-config-id-type" class="headerlink" title="mybatis-plus-global-config-db-config-id-type"></a>mybatis-plus-global-config-db-config-id-type</h5><p>通过SpringBoot配置文件为所有主键配置主键策略为AUTO，由数据库接管生成主键</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">mybatis-plus:</span><br>  <span class="hljs-attr">configuration:</span><br>    <span class="hljs-attr">log-impl:</span> <span class="hljs-string">org.apache.ibatis.logging.stdout.StdOutImpl</span> <span class="hljs-comment"># 以控制台输出Sql语句</span><br>  <span class="hljs-attr">type-aliases-package:</span> <span class="hljs-string">com.xiaobai.pojo</span> <span class="hljs-comment"># 给实体类起别名</span><br>  <span class="hljs-attr">global-config:</span><br>    <span class="hljs-attr">db-config:</span><br>      <span class="hljs-attr">table-prefix:</span> <span class="hljs-string">t_</span> <span class="hljs-comment"># 为所有表名前添加前缀</span><br>      <span class="hljs-attr">id-type:</span> <span class="hljs-string">auto</span> <span class="hljs-comment"># 全局设置主键策略为AUTO</span><br></code></pre></td></tr></table></figure><hr><h5 id="自增长主键"><a href="#自增长主键" class="headerlink" title="自增长主键"></a>自增长主键</h5><p>当数据表数据特别庞大的时候，需要水平分割数张表，这是如果使用主键自增模式可能会出现主键冲突</p><p>所以我们就需要UUID或者雪花算法来生成唯一主键，一般应用于大型分布式项目中</p><hr><h3 id="TableFieId"><a href="#TableFieId" class="headerlink" title="@TableFieId"></a>@TableFieId</h3><p>当非主键的列名和属性名不一致时，我们需要@TableFieId注解来配置映射</p><p>想要让MyBatisPlus忽略这个这个属性映射时，我们也要用@TableFieId注解来配置映射</p><ul><li>value属性：配置列名</li><li>exist属性：默认为true，则确认该属性是数据库存在的列，配置为false则忽略此属性</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-meta">@TableId(type = IdType.AUTO)</span><br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> String email;<br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>SSM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MybatisPlus-条件构造器</title>
    <link href="/2024/07/04/MybatisPlus-%E6%9D%A1%E4%BB%B6%E6%9E%84%E9%80%A0%E5%99%A8/"/>
    <url>/2024/07/04/MybatisPlus-%E6%9D%A1%E4%BB%B6%E6%9E%84%E9%80%A0%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="MybatisPlus-条件构造器"><a href="#MybatisPlus-条件构造器" class="headerlink" title="MybatisPlus-条件构造器"></a>MybatisPlus-条件构造器</h1><p><strong>AbstractWrapper</strong>：这是一个抽象基类，提供了所有 Wrapper 类共有的方法和属性。它定义了条件构造的基本逻辑，包括字段（column）、值（value）、操作符（condition）等</p><p><em>wrapper中文释义：包装纸</em></p><p>MyBatis-Plus 的 Wrapper 类是构建复杂查询和更新条件的关键工具</p><p>它允许开发者以链式调用的方式构造 SQL 的 WHERE 子句，提供了极大的灵活性和便利性</p><ul><li>Wrapper接口</li><li>AbStractWrapper抽象类（继承自Wrapper接口）<ul><li>UpdateWrapper实现类</li><li>QueryWrapper实现类</li><li>AbstractLambdaWrapper抽象类<ul><li>LambdaUpdateWrapper实现类</li><li>LambdaQueryWrapper实现类</li></ul></li></ul></li></ul><p><a href="https://baomidou.com/guides/wrapper/">条件构造器 | MyBatis-Plus (baomidou.com)</a></p><hr><h3 id="QueryWrapper"><a href="#QueryWrapper" class="headerlink" title="QueryWrapper"></a>QueryWrapper</h3><p><strong>QueryWrapper</strong>：专门用于构造查询条件，支持基本的等于、不等于、大于、小于等各种常见操作。它允许你以链式调用的方式添加多个查询条件，并且可以组合使用 <code>and</code> 和 <code>or</code> 逻辑。</p><p>查询用户名包含a，年龄在20到30之间，并且邮箱不为空的用户信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">QueryWrapper&lt;User&gt; userQueryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;User&gt;(); <span class="hljs-comment">// 实例化QueryWrapper对象</span><br>userQueryWrapper.between(<span class="hljs-string">&quot;age&quot;</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>);<br>userQueryWrapper.like(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>);<br>userQueryWrapper.isNotNull(<span class="hljs-string">&quot;email&quot;</span>);<br>userMapper.selectList(userQueryWrapper);<br></code></pre></td></tr></table></figure><blockquote><p>实际上的SQL语句如下：</p><p>&#x2F;&#x2F; &#x3D;&#x3D;&gt;  Preparing: SELECT id,name,age,email FROM user WHERE (age BETWEEN ? AND ? AND name LIKE ? AND email IS NOT NULL)<br>&#x2F;&#x2F; &#x3D;&#x3D;&gt; Parameters: 20(Integer), 30(Integer), %a%(String)</p></blockquote><hr><h5 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h5><p>我们通过链式调用的方式连续调用方法，为wrapper对象增加条件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">QueryWrapper&lt;User&gt; userQueryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;User&gt;();<br>userQueryWrapper.between(<span class="hljs-string">&quot;age&quot;</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>).like(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>).isNotNull(<span class="hljs-string">&quot;email&quot;</span>);<br>userMapper.selectList(userQueryWrapper);<br></code></pre></td></tr></table></figure><hr><h5 id="or拼接"><a href="#or拼接" class="headerlink" title="or拼接"></a>or拼接</h5><p>默认的条件之间的拼接是and关键字，如果想用or关键字进行条件拼接，我们需要使用or方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">userQueryWrapper.between(<span class="hljs-string">&quot;age&quot;</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>).like(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>).or().isNotNull(<span class="hljs-string">&quot;email&quot;</span>);<br></code></pre></td></tr></table></figure><hr><h5 id="指定列查询"><a href="#指定列查询" class="headerlink" title="指定列查询"></a>指定列查询</h5><p>在使用QueryWrapper设置查询条件时，默认是查询全部列</p><p>如果想查询指定列，需要使用select方法，拼接select关键字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">userQueryWrapper.select(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;age&quot;</span>);  <span class="hljs-comment">// 指定查询name列和age列</span><br></code></pre></td></tr></table></figure><hr><h5 id="condition"><a href="#condition" class="headerlink" title="condition"></a>condition</h5><p>我们在MyBatis中学习了动态语句标签，以实现前端参数不确定传入的动态语句</p><p>在MyBatisPlus中，每一个拼接的条件方法都提供了一个boolean condition的参数，用以控制动态sql语句查询</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">userQueryWrapper.eq(StringUtils.isNotBlank(name),<span class="hljs-string">&quot;name&quot;</span>,name); <br><span class="hljs-comment">// 当name不为空时，eq方法条件生效</span><br></code></pre></td></tr></table></figure><hr><h3 id="UpdateWrapper"><a href="#UpdateWrapper" class="headerlink" title="UpdateWrapper"></a>UpdateWrapper</h3><p><strong>UpdateWrapper</strong>：用于构造更新条件，可以在更新数据时指定条件。与 QueryWrapper 类似，它也支持链式调用和逻辑组合。使用 UpdateWrapper 可以在不创建实体对象的情况下，直接设置更新字段和条件。</p><p>QueryWrapper也能应用于修改，但需要用户自己准备修改的实体类数据，<strong>而且不能将数据修改为空值</strong></p><p><em>当实体类属性为null则被修改语句忽略</em></p><p>所以，使用UpdateWrapper替代QueryWrapper进行数据修改</p><p>UpdateWrapper不只能设置条件，还能利用set()方法设置修改的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testUpdate</span><span class="hljs-params">()</span> &#123;<br>    UpdateWrapper&lt;User&gt; updateWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">UpdateWrapper</span>&lt;User&gt;();<br>    updateWrapper.between(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>)<br>            .like(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>)<br>            .isNotNull(<span class="hljs-string">&quot;email&quot;</span>)<br>            .set(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-string">&quot;23&quot;</span>) <span class="hljs-comment">// 将符合条件的年龄列设置为23</span><br>            .set(<span class="hljs-string">&quot;email&quot;</span>, <span class="hljs-literal">null</span>); <span class="hljs-comment">// 将符合条件的邮箱列设置为null</span><br><br>    userMapper.update(updateWrapper);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="Lambda系列"><a href="#Lambda系列" class="headerlink" title="Lambda系列"></a>Lambda系列</h1><ul><li><strong>LambdaQueryWrapper</strong>：这是一个基于 Lambda 表达式的查询条件构造器，它通过 Lambda 表达式来引用实体类的属性，从而避免了硬编码字段名。这种方式提高了代码的可读性和可维护性，尤其是在字段名可能发生变化的情况下。</li><li><strong>LambdaUpdateWrapper</strong>：类似于 LambdaQueryWrapper，LambdaUpdateWrapper 是基于 Lambda 表达式的更新条件构造器。它允许你使用 Lambda 表达式来指定更新字段和条件，同样避免了硬编码字段名的问题。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">LambdaUpdateWrapper&lt;User&gt; userLambdaUpdateWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaUpdateWrapper</span>&lt;&gt;();<br>userLambdaUpdateWrapper.like(User::getName,<span class="hljs-string">&quot;a&quot;</span>); <span class="hljs-comment">// 添加条件，模糊查询a</span><br>userMapper.update(updateWrapper);<br></code></pre></td></tr></table></figure><p>like的第一个参数使用方法引用的方式传递参数，而通过User::getName是如何获得其类的属性名呢？</p><p>其中底层逻辑十分复杂：</p><p><a href="https://blog.csdn.net/u013202238/article/details/105779686">详解Java8中如何通过方法引用获取属性名_java通过对象get方法获取属性的名称对应的字符串-CSDN博客</a></p><p>其理解就是，LambdaUpdateWrapper的所需参数（代替列名）使用SerializableFunction接收</p><p>就可以通过<code>类名::get属性名</code>的方式直接获取到属性名</p><p>LambdaUpdateWrapper使用此属性名，通过反射的机制获得表中列名</p><p>这种方式就不用以字符串的形式手写列名，避免了列名写错的问题</p><p><em>这里的底层逻辑实在是太复杂，方法引用和Lambda表达式从来都是难点，所以我们直接学习他的用法即可</em></p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Wrapper的使用也只是基于BaseMapper和IService两种由MyBatisPlus生成的单表的crud，实现ORM思想</p><p>使用Wrapper的方式来替代条件crud的依赖Sql语句的问题</p><p>但归根结底，Wrapper的使用场景，或者说是MyBatisPlus的ORM也仅限于支持到单表</p><p>如果存在多表的，或者嵌套的，亦或者是特别复杂的Sql，我们仍然使用mapper.xml的映射文件搭配mapper接口来完成这种操作</p><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>SSM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MyBatisPlus-BaseMapper&amp;IService</title>
    <link href="/2024/07/02/MyBatisPlus-BaseMapper&amp;IService/"/>
    <url>/2024/07/02/MyBatisPlus-BaseMapper&amp;IService/</url>
    
    <content type="html"><![CDATA[<h1 id="MyBatisPlus-BaseMapper"><a href="#MyBatisPlus-BaseMapper" class="headerlink" title="MyBatisPlus-BaseMapper"></a>MyBatisPlus-BaseMapper</h1><p>MyBatisPlus提供了BaseMapper这个父类，让mapper接口实现此父类可直接生成单表的增删改查</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseMapper</span>&lt;User&gt; &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>在调用时直接调用提供的方法即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">userMapper.selectList(<span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure><p><em>注：这里继承的BaseMapper类的泛型使用表名，也就是实体类名，自动生成单表crud的必要条件就是这两个名字是一样的</em></p><hr><p>BaseMapper提供的方法如下：</p><h3 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h3><table><thead><tr><th>方法名</th><th>类型</th><th>参数名</th><th>描述</th></tr></thead><tbody><tr><td>insert</td><td>T</td><td>entity</td><td>实体对象</td></tr></tbody></table><hr><h3 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h3><table><thead><tr><th>方法名</th><th>类型</th><th>参数名</th><th>描述</th></tr></thead><tbody><tr><td>delete</td><td>Wrapper<T></td><td>wrapper</td><td>实体对象封装操作类（可以为 null）</td></tr><tr><td>deleteBatchIds</td><td>Collection&lt;? extends Serializable&gt;</td><td>idList</td><td>主键 ID 列表(不能为 null 以及 empty)</td></tr><tr><td>deleteById</td><td>Serializable</td><td>id</td><td>主键 ID</td></tr><tr><td>deleteByMap</td><td>Map&lt;String, Object&gt;</td><td>columnMap</td><td>表字段 map 对象</td></tr></tbody></table><hr><h3 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h3><p>当执行updateById进行更新的时候，根据实体类的字段进行判断是否更新列</p><p>如果采用基本类型包装类，则默认列为null，如果采用基本类型，比如int，默认值为0，就会将原有的数值改成0</p><p><strong>结论：实体类需要使用包装类型</strong></p><table><thead><tr><th>方法名</th><th>类型</th><th>参数名</th><th>描述</th></tr></thead><tbody><tr><td>updateById</td><td>T</td><td>entity</td><td>实体对象 (set 条件值,可为 null)</td></tr><tr><td>update</td><td>Wrapper<T></td><td>updateWrapper</td><td>实体对象封装操作类（可以为 null,里面的 entity 用于生成 where 语句）</td></tr></tbody></table><hr><h3 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h3><table><thead><tr><th>方法名</th><th>类型</th><th>参数名</th><th>描述</th></tr></thead><tbody><tr><td>selectById</td><td>Serializable</td><td>id</td><td>主键 ID</td></tr><tr><td>selectOne、selectList、selectMaps、selectObjs、selectCount</td><td>Wrapper<T></td><td>queryWrapper</td><td>实体对象封装操作类（可以为 null）</td></tr><tr><td>selectBatchIds</td><td>Collection&lt;? extends Serializable&gt;</td><td>idList</td><td>主键 ID 列表(不能为 null 以及 empty)</td></tr><tr><td>selectByMap</td><td>Map&lt;String, Object&gt;</td><td>columnMap</td><td>表字段 map 对象</td></tr><tr><td>selectPage、selectMapsPage</td><td>IPage<T></td><td>page</td><td>分页查询条件（可以为 RowBounds.DEFAULT）</td></tr></tbody></table><hr><h1 id="MyBatisPlus-IService"><a href="#MyBatisPlus-IService" class="headerlink" title="MyBatisPlus-IService"></a>MyBatisPlus-IService</h1><p>通过 Service CRUD 封装IService 接口，进一步封装 CRUD </p><p>采用 get 查询单行、remove 删除、list 查询集合、page 分页的前缀命名方式区分 Mapper 层避免混淆</p><p><strong>对比Mapper接口CRUD区别：</strong></p><ul><li>service添加了批量方法</li><li>service层的方法自动添加事务</li></ul><p><em>这种解决问题的思维方式就是，简单问题Service解决，复杂业务逻辑再交给Mapper层解决</em></p><hr><h3 id="Service接口"><a href="#Service接口" class="headerlink" title="Service接口"></a>Service接口</h3><p>Service接口需要继承Iservice&lt;实体类&gt;的接口，其原理跟mapper接口是一样的</p><p>MyBatis帮助我们在Service层就实现了一部分单表的crud功能</p><p>但这个接口没有实现全部功能，其中有一些抽象方法等着被实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">IService</span>&lt;User&gt; &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="Service实现类"><a href="#Service实现类" class="headerlink" title="Service实现类"></a>Service实现类</h3><p>实现类正常继承该接口，再通过实现ServiceImpl实现类的方式补全剩下的抽象方法实现</p><p>这个ServiceImpl有两个泛型</p><ul><li>mapper接口：用户自身编写继承自BaseMapper的接口，因为crud底层还是通过mapper实现</li><li>实体类：用以生成crud功能的实体类名，也就是表名</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ServiceImpl</span>&lt;UserMapper, User&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">com</span>.xiaobai.service.UserService &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="Crud方法"><a href="#Crud方法" class="headerlink" title="Crud方法"></a>Crud方法</h3><p><a href="https://baomidou.com/guides/data-interface/">持久层接口 | MyBatis-Plus (baomidou.com)</a></p><hr><h1 id="分页查询的实现"><a href="#分页查询的实现" class="headerlink" title="分页查询的实现"></a>分页查询的实现</h1><p>MyBatisPlus的分页实现不再是基于PageHelper插件，而是PaginationInnerInterceptor</p><p>MyBaitsPlus提供了一个插件集合，将所需插件添加到插件集合中，再将插件集合注入到IoC容器中即可</p><p>使用启动类@Bean注入（启动类也是配置类）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@MapperScan(&quot;com.xiaobai.mapper&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(MainApplication.class, args);<br>    &#125;<br><br>    <span class="hljs-comment">// 配置MyBatisPlus分页插件</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> MybatisPlusInterceptor <span class="hljs-title function_">mybatisPlusInterceptor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">MybatisPlusInterceptor</span> <span class="hljs-variable">interceptor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MybatisPlusInterceptor</span>();<br>        interceptor.addInnerInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PaginationInnerInterceptor</span>(DbType.MYSQL)); <span class="hljs-comment">// 配置数据库类型为MySQL</span><br>        <span class="hljs-keyword">return</span> interceptor;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="IPage接口和Page实现类"><a href="#IPage接口和Page实现类" class="headerlink" title="IPage接口和Page实现类"></a>IPage接口和Page实现类</h3><p>使用Page对象+mapper层（service层）封装好的分页查询方法</p><p>替换掉MyBatis原来的startPage+PageInfo在Sql后拼接Limit的方法，使用更简单</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">// 实例化IPage接口的实现类Page对象，设置分页参数</span><br>    Page&lt;User&gt; page = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Page</span>&lt;&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>);<br>    <span class="hljs-comment">// 调用Mapper层的分页查询方法，将page对象作为参数传递</span><br>    Page&lt;User&gt; userPage = userMapper.selectPage(page, <span class="hljs-literal">null</span>);<br><br>    <span class="hljs-comment">// Page对象也会被封装结果，其中也提供了分页五大件的获取方法</span><br>    page.getCurrent(); <span class="hljs-comment">// currentPage</span><br>    page.getSize(); <span class="hljs-comment">// PageSize</span><br>    page.getTotal(); <span class="hljs-comment">// total</span><br>    page.getRecords(); <span class="hljs-comment">// pageInfo.getList()</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="自定义Mapper方法中使用分页"><a href="#自定义Mapper方法中使用分页" class="headerlink" title="自定义Mapper方法中使用分页"></a>自定义Mapper方法中使用分页</h3><p>在mappe接口中自定义方法，返回值为IPage接口类型，传入一个IPage类型的参数page</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">IPage&lt;UserVo&gt; <span class="hljs-title function_">selectPageVo</span><span class="hljs-params">(IPage&lt;?&gt; page, Integer state)</span>;<br></code></pre></td></tr></table></figure><h5 id="mapper接口"><a href="#mapper接口" class="headerlink" title="mapper接口"></a>mapper接口</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseMapper</span>&lt;User&gt; &#123;<br>    IPage&lt;User&gt; <span class="hljs-title function_">selectUserPage</span><span class="hljs-params">(Page&lt;User&gt; page, <span class="hljs-meta">@Param(&quot;age&quot;)</span> Integer age)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="mapper-xml映射文件"><a href="#mapper-xml映射文件" class="headerlink" title="mapper.xml映射文件"></a>mapper.xml映射文件</h5><p>在MyBatis中，mapper.xml文件默认存放路径就是classpath:&#x2F;mapper</p><p>所以在配置文件中无需配置mapper-locations字段</p><blockquote><p>private String[] mapperLocations &#x3D; new String[]{“classpath*:&#x2F;mapper&#x2F;**&#x2F;*.xml”};</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.xiaobai.mapper.UserMapper&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--此处resultType仍然使用泛型的类型--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUserPage&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span><br>        select *<br>        from user<br>        where age &gt; #&#123;age&#125;<br>        <span class="hljs-comment">&lt;!--这里仍然不可以使用limit结尾，因为使用分页插件--&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 使用匿名内部类实例化Page对象传入，查找age&gt;18的数据</span><br>    IPage&lt;User&gt; userIPage = userMapper.selectUserPage(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Page</span>&lt;User&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>), <span class="hljs-number">18</span>);<br><br>    System.out.println(userIPage.getCurrent());<br>    System.out.println(userIPage.getSize());<br>    System.out.println(userIPage.getTotal());<br>    userIPage.getRecords().forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>SSM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MyBatisPlus</title>
    <link href="/2024/07/02/MyBatisPlus/"/>
    <url>/2024/07/02/MyBatisPlus/</url>
    
    <content type="html"><![CDATA[<h1 id="MyBatisPlus"><a href="#MyBatisPlus" class="headerlink" title="MyBatisPlus"></a>MyBatisPlus</h1><p>MyBatis-Plus  (opens new window)（简称 MP）是一个 MyBatis  (opens new window) 的增强工具</p><p>在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生</p><p><a href="https://baomidou.com/">MyBatis-Plus 🚀 为简化开发而生 (baomidou.com)</a></p><ul><li><strong>无侵入</strong></li><li><strong>损耗小</strong></li><li><strong>强大的 CRUD 操作</strong></li><li><strong>支持 Lambda 形式调用</strong></li><li><strong>支持主键自动生成</strong></li><li><strong>支持 ActiveRecord 模式</strong></li><li><strong>支持自定义全局通用操作</strong></li><li><strong>内置代码生成器</strong></li><li><strong>内置分页插件</strong></li><li><strong>分页插件支持多种数据库</strong></li><li><strong>内置性能分析插件</strong></li><li><strong>内置全局拦截插件</strong></li></ul><p>支持的数据库：</p><ul><li>MySQL，Oracle，DB2，H2，HSQL，SQLite，PostgreSQL，SQLServer，Phoenix，Gauss ，ClickHouse，Sybase，OceanBase，Firebird，Cubrid，Goldilocks，csiidb，informix，TDengine，redshift</li><li>达梦数据库，虚谷数据库，人大金仓数据库，南大通用(华库)数据库，南大通用数据库，神通数据库，瀚高数据库，优炫数据库</li></ul><hr><h3 id="依赖导入"><a href="#依赖导入" class="headerlink" title="依赖导入"></a>依赖导入</h3><p>同样的，Spring没有提供MyBatisPlus的启动器，由MyBatisPlus提供启动器（整合依赖包）</p><blockquote><p>mybatis-plus-boot-starter</p><p>mybatis-plus-spring-boot3-starter # springBoot3请使用这个依赖</p></blockquote><hr><h3 id="Application配置文件"><a href="#Application配置文件" class="headerlink" title="Application配置文件"></a>Application配置文件</h3><p>MyBatisPlus的配置文件和MyBatis大同小异（本是同根生）</p><p>但很多我们在MyBatis需要手动开启的配置，MyBatisPlus都已经帮我们<strong>默认开启</strong>了（比如驼峰命名规则）</p><p>我们可以在配置文件中，打印一下他帮我们生成的crud</p><p>配置一下type-aliases-package，让MyBatisPlus帮我们给实体类起一个别名</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">mybatis-plus:</span><br>  <span class="hljs-attr">configuration:</span><br>    <span class="hljs-attr">log-impl:</span> <span class="hljs-string">org.apache.ibatis.logging.stdout.StdOutImpl</span> <span class="hljs-comment"># 以控制台输出Sql语句</span><br>  <span class="hljs-attr">type-aliases-package:</span> <span class="hljs-string">com.xiaobai.pojo</span><br></code></pre></td></tr></table></figure><hr><h3 id="Test测试类"><a href="#Test测试类" class="headerlink" title="Test测试类"></a>Test测试类</h3><p><em>注：我在测试的时候一直提示我mapper接口文件没有被注入到IoC容器中，使用@RunWith(SpringRunner.class)注释测试类后成功运行</em></p><p><em>询问大佬后了解，测试类的包结构应该与启动类相同，否则会在依赖注入问题</em></p><p>导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>创建测试类，使用@RunWith(SpringRunner.class)和@SpringBootTest注解</p><p>将对象注入，直接使用测试方法测试即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RunWith(SpringRunner.class)</span><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringBootMyBatisPlusTest</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserMapper userMapper;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        List&lt;User&gt; users = userMapper.selectList(<span class="hljs-literal">null</span>);<br>        System.out.println(users);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>SSM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot-打包和运行</title>
    <link href="/2024/07/02/SpringBoot-%E6%89%93%E5%8C%85%E5%92%8C%E8%BF%90%E8%A1%8C/"/>
    <url>/2024/07/02/SpringBoot-%E6%89%93%E5%8C%85%E5%92%8C%E8%BF%90%E8%A1%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot-打包和运行"><a href="#SpringBoot-打包和运行" class="headerlink" title="SpringBoot-打包和运行"></a>SpringBoot-打包和运行</h1><h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><p>SpringBoot内置了服务器软件，打包后为jar包而不是war包，打完包之后可直接运行</p><p>在pom.xml中为当前的maven项目添加spring-boot-maven-plugin打包插件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><blockquote><p>maven工具 -&gt; 生命周期 -&gt; clean -&gt; packge</p></blockquote><p><em>在新版本的maven中，需要将lombok依赖的scope属性调整为provided才能正常打包</em></p><hr><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p><code>java -jar</code>命令用于在Java环境中执行可执行的JAR文件。下面是关于<code>java -jar</code>命令的说明：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">命令格式：java -jar  [选项] [参数] <span class="hljs-tag">&lt;<span class="hljs-name">jar文件名</span>&gt;</span><br></code></pre></td></tr></table></figure><ol><li><code>-D&lt;name&gt;=&lt;value&gt;</code>：设置系统属性，可以通过<code>System.getProperty()</code>方法在应用程序中获取该属性值。例如：<code>java -jar -Dserver.port=8080 myapp.jar</code></li><li><code>-X</code>：设置JVM参数，例如内存大小、垃圾回收策略等。常用的选项包括：<ul><li><code>-Xmx&lt;size&gt;</code>：设置JVM的最大堆内存大小，例如 <code>-Xmx512m</code> 表示设置最大堆内存为512MB</li><li><code>-Xms&lt;size&gt;</code>：设置JVM的初始堆内存大小，例如 <code>-Xms256m</code> 表示设置初始堆内存为256MB</li><li><code>-Dspring.profiles.active=&lt;profile&gt;</code>：指定Spring Boot的激活配置文件，可以通过<code>application-&lt;profile&gt;.properties</code>或<code>application-&lt;profile&gt;.yml</code>文件来加载相应的配置。例如：<code>java -jar -Dspring.profiles.active=dev myapp.jar</code></li></ul></li></ol><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>SSM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot-整合SpringTX&amp;SpringAoP</title>
    <link href="/2024/07/02/SpringBoot-%E6%95%B4%E5%90%88SpringTX&amp;SpringAoP/"/>
    <url>/2024/07/02/SpringBoot-%E6%95%B4%E5%90%88SpringTX&amp;SpringAoP/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot-整合SpringTX"><a href="#SpringBoot-整合SpringTX" class="headerlink" title="SpringBoot-整合SpringTX"></a>SpringBoot-整合SpringTX</h1><p>SpringTX的功能由JDBC来实现，所以我们需要导入JDBC依赖</p><blockquote><p>spring-boot-starter-data-jdbc</p></blockquote><p> SpringBoot使用事务特别简单，只需要添加JDBC依赖，然后在需要事务管理的方法上使用@Transactional注解</p><hr><h1 id="SpringBoot-整合SpringAoP"><a href="#SpringBoot-整合SpringAoP" class="headerlink" title="SpringBoot-整合SpringAoP"></a>SpringBoot-整合SpringAoP</h1><p>SpringAoP的功能需要导入AoP的依赖，此依赖由Spring提供</p><blockquote><p>spring-boot-starter-aop</p></blockquote><p>SpringBoot使用AoP也特别简单，只需要添加AoP依赖，直接创建增强类和方法，正常使用即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span> <span class="hljs-comment">// 加入IoC容器</span><br><span class="hljs-meta">@Aspect</span> <span class="hljs-comment">// 开启注解支持</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogAdvice</span> &#123;<br>    <span class="hljs-meta">@Before(&quot;execution(* com..service.*.*(..))&quot;)</span> <span class="hljs-comment">// 配置切点表达式</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">log</span><span class="hljs-params">(JoinPoint joinPoint)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> joinPoint.getTarget().getClass().getName(); <span class="hljs-comment">// 获取类名</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> joinPoint.getSignature().getName(); <span class="hljs-comment">// 获取方法名</span><br>        System.out.println(className + methodName + <span class="hljs-string">&quot;开始执行&quot;</span>); <span class="hljs-comment">// 打印日志信息</span><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>SSM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot-整合MyBatis</title>
    <link href="/2024/07/02/SpringBoot-%E6%95%B4%E5%90%88MyBatis/"/>
    <url>/2024/07/02/SpringBoot-%E6%95%B4%E5%90%88MyBatis/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot-整合MyBatis"><a href="#SpringBoot-整合MyBatis" class="headerlink" title="SpringBoot-整合MyBatis"></a>SpringBoot-整合MyBatis</h1><p>Spring没有提供MyBatis的启动器，由MyBatis提供启动器（整合依赖包）</p><blockquote><p>mybatis-spring-boot-starter</p></blockquote><hr><h3 id="干掉配置类！！！"><a href="#干掉配置类！！！" class="headerlink" title="干掉配置类！！！"></a>干掉配置类！！！</h3><p>SpringBoot的主要目的就是尽量干掉配置类，使用application.yaml配置文件的方式替换配置类</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># mybatis配置（彻底抛弃mybatis-config.xml）</span><br><span class="hljs-attr">mybatis:</span><br>  <span class="hljs-attr">mapper-locations:</span> <span class="hljs-string">classpath:/mapper/*.xml</span> <span class="hljs-comment"># 指定mapper.xml文件的位置</span><br>  <span class="hljs-attr">type-aliases-package:</span> <span class="hljs-string">com.xiaobai.pojo</span> <span class="hljs-comment"># 给实体类起别名</span><br>  <span class="hljs-attr">configuration:</span><br>    <span class="hljs-attr">map-underscore-to-camel-case:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 开启自动驼峰式映射</span><br>    <span class="hljs-attr">auto-mapping-behavior:</span> <span class="hljs-string">full</span> <span class="hljs-comment"># 开启resultMap自动映射</span><br>    <span class="hljs-attr">log-impl:</span> <span class="hljs-string">org.apache.ibatis.logging.slf4j.Slf4jImpl</span> <span class="hljs-comment"># 开启logback日志输出</span><br></code></pre></td></tr></table></figure><p><em>当我们使用SpringBoot配置了mapper-locations属性后，软件包和资源目录的mapper结构也就无须相同</em></p><hr><h5 id="包扫描"><a href="#包扫描" class="headerlink" title="包扫描"></a>包扫描</h5><p>我们之前在配置类中向IoC容器注入mapperScannerConfigurer对象，以完成mapper包的扫描</p><p>而使用SpringBoot，我们只需要在启动类上使用@MapperScan注解，即可完成mapper包的扫描</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@MapperScan(&quot;com.xiaobai.mapper&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(Main.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="配置pageHelper"><a href="#配置pageHelper" class="headerlink" title="配置pageHelper"></a>配置pageHelper</h5><p>Spring没有提供pageHelper的启动器，由pageHelper提供启动器（整合依赖包）</p><blockquote><p>pagehelper-spring-boot-starter</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">pagehelper:</span><br>  <span class="hljs-attr">helper-dialect:</span> <span class="hljs-string">mysql</span><br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>SSM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot-整合Druid</title>
    <link href="/2024/07/01/SpringBoot-%E6%95%B4%E5%90%88Druid/"/>
    <url>/2024/07/01/SpringBoot-%E6%95%B4%E5%90%88Druid/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot-整合Druid"><a href="#SpringBoot-整合Druid" class="headerlink" title="SpringBoot-整合Druid"></a>SpringBoot-整合Druid</h1><p>Spring没用提供Druid的启动器，由Druid提供启动器（整合依赖包）</p><blockquote><p>druid-spring-boot-starter</p></blockquote><hr><h3 id="application-yaml"><a href="#application-yaml" class="headerlink" title="application.yaml"></a>application.yaml</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span><br>    <span class="hljs-comment"># Druid的其他属性配置 springboot3整合情况下,数据库连接信息必须在Druid属性下!</span><br>    <span class="hljs-attr">druid:</span><br>      <span class="hljs-comment"># 初始化时建立物理连接的个数</span><br>      <span class="hljs-attr">initial-size:</span> <span class="hljs-number">5</span><br>      <span class="hljs-comment"># 连接池的最小空闲数量</span><br>      <span class="hljs-attr">min-idle:</span> <span class="hljs-number">5</span><br>      <span class="hljs-comment"># 连接池最大连接数量</span><br>      <span class="hljs-attr">max-active:</span> <span class="hljs-number">20</span><br>      <span class="hljs-comment"># 获取连接时最大等待时间，单位毫秒</span><br>      <span class="hljs-attr">max-wait:</span> <span class="hljs-number">60000</span><br>      <span class="hljs-comment"># 申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。</span><br>      <span class="hljs-attr">test-while-idle:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-comment"># 既作为检测的间隔时间又作为testWhileIdel执行的依据</span><br>      <span class="hljs-attr">time-between-eviction-runs-millis:</span> <span class="hljs-number">60000</span><br>      <span class="hljs-comment"># 销毁线程时检测当前连接的最后活动时间和当前时间差大于该值时，关闭当前连接(配置连接在池中的最小生存时间)</span><br>      <span class="hljs-attr">min-evictable-idle-time-millis:</span> <span class="hljs-number">30000</span><br>      <span class="hljs-comment"># 用来检测数据库连接是否有效的sql 必须是一个查询语句(oracle中为 select 1 from dual)</span><br>      <span class="hljs-attr">validation-query:</span> <span class="hljs-string">select</span> <span class="hljs-number">1</span><br>      <span class="hljs-comment"># 申请连接时会执行validationQuery检测连接是否有效,开启会降低性能,默认为true</span><br>      <span class="hljs-attr">test-on-borrow:</span> <span class="hljs-literal">false</span><br>      <span class="hljs-comment"># 归还连接时会执行validationQuery检测连接是否有效,开启会降低性能,默认为true</span><br>      <span class="hljs-attr">test-on-return:</span> <span class="hljs-literal">false</span><br>      <span class="hljs-comment"># 是否缓存preparedStatement, 也就是PSCache,PSCache对支持游标的数据库性能提升巨大，比如说oracle,在mysql下建议关闭。</span><br>      <span class="hljs-attr">pool-prepared-statements:</span> <span class="hljs-literal">false</span><br>      <span class="hljs-comment"># 要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100</span><br>      <span class="hljs-attr">max-pool-prepared-statement-per-connection-size:</span> <span class="hljs-number">-1</span><br>      <span class="hljs-comment"># 合并多个DruidDataSource的监控数据</span><br>      <span class="hljs-attr">use-global-data-source-stat:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-comment"># JDBC四大件</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/mybatis-example</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">Zhuwenxue2002</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>    <br><span class="hljs-comment"># 开启日志，等级为debug</span><br><br><span class="hljs-attr">logging:</span><br>  <span class="hljs-attr">level:</span><br>    <span class="hljs-attr">root:</span> <span class="hljs-string">debug</span> <br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>SSM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot-整合SpringMVC</title>
    <link href="/2024/07/01/SpringBoot-%E6%95%B4%E5%90%88SpringMVC/"/>
    <url>/2024/07/01/SpringBoot-%E6%95%B4%E5%90%88SpringMVC/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot-整合SpringMVC"><a href="#SpringBoot-整合SpringMVC" class="headerlink" title="SpringBoot-整合SpringMVC"></a>SpringBoot-整合SpringMVC</h1><h3 id="导入spring-boot-starter-web启动器"><a href="#导入spring-boot-starter-web启动器" class="headerlink" title="导入spring-boot-starter-web启动器"></a>导入spring-boot-starter-web启动器</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h3 id="创建启动类"><a href="#创建启动类" class="headerlink" title="创建启动类"></a>创建启动类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(Main.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="SpringMVC相关的web配置"><a href="#SpringMVC相关的web配置" class="headerlink" title="SpringMVC相关的web配置"></a>SpringMVC相关的web配置</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span> <span class="hljs-comment"># 端口号，默认是8080</span><br>  <span class="hljs-attr">servlet:</span><br>    <span class="hljs-attr">context-path:</span> <span class="hljs-string">/</span> <span class="hljs-comment"># 上下文路径（访问路径）</span><br><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">mvc:</span><br>    <span class="hljs-attr">view:</span><br>      <span class="hljs-attr">prefix:</span> <span class="hljs-string">WEB-INF/</span> <span class="hljs-comment"># 配置视图解析器前缀完成JSP的页面跳转</span><br>      <span class="hljs-attr">suffix:</span> <span class="hljs-string">.jsp</span> <span class="hljs-comment"># 配置视图解析器后缀完成JSP的页面跳转</span><br></code></pre></td></tr></table></figure><hr><h5 id="静态资源配置"><a href="#静态资源配置" class="headerlink" title="静态资源配置"></a>静态资源配置</h5><p>Spring提供了存放静态资源的默认目录：</p><ul><li><p><strong>classpath:&#x2F;META-INF&#x2F;resources&#x2F;</strong></p></li><li><p><strong>classpath:&#x2F;resources&#x2F;</strong></p></li><li><p><strong>classpath:&#x2F;static&#x2F;</strong></p></li><li><p><strong>classpath:&#x2F;public&#x2F;</strong></p></li></ul><p>或者我们可以通过配置文件手动指定静态资源的存放目录</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">web:</span><br>    <span class="hljs-attr">resources:</span><br>      <span class="hljs-attr">static-locations:</span> <span class="hljs-string">classpath:/webapp</span> <span class="hljs-comment"># 配置静态资源文件夹为/webapp目录下</span><br></code></pre></td></tr></table></figure><p><em>注：当我们手动配置后，默认的静态资源目录即无法访问</em></p><hr><h3 id="配置拦截器"><a href="#配置拦截器" class="headerlink" title="配置拦截器"></a>配置拦截器</h3><p>我们在SpringBoot的项目中仍然可以配置SpringMVC的配置类</p><p>在配置类中正常配置拦截器即可</p><p><strong>这个配置类无需使用@EnableWebMvc注解，也无需使用@ComponentScan扫描包</strong></p><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>SSM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot-统一参数配置</title>
    <link href="/2024/06/30/SpringBoot-%E7%BB%9F%E4%B8%80%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE/"/>
    <url>/2024/06/30/SpringBoot-%E7%BB%9F%E4%B8%80%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot-统一参数配置"><a href="#SpringBoot-统一参数配置" class="headerlink" title="SpringBoot-统一参数配置"></a>SpringBoot-统一参数配置</h1><p>SpringBoot工程下，进行统一的配置管理，你想设置的任何参数（端口号、项目根路径、数据库连接信息等等)都集中到一个固定位置和命名的配置文件（<code>application.properties</code>或<code>application.yml</code>）中！</p><p>配置文件应该放置在Spring Boot工程的<code>src/main/resources</code>目录下。这是因为<code>src/main/resources</code>目录是Spring Boot默认的类路径（classpath），配置文件会被自动加载并可供应用程序访问</p><hr><h3 id="使用SpringBoot提供的key"><a href="#使用SpringBoot提供的key" class="headerlink" title="使用SpringBoot提供的key"></a>使用SpringBoot提供的key</h3><p><a href="https://docs.spring.io/spring-boot/appendix/application-properties/index.html#appendix.application-properties.server">Spring提供一些固定的Key :: Spring Boot</a></p><p>例如：server.port&#x3D;8080 启动端口号</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">server.port</span>=<span class="hljs-string">8080</span><br></code></pre></td></tr></table></figure><hr><h3 id="自定义key"><a href="#自定义key" class="headerlink" title="自定义key"></a>自定义key</h3><p>我们也可以在配置文件中写一些自定义的key，用@value注解获取key的值</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">bsy.name=xiaobai<br>bsy.age=18<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;hello&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloController</span> &#123;<br>    <span class="hljs-meta">@Value(&quot;$&#123;bsy.name&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-meta">@Value(&quot;$&#123;bsy.age&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="Yaml"><a href="#Yaml" class="headerlink" title="Yaml"></a>Yaml</h1><p>application配置文件是SpringBoot为所有的配置提供参数的位置，所以必须保证key不重复</p><p>为此，SpringBoot采取了多层命名的方式</p><p>然而，properties配置文件写多层命名会特别麻烦，而yml（yaml）格式就很适合写多层命名</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">server.port=8080<br>server.servlet.context-path=/<br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br>  <span class="hljs-attr">servlet:</span><br>    <span class="hljs-attr">context-path:</span> <span class="hljs-string">/</span><br></code></pre></td></tr></table></figure><hr><h3 id="yaml格式介绍"><a href="#yaml格式介绍" class="headerlink" title="yaml格式介绍"></a>yaml格式介绍</h3><p><em>YAML 和 YML 是同一个文件格式的不同文件扩展名</em></p><p>YAML（YAML Ain’t Markup Language）是一种基于层次结构的数据序列化格式，旨在提供一种易读、人类友好的数据表示方式。</p><p>与<code>.properties</code>文件相比，YAML格式有以下优势：</p><ul><li><p>层次结构</p></li><li><p>自我描述性</p></li><li><p>注释支持</p></li><li><p>多行文本</p></li><li><p>类型支持</p></li><li><p>更好的可读性</p></li></ul><hr><h3 id="yaml语法说明"><a href="#yaml语法说明" class="headerlink" title="yaml语法说明"></a>yaml语法说明</h3><ul><li><p>数据结构用树形结构呈现，通过缩进来表示层级，</p></li><li><p>如果key有多个value（集合）通过减号 ” - ” 来表示</p></li><li><p>键值结构里面的key&#x2F;value对用冒号 ” : ” 来分隔，如果存在value，需要加空格</p></li><li><p>YAML配置文件的扩展名是yaml 或 yml</p></li></ul><hr><h1 id="配置文件-读取数据"><a href="#配置文件-读取数据" class="headerlink" title="配置文件-读取数据"></a>配置文件-读取数据</h1><p>@Value读取数据的方式也是有很多缺点的：</p><ul><li>key必须写全</li><li>只能读取单个值，比如单key多value的集合无法读取</li></ul><hr><h3 id="ConfigurationProperties"><a href="#ConfigurationProperties" class="headerlink" title="@ConfigurationProperties"></a>@ConfigurationProperties</h3><p>为了解决这个问题，SpringBoot提供了@ConfigurationProperties注解</p><p>通过prefix属性配置文件中的前缀，分别给属性赋值，这样做有两个好处：</p><ul><li>方便</li><li>可以给集合赋值</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">bsy:</span><br>  <span class="hljs-attr">user:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">xiaobai</span><br>    <span class="hljs-attr">age:</span> <span class="hljs-number">18</span><br>    <span class="hljs-attr">girlfriend:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">xiaohong</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">xiaolv</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">xiaohuang</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;bsy.user&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">user</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">private</span> List&lt;String&gt; girlfriend;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="动态配置文件"><a href="#动态配置文件" class="headerlink" title="动态配置文件"></a>动态配置文件</h1><p>在Spring Boot中，可以使用多环境配置来根据不同的运行环境（如开发、测试、生产）加载不同的配置</p><p>SpringBoot支持多环境配置让应用程序在不同的环境中使用不同的配置参数</p><p>以下是实现Spring Boot多环境配置的常见方法：</p><ul><li><p>属性文件分离</p></li><li><p>YAML配置文件</p></li><li><p>命令行参数(动态)</p></li></ul><p><strong>application-dev.yml（开发）</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">jdbc:</span><br>    <span class="hljs-attr">datasource:</span><br>      <span class="hljs-attr">driverClassName:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>      <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql:///dev</span><br>      <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>      <span class="hljs-attr">password:</span> <span class="hljs-string">root</span><br></code></pre></td></tr></table></figure><p><strong>application-test.yml（测试）</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">jdbc:</span><br>    <span class="hljs-attr">datasource:</span><br>      <span class="hljs-attr">driverClassName:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>      <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql:///test</span><br>      <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>      <span class="hljs-attr">password:</span> <span class="hljs-string">root</span><br></code></pre></td></tr></table></figure><p><strong>application-prod.yml（生产）</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">jdbc:</span><br>    <span class="hljs-attr">datasource:</span><br>      <span class="hljs-attr">driverClassName:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>      <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql:///prod</span><br>      <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>      <span class="hljs-attr">password:</span> <span class="hljs-string">root</span><br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span> <span class="hljs-comment"># 通过更换active的value，实现不同的配置</span><br></code></pre></td></tr></table></figure><hr><h3 id="优先级问题"><a href="#优先级问题" class="headerlink" title="优先级问题"></a>优先级问题</h3><p>当application-dev.yml 和 application.yml具有同样配置时，以外部文件（application-dev）为准</p><h3 id="多环境配置"><a href="#多环境配置" class="headerlink" title="多环境配置"></a>多环境配置</h3><p>因为统一参数配置，application.yml会有特别多的key，把这些key归类提取不同的文件</p><p>再通过application.yml统一管理，同时激活多个配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">dev,test</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>SSM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot</title>
    <link href="/2024/06/30/SpringBoot/"/>
    <url>/2024/06/30/SpringBoot/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><p>SpringBoot 帮我们简单、快速地创建一个独立的、生产级别的 <strong>Spring 应用（说明：SpringBoot底层是Spring）</strong>，大多数 SpringBoot 应用只需要编写少量配置即可快速整合 Spring 平台以及第三方技术！</p><p>SpringBoot的主要目标是：</p><ul><li>为所有 Spring 开发提供更快速、可广泛访问的入门体验。</li><li>开箱即用，设置合理的默认值，但是也可以根据需求进行适当的调整。</li><li>提供一系列大型项目通用的非功能性程序（如嵌入式服务器、安全性、指标、运行检查等）。</li><li>约定大于配置，基本不需要主动编写配置类、也不需要 XML 配置文件。</li></ul><p><strong>总结：简化开发，简化配置，简化整合，简化部署，简化监控，简化运维。</strong></p><hr><h3 id="父工程"><a href="#父工程" class="headerlink" title="父工程"></a>父工程</h3><p>在SSM的学习中，我们都是新建一个工程作为父工程，做依赖的统一管理</p><p>而在Springboot中，要将我们创建好的工程直接设置为springboot的子工程（认boot作父）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>每个boot项目都有一个父项目<code>spring-boot-starter-parent</code></li><li>parent的父项目是<code>spring-boot-dependencies</code></li><li>父项目 <strong>版本仲裁中心</strong>，把所有常见的jar的依赖版本都声明好了</li></ul><hr><h3 id="启动器（Strater）"><a href="#启动器（Strater）" class="headerlink" title="启动器（Strater）"></a>启动器（Strater）</h3><p>Spring Boot提供了一种叫做Starter的概念，它是一组预定义的依赖项集合，旨在简化Spring应用程序的配置和构建过程</p><p>Starter包含了一组相关的依赖项，以便在启动应用程序时自动引入所需的库、配置和功能</p><ul><li><p>简化依赖管理</p></li><li><p>自动配置</p></li><li><p>提供约定优于配置</p></li><li><p>快速启动和开发应用程序</p></li><li><p>模块化和可扩展性</p></li></ul><p>Spring Boot提供了许多预定义的Starter，例如spring-boot-starter-web用于构建Web应用程序，spring-boot-starter-data-jpa用于使用JPA进行数据库访问，spring-boot-starter-security用于安全认证和授权等等</p><p><a href="https://docs.spring.io/spring-boot/reference/using/build-systems.html">Spring启动器列表；来自Spring官网</a></p><hr><h5 id="命名规范："><a href="#命名规范：" class="headerlink" title="命名规范："></a>命名规范：</h5><ul><li>官方提供的场景：命名为：<code>spring-boot-starter-*</code></li><li>第三方提供场景：命名为：<code>*-spring-boot-starter</code></li></ul><hr><h5 id="spring-boot-starter-web"><a href="#spring-boot-starter-web" class="headerlink" title="spring-boot-starter-web"></a>spring-boot-starter-web</h5><p>添加web整合依赖，包括但不限于：</p><ul><li>Spring-webmvc</li><li>servlet</li><li>jackson</li><li>……</li></ul><p><em>注：因为父工程的版本控制，所以这个依赖也不需要写版本号</em></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h3 id="启动类（-SpringBootApplication）"><a href="#启动类（-SpringBootApplication）" class="headerlink" title="启动类（@SpringBootApplication）"></a>启动类（@SpringBootApplication）</h3><p>@SpringBootApplication注解修饰的类即为启动类，我们先来研究一下注解内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">……<br><span class="hljs-meta">@SpringBootConfiguration</span><br><span class="hljs-meta">@EnableAutoConfiguration</span><br><span class="hljs-meta">@ComponentScan</span><br>……<br></code></pre></td></tr></table></figure><ul><li>@SpringBootConfiguration继承自@Configuration注解，它标识这这个类是一个<strong>配置类</strong></li><li>@EnableAutoConfiguration：自动加载其他的配置类</li><li>@ComponentScan：扫描包，默认是扫描当前类所在的包及其子包的注解</li></ul><hr><h5 id="SpringApplication-run"><a href="#SpringApplication-run" class="headerlink" title="SpringApplication.run"></a>SpringApplication.run</h5><p>调用SpringApplication.run方法，将启动类本身的类对象和主方法参数作为参数传递</p><ul><li>创建IoC容器，加载配置</li><li>启动内置的Web服务器（Tomcat）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xiaobai;<br><br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(Main.class, args); <span class="hljs-comment">// 自动创建IoC容器，启动tomcat软件</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="Bean"><a href="#Bean" class="headerlink" title="@Bean"></a>@Bean</h5><p>因为启动类本身就是一个配置类，所以我们可以直接创建方法用@Bean修饰，手动注入组件或工厂Bean到IoC容器中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xiaobai;<br><br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(Main.class, args); <span class="hljs-comment">// 自动创建IoC容器，启动tomcat软件</span><br>    &#125;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">object</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>SSM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SSM整合-其他问题</title>
    <link href="/2024/06/30/SSM%E6%95%B4%E5%90%88-%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98/"/>
    <url>/2024/06/30/SSM%E6%95%B4%E5%90%88-%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="SSM整合-其他问题"><a href="#SSM整合-其他问题" class="headerlink" title="SSM整合-其他问题"></a>SSM整合-其他问题</h1><h3 id="Slf4j"><a href="#Slf4j" class="headerlink" title="@Slf4j"></a>@Slf4j</h3><p>想要输出的类上使用@Slf4j注解，调用log对象的方法（例如info），使用<code>&#123;&#125;</code>作为占位符打印日志</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@ComponentScan(&quot;com.xiaobai.controller&quot;)</span><br><span class="hljs-meta">@RequestMapping(&quot;schedule&quot;)</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ScheduleController</span> &#123;<br>    log.info(<span class="hljs-string">&quot;查询到的数据为：&#123;&#125;&quot;</span>, r);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="PageBean"><a href="#PageBean" class="headerlink" title="PageBean"></a>PageBean</h3><p>尚硅谷提供了一个实体类PageBean，此实体类可以用于PageHelper插件查询之后，使用PageInfo获取到分页信息后，封装到此实体类中</p><p><em>我们在之前学习的微头条项目中，使用Vo对象来接收查询到的分页参数</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PageBean</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> currentPage;   <span class="hljs-comment">// 当前页码</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> pageSize;      <span class="hljs-comment">// 每页显示的数据量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> total;       <span class="hljs-comment">// 总数据条数</span><br>    <span class="hljs-keyword">private</span> List&lt;T&gt; data;      <span class="hljs-comment">// 当前页的数据集合</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="R（Result包装对象）"><a href="#R（Result包装对象）" class="headerlink" title="R（Result包装对象）"></a>R（Result包装对象）</h3><p>在JavaWeb中，我们也有这样的类，封装了响应业务码，还有枚举类型的响应状态信息</p><p>尚硅谷提供了一个包装对象，但这个简单得多，只有成功（200），和失败（500）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xiaobai.util;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">R</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> <span class="hljs-number">200</span>; <span class="hljs-comment">//200成功状态码</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">//返回状态</span><br><br>    <span class="hljs-keyword">private</span> Object data;  <span class="hljs-comment">//返回具体数据</span><br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> R <span class="hljs-title function_">ok</span><span class="hljs-params">(Object data)</span> &#123;<br>        <span class="hljs-type">R</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">R</span>();<br>        r.data = data;<br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> R <span class="hljs-title function_">fail</span><span class="hljs-params">(Object data)</span> &#123;<br>        <span class="hljs-type">R</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">R</span>();<br>        r.code = <span class="hljs-number">500</span>; <span class="hljs-comment">//错误码</span><br>        r.flag = <span class="hljs-literal">false</span>; <span class="hljs-comment">//错误状态</span><br>        r.data = data;<br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> code;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCode</span><span class="hljs-params">(<span class="hljs-type">int</span> code)</span> &#123;<br>        <span class="hljs-built_in">this</span>.code = code;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFlag</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> flag;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setFlag</span><span class="hljs-params">(<span class="hljs-type">boolean</span> flag)</span> &#123;<br>        <span class="hljs-built_in">this</span>.flag = flag;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getData</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> data;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setData</span><span class="hljs-params">(Object data)</span> &#123;<br>        <span class="hljs-built_in">this</span>.data = data;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="Service分页查询处理"><a href="#Service分页查询处理" class="headerlink" title="Service分页查询处理"></a>Service分页查询处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> R <span class="hljs-title function_">page</span><span class="hljs-params">(<span class="hljs-type">int</span> pageSize, <span class="hljs-type">int</span> currentPage)</span> &#123;<br>    <span class="hljs-comment">// 调用分页插件</span><br>    PageHelper.startPage(currentPage, pageSize);<br>    <span class="hljs-comment">// 查询</span><br>    List&lt;Schedule&gt; schedules = scheduleMapper.queryList();<br>    <span class="hljs-comment">// 分页数据装配</span><br>    PageInfo&lt;Schedule&gt; pageInfo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PageInfo</span>&lt;&gt;(schedules);<br>    <span class="hljs-comment">// 封装pageBean</span><br>    PageBean&lt;Schedule&gt; schedulePageBean = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PageBean</span>&lt;&gt;(currentPage,pageSize, pageInfo.getTotal(),pageInfo.getList());<br>    <span class="hljs-comment">// 封装R</span><br>    <span class="hljs-keyword">return</span> R.ok(schedulePageBean);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="同源禁止策略的解决方案"><a href="#同源禁止策略的解决方案" class="headerlink" title="同源禁止策略的解决方案*"></a>同源禁止策略的解决方案*</h3><p>我们在JavaWeb中解决这个问题的方式，是建立一个Filter过滤器</p><h5 id="CrossOrigin"><a href="#CrossOrigin" class="headerlink" title="@CrossOrigin"></a>@CrossOrigin</h5><p>在ssm项目中，在Controller层类或方法上面使用@CrossOrigin注解，即可允许跨域访问</p><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>SSM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SSM整合</title>
    <link href="/2024/06/29/SSM%E6%95%B4%E5%90%88/"/>
    <url>/2024/06/29/SSM%E6%95%B4%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h1 id="SSM整合"><a href="#SSM整合" class="headerlink" title="SSM整合"></a>SSM整合</h1><p><img src="/upload/SSM%E6%95%B4%E5%90%88.png" alt="SSM整合.png"></p><p><strong>微观</strong>：将学习的Spring SpringMVC Mybatis框架应用到项目中!</p><ul><li>SpringMVC框架负责控制层</li><li>Spring 框架负责整体和业务层的声明式事务管理</li><li>MyBatis框架负责数据库访问层</li></ul><p><strong>宏观</strong>：Spring接管一切（将框架核心组件交给Spring进行IoC管理），代码更加简洁。</p><ul><li>SpringMVC管理表述层、SpringMVC相关组件</li><li>Spring管理业务层、持久层、以及数据库相关（DataSource,MyBatis）的组件</li><li>使用IoC的方式管理一切所需组件</li></ul><p><strong>实施</strong>：通过编写配置文件，实现SpringIoC容器接管一切组件。</p><hr><h3 id="两个容器"><a href="#两个容器" class="headerlink" title="两个容器"></a>两个容器</h3><ul><li>web容器<ul><li>Controller</li><li>HandlerMapping</li><li>HandlerAdapter</li><li>……web相关组件</li></ul></li><li>root容器<ul><li>Service<ul><li>Service层</li><li>AOP相关组件</li><li>TX相关组件</li></ul></li><li>Mapper<ul><li>Mapper层</li><li>DataSource</li><li>MyBatis相关组件</li></ul></li></ul></li></ul><p>学过SpringIoC容器，我们知道，两个容器之间的组件无法相互引用，也就是Controller无法调用Service的内容</p><p>为了解决这个问题，在初始化SpringMVC的时候，将web容器作为root容器的子容器，呈现父子关系</p><p>这样，作为子容器中的组件controller就能正常引用父容器的组件Service了</p><hr><h3 id="三个配置类"><a href="#三个配置类" class="headerlink" title="三个配置类"></a>三个配置类</h3><p>为了脉络清晰，我们准备三个配置类：</p><ul><li>WebJavaConfig.java</li><li>ServiceJavaConfig.java</li><li>MapperJavaConfig.java</li></ul><p>最后将WebJavaConfig.java初始化web容器</p><p>将ServiceJavaConfig.java和MapperJavaConfig.java初始化进root容器中即可</p><p>我们也可以每一个功能都单独写一个配置类，AOP写一个，TX也写一个，DataSource写一个，MyBatis写一个</p><p>但是无论写多少个配置类，最后我们按照规则放到响应的两个容器中，即可正常使用了</p><p><em>注：如果将DataSource与MyBatis配置类写到一起会出现问题，具体看后文</em></p><hr><h3 id="配置初始化"><a href="#配置初始化" class="headerlink" title="配置初始化"></a>配置初始化</h3><p>前文提到过，通过自定义初始化类继承AbstractAnnotationConfigDispatcherServletInitializer实现类后重写方法，即可完成对两个容器的配置和初始化</p><p>具体的内容请看：</p><blockquote><p>笔记 -&gt; SSM -&gt; SpringMVC -&gt;  WebApplicationInitializer接口（祖宗）&amp;  用户自定义初始化类</p></blockquote><hr><h3 id="依赖整合"><a href="#依赖整合" class="headerlink" title="依赖整合"></a>依赖整合</h3><ul><li>spring<ul><li>ioc&#x2F;di<ul><li>spring-context</li><li>jakarta.annotation-api：<em>使用@PostConstruct和@ProDestroy还有@Resource注解的所需依赖</em></li></ul></li><li>aop<ul><li>spring-aspects</li></ul></li><li>tx<ul><li>spring-tx</li><li>spring-jdbc：用以对tx的实现</li></ul></li></ul></li><li>SpringMVC<ul><li>spring-webmvc</li><li>jakarta.jakartaee-web-api：Servlet所需依赖</li><li>jackson-databind：JSON处理所需依赖</li><li>校验注解<ul><li>hibernate-validator</li><li>hibernate-validator-annotation-processor</li></ul></li></ul></li><li>MyBatis<ul><li>mybatis</li><li>mysql</li><li>pagehelper：mybatis的插件，用以实现翻页功能</li></ul></li><li>整合需要<ul><li>此处需要导入spring-web以正常初始化加载spring容器，但此依赖被spring-webmvc依赖传递，所以无需重复导入</li><li>mybatis-spring：提供MyBatis的FactoryBean</li><li>Druid：德鲁伊连接池</li><li>lombok：实体类的getter&#x2F;setter……生成</li><li>logback：用以处理MyBatis的日志输出</li><li>slf4j：本来应该被logback依赖传递导入到项目中，但我一直报错，导入就好了</li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>6.1.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/jakarta.annotation/jakarta.annotation-api --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>jakarta.annotation<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jakarta.annotation-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-aspects --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-aspects<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>6.1.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-tx --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-tx<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>6.1.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>6.1.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/jakarta.platform/jakarta.jakartaee-web-api --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>jakarta.platform<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jakarta.jakartaee-web-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>10.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-databind<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.17.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.hibernate.validator/hibernate-validator --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.hibernate.validator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hibernate-validator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.1.Final<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.hibernate.validator/hibernate-validator-annotation-processor --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.hibernate.validator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hibernate-validator-annotation-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.1.Final<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.16<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/com.mysql/mysql-connector-j --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.4.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/com.github.pagehelper/pagehelper --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.pagehelper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>pagehelper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>6.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis-spring --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.23<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.18.32<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/ch.qos.logback/logback-classic --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>ch.qos.logback<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>logback-classic<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.5.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.slf4j/slf4j-api --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.13<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h3 id="logback-xml"><a href="#logback-xml" class="headerlink" title="logback.xml"></a>logback.xml</h3><p>这是一个全新的插件，用于输出日志的工具</p><p>每个公司都会提供自己的logback.xml，将其放在resources文件夹下即可</p><p>在这里，尚硅谷提供了一个logback.xml文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span> <span class="hljs-attr">debug</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 指定日志输出的位置，ConsoleAppender表示输出到控制台 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;STDOUT&quot;</span></span><br><span class="hljs-tag">              <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- 日志输出的格式 --&gt;</span><br>            <span class="hljs-comment">&lt;!-- 按照顺序分别是：时间、日志级别、线程名称、打印日志的类、日志主体内容、换行 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>[%d&#123;HH:mm:ss.SSS&#125;] [%-5level] [%thread] [%logger] [%msg]%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">charset</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">charset</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 设置全局日志级别。日志级别按顺序分别是：TRACE、DEBUG、INFO、WARN、ERROR --&gt;</span><br>    <span class="hljs-comment">&lt;!-- 指定任何一个日志级别都只打印当前级别和后面级别的日志。 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;DEBUG&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 指定打印日志的appender，这里通过“STDOUT”引用了前面配置的appender --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;STDOUT&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 根据特殊需求指定局部日志级别，可也是包名或全类名。 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.xiaobai.mybatis&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;DEBUG&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h1 id="MyBatis整合"><a href="#MyBatis整合" class="headerlink" title="MyBatis整合"></a>MyBatis整合</h1><p>在之前，我们想要使用MyBatis的时候，需要以下的步骤来完成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1.读取外部配置文件</span><br><span class="hljs-type">InputStream</span> <span class="hljs-variable">ips</span> <span class="hljs-operator">=</span> Resources.getResourceAsStream(<span class="hljs-string">&quot;mybatis-config.xml&quot;</span>);<br><br><span class="hljs-comment">//2.创建sqlSessionFactory</span><br><span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sqlSessionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(ips);<br><br><span class="hljs-comment">//3.创建sqlSession</span><br><span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession();<br><span class="hljs-comment">//4.获取mapper代理对象</span><br><span class="hljs-type">EmpMapper</span> <span class="hljs-variable">empMapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(EmpMapper.class);<br><span class="hljs-comment">//5.数据库方法调用</span><br><span class="hljs-type">int</span> <span class="hljs-variable">rows</span> <span class="hljs-operator">=</span> empMapper.deleteEmpById(<span class="hljs-number">1</span>);<br>System.out.println(<span class="hljs-string">&quot;rows = &quot;</span> + rows);<br><span class="hljs-comment">//6.提交和回滚</span><br>sqlSession.commit();<br>sqlSession.close();<br></code></pre></td></tr></table></figure><ul><li><p>SqlSessionFactoryBuilder</p><p>这个类可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory，就不再需要它了。<br>因此 SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域（也就是局部方法变量）。 无需ioc容器管理！</p></li><li><p>SqlSessionFactory</p><p>一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例。 使用 SqlSessionFactory 的最佳实践是在应用运行期间不要重复创建多次，因此 SqlSessionFactory 的最佳作用域是应用作用域。 <strong>需要ioc容器管理！</strong></p></li><li><p>SqlSession</p><p>每个线程都应该有它自己的 SqlSession 实例。SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。 无需ioc容器管理！</p></li><li><p>Mapper映射器实例</p><p>映射器是一些绑定映射语句的接口。映射器接口的实例是从 SqlSession 中获得的。虽然从技术层面上来讲，任何映射器实例的最大作用域与请求它们的 SqlSession 相同。但方法作用域才是映射器实例的最合适的作用域。</p><p>从作用域的角度来说，映射器实例不应该交给ioc容器管理！</p><p>但是从使用的角度来说，业务类（service）需要注入mapper接口，<strong>所以mapper应该交给ioc容器管理！</strong></p></li><li><p>总结</p><ul><li>将SqlSessionFactory实例存储到IoC容器</li><li>将Mapper实例存储到IoC容器</li></ul></li></ul><hr><h3 id="使用mybatis-spring提供的工厂Bean"><a href="#使用mybatis-spring提供的工厂Bean" class="headerlink" title="使用mybatis-spring提供的工厂Bean"></a>使用mybatis-spring提供的工厂Bean</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.mybatis.spring;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SqlSessionFactoryBean</span><br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">FactoryBean</span>&lt;SqlSessionFactory&gt;, InitializingBean, ApplicationListener&lt;ContextRefreshedEvent&gt; &#123;<br>    <br>   <span class="hljs-comment">//封装了实例化流程</span><br>   <span class="hljs-keyword">public</span> SqlSessionFactory <span class="hljs-title function_">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.sqlSessionFactory == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">//实例化对象逻辑</span><br>        afterPropertiesSet();<br>      &#125;<br>      <span class="hljs-comment">//返回对象逻辑</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.sqlSessionFactory;<br>   &#125;<br>   ……<br>&#125; <br></code></pre></td></tr></table></figure><hr><h3 id="保留mybatis-config-xml"><a href="#保留mybatis-config-xml" class="headerlink" title="保留mybatis-config.xml"></a>保留mybatis-config.xml</h3><p>我们可以保留此xml配置文件，但如果想要让Druid接管数据库连接池，则需要单独使用jdbc.properties</p><p>在mybatis-config.xml中不再声明jdbc四大件和扫描mapper包（mapper包的扫描由配置类接管）</p><p>使用mybatis-spring提供的SqlSessionFactoryBean直接将sqlSessionFactory对象注入到IoC容器中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.alibaba.druid.pool.DruidDataSource;<br><span class="hljs-keyword">import</span> org.mybatis.spring.SqlSessionFactoryBean;<br><span class="hljs-keyword">import</span> org.mybatis.spring.mapper.MapperScannerConfigurer;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Value;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.PropertySource;<br><span class="hljs-keyword">import</span> org.springframework.core.io.ClassPathResource;<br><span class="hljs-keyword">import</span> org.springframework.core.io.Resource;<br><br><span class="hljs-keyword">import</span> javax.sql.DataSource;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 此类为Mapper层的配置文件，可用以替换掉mybatis-config.xml</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span> <span class="hljs-comment">// 导入jdbc配置文件</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapperJavaConfig</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建Druid连接池，以<span class="hljs-doctag">@Value</span>注解修饰形参列表的方式读取jdbc.properties文件中内容</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> driver   驱动</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> url      url</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> username 数据库用户名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> password 数据库密码</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> Druid连接池对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> DataSource <span class="hljs-title function_">dataSource</span><span class="hljs-params">(</span><br><span class="hljs-params">            <span class="hljs-meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span></span><br><span class="hljs-params">            String driver,</span><br><span class="hljs-params">            <span class="hljs-meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="hljs-params">            String url,</span><br><span class="hljs-params">            <span class="hljs-meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="hljs-params">            String username,</span><br><span class="hljs-params">            <span class="hljs-meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span></span><br><span class="hljs-params">            String password</span><br><span class="hljs-params">    )</span> &#123;<br>        <span class="hljs-type">DruidDataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DruidDataSource</span>();<br>        dataSource.setDriverClassName(driver);<br>        dataSource.setUrl(url);<br>        dataSource.setUsername(username);<br>        dataSource.setPassword(password);<br>        <span class="hljs-keyword">return</span> dataSource;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> dataSource 从IoC容器中拿连接池对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> sqlSessionFactoryBean对象，取代sqlSessionFactory，用于生成sqlSession</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> SqlSessionFactoryBean <span class="hljs-title function_">sqlSessionFactory</span><span class="hljs-params">(DataSource dataSource)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">SqlSessionFactoryBean</span> <span class="hljs-variable">sqlSessionFactoryBean</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBean</span>();<br>        sqlSessionFactoryBean.setDataSource(dataSource); <span class="hljs-comment">// 将Druid连接池配置到MyBatis中</span><br>        <span class="hljs-type">Resource</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathResource</span>(<span class="hljs-string">&quot;mybatis-config.xml&quot;</span>);<span class="hljs-comment">// 将mybatis-config.xml配置到MyBatis中</span><br>        sqlSessionFactoryBean.setConfigLocation(resource);<br>        <span class="hljs-keyword">return</span> sqlSessionFactoryBean;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 此方法扫描包，生成mapper加入IoC容器中，取代了mybatis-config.xml的扫描包步骤</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> mapperScannerConfigurer对象到IoC容器中</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> MapperScannerConfigurer <span class="hljs-title function_">mapperScannerConfigurer</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">MapperScannerConfigurer</span> <span class="hljs-variable">mapperScannerConfigurer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MapperScannerConfigurer</span>();<br>        mapperScannerConfigurer.setBasePackage(<span class="hljs-string">&quot;com.xiaobai.mapper&quot;</span>);<br>        <span class="hljs-keyword">return</span> mapperScannerConfigurer;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="抽取DataSource！！！"><a href="#抽取DataSource！！！" class="headerlink" title="抽取DataSource！！！*"></a>抽取DataSource！！！*</h3><p><strong>但此配置类存在问题</strong>： 如果将dataSource和mybatis的组件配置到一起，就会存在@Value注解不生效的问题</p><p>因为MyBatis组件比@Value注解先执行，就会导致DataSource四大件是空的</p><p>解决方案就是将DataSource抽出来，作为单独配置类</p><p><em>或者直接不适用@Value注解，不通过外部配置文件，就不用单独抽取DataSource</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xiaobai.config;<br><br><span class="hljs-keyword">import</span> com.alibaba.druid.pool.DruidDataSource;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Value;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><br><span class="hljs-keyword">import</span> javax.sql.DataSource;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span> <span class="hljs-comment">// 导入jdbc配置文件</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DataSourceJavaConfig</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建Druid连接池，以<span class="hljs-doctag">@Value</span>注解修饰形参列表的方式读取jdbc.properties文件中内容</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> driver   驱动</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> url      url</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> username 数据库用户名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> password 数据库密码</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> Druid连接池对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> DataSource <span class="hljs-title function_">dataSource</span><span class="hljs-params">(</span><br><span class="hljs-params">            <span class="hljs-meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span></span><br><span class="hljs-params">            String driver,</span><br><span class="hljs-params">            <span class="hljs-meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="hljs-params">            String url,</span><br><span class="hljs-params">            <span class="hljs-meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="hljs-params">            String username,</span><br><span class="hljs-params">            <span class="hljs-meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span></span><br><span class="hljs-params">            String password</span><br><span class="hljs-params">    )</span> &#123;<br>        <span class="hljs-type">DruidDataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DruidDataSource</span>();<br>        dataSource.setDriverClassName(driver);<br>        dataSource.setUrl(url);<br>        dataSource.setUsername(username);<br>        dataSource.setPassword(password);<br>        <span class="hljs-keyword">return</span> dataSource;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="不保留mybatis-config-xml（完全配置类）"><a href="#不保留mybatis-config-xml（完全配置类）" class="headerlink" title="不保留mybatis-config.xml（完全配置类）*"></a>不保留mybatis-config.xml（完全配置类）*</h3><p>删除以下两行代码，改为单独配置，实现配置类替换mybatis.config.xml</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Resource</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathResource</span>(<span class="hljs-string">&quot;mybatis-config.xml&quot;</span>);<span class="hljs-comment">// 将mybatis-config.xml配置到MyBatis中</span><br>sqlSessionFactoryBean.setConfigLocation(resource);<br></code></pre></td></tr></table></figure><hr><h5 id="Setting标签"><a href="#Setting标签" class="headerlink" title="Setting标签"></a>Setting标签</h5><p><em>注：这里的configuration是org.apache.ibatis.session.Configuration，别导错包！！！</em></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 开启驼峰式映射--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!-- 开启logback日志输出--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;logImpl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;SLF4J&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--开启resultMap自动映射 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;autoMappingBehavior&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;FULL&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">org.apache.ibatis.session.<span class="hljs-type">Configuration</span> <span class="hljs-variable">configuration</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">org</span>.apache.ibatis.session.Configuration();<br>configuration.setMapUnderscoreToCamelCase(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 开启驼峰式映射</span><br>configuration.setLogImpl(Slf4jImpl.class); <span class="hljs-comment">// 开启logback日志输出</span><br>configuration.setAutoMappingBehavior(AutoMappingBehavior.FULL); <span class="hljs-comment">// 开启resultMap自动映射</span><br>sqlSessionFactoryBean.setConfiguration(configuration);<br></code></pre></td></tr></table></figure><hr><h5 id="typeAliases标签"><a href="#typeAliases标签" class="headerlink" title="typeAliases标签"></a>typeAliases标签</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 给实体类起别名 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.atguigu.pojo&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">sqlSessionFactoryBean.setTypeAliasesPackage(<span class="hljs-string">&quot;com.xiaobai.pojo&quot;</span>); <span class="hljs-comment">// 给实体类起别名</span><br></code></pre></td></tr></table></figure><hr><h5 id="plugins标签"><a href="#plugins标签" class="headerlink" title="plugins标签"></a>plugins标签</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--配置分页插件--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span> <span class="hljs-attr">interceptor</span>=<span class="hljs-string">&quot;com.github.pagehelper.PageInterceptor&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;helperDialect&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;mysql&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 替换plugins标签，配置分页插件</span><br><span class="hljs-type">PageInterceptor</span> <span class="hljs-variable">pageInterceptor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PageInterceptor</span>();<br><span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>properties.setProperty(<span class="hljs-string">&quot;helperDialect&quot;</span>, <span class="hljs-string">&quot;mysql&quot;</span>);   <span class="hljs-comment">// 准备一个properties对象</span><br>pageInterceptor.setProperties(properties);<br>sqlSessionFactoryBean.addPlugins(pageInterceptor);<br></code></pre></td></tr></table></figure><hr><h3 id="MapperJavaConfig"><a href="#MapperJavaConfig" class="headerlink" title="MapperJavaConfig"></a>MapperJavaConfig</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xiaobai.config;<br><br><span class="hljs-keyword">import</span> com.github.pagehelper.PageInterceptor;<br><span class="hljs-keyword">import</span> org.apache.ibatis.logging.slf4j.Slf4jImpl;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.AutoMappingBehavior;<br><span class="hljs-keyword">import</span> org.mybatis.spring.SqlSessionFactoryBean;<br><span class="hljs-keyword">import</span> org.mybatis.spring.mapper.MapperScannerConfigurer;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.PropertySource;<br><br><span class="hljs-keyword">import</span> javax.sql.DataSource;<br><span class="hljs-keyword">import</span> java.util.Properties;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 此类为Mapper层的配置文件，可用以替换掉mybatis-config.xml</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapperJavaConfig</span> &#123;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> dataSource 从IoC容器中拿连接池对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> sqlSessionFactoryBean对象，取代sqlSessionFactory，用于生成sqlSession</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> SqlSessionFactoryBean <span class="hljs-title function_">sqlSessionFactory</span><span class="hljs-params">(DataSource dataSource)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">SqlSessionFactoryBean</span> <span class="hljs-variable">sqlSessionFactoryBean</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBean</span>();<br>        sqlSessionFactoryBean.setDataSource(dataSource); <span class="hljs-comment">// 将Druid连接池配置到MyBatis中</span><br><br>        <span class="hljs-comment">// 替换Setting标签</span><br>        org.apache.ibatis.session.<span class="hljs-type">Configuration</span> <span class="hljs-variable">configuration</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">org</span>.apache.ibatis.session.Configuration();<br>        configuration.setMapUnderscoreToCamelCase(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 开启驼峰式映射</span><br>        configuration.setLogImpl(Slf4jImpl.class); <span class="hljs-comment">// 开启logback日志输出</span><br>        configuration.setAutoMappingBehavior(AutoMappingBehavior.FULL); <span class="hljs-comment">// 开启resultMap自动映射</span><br>        sqlSessionFactoryBean.setConfiguration(configuration);<br><br>        <span class="hljs-comment">// 替换typeAliases标签</span><br>        sqlSessionFactoryBean.setTypeAliasesPackage(<span class="hljs-string">&quot;com.xiaobai.pojo&quot;</span>); <span class="hljs-comment">// 给实体类起别名</span><br><br>        <span class="hljs-comment">// 替换plugins标签，配置分页插件</span><br>        <span class="hljs-type">PageInterceptor</span> <span class="hljs-variable">pageInterceptor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PageInterceptor</span>();<br>        <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>        properties.setProperty(<span class="hljs-string">&quot;helperDialect&quot;</span>, <span class="hljs-string">&quot;mysql&quot;</span>);   <span class="hljs-comment">// 准备一个properties对象</span><br>        pageInterceptor.setProperties(properties);<br><br>        <span class="hljs-keyword">return</span> sqlSessionFactoryBean;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 此方法扫描包，生成mapper加入IoC容器中，取代了mybatis-config.xml的扫描包步骤</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> mapperScannerConfigurer对象到IoC容器中</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> MapperScannerConfigurer <span class="hljs-title function_">mapperScannerConfigurer</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">MapperScannerConfigurer</span> <span class="hljs-variable">mapperScannerConfigurer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MapperScannerConfigurer</span>();<br>        mapperScannerConfigurer.setBasePackage(<span class="hljs-string">&quot;com.xiaobai.mapper&quot;</span>);<br>        <span class="hljs-keyword">return</span> mapperScannerConfigurer;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h1><p>接下来就是将所有的配置类放到AbstractAnnotationConfigDispatcherServletInitializer</p><p>简称AACD进行初始化了（这破🪝八名字真TM的长）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * springMVC的初始化类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringIoCInit</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractAnnotationConfigDispatcherServletInitializer</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;DataSourceJavaConfig.class, MapperJavaConfig.class, ServiceJavaConfig.class&#125;;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;WebJavaConfig.class&#125;;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> String[] getServletMappings() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;/&quot;</span>&#125;;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>SSM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SpringMVC-高级扩展</title>
    <link href="/2024/06/28/SpringMVC-%E9%AB%98%E7%BA%A7%E6%89%A9%E5%B1%95/"/>
    <url>/2024/06/28/SpringMVC-%E9%AB%98%E7%BA%A7%E6%89%A9%E5%B1%95/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringMVC-全局异常处理"><a href="#SpringMVC-全局异常处理" class="headerlink" title="SpringMVC-全局异常处理"></a>SpringMVC-全局异常处理</h1><p>在传统的JavaWeb中，我们使用编程式异常处理，使用try-catch关键字来捕获 -&gt;处理异常</p><p>在SpringMVC中，提供了声明式异常处理的方式</p><hr><h3 id="RestConrollerAdvice"><a href="#RestConrollerAdvice" class="headerlink" title="@RestConrollerAdvice"></a>@RestConrollerAdvice</h3><p>@ControllerAdvice是发生异常后调用此类的handler方法，但可以正常返回逻辑视图、转发、重定向操作</p><p>@RestConrollerAdvice &#x3D; @ControllerAdvice + @ResponseBody</p><p>使用@RestConrollerAdvice标识全局异常处理器，直接返回JSON字符串（用于前后端分离项目）</p><p><em>这种异常处理的方式也就是AOP面向切面编程的思维</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestControllerAdvice</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GlobalExceptionHandler</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="ExceptionHandler"><a href="#ExceptionHandler" class="headerlink" title="@ExceptionHandler"></a>@ExceptionHandler</h5><p>此方法在异常处理器的方法上，修饰异常处理的handler</p><p>通过.class的类名来捕获指定的异常，由异常处理器接管</p><p><em>注：全局异常处理类也需要被加入IoC容器中，所以在配置类中要将此包扫描</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestControllerAdvice</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GlobalExceptionHandler</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 当发生ArithmeticException（算术异常）时，被此handler接管</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@ExceptionHandler(ArithmeticException.class)</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">ArithmeticExceptionHandler</span><span class="hljs-params">(ArithmeticException e)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 当发生异常时，被此handler接管</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> e Exception的异常信息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@ExceptionHandler(Exception.class)</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">ExceptionHandler</span><span class="hljs-params">(Exception e)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="SpringMVC-拦截器"><a href="#SpringMVC-拦截器" class="headerlink" title="SpringMVC-拦截器"></a>SpringMVC-拦截器</h1><p>在使用SpringMVC后，我们仍旧可以使用Filter（过滤器）技术</p><p>但Filter是位于整个JavaWeb项目之外的，无论什么请求都会被拦截一次</p><p>为此，SpringMVC提供了拦截器，相比于Filter对请求做更为细化的拦截</p><p>但拦截器无法拦截SpringMVC接管之外的请求</p><p><em>总结：如果拦截器能够实现，则不使用Filter</em></p><hr><h3 id="HandlerInterceptor接口"><a href="#HandlerInterceptor接口" class="headerlink" title="HandlerInterceptor接口"></a>HandlerInterceptor接口</h3><p><em>intercepter中文释义：拦截器</em></p><p>新建一个拦截器，并实现HandlerInterceptor接口，重写以下三个方法：</p><ul><li>preHandle：在handler执行之前进行拦截，最终以拦截器方法的返回值决定是否放行（true放行）<ul><li>编码格式设置</li><li>登陆保护</li><li>权限处理</li></ul></li><li>postHandle：在handler执行完毕后触发的方法（没有拦截功能）<ul><li>敏感词汇检查</li><li>对结果进行处理</li></ul></li><li>afterCompletion：整体处理完毕后，调用此方法（没有拦截功能）<ul><li>多一个ex参数：为报错后的异常对象</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">return</span> HandlerInterceptor.<span class="hljs-built_in">super</span>.preHandle(request, response, handler);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        HandlerInterceptor.<span class="hljs-built_in">super</span>.postHandle(request, response, handler, modelAndView);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        HandlerInterceptor.<span class="hljs-built_in">super</span>.afterCompletion(request, response, handler, ex);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="配置拦截器"><a href="#配置拦截器" class="headerlink" title="配置拦截器"></a>配置拦截器</h3><p>将Mvc配置类实现WebMvcConfigurer接口后，重写addInterceptors方法</p><p>通过registry调用addInterceptor方法，将MyInterceptor的对象作为参数</p><p>即可拦截所有请求，都走MyInterceptor拦截器中的内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableWebMvc</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(&#123;&quot;com.xiaobai.controller&quot;,&quot;com.xiaobai.Error&quot;&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MvcConfig</span>  <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br>        registry.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyInterceptor</span>());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="指定地址拦截"><a href="#指定地址拦截" class="headerlink" title="指定地址拦截"></a>指定地址拦截</h5><p>使用registry.addInterceptor(new MyInterceptor())的链式调用，可以指定拦截的路径</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableWebMvc</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(&#123;&quot;com.xiaobai.controller&quot;,&quot;com.xiaobai.Error&quot;&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MvcConfig</span>  <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br>        <span class="hljs-comment">// 拦截访问URI为/user/data的请求</span><br>        registry.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyInterceptor</span>()).addPathPatterns(<span class="hljs-string">&quot;/user/data&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="排除地址拦截"><a href="#排除地址拦截" class="headerlink" title="排除地址拦截"></a>排除地址拦截</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableWebMvc</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(&#123;&quot;com.xiaobai.controller&quot;,&quot;com.xiaobai.Error&quot;&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MvcConfig</span>  <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br>        <span class="hljs-comment">// 排除访问URI为/user/data请求</span><br>        registry.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyInterceptor</span>()).excludePathPatterns(<span class="hljs-string">&quot;/user/data1&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="多个拦截器"><a href="#多个拦截器" class="headerlink" title="多个拦截器"></a>多个拦截器</h3><p>其实学到现在，我们可以发现，拦截器就是针对于Handler的增强通知类</p><p>针对于handler的执行前后做响应的处理</p><p>所以，当存在多个拦截器的时候，执行顺序也是同心圆原则，也就是Filter的执行顺序规则</p><p>当同时存在MyInterceptor1和MyInterceptor2时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br>    registry.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyInterceptor</span>());<br>    registry.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyInterceptor1</span>());<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p> 执行顺序为：preHandle -&gt; preHandle1 -&gt; handler -&gt; postHandle1 -&gt; postHandle -&gt; afterCompletion1 -&gt; afterCompletion</p></blockquote><hr><h1 id="SpringMVC-参数校验"><a href="#SpringMVC-参数校验" class="headerlink" title="SpringMVC-参数校验"></a>SpringMVC-参数校验</h1><p>JSR 303 是 Java 为 Bean 数据合法性校验提供的标准框架，它已经包含在 JavaEE 6.0 标准中</p><p>通过在 Bean（实体类）属性上标注类似于 @NotNull、@Max 等标准的注解指定校验规则，并通过标准的验证接口对Bean进行验证</p><table><thead><tr><th>注解</th><th>规则</th></tr></thead><tbody><tr><td>@Null</td><td>标注值必须为 null</td></tr><tr><td>@NotNull</td><td>标注值不可为 null</td></tr><tr><td>@AssertTrue</td><td>标注值必须为 true</td></tr><tr><td>@AssertFalse</td><td>标注值必须为 false</td></tr><tr><td>@Min(value)</td><td>标注值必须大于或等于 value</td></tr><tr><td>@Max(value)</td><td>标注值必须小于或等于 value</td></tr><tr><td>@DecimalMin(value)</td><td>标注值必须大于或等于 value</td></tr><tr><td>@DecimalMax(value)</td><td>标注值必须小于或等于 value</td></tr><tr><td>@Size(max,min)</td><td>标注值大小必须在 max 和 min 限定的范围内</td></tr><tr><td>@Digits(integer,fratction)</td><td>标注值值必须是一个数字，且必须在可接受的范围内</td></tr><tr><td>@Past</td><td>标注值只能用于日期型，且必须是过去的日期</td></tr><tr><td>@Future</td><td>标注值只能用于日期型，且必须是将来的日期</td></tr><tr><td>@Pattern(value)</td><td>标注值必须符合指定的正则表达式</td></tr></tbody></table><p>JSR 303 只是一套标准，需要提供其实现才可以使用</p><p>Hibernate Validator 是 JSR 303 的一个参考实现，除支持所有标准的校验注解外，它还支持以下的扩展注解：</p><table><thead><tr><th>注解</th><th>规则</th></tr></thead><tbody><tr><td>@Email</td><td>标注值必须是格式正确的 Email 地址</td></tr><tr><td>@Length</td><td>标注值字符串大小必须在指定的范围内</td></tr><tr><td>@NotEmpty</td><td>标注值字符串不能是空字符串</td></tr><tr><td>@Range</td><td>标注值必须在指定的范围内</td></tr></tbody></table><hr><h3 id="三种非空的区别"><a href="#三种非空的区别" class="headerlink" title="三种非空的区别"></a>三种非空的区别</h3><p>@NotNull、@NotEmpty、@NotBlank 都是用于在数据校验中检查字段值是否为空的注解，但是它们的用法和校验规则有所不同</p><ol><li><p>@NotNull  (包装类型不为null)</p><p>@NotNull 注解是 JSR 303 规范中定义的注解，当被标注的字段值为 null 时，会认为校验失败而抛出异常。该注解不能用于字符串类型的校验，若要对字符串进行校验，应该使用 @NotBlank 或 @NotEmpty 注解</p></li><li><p>@NotEmpty (集合类型长度大于0)</p><p>@NotEmpty 注解同样是 JSR 303 规范中定义的注解，对于 CharSequence、Collection、Map 或者数组对象类型的属性进行校验，校验时会检查该属性是否为 Null 或者 size()&#x3D;&#x3D;0，如果是的话就会校验失败。但是对于其他类型的属性，该注解无效。需要注意的是只校验空格前后的字符串，如果该字符串中间只有空格，不会被认为是空字符串，校验不会失败</p></li><li><p>@NotBlank （字符串，不为null，切不为”  “字符串）</p><p>@NotBlank 注解是 Hibernate Validator 附加的注解，对于字符串类型的属性进行校验，校验时会检查该属性是否为 Null 或 “” 或者只包含空格，如果是的话就会校验失败。需要注意的是，@NotBlank 注解只能用于字符串类型的校验</p></li></ol><p>总之，这三种注解都是用于校验字段值是否为空的注解，但是其校验规则和用法有所不同。在进行数据校验时，需要根据具体情况选择合适的注解进行校验</p><hr><h3 id="依赖导入"><a href="#依赖导入" class="headerlink" title="依赖导入"></a>依赖导入</h3><p>这一套参数校验的注解由Java提供，由hibernate来实现，SpringMVC只是做了注解的支持</p><p>所以，我们仍需要导入hibernate注解实现的依赖</p><ul><li>hibernate-validator</li><li>hibernate-validator-annotation-processor</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.hibernate.validator/hibernate-validator-annotation-processor --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.hibernate.validator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hibernate-validator-annotation-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;hibernate.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.hibernate.validator/hibernate-validator --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.hibernate.validator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hibernate-validator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;hibernate.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h3 id="应用步骤"><a href="#应用步骤" class="headerlink" title="应用步骤"></a>应用步骤</h3><h5 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h5><p>在想要做参数校验的实体类属性上加上相应的注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-meta">@NotBlank</span><br>    String name;<br>    <span class="hljs-meta">@Length(min = 6, max = 20)</span><br>    String password;<br>    <span class="hljs-meta">@Min(1)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-meta">@Email</span><br>    <span class="hljs-keyword">private</span> String email;<br>    <span class="hljs-meta">@Past</span><br>    <span class="hljs-keyword">private</span> Date birthday;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Validated"><a href="#Validated" class="headerlink" title="@Validated"></a>@Validated</h5><p>在controller中使用@Validated注解修饰实体类接收的形参，这样才能让实体类属性上的注解生效</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;user&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br>    <span class="hljs-meta">@PostMapping(&quot;register&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">register</span><span class="hljs-params">(<span class="hljs-meta">@Validated</span> <span class="hljs-meta">@RequestBody</span> User user)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;user&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="结果响应"><a href="#结果响应" class="headerlink" title="结果响应"></a>结果响应</h3><p>使用参数校验，如果校验失败会直接返回异常信息，这是不对的</p><p>我们应该返回自定义的响应错误信息，而不是直接将异常暴露给前端</p><h5 id="BindingResult"><a href="#BindingResult" class="headerlink" title="BindingResult"></a>BindingResult</h5><p>在校验对象的形参后，我们加上一个形参——BindingResult（要求这个形参紧挨着校验对象）</p><p>使用bindingResult的hasErrors方法判断错误是否存在错误，自定义返回信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;register&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">register</span><span class="hljs-params">(<span class="hljs-meta">@Validated</span> <span class="hljs-meta">@RequestBody</span> User user, BindingResult bindingResult)</span>&#123;<br>    <span class="hljs-keyword">if</span>(bindingResult.hasErrors())&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;error&quot;</span>; <span class="hljs-comment">// 自定义返回信息</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;user&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>SSM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>RESTful</title>
    <link href="/2024/06/27/RESTful/"/>
    <url>/2024/06/27/RESTful/</url>
    
    <content type="html"><![CDATA[<h1 id="RESTful"><a href="#RESTful" class="headerlink" title="RESTful"></a>RESTful</h1><p>REST即表述性状态传递（英文：Representational State Transfer，简称REST）</p><p>是Roy Fielding博士在2000年他的博士论文中提出来的一种软件架构风格</p><p>它是一种针对网络应用的设计和开发方式，可以降低开发的复杂性，提高系统的可伸缩性</p><p>使用RESTful设计风格可以写出符合标准的http应用程序</p><hr><h3 id="请求方式和URI"><a href="#请求方式和URI" class="headerlink" title="请求方式和URI"></a>请求方式和URI</h3><p>在我们之前的学习中，前端项目对后端发起的请求URI中直接包含了对请求的动作</p><p>例如：user&#x2F;findById，无论是get还是post的方式，我们将想要做的动作（find）暴露在URI中了</p><p>而http作者设计的本质不是这样，他想通过不同的请求方式来区分对后端资源的操作，而不是通过URI区分</p><p>http提供了四个请求方式：</p><ul><li>get：查询</li><li>post：保存（新增）</li><li>delete：删除</li><li>put：更新</li></ul><hr><h3 id="总结规则"><a href="#总结规则" class="headerlink" title="总结规则"></a>总结规则</h3><p>使用GET或DELETE请求方式时，如果参数为单一标识（id），则使用路径传递参数</p><p>如果参数不为单一标识时，则使用param参数</p><p>使用POST或PUT请求方式时，直接使用JSON请求体传递参数</p><hr><h3 id="项目实战"><a href="#项目实战" class="headerlink" title="项目实战"></a>项目实战</h3><table><thead><tr><th>功能</th><th>接口和请求方式</th><th>请求参数</th><th>返回值</th></tr></thead><tbody><tr><td>分页查询</td><td>GET  &#x2F;user</td><td>page&#x3D;1&amp;size&#x3D;10</td><td>{响应数据}</td></tr><tr><td>用户添加</td><td>POST &#x2F;user</td><td>{ user 数据 }</td><td>{响应数据}</td></tr><tr><td>用户详情</td><td>GET &#x2F;user&#x2F;1</td><td>路径参数</td><td>{响应数据}</td></tr><tr><td>用户更新</td><td>PUT &#x2F;user</td><td>{ user 更新数据}</td><td>{响应数据}</td></tr><tr><td>用户删除</td><td>DELETE &#x2F;user&#x2F;1</td><td>路径参数</td><td>{响应数据}</td></tr><tr><td>条件模糊</td><td>GET &#x2F;user&#x2F;search</td><td>page&#x3D;1&amp;size&#x3D;10&amp;keywork&#x3D;关键字</td><td>{响应数据}</td></tr></tbody></table><h5 id="pojo"><a href="#pojo" class="headerlink" title="pojo"></a>pojo</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xiaobai.controller;<br><br><span class="hljs-keyword">import</span> com.xiaobai.pojo.User;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.*;<br><br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;user&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 分页查询</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> page 可以不传，默认参数为1</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> size 可以不传，默认参数为10</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 查到的User集合</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@GetMapping</span><br>    <span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title function_">page</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(required = false,defaultValue = &quot;1&quot;)</span> <span class="hljs-type">int</span> page, <span class="hljs-meta">@RequestParam(required = false,defaultValue = &quot;10&quot;)</span><span class="hljs-type">int</span> size)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 新增一个用户</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> user 以JSON方式接收User参数</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 新增的用户回显</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@PostMapping</span><br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">save</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> User user)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取用户详情</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id 用户id，以路径参数的方式接收</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 查询到的用户对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@GetMapping(&quot;&#123;id&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">detail</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Integer id)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 更新用户信息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> user 更新后的用户对象，以JSON的方式接收</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 更新后的用户对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@PutMapping</span><br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> User user)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除用户</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id 被删除的用户id，以路径参数的方式接收</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@DeleteMapping(&quot;&#123;id&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Integer id)</span>&#123;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 模糊查询（带分页）</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> keyword 关键词，用以模糊查询</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> page 可以不传，默认参数为1</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> size 可以不传，默认参数为10</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 返回查询结果</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@GetMapping(&quot;search&quot;)</span><br>    <span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> String keyword,</span><br><span class="hljs-params">                             <span class="hljs-meta">@RequestParam(required = false,defaultValue = &quot;1&quot;)</span> <span class="hljs-type">int</span> page,</span><br><span class="hljs-params">                             <span class="hljs-meta">@RequestParam(required = false,defaultValue = &quot;10&quot;)</span><span class="hljs-type">int</span> size)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>SSM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SpringMVC-数据响应</title>
    <link href="/2024/06/27/SpringMVC-%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94/"/>
    <url>/2024/06/27/SpringMVC-%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringMVC-数据响应"><a href="#SpringMVC-数据响应" class="headerlink" title="SpringMVC-数据响应"></a>SpringMVC-数据响应</h1><h3 id="页面跳转"><a href="#页面跳转" class="headerlink" title="页面跳转"></a>页面跳转</h3><p>在非前后端分离项目中，我们采用模板页面的方式（JSP）来处理前端页面</p><p>在SpringMVC中，我们通过调用视图解析器来完成对JSP页面的跳转</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableWebMvc</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(&quot;com.xiaobai.controller&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br>    <span class="hljs-comment">// 配置视图解析器</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configureViewResolvers</span><span class="hljs-params">(ViewResolverRegistry registry)</span> &#123;<br>        registry.jsp(<span class="hljs-string">&quot;/WEB-INF/&quot;</span>, <span class="hljs-string">&quot;.jsp&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>registry中文释义：注册表</em></p><p>将配置类实现WebMvcConfigurer接口，可完成对SpringMVC组件的快速配置</p><p>我们重写了configureViewResolvers，通过registry调用.jsp方法，填写前缀和后缀，完成视图解析器的配置</p><hr><p>在Controller中，直接返回跳转的视图名称，框架会将这个名称与我们配置好的前缀和后缀进行字符串拼接</p><blockquote><p>例如，此案例中拼接好的跳转地址为：&#x2F;WEB-INF&#x2F;views&#x2F;index.jsp</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-meta">@RequestMapping(&quot;jsp&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JspController</span> &#123;<br>    <span class="hljs-meta">@RequestMapping(&quot;index&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">index</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;views/index&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h5><p>将方法的返回值定义成字符串，在返回的字符串前添加forward:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;forward&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">forward</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;forward:views/index&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h5><p><em>注：在学习servlet的转发和重定向时，上下文路径（访问路径）（Application context）如果存在的话，我们重定向的时候需要额外加上这个路径，但在SpringMVC中，这个路径时缺省的</em></p><p>将方法的返回值定义成字符串，在返回的字符串前添加redirect:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;redirect&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">redirect</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:views/index&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="返回数据"><a href="#返回数据" class="headerlink" title="返回数据"></a>返回数据</h3><p>返回Json时，我们仍然需要为handlerAdapter装配一个jackson（json转换器）</p><p>使用@EnableWebMvc注解即可自动装配</p><hr><h5 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="@ResponseBody"></a>@ResponseBody</h5><p>使用@ResponseBody注解标识的方法，会由handler将返回的内容转换成Json串，将其放在响应体中，直接返回，不访问视图解析器</p><p><em>@ResponseBody注解可以标识类上，代表类中所有方法都返回JSON格式而不是跳转页面</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-meta">@RequestMapping(&quot;user&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br>    <span class="hljs-meta">@RequestMapping(&quot;data&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">data</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>        <br>        user.setName(<span class="hljs-string">&quot;xiaobai&quot;</span>);<br>        user.setAge(<span class="hljs-number">18</span>);<br>        <br>        <span class="hljs-keyword">return</span> user;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;xiaobai&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">18</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><hr><p>相同的，集合和数组也可以由SpringMVC自动转换为JSON格式写入响应体中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;data1&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title function_">data1</span><span class="hljs-params">()</span>&#123;<br>    List&lt;User&gt; users = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;User&gt;();<br>    <br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>    user.setName(<span class="hljs-string">&quot;xiaobai&quot;</span>);<br>    user.setAge(<span class="hljs-number">18</span>);<br>    <br>    users.add(user);<br>    <br>    <span class="hljs-keyword">return</span> users;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;xiaobai&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">18</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><hr><h5 id="RestContorller"><a href="#RestContorller" class="headerlink" title="@RestContorller*"></a>@RestContorller*</h5><p>@RestContorller注解 &#x3D; @Controller注解 + @ResponseBody注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;user&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br>    <span class="hljs-meta">@RequestMapping(&quot;data&quot;)</span><br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">data</span><span class="hljs-params">()</span>&#123;<br>        ……<br>    &#125;<br>    <span class="hljs-meta">@RequestMapping(&quot;data1&quot;)</span><br>    <span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title function_">data1</span><span class="hljs-params">()</span>&#123;<br>        ……<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h3><p>我们所有对后端的请求都会交给SpringMVC的底层处理，也就是HandlerMapping去寻找路径映射规则</p><p>所以在Servlet中的直接访问静态资源的方法就失效了</p><p>将配置类实现WebMvcConfigurer接口，重写configureDefaultServletHandling方法后，开启configurer.enable()</p><blockquote><p>开启之后，访问方式为 DispatcherServlet -&gt; HandlerMapping -&gt; 静态资源</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configureDefaultServletHandling</span><span class="hljs-params">(DefaultServletHandlerConfigurer configurer)</span> &#123;<br>    <span class="hljs-comment">// 配置缺省 Servlet 处理</span><br>    configurer.enable();<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>想要通过路径访问静态资源，仍然在handler方法中不能使用@ResponseBody注解，否则就直接返回了</p><p>当configurer.enable();配置时，底层是配置了xml文件&lt;mvc:default-servlet-handler&gt;，调用DefaultServletHandlerBeanDefinitionParser类</p><p>这个类创建了一个关键的对象：DefaultServletHttpRequestHandler</p><p>其操作就是将HandlerMapping找不到的路径交给DefaultServletHttpRequestHandler来查找转发</p><p>这样就实现了静态资源的访问</p><p><em>其底层内容和@EnableWebMvc注解配置方式相似</em></p><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>SSM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SpringMVC-获取Servlet原生对象</title>
    <link href="/2024/06/26/SpringMVC-%E8%8E%B7%E5%8F%96Servlet%E5%8E%9F%E7%94%9F%E5%AF%B9%E8%B1%A1/"/>
    <url>/2024/06/26/SpringMVC-%E8%8E%B7%E5%8F%96Servlet%E5%8E%9F%E7%94%9F%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringMVC-获取Servlet原生对象"><a href="#SpringMVC-获取Servlet原生对象" class="headerlink" title="SpringMVC-获取Servlet原生对象"></a>SpringMVC-获取Servlet原生对象</h1><p>直接在形参列表中声明原生对象，即可直接使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApiController</span> &#123;<br><span class="hljs-comment">// 直接使用原生对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">data</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span>&#123;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th>Controller method argument 控制器方法参数</th><th>Description</th></tr></thead><tbody><tr><td><code>jakarta.servlet.ServletRequest</code>, <code>jakarta.servlet.ServletResponse</code></td><td>请求&#x2F;响应对象</td></tr><tr><td><code>jakarta.servlet.http.HttpSession</code></td><td>强制存在会话。因此，这样的参数永远不会为 <code>null</code> 。</td></tr><tr><td><code>java.io.InputStream</code>, <code>java.io.Reader</code></td><td>用于访问由 Servlet API 公开的原始请求正文。</td></tr><tr><td><code>java.io.OutputStream</code>, <code>java.io.Writer</code></td><td>用于访问由 Servlet API 公开的原始响应正文。</td></tr><tr><td><code>@PathVariable</code></td><td>接收路径参数注解</td></tr><tr><td><code>@RequestParam</code></td><td>用于访问 Servlet 请求参数，包括多部分文件。参数值将转换为声明的方法参数类型。</td></tr><tr><td><code>@RequestHeader</code></td><td>用于访问请求标头。标头值将转换为声明的方法参数类型。</td></tr><tr><td><code>@CookieValue</code></td><td>用于访问Cookie。Cookie 值将转换为声明的方法参数类型。</td></tr><tr><td><code>@RequestBody</code></td><td>用于访问 HTTP 请求正文。正文内容通过使用 <code>HttpMessageConverter</code> 实现转换为声明的方法参数类型。</td></tr><tr><td><code>java.util.Map</code>, <code>org.springframework.ui.Model</code>, <code>org.springframework.ui.ModelMap</code></td><td>共享域对象，并在视图呈现过程中向模板公开。</td></tr><tr><td><code>Errors</code>, <code>BindingResult</code></td><td>验证和数据绑定中的错误信息获取对象！</td></tr></tbody></table><hr><h3 id="servletContext"><a href="#servletContext" class="headerlink" title="servletContext"></a>servletContext</h3><p>我们获取ServletContext对象的方式有三种：</p><ul><li>通过request调用getServletContext方法</li><li>通过session调用getServletContext方法</li><li>通过@Autowired全局注入</li></ul><hr><h5 id="调用方法方式"><a href="#调用方法方式" class="headerlink" title="调用方法方式"></a>调用方法方式</h5><p>session也可以作为形参直接获取到对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApiController</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">data</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp, HttpSession session)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">ServletContext</span> <span class="hljs-variable">servletContext</span> <span class="hljs-operator">=</span> req.getServletContext();<br>        <span class="hljs-type">ServletContext</span> <span class="hljs-variable">servletContext1</span> <span class="hljs-operator">=</span> session.getServletContext();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="全局注入方式"><a href="#全局注入方式" class="headerlink" title="全局注入方式"></a>全局注入方式</h5><p>在SpringMVC的初始化时，已经将Context对象放入IoC容器中了</p><p>使用@Autowired注解将其注入到全局变量中即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApiController</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ServletContext servletContext;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="SpringMVC-获取Servlet共享域对象"><a href="#SpringMVC-获取Servlet共享域对象" class="headerlink" title="SpringMVC-获取Servlet共享域对象"></a>SpringMVC-获取Servlet共享域对象</h1><p>上面的内容已经可以获取三大域对象了，但除此之外，SpringMVC也提供了三大域对象的获取方式</p><hr><h3 id="获取request对象"><a href="#获取request对象" class="headerlink" title="获取request对象"></a>获取request对象</h3><p>Spring额外提供了四种在request域中存放数据的方式：</p><ul><li>model</li><li>modelMap</li><li>map</li><li>modelAndView</li></ul><p><em>以上内容了解即可，当看到了别蒙</em></p><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>SSM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SpringMVC-@EnableWebMvc</title>
    <link href="/2024/06/26/SpringMVC-@EnableWebMvc/"/>
    <url>/2024/06/26/SpringMVC-@EnableWebMvc/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringMVC-EnableWebMvc"><a href="#SpringMVC-EnableWebMvc" class="headerlink" title="SpringMVC-@EnableWebMvc"></a>SpringMVC-@EnableWebMvc</h1><p>在之前的学习中，使用@EnableWebMvc注解修饰mvc的配置类后，就可以让handlerAdapter拥有处理Json的能力</p><p>其实这个注解做的远远不止这些</p><p>这个注解在早期使用xml配置的时候对应的是&lt;mvc:annotation-driven&gt;标签</p><p>这个标签使用AnnotationDrivenBeanDefinitionParser()类进行一系列操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">RootBeanDefinition</span> <span class="hljs-variable">handlerMappingDef</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RootBeanDefinition</span>(RequestMappingHandlerMapping.class);<br><br><span class="hljs-type">RootBeanDefinition</span> <span class="hljs-variable">handlerAdapterDef</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RootBeanDefinition</span>(RequestMappingHandlerAdapter.class);<br><br><span class="hljs-comment">// 加JSON处理器</span><br><span class="hljs-built_in">this</span>.addRequestBodyAdvice(handlerAdapterDef);<br><span class="hljs-built_in">this</span>.addResponseBodyAdvice(handlerAdapterDef);<br></code></pre></td></tr></table></figure><p>从这个源码我们可以了解到，@EnableWebMvc三个关键的行为：</p><ul><li>初始化RequestMappingHandlerMapping</li><li>初始化RequestMappingHandlerAdapter</li><li>将Jackson添加到handlerAdapter中</li></ul><hr><h3 id="MvcConfig"><a href="#MvcConfig" class="headerlink" title="MvcConfig"></a>MvcConfig</h3><p>综上所述，我们在mvc的配置文件中无需自己配置HandlerMapping和HandlerAdapter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableWebMvc</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(&quot;com.xiaobai.controller&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MVCConfig</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>SSM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SpringMVC-参数接收</title>
    <link href="/2024/06/26/SpringMVC-%E5%8F%82%E6%95%B0%E6%8E%A5%E6%94%B6/"/>
    <url>/2024/06/26/SpringMVC-%E5%8F%82%E6%95%B0%E6%8E%A5%E6%94%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringMVC-参数接收"><a href="#SpringMVC-参数接收" class="headerlink" title="SpringMVC-参数接收"></a>SpringMVC-参数接收</h1><p>在servlet的项目中，我们进行参数的接收使用的是HttpServletRequest对象中的String getParameter(String ParameterName)方法</p><p>接收Json也是十分麻烦，为此我们还编写了用以接收和发送参数的工具类：WebUtil</p><p>但在SpringMVC中，这一切都会被框架封装好，我们的操作就会变得很简单</p><hr><h3 id="Param参数接收"><a href="#Param参数接收" class="headerlink" title="Param参数接收"></a>Param参数接收</h3><p>Param类型的参数接收方式有三种：</p><ul><li><p>直接接收</p></li><li><p>注解指定</p></li><li><p>特殊值</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;data&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">data</span><span class="hljs-params">(String name)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;name&quot;</span> + name;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="Spring版本问题带来的Param参数接收的问题"><a href="#Spring版本问题带来的Param参数接收的问题" class="headerlink" title="Spring版本问题带来的Param参数接收的问题"></a>Spring版本问题带来的Param参数接收的问题</h5><p>在使用新版本的Spring FrameWork时，直接接收参数会报错</p><blockquote><p> Ensure that the compiler uses the ‘-parameters’ flag.</p></blockquote><p>其中，官方文档时这么说明的：</p><p><strong>Parameter Name Retention</strong></p><p><code>LocalVariableTableParameterNameDiscoverer</code> has been removed in 6.1. Consequently, code within the Spring Framework and Spring portfolio frameworks no longer attempts to deduce parameter names by parsing bytecode. If you experience issues with dependency injection, property binding, SpEL expressions, or other use cases that depend on the names of parameters, you should compile your Java sources with the common Java 8+ flag for parameter name retention (instead of relying on the compiler flag) in order to be compatible with . </p><p>Maven users need to configure the for Java source code:<code>maven-compiler-plugin</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">parameters</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">parameters</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><p>简而言之，在6.1版本之后，如果你想继续使用这种方式来接收参数的话，需要在pom.xml中配置以上内容</p><p>它会影响以下几个问题：</p><ul><li>直接接收参数是否报错</li><li>使用注解接收参数时，注解的value（name）的值是否可以省略</li><li>无法使用实体对象接值</li></ul><hr><h5 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h5><p>使用@RequestParam注解进行参数的指定</p><ul><li>value（name）属性：指定参数的名称，如果和参数名相同，则可以缺省</li><li>required属性：默认值为true，该属性配置是否允许不传递该参数</li><li>defaultValue属性：参数如果为空，则默认是为该属性的值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;data2&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">data2</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(value = &quot;name&quot;,required = false, defaultValue = &quot;xiaobai&quot;)</span> String name)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;name：&quot;</span> + name;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="一参多值"><a href="#一参多值" class="headerlink" title="一参多值"></a>一参多值</h5><p>当传递的参数为一参数多个值的时候，则使用集合作为形参来接收参数</p><p><em>这种方式必须使用RequestParam注解</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;data3&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">data3</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;hbs&quot;)</span> List&lt;String&gt; hbs)</span> &#123;<br><br>    System.out.println(hbs);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ok&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="使用实体对象接值"><a href="#使用实体对象接值" class="headerlink" title="使用实体对象接值*"></a>使用实体对象接值*</h5><p>首先我们要确保pojo包下的实体类User是存在getter&#x2F;setter方法的</p><p>在接收参数时，无法对user中的属性指定接收形参，所以使用直接接收参数的方式即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;data4&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">data4</span><span class="hljs-params">(User user)</span> &#123;<br>    System.out.println(user);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ok&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="Json参数接收"><a href="#Json参数接收" class="headerlink" title="Json参数接收"></a>Json参数接收</h3><p>Java原生的api只支持路径参数和param参数，不支持json参数</p><p>如果想要使用SpringMVC处理Json参数，则需要导入Json处理的依赖</p><p>为handlerAdapter配置Json处理转换器（没错，这个工具仍然是jackson）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-databind<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;jackson.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="EnableWebMvc"><a href="#EnableWebMvc" class="headerlink" title="@EnableWebMvc*"></a>@EnableWebMvc*</h5><p>在SpringMVC的配置类上配置@EnableWebMvc注解</p><p>其作用是为handlerAdapter配置了Json转换器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableWebMvc</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(&quot;com.xiaobai.controller&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MVCConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RequestMappingHandlerMapping <span class="hljs-title function_">requestMappingHandlerMapping</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestMappingHandlerMapping</span>();<br>    &#125;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RequestMappingHandlerAdapter <span class="hljs-title function_">handlerAdapter</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestMappingHandlerAdapter</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h5><p>使用此注解修饰形参，则代表此形参和请求体中的参数映射</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;json&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JsonController</span> &#123;<br>    <span class="hljs-meta">@RequestMapping(&quot;data&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">data</span> <span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Person person)</span> &#123;<br>        System.out.println(person.toString());<br>        <span class="hljs-keyword">return</span> person.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="路径传参"><a href="#路径传参" class="headerlink" title="路径传参"></a>路径传参</h3><p>路径传参我们在vue的路由传参中接触过</p><h5 id="PathVariable"><a href="#PathVariable" class="headerlink" title="@PathVariable"></a>@PathVariable</h5><ul><li>value（name）属性：指定参数的名称，如果和参数名相同，则可以缺省</li><li>required属性：默认值为true，该属性配置是否允许不传递该参数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-meta">@RequestMapping(&quot;path&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PathController</span> &#123;<br>    <span class="hljs-meta">@RequestMapping(&quot;&#123;username&#125;/&#123;password&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">login</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> String username, <span class="hljs-meta">@PathVariable</span> String password)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;username = &quot;</span> + username + <span class="hljs-string">&quot; password = &quot;</span> + password);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当URI为：&#x2F;path&#x2F;xiaobai&#x2F;xiaobai，则传输username和password都为xiaobai</p><p>使用{username}&#x2F;{password}做占位符，在形参使用PathVariable注解修饰形参</p><p>就可以完成路径参数的接收了</p><hr><h3 id="SpringMVC-接收请求头和Cookie"><a href="#SpringMVC-接收请求头和Cookie" class="headerlink" title="SpringMVC-接收请求头和Cookie"></a>SpringMVC-接收请求头和Cookie</h3><h5 id="Cookie的获取"><a href="#Cookie的获取" class="headerlink" title="Cookie的获取"></a>Cookie的获取</h5><p>在Servlet的学习中，我们使用request的方法Cookie[] getCookies() 来获取所有的Cookie</p><p>在SpringMVC中，我们使用@CookieValue注解的方式获取Cookie的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CookieController</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">data</span><span class="hljs-params">(<span class="hljs-meta">@CookieValue(&quot;cookieName&quot;)</span> String cookieValue)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;cookieValue = &quot;</span> + cookieValue);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ok&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="请求头的获取"><a href="#请求头的获取" class="headerlink" title="请求头的获取"></a>请求头的获取</h5><p>在Servlet的学习中，我们使用request的方法来获取请求头</p><table><thead><tr><th>API</th><th>说明</th></tr></thead><tbody><tr><td>String getHeader(String headerName)</td><td>根据头名称获取请求头</td></tr><tr><td>Emumeration&lt;String&gt; getHeaderNames()</td><td>获取所有请求头名字</td></tr><tr><td>String ContentType()</td><td>获取content-type请求头</td></tr></tbody></table><p>在SpringMVC中，我们使用@RequestHeader来获取请求头</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">data1</span><span class="hljs-params">(<span class="hljs-meta">@RequestHeader(&quot;host&quot;)</span> String host)</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;host = &quot;</span> + host);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ok&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>SSM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SpringMVC</title>
    <link href="/2024/06/20/SpringMVC/"/>
    <url>/2024/06/20/SpringMVC/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><p>Spring Web MVC 是基于servlet API构建的原始Web框架，本身被SpringFramework包含其中</p><ul><li>DispatcherServlet<ul><li>Servlet核心，用来接收request和返回response</li></ul></li><li>HandlerMapping<ul><li>缓存handler方法和地址</li><li><em>在普通的MVC中，我们通过模糊WebServlet注解的方式通过业务+方法名来调用业务接口</em></li></ul></li><li>HandlerAdapter<ul><li>简化参数处理，原始的参数转成handler需要的参数</li><li>简化数据响应，将handler返回的数据封装到response中x</li></ul></li><li>ViewResovler（视图解析器）<ul><li>简化URL的前缀和后缀，直接使用页面名字就能查找，方便查找</li></ul></li></ul><hr><h3 id="依赖导入"><a href="#依赖导入" class="headerlink" title="依赖导入"></a>依赖导入</h3><ul><li>SpringIoC</li><li>SpringMVC</li><li>Servlet</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/jakarta.servlet/jakarta.servlet-api --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>jakarta.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jakarta.servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;servlet.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h3 id="WebApplicationInitializer接口（祖宗）"><a href="#WebApplicationInitializer接口（祖宗）" class="headerlink" title="WebApplicationInitializer接口（祖宗）"></a>WebApplicationInitializer接口（祖宗）</h3><p>此接口由org.springframework.web提供，当web项目启动时，自动执行onStartup的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onStartup</span><span class="hljs-params">(ServletContext servletContext)</span> <span class="hljs-keyword">throws</span> ServletException &#123;&#125;<br></code></pre></td></tr></table></figure><p>我们最后使用的是具体实现类AbstractAnnotationConfigDispatcherServletInitializer，有着层层实现的关系</p><h5 id="AbstractContextLoaderInitializer"><a href="#AbstractContextLoaderInitializer" class="headerlink" title="AbstractContextLoaderInitializer"></a>AbstractContextLoaderInitializer</h5><p>这个类直接实现了WebApplicationInitializer接口，并且创建了一个重要的方法：createRootApplicationContext</p><h5 id="AbstractDispatcherServletInitializer"><a href="#AbstractDispatcherServletInitializer" class="headerlink" title="AbstractDispatcherServletInitializer"></a>AbstractDispatcherServletInitializer</h5><p>这个类继承了AbstractContextLoaderInitializer类，并且创建了另一个重要的方法：createServletApplicationContext</p><p>还有一个重要的方法：getServletMappings</p><h5 id="AbstractAnnotationConfigDispatcherServletInitializer"><a href="#AbstractAnnotationConfigDispatcherServletInitializer" class="headerlink" title="AbstractAnnotationConfigDispatcherServletInitializer"></a>AbstractAnnotationConfigDispatcherServletInitializer</h5><p>这个类继承了AbstractDispatcherServletInitializer类，并创建了两个抽象的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> Class&lt;?&gt;[] getRootConfigClasses();<br><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> Class&lt;?&gt;[] getServletConfigClasses();<br></code></pre></td></tr></table></figure><p>他进一步实现了createRootApplicationContext</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> WebApplicationContext <span class="hljs-title function_">createRootApplicationContext</span><span class="hljs-params">()</span> &#123;<br>    Class&lt;?&gt;[] configClasses = getRootConfigClasses(); <span class="hljs-comment">// 调用上面的抽象方法，由用户来返回这个配置类</span><br>    <span class="hljs-keyword">if</span> (!ObjectUtils.isEmpty(configClasses)) &#123;<br>        <span class="hljs-comment">// 利用配置类创建IoC对象</span><br>       <span class="hljs-type">AnnotationConfigWebApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigWebApplicationContext</span>();<br>       context.register(configClasses);<br>       <span class="hljs-keyword">return</span> context;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>还进一步实现了createServletApplicationContext</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> WebApplicationContext <span class="hljs-title function_">createServletApplicationContext</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 利用配置类创建IoC对象</span><br>    <span class="hljs-type">AnnotationConfigWebApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigWebApplicationContext</span>();<br>    Class&lt;?&gt;[] configClasses = getServletConfigClasses(); <span class="hljs-comment">// 调用上面的抽象方法，由用户来返回这个配置类</span><br>    <span class="hljs-keyword">if</span> (!ObjectUtils.isEmpty(configClasses)) &#123;<br>       context.register(configClasses);<br>    &#125;<br>    <span class="hljs-keyword">return</span> context;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="用户自定义初始化类"><a href="#用户自定义初始化类" class="headerlink" title="用户自定义初始化类"></a>用户自定义初始化类</h3><p>这个类就是用户自己编写的类，继承于AbstractAnnotationConfigDispatcherServletInitializer类</p><p>它的作用就是通过配置类对SpringMVC的项目进行初始化操作</p><p><em>真是忍不住吐槽这类名有点过于长了吧！！！</em> 😓</p><p>重写三个重要方法：</p><ul><li>getRootConfigClasses：提供配置类，其父类会对service，mapper层的IoC容器进行初始化</li><li>getServletConfigClasses：通过配置类对，其父类会对springMVC，controller层的IoC容器进行初始化</li><li>getServletMappings：配置SpringMVC内部自带的Servlet访问地址，<em>一般配置成 “&#x2F;”</em></li></ul><p>这三个都是以数组的方式返回值，我们只需要提供值，其父类会用值进行相应的初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xiaobai;<br><br><span class="hljs-keyword">import</span> com.xiaobai.config.MvcConfig;<br><span class="hljs-keyword">import</span> org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractAnnotationConfigDispatcherServletInitializer</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> String[] getServletMappings() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;/&quot;</span>&#125;;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;MvcConfig.class&#125;;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><h3 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h3><p>RequestMapping注解可以将Controller层的业务方法加入到HandlerMapping中</p><p>其中的值是URI访问地址，和JavaWeb中的WebServlet功能类似</p><p><em>注：书写形式没有那么规范，把&#x2F;user&#x2F;login写成user&#x2F;login也是可以的</em></p><p>在类上使用RequestMapping注解可提取前缀</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-meta">@RequestMapping(&quot;User&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br>    <span class="hljs-comment">// 如果括号中没有内容，则通过根访问，例如，这个index是通过/user/访问</span><br>    <span class="hljs-meta">@RequestMapping</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">index</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;login&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">login</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;register&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">register</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="多个访问方式和模糊访问"><a href="#多个访问方式和模糊访问" class="headerlink" title="多个访问方式和模糊访问"></a>多个访问方式和模糊访问</h5><p>使用方法基本与@WebServlet相同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 多个注解</span><br><span class="hljs-meta">@RequestMapping(</span><br><span class="hljs-meta">        &#123;</span><br><span class="hljs-meta">        &quot;register&quot;,&quot;regist&quot;</span><br><span class="hljs-meta">        &#125;</span><br><span class="hljs-meta">)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">register</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="指定请求方式"><a href="#指定请求方式" class="headerlink" title="指定请求方式"></a>指定请求方式</h5><p>默认情况下，不指定请求方式时，可以被任何请求方式访问</p><p>当不符合指定的请求方式时，会返回405，请求方式异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 设置login的请求方式只能为Post</span><br><span class="hljs-meta">@RequestMapping(value = &quot;login&quot;,method = RequestMethod.POST)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">login</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="注解扩展"><a href="#注解扩展" class="headerlink" title="注解扩展"></a>注解扩展</h5><p>以下注解的功能相同，但扩展的注解不能使用在类上，只能使用在方法上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;login&quot;,method = RequestMethod.GET)</span><br><span class="hljs-meta">@GetMapping</span><br><br><span class="hljs-meta">@RequestMapping(value = &quot;login&quot;,method = RequestMethod.POST)</span><br><span class="hljs-meta">@PostMapping</span><br><br><span class="hljs-meta">@RequestMapping(value = &quot;login&quot;,method = RequestMethod.PUT)</span><br><span class="hljs-meta">@PutMapping</span><br><br><span class="hljs-meta">@RequestMapping(value = &quot;login&quot;,method = RequestMethod.DELETE)</span><br><span class="hljs-meta">@DeleteMapping</span><br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>SSM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MyBatis-实用扩展</title>
    <link href="/2024/06/19/MyBatis-%E5%AE%9E%E7%94%A8%E6%89%A9%E5%B1%95/"/>
    <url>/2024/06/19/MyBatis-%E5%AE%9E%E7%94%A8%E6%89%A9%E5%B1%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Mybatis-实用扩展"><a href="#Mybatis-实用扩展" class="headerlink" title="Mybatis-实用扩展"></a>Mybatis-实用扩展</h1><h3 id="mapper包扫描"><a href="#mapper包扫描" class="headerlink" title="mapper包扫描"></a>mapper包扫描</h3><p>在配置mapper.xml时，我们需要在mybatis-config文件夹下使用mappers -&gt; mapper标签配置每一条mapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- Mapper注册：指定Mybatis映射文件的具体位置 --&gt;</span><br>    <span class="hljs-comment">&lt;!-- mapper标签：配置一个具体的Mapper映射文件 --&gt;</span><br>    <span class="hljs-comment">&lt;!-- resource属性：指定Mapper映射文件的实际存储位置，这里需要使用一个以类路径根目录为基准的相对路径 --&gt;</span><br>    <span class="hljs-comment">&lt;!--    对Maven工程的目录结构来说，resources目录下的内容会直接放入类路径，所以这里我们可以以resources目录为基准 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;mapper/EmployeeMapper.xml&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br></code></pre></td></tr></table></figure><p>我们可以通过包扫描的方式，批量添加mapper.xml文件，但这样做有几个要求：</p><ul><li>要求mapper.xml和mapper接口的名字必须相同</li><li>要求编译后的mapper.xml和mapper接口在同一个文件夹下<ul><li>解决这个问题的最好方案就是在resources文件夹下建立相同的文件结构</li></ul></li></ul><p><em>想要一次性创建多层目录结构，使用分隔符不再是 . 而是 &#x2F;</em></p><p><img src="/upload/mapper%E5%8C%85%E6%89%AB%E6%8F%8F.png" alt="mapper包扫描.png"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.xiaobai.mapper&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h3 id="PageHelper插件"><a href="#PageHelper插件" class="headerlink" title="PageHelper插件"></a>PageHelper插件</h3><p>MyBatis 的插件机制包括以下三个组件：</p><ul><li><p><code>Interceptor</code>（拦截器）：定义一个拦截方法 <code>intercept</code>，该方法在执行 SQL 语句、执行查询、查询结果的映射时会被调用</p></li><li><p><code>Invocation</code>（调用）：实际上是对被拦截的方法的封装，封装了 <code>Object target</code>、<code>Method method</code> 和 <code>Object[] args</code> 这三个字段</p></li><li><p><code>InterceptorChain</code>（拦截器链）：对所有的拦截器进行管理，包括将所有的 Interceptor 链接成一条链，并在执行 SQL 语句时按顺序调用</p></li></ul><p><em>我们使用的pagehelper插件在Interceptor之中，拦截sql语句并拼接代码</em></p><hr><blockquote><p>当时我们前端工程化的微头条项目中用servlet手搓了分页：笔记 -&gt; 前端工程化 -&gt; 微头条项目开发 -&gt; 分页</p></blockquote><p>Mybatis提供了很多Sql追加插件，其中最著名的就是PageHelper插件</p><p><a href="https://github.com/pagehelper/Mybatis-PageHelper/tree/master">pagehelper&#x2F;Mybatis-PageHelper: Mybatis通用分页插件 (github.com)</a></p><p>分页的limit大概为：</p><p>通过pageNum（当前页码数）和pageSize（每页显示数量）来计算limit所需要的参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">(PageNum() - <span class="hljs-number">1</span>) * PageSize();<span class="hljs-comment">// limit参数1：从第几条参数（用页码*每页数据量）</span><br>PageSize();<span class="hljs-comment">// limit参数2：返回多少条数据</span><br></code></pre></td></tr></table></figure><p>而PageHelper会接手这个过程，只需要提供pageNum和pageSize，PageHelper会自动生成limit语句并拼接在原有的sql之后</p><hr><h5 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h5><p>在maven中添加pagehelper依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.pagehelper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>pagehelper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;pagehelper.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在mybatis配置文件（mybatis-config.xml）中添加插件</p><p><em>在配置文件的dtd中，我们可以看到各个标签的先后顺序，plugin标签在environment标签之前</em></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span> <span class="hljs-attr">interceptor</span>=<span class="hljs-string">&quot;com.github.pagehelper.PageInterceptor&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--分页插件的拼接方式为mysql--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;helperDialect&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;mysql&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h5 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h5><p>mapper中的sql语句正常书写</p><p><em>注：不要加limit关键字，<strong>并且不能以分号结尾</strong></em></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;queryAll&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Employee&quot;</span>&gt;</span><br>    select *<br>    from t_emp<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>使用时，调用PageHelper.startPage方法将pageNum和pageSize参数传入</p><p><em>注：在startPage和PageInfo中只能有一条查询语句，不能将两条查询sql装载到同一个分页插件中去</em></p><p>查询后，将查询数据封装到PageInfo实体类中</p><p><em>在之前的学习中，我们使用vo对象来接受分页五大件的所有信息，现在我们使用PageInfo实体类来接收</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">EmployeeMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(EmployeeMapper.class);<br>    <span class="hljs-comment">// 配置pageNum和pageSize</span><br>    PageHelper.startPage(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br>    <br>    List&lt;Employee&gt; employees = mapper.queryAll();<br>    <span class="hljs-comment">// 使用PageInfo实体类封装分页五大件</span><br>    PageInfo&lt;Employee&gt; pageInfo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PageInfo</span>&lt;&gt;(employees);<br>&#125;<br></code></pre></td></tr></table></figure><p><em>PageHelper的开发者是国人，所以我们直接在idea中下载PageInfo类的源码即可查看其中获取数据的方法和中文注释！！！</em> 😊</p><hr><h3 id="逆向工程和MybatisX插件"><a href="#逆向工程和MybatisX插件" class="headerlink" title="逆向工程和MybatisX插件"></a>逆向工程和MybatisX插件</h3><p>ORM思维我们在JDBC的学习中曾经提到过，是对象到关系数据库的映射思想</p><p>Mybatis就是一个ORM思维的持久性框架，使用面向对象思维进行数据库操作</p><hr><h5 id="半自动和全自动"><a href="#半自动和全自动" class="headerlink" title="半自动和全自动"></a>半自动和全自动</h5><p>hibernate就是典型的全自动ORM框架，程序员做ORM的配置文件映射，由框架生成sql语句</p><p>mybatis就是半自动ORM框架，虽然提供了crud的方法，但需要程序员手写sql语句</p><p>时代发展如今，人们期望半自动ORM框架也能实现单表的crud自动生成，这个工程就是逆向工程</p><p><em>在后面回学习mybatis-plus，其中就包含单表crud的mapper</em></p><p><em>注：无论是mybatis-plus还是逆向工程，都是针对单表的crud</em></p><hr><h5 id="MyBatisX插件"><a href="#MyBatisX插件" class="headerlink" title="MyBatisX插件"></a>MyBatisX插件</h5><ul><li><p>这个插件在idea中安装，且idea默认不带这个插件</p></li><li><p>安装后用idea连接数据库</p></li><li><p>选择表右键使用MyBatisX插件逆向工程生成文件</p></li></ul><p><img src="/upload/MybatisX.png" alt="MybatisX.png"></p><p><img src="/upload/MybatisX2.png" alt="MybatisX2.png"></p><p>至此，单表的增删改查和实体类全部被生成</p><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>SSM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MyBatis-动态语句</title>
    <link href="/2024/06/19/MyBatis-%E5%8A%A8%E6%80%81%E8%AF%AD%E5%8F%A5/"/>
    <url>/2024/06/19/MyBatis-%E5%8A%A8%E6%80%81%E8%AF%AD%E5%8F%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="Mybatis-动态语句"><a href="#Mybatis-动态语句" class="headerlink" title="Mybatis-动态语句"></a>Mybatis-动态语句</h1><p>动态 SQL 是 MyBatis 的强大特性之一</p><p>通过在mapper.xml的标签来拼接所需的sql语句，例如不同的where条件 </p><hr><h3 id="if标签"><a href="#if标签" class="headerlink" title="if标签"></a>if标签</h3><p>使用if标签可实现动态的sql语句</p><p>如果test属性中表达式的值为true，则将标签内的sql语句进行拼接，反之则忽略</p><p>test属性中的表达式的书写规则：</p><ul><li>逻辑与用and，逻辑或用or</li><li>比较符号不推荐直接使用 <code>&lt;</code> <code>&gt;</code>因为老版本的MyBatis会错误的识别成标签结束符号，推荐使用实体符号<ul><li>实体符号是html中曾经使用过的转义符号：大于号用<code>&amp;gt</code>  小于号用<code>&amp;lt</code></li></ul></li></ul><hr><h3 id="where标签"><a href="#where标签" class="headerlink" title="where标签"></a>where标签</h3><ul><li>如果where标签的子标签if标签满足条件，则会自动添加where关键字，反之缺省where关键字</li><li>自动去掉多余的and和or关键字</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;queryByNameAndSalary&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;employee&quot;</span>&gt;</span><br>    select *<br>    from t_emp<br>    <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;name != null&quot;</span>&gt;</span><br>            emp_name = #&#123;name&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;salary != null&quot;</span>&gt;</span><br>            and emp_salary = #&#123;salary&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h3 id="set标签"><a href="#set标签" class="headerlink" title="set标签"></a>set标签</h3><p>和where标签功能大致相同，用于取代原本sql的update关键字</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;update&quot;</span>&gt;</span><br>    update t_emp<br>    <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;empName!=null&quot;</span>&gt;</span><br>            emp_name = #&#123;empName&#125; ,<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;empSalary!=null&quot;</span>&gt;</span><br>            emp_salary = #&#123;empSalary&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br>    where emp_id = #&#123;empId&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h3 id="trim标签"><a href="#trim标签" class="headerlink" title="trim标签"></a>trim标签</h3><p><em>trim中文释义：修剪</em></p><p>trim标签相当于自定义模式，用以替代where和set标签</p><ul><li>prefix属性：如果if成立并且其标签下的语句存在，则自动补全prefix的值</li><li>prefixOverrides属性：自动修剪sql前多余的语句</li><li>suffixOverrides属性：自动修剪sql后多余的语句</li></ul><p><em>可以理解成where和set只是定义好的trim</em></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;queryByNameAndSalaryTrim&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;employee&quot;</span>&gt;</span><br>    select *<br>    from t_emp<br>    <span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">&quot;where&quot;</span> <span class="hljs-attr">prefixOverrides</span>=<span class="hljs-string">&quot;and&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;name != null&quot;</span>&gt;</span><br>            emp_name = #&#123;name&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;salary != null&quot;</span>&gt;</span><br>            and emp_salary = #&#123;salary&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h3 id="choose、when和otherwise标签"><a href="#choose、when和otherwise标签" class="headerlink" title="choose、when和otherwise标签"></a>choose、when和otherwise标签</h3><p>这三个标签就相当于Java中的switch</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;queryByNameAndSalaryChoose&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;employee&quot;</span>&gt;</span><br>    select *<br>    from t_emp<br>    where<br>    <span class="hljs-tag">&lt;<span class="hljs-name">choose</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--根据名字查询--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;name != null&quot;</span>&gt;</span><br>            emp_name = #&#123;name&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--根据工资查询--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;salary != null&quot;</span>&gt;</span><br>            emp_salary = #&#123;salary&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--如果以上两个条件都不满足，则查询全部--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">otherwise</span>&gt;</span>1=1<span class="hljs-tag">&lt;/<span class="hljs-name">otherwise</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">choose</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>choose中一定会执行一个where的判断条件，所以无需使用where标签来考虑是否忽略where</p><p>choose中只会执行一个where的判断条件，所以无需考虑and或or的语句修建问题</p><p><em>无论是查询结果为一个对象还是一个集合，resultType都会选择实体类，如果是集合的话resultType也是填写其泛型</em></p><hr><h3 id="foreach标签"><a href="#foreach标签" class="headerlink" title="foreach标签"></a>foreach标签</h3><ul><li>collection属性：被遍历的数据<ul><li>使用param注解添加的别名</li><li>使用arg0</li><li>使用list</li></ul></li><li>open属性：遍历之前要追加的字符串</li><li>close属性：遍历结束要追加的字符串</li><li>separator属性：每次遍历的分隔符号（最后一个不加符号）</li><li>item属性：遍历项</li></ul><p><em>batch中文释义：批处理</em></p><hr><h5 id="mapper接口"><a href="#mapper接口" class="headerlink" title="mapper接口"></a>mapper接口</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 批量处理crud</span><br>List&lt;Employee&gt; <span class="hljs-title function_">queryBatch</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;ids&quot;)</span> List&lt;Integer&gt; ids)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">deleteBatch</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;ids&quot;)</span> List&lt;Integer&gt; ids)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">insertBatch</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;employees&quot;)</span> List&lt;Employee&gt; employees)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">updateBatch</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;employees&quot;)</span> List&lt;Employee&gt; employees)</span>;<br></code></pre></td></tr></table></figure><h5 id="批量查询"><a href="#批量查询" class="headerlink" title="批量查询"></a>批量查询</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--这个select不考虑传入的id集合为空的情况--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;queryBatch&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;employee&quot;</span>&gt;</span><br>    select * from t_emp<br>    where emp_id in<br>    <span class="hljs-comment">&lt;!--这个foreach的遍历结果为：(1,2,3,……)--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;ids&quot;</span> <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;id&quot;</span>&gt;</span><br>        #&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="批量删除"><a href="#批量删除" class="headerlink" title="批量删除"></a>批量删除</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteBatch&quot;</span>&gt;</span><br>    delete from t_emp<br>    where emp_id in<br>    <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;ids&quot;</span> <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;id&quot;</span>&gt;</span><br>        #&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="批量插入"><a href="#批量插入" class="headerlink" title="批量插入"></a>批量插入</h5><p>每一个item项中都是固定格式(empName,empSalary)所以没有遍历前后的追加括号</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertBatch&quot;</span>&gt;</span><br>    insert into t_emp(emp_name,emp_salary)<br>    values<br>    <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;employee&quot;</span>&gt;</span><br>        (#&#123;employee.empName&#125;,#&#123;employee.empSalary&#125;)<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="批量更新"><a href="#批量更新" class="headerlink" title="批量更新"></a>批量更新</h5><p>update比较特殊，没有什么能单独foreach的数据，所以将整条语句循环执行</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateBatch&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;employees&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;emp&quot;</span>&gt;</span><br>        update t_emp<br>        set emp_name = #&#123;emp.empName&#125;,emp_salary = #&#123;emp.empSalary&#125;<br>        where emp_id = #&#123;emp.empId&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br></code></pre></td></tr></table></figure><p>但这种操作需要开启数据库支持，在mybatis-config.xml配置文件中，url一项后增加<code>?allowMultiQueries=true</code>参数即可</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/mybatis-example?allowMultiQueries=true&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Zhuwenxue2002&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><hr><h3 id="sql-include标签"><a href="#sql-include标签" class="headerlink" title="sql&amp;include标签"></a>sql&amp;include标签</h3><p>通过使用sql将重复的sql代码提取出来，通过include重新引用</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectSql&quot;</span>&gt;</span><br>    select *<br>    from t_emp<br><span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;queryALl&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;employee&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;selectSql&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>SSM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>windows工具下载</title>
    <link href="/2024/06/19/windows%E5%B7%A5%E5%85%B7%E4%B8%8B%E8%BD%BD/"/>
    <url>/2024/06/19/windows%E5%B7%A5%E5%85%B7%E4%B8%8B%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<h1 id="DirectX修复工具"><a href="#DirectX修复工具" class="headerlink" title="DirectX修复工具"></a>DirectX修复工具</h1><p><a href="https://blog.csdn.net/vbcom/article/details/7396482">https://blog.csdn.net/vbcom/article/details/7396482</a></p><h1 id="HEU-KMS激活工具"><a href="#HEU-KMS激活工具" class="headerlink" title="HEU KMS激活工具"></a>HEU KMS激活工具</h1><p>地址1：<a href="https://wwi.lanzoup.com/b05gumbe">https://wwi.lanzoup.com/b05gumbe</a> 密码:9xum<br>地址2：<a href="https://www.123pan.com/s/xY3DVv-375HA">https://www.123pan.com/s/xY3DVv-375HA</a><br>地址3：<a href="https://github.com/zbezj/HEU_KMS_Activator/releases">https://github.com/zbezj/HEU_KMS_Activator/releases</a></p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
      <category>note</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>软路由</title>
    <link href="/2024/06/18/%E8%BD%AF%E8%B7%AF%E7%94%B1/"/>
    <url>/2024/06/18/%E8%BD%AF%E8%B7%AF%E7%94%B1/</url>
    
    <content type="html"><![CDATA[<h3 id="软路由"><a href="#软路由" class="headerlink" title="软路由"></a>软路由</h3><p><a href="https://firmware-selector.immortalwrt.org/">https://firmware-selector.immortalwrt.org/</a></p><p>插件推荐</p><ul><li>argo: 主题</li><li>ttyd: 网页端ssh命令行</li><li></li></ul><p><a href="https://cloud.tencent.com/developer/article/2036952">https://cloud.tencent.com/developer/article/2036952</a></p><p><a href="https://xiaobai0827.ddnsto.com/cgi-bin/luci/">https://xiaobai0827.ddnsto.com/cgi-bin/luci/</a></p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
      <category>note</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MyBatis-多表查询</title>
    <link href="/2024/06/16/MyBatis-%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/"/>
    <url>/2024/06/16/MyBatis-%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="MyBatis-多表查询"><a href="#MyBatis-多表查询" class="headerlink" title="MyBatis-多表查询"></a>MyBatis-多表查询</h1><ul><li><p>多表查询的sql语句仍然需要我们自己编写（连接查询）</p></li><li><p>自己设计存储数据的实体类，承接多个表的查询结果</p></li><li><p>使用自定义结果集映射（resultMap）</p></li></ul><hr><h3 id="多表之间的关系"><a href="#多表之间的关系" class="headerlink" title="多表之间的关系"></a>多表之间的关系</h3><p>在数据库中，多表之间存在多个关系：</p><ul><li>一对一</li><li>一对多</li><li>多对多</li></ul><p>但在实体类中，多实体类中只看单向的关系，比如：</p><p>一个客户对应多个订单，就是<strong>对多</strong>的关系</p><p>一个订单对应多个客户，就是<strong>对一</strong>的关系</p><p><em>在微头条项目中，我们学会了值对象（VO），使用这种对象可以接受数据库多表查询的结果</em></p><p>而现在，我们解决多表查询的方法是，将一个实体类对象作为属性放到另一个实体类中</p><p><strong>如果为对一关系，比如上面的例子，就在订单实体类中存放一个客户实体类对象作为属性</strong></p><p><strong>如果为对多关系，比如上面的例子，就在客户实体类中存放一个类型为客户实体类的List集合作为属性</strong></p><p><em>在实际开发中，只有在查询所需时才修改实体类，并且修改时只做一个实体类的修改，其对应的不需要考虑</em></p><hr><h3 id="对一映射"><a href="#对一映射" class="headerlink" title="对一映射"></a>对一映射</h3><h5 id="pojo"><a href="#pojo" class="headerlink" title="pojo"></a>pojo</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> customerId;<br>    <span class="hljs-keyword">private</span> String customerName;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Order</span> &#123;<br>    <span class="hljs-keyword">private</span> Integer orderId;<br>    <span class="hljs-keyword">private</span> String orderName;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> customerId;<br>    <span class="hljs-keyword">private</span> Customer customer;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="mapper接口"><a href="#mapper接口" class="headerlink" title="mapper接口"></a>mapper接口</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">OrderMapper</span> &#123;<br>    Order <span class="hljs-title function_">queryOrderById</span><span class="hljs-params">(Integer id)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="mapper-xml"><a href="#mapper-xml" class="headerlink" title="mapper.xml"></a>mapper.xml</h5><p>使用resultMap标签为查询结果做映射</p><p>通过association，即可为对象中的对象属性做映射，在标签中套用子标签即可赋值对象属性的属性</p><ul><li>property属性：属性名</li><li>javaType：类的全限定符或类别名</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.xiaobai.mapper.OrderMapper&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;orderMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;order&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;order_id&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;orderId&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;order_name&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;orderName&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;customer_id&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;customerId&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!--给对象赋值--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;customer&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;customer&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;customer_id&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;customerId&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;customer_name&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;customerName&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">association</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;queryIdby&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;orderMap&quot;</span>&gt;</span><br>        select * from t_order tor join t_customer tur<br>        on tor.customer_id = tur.customer_id<br>        where tor.order_id = #&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h3 id="对多映射"><a href="#对多映射" class="headerlink" title="对多映射"></a>对多映射</h3><h5 id="pojo-1"><a href="#pojo-1" class="headerlink" title="pojo"></a>pojo</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> customerId;<br>    <span class="hljs-keyword">private</span> String customerName;<br><br>    <span class="hljs-keyword">private</span> List&lt;Order&gt; orders;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Order</span> &#123;<br>    <span class="hljs-keyword">private</span> Integer orderId;<br>    <span class="hljs-keyword">private</span> String orderName;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> customerId;<br>    <span class="hljs-keyword">private</span> Customer customer;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="mapper接口-1"><a href="#mapper接口-1" class="headerlink" title="mapper接口"></a>mapper接口</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">CustomerMapper</span> &#123;<br>    List&lt;Customer&gt; <span class="hljs-title function_">selectAllCustomer</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="mapper-xml-1"><a href="#mapper-xml-1" class="headerlink" title="mapper.xml"></a>mapper.xml</h5><p>使用resultMap标签为查询结果做映射</p><p>通过collection，即可为对象中的List集合属性做映射，在标签中套用子标签即可赋值集合中对象属性的属性</p><ul><li>property属性：属性名</li><li>ofType：集合的泛型，也就是集合中的对象的数据类型</li></ul><p><em>注：我们在进行两个表的相互映射过程中，只考虑单向的映射关系，比如在这个例子中，我们在List集合中的order对象中也存在customer对象，但不要映射此对象，否则会出现映射循环</em></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.xiaobai.mapper.CustomerMapper&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;customerMapper&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;customer&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;customer_id&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;customerId&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;customer_name&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;customerName&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!--映射集合对象--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;orders&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;order&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;order_id&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;orderId&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;order_name&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;orderName&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;customer_id&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;customerId&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectAllCustomer&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;customerMapper&quot;</span>&gt;</span><br>        select *<br>        from t_order tor join t_customer tur<br>        on tor.customer_id = tur.customer_id<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h3 id="autoMapppingBehavior"><a href="#autoMapppingBehavior" class="headerlink" title="autoMapppingBehavior"></a>autoMapppingBehavior</h3><p>配置mybatis-config.xml的setting标签，开启此功能，指定 MyBatis 应如何自动映射列到字段或属性</p><p><em><strong>注：仅仅映射result也就是常规列的内容，主键列不会自动映射</strong></em></p><p>value属性有三个选项值：</p><ul><li>NONE：关闭自动映射</li><li>PARTIAL：部分映射</li><li>FULL：深度映射</li></ul><p>默认情况下，resultMap只会映射一层result的标签，也就是说，不支持对一和对多映射对象属性（集合属性）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 开启MyBaits日志输出 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;logImpl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;STDOUT_LOGGING&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!-- 开启MyBaits驼峰式映射 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--开启MyBatis自动映射列到字段或属性（单一层次）--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;autoMappingBehavior&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;PARTIAL&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br></code></pre></td></tr></table></figure><p>value值更改为FULL，则开启深层次映射</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 开启MyBaits日志输出 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;logImpl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;STDOUT_LOGGING&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!-- 开启MyBaits驼峰式映射 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--开启MyBatis自动映射列到字段或属性（单一层次）--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;autoMappingBehavior&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;FULL&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml">    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;customerMapper&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;customer&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;customer_id&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;customerId&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!--        &lt;result column=&quot;customer_name&quot; property=&quot;customerName&quot;/&gt;--&gt;</span><br>        <span class="hljs-comment">&lt;!--映射集合对象--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;orders&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;order&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;order_id&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;orderId&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!--            &lt;result column=&quot;order_name&quot; property=&quot;orderName&quot;/&gt;--&gt;</span><br><span class="hljs-comment">&lt;!--            &lt;result column=&quot;customer_id&quot; property=&quot;customerId&quot;/&gt;--&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br></code></pre></td></tr></table></figure><p><em>在进行深层次映射时，我不禁想到一个问题，深层次映射是否会导致映射循环</em></p><p><em>但仔细阅读代码发现，深层次映射也只是根据collection和association标签来进行映射</em></p><p><em>在resultMap中，当发现对象属性（集合属性）则不进行自动映射，进而寻找collection（association）标签</em></p><p><em>一个标签代表着一个对象（一个集合），这样就完美的避免了映射循环的问题</em></p><hr><h3 id="嵌套选择"><a href="#嵌套选择" class="headerlink" title="嵌套选择"></a>嵌套选择</h3><p><code>&lt;association&gt;</code> 标签中的 <code>select</code> 和 <code>column</code> 属性是 MyBatis 提供的一种强大而灵活的功能，它允许你通过指定另一个 Mapper 接口的方法来加载关联对象。这种机制被称为 <strong>嵌套选择（Nested Select）</strong>，它是 MyBatis 结果映射的一部分，用于处理复杂的数据关系。</p><p> <code>&lt;association&gt;</code> 标签的作用</p><ul><li><strong><code>property</code></strong>：指定要映射到的结果对象的属性名称。</li><li><strong><code>javaType</code></strong>：指定该属性对应的 Java 类型。</li><li><strong><code>column</code></strong>：指定从主查询结果集中提取的列名或别名，作为参数传递给子查询。</li><li><strong><code>select</code></strong>：指定一个查询语句的 ID，通常是另一个 Mapper 接口中的方法名，用来执行子查询并填充关联对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;resultMap id=<span class="hljs-string">&quot;NodeVoResult&quot;</span> type=<span class="hljs-string">&quot;NodeVo&quot;</span>&gt;<br>    &lt;association property=<span class="hljs-string">&quot;region&quot;</span> javaType=<span class="hljs-string">&quot;Region&quot;</span> column=<span class="hljs-string">&quot;regionId&quot;</span> select=<span class="hljs-string">&quot;com.dkd.manage.mapper.RegionMapper.selectRegionById&quot;</span>/&gt;<br>    &lt;association property=<span class="hljs-string">&quot;partner&quot;</span> javaType=<span class="hljs-string">&quot;Partner&quot;</span> column=<span class="hljs-string">&quot;partnerId&quot;</span> select=<span class="hljs-string">&quot;com.dkd.manage.mapper.PartnerMapper.selectPartnerById&quot;</span>/&gt;<br>&lt;/resultMap&gt;<br></code></pre></td></tr></table></figure><p>在这里，mybatis会通过外键regionId和partnerId分别调用两个mapper的方法单独发送请求查询，并通过resultmap进行对象的映射</p><p>这种方式很相似在Service层调用多个Dao查询多个表，然后在Service层组织Vo返回，这里只不过是将组织Vo这一步骤放在Dao层，利用Mybatis的特性来解决</p><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>SSM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>The Role of Physical Exercise in University</title>
    <link href="/2024/06/14/The%20Role%20of%20Physical%20Exercise%20in%20University/"/>
    <url>/2024/06/14/The%20Role%20of%20Physical%20Exercise%20in%20University/</url>
    
    <content type="html"><![CDATA[<h1 id="The-Role-of-Physical-Exercise-in-University"><a href="#The-Role-of-Physical-Exercise-in-University" class="headerlink" title="The Role of Physical Exercise in  University"></a>The Role of Physical Exercise in  University</h1><p>Nowadays, the topic of physical exercise has attracted  public attention. However, a great number of college students still neglect the important role it plays in achieving success. </p><p>To list just a few of the benefits of taking physical exercise.  First of all, exercise on a regular basis, such as jogging and swimming, enhances our physical health, furthermore, keeps us energetic and vigorous in learning and working.</p><p>In addition, sports, such as football and basketball, can cultivate our team spirit, communicative capacity and leadership, and these vital skills will carry us further in career and social life. Most importantly, the sweat from exercise takes away our daily stress and anxiety.</p><p>In conclusion, we should never ignore the significance of physical activities. I am confident that a bringht future awaiting us. It is time to begin running! </p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
      <category>ccut</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MyBatis-测试方法封装</title>
    <link href="/2024/06/04/MyBatis-%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E5%B0%81%E8%A3%85/"/>
    <url>/2024/06/04/MyBatis-%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E5%B0%81%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h1 id="MyBatis-测试方法封装"><a href="#MyBatis-测试方法封装" class="headerlink" title="MyBatis-测试方法封装"></a>MyBatis-测试方法封装</h1><p>Junit5中提供了一些针对测试方法的注解</p><h3 id="BeforeEach"><a href="#BeforeEach" class="headerlink" title="@BeforeEach"></a>@BeforeEach</h3><p>在每一个测试方法之前都要执行的方法</p><h3 id="AfterEach"><a href="#AfterEach" class="headerlink" title="@AfterEach"></a>@AfterEach</h3><p>在每一个测试方法之后都要执行的方法</p><hr><h3 id="Mybatis测试改写"><a href="#Mybatis测试改写" class="headerlink" title="Mybatis测试改写"></a>Mybatis测试改写</h3><p>我们将读取文件创建流 -&gt; sqlSessionFactory -&gt; sqlSession -&gt; mapper 这一系列步骤进行封装</p><p>sqlSession是每次运行测试都要开启和关闭的，</p><p>所以将sqlSession的创建和mapper的创建写进@BeforeEach中</p><p>将sqlSession资源的关闭写进@AfterEach中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xiaobai.test;<br><br><span class="hljs-keyword">import</span> org.apache.ibatis.io.Resources;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSession;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;<br><span class="hljs-keyword">import</span> org.junit.jupiter.api.AfterEach;<br><span class="hljs-keyword">import</span> org.junit.jupiter.api.BeforeEach;<br><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.InputStream;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBatisTest</span> &#123;<br>    InputStream is;<br>    SqlSession sqlSession;<br>    UserMapper mapper;<br><br>    &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            is = Resources.getResourceAsStream(<span class="hljs-string">&quot;mybatis-config.xml&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sqlSessionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(is);<br><br><br>    <span class="hljs-meta">@BeforeEach</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUp</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        sqlSession = sqlSessionFactory.openSession();<br>    &#125;<br><br>    <span class="hljs-meta">@AfterEach</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tearDown</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        sqlSession.close();<br>    &#125;<br>…………<br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>SSM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MyBatis-mapper.xml</title>
    <link href="/2024/06/03/MyBatis-mapper.xml/"/>
    <url>/2024/06/03/MyBatis-mapper.xml/</url>
    
    <content type="html"><![CDATA[<h1 id="Mybatis-mapper-xml"><a href="#Mybatis-mapper-xml" class="headerlink" title="Mybatis-mapper.xml"></a>Mybatis-mapper.xml</h1><p>使用根标签mapper的namespace属性配置接口</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><br><span class="hljs-comment">&lt;!--这句话是文档类型声明，用以写xml文件约束，不是根标签--&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--根标签mapper，namespace属性的值是与之对应接口的全路径名--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.xiaobai.mapper.EmployeeMapper&quot;</span>&gt;</span><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在根标签中可以使用子标签写crud的sql语句，每一个根标签都对应着Mapper接口中的一个具体的功能方法，也对应其具体的实现</p><ul><li><p>select标签：查找的SQL语句标签</p><ul><li>id属性：对应Mapper接口的方法名</li><li>resultType属性：对应SQL语句的返回值类型</li></ul></li><li><p>insert</p><ul><li>id属性：对应Mapper接口的方法名</li><li>useGeneratedKeys：开启主键回显</li><li>keyColumn：要回显的列名</li><li>keyProperty：对应回显的属性名</li></ul></li><li><p>update</p><ul><li>id属性：对应Mapper接口的方法名</li></ul></li><li><p>delete</p><ul><li>id属性：对应Mapper接口的方法名</li></ul></li></ul><p><em>注：在mapper接口中，不能进行方法的重载，标签与方法的映射是通过方法名实现，重载是同名不同参</em></p><hr><h3 id="和-两种占位符"><a href="#和-两种占位符" class="headerlink" title="# 和 $ 两种占位符"></a># 和 $ 两种占位符</h3><p>#{ key }：先将 ? 赋值给此处，再将具体的值赋值给 ? </p><p>${ key }：直接进行字符串拼接</p><p>推荐使用#{ key }，防止注入攻击，但#{ key }的方式只能替代参数值</p><p>${ key }的方式可以替代容器名（标签、列名、关键字），使用此方式能实现容器名的动态</p><p><em>在JDBC中，我们使用PreparedStatement代替Statement解决注入攻击问题</em></p><hr><h3 id="key占位符"><a href="#key占位符" class="headerlink" title="key占位符"></a>key占位符</h3><h5 id="单个参数"><a href="#单个参数" class="headerlink" title="单个参数"></a>单个参数</h5><p>当传入单个简单类型时，这个key随意写，但习惯于使用参数名，保证代码规范</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;queryEmployeeById&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.xiaobai.pojo.Employee&quot;</span>&gt;</span><br>    select emp_id empId, emp_name empName , emp_salary empSalary<br>    from t_emp where emp_id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteById&quot;</span>&gt;</span><br>    delete from t_emp where emp_id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;queryBySalary&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.xiaobai.pojo.Employee&quot;</span>&gt;</span><br>    select emp_id empId, emp_name empName , emp_salary empSalary<br>    from t_emp where emp_salary = #&#123;salary&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h5 id="实体类对象"><a href="#实体类对象" class="headerlink" title="实体类对象"></a>实体类对象</h5><p>当传入对象为实体类对象时，key写该对象的属性名</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertEmployee&quot;</span>&gt;</span><br>    insert into t_emp (emp_name , emp_salary) values (#&#123;empName&#125;,#&#123;empSalary&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h5 id="多个参数"><a href="#多个参数" class="headerlink" title="多个参数"></a>多个参数</h5><p>当传入多个简单类型时，有两个方案写key</p><p>注解指定：在形参列表中使用@param注解指定，注解的值即为key的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Employee&gt; <span class="hljs-title function_">queryByNameAndSalary</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;name&quot;)</span> String name, <span class="hljs-meta">@Param(&quot;salary&quot;)</span> Double salary)</span>;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;queryByNameAndSalary&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.xiaobai.pojo.Employee&quot;</span>&gt;</span><br>    select emp_id empId , emp_name empName , emp_salary empSalary<br>    from t_emp where emp_name = #&#123;name&#125; and emp_salary = #&#123;salary&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>MyBatis机制：在形参列表中的参数，从左到右依次对应arg0, arg1……</p><p><em>或者使用param1, param2……</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Employee&gt; <span class="hljs-title function_">queryByNameAndSalary</span><span class="hljs-params">(String name, Double salary)</span>;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;queryByNameAndSalary&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.xiaobai.pojo.Employee&quot;</span>&gt;</span><br>    select emp_id empId , emp_name empName , emp_salary empSalary<br>    from t_emp where emp_name = #&#123;arg0&#125; and emp_salary = #&#123;arg1&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;queryByNameAndSalary&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.xiaobai.pojo.Employee&quot;</span>&gt;</span><br>    select emp_id empId , emp_name empName , emp_salary empSalary<br>    from t_emp where emp_name = #&#123;param1&#125; and emp_salary = #&#123;param2&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h5 id="map集合参数"><a href="#map集合参数" class="headerlink" title="map集合参数"></a>map集合参数</h5><p>当传入的参数为map集合时，使用map集合的key值获取参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Map ：</span><br><span class="hljs-comment">// nameKey -&gt; nameValue</span><br><span class="hljs-comment">// salaryKey -&gt; salaryValue</span><br>List&lt;Employee&gt; <span class="hljs-title function_">queryByNameAndSalary</span><span class="hljs-params">(Map data)</span>;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;queryByNameAndSalary&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.xiaobai.pojo.Employee&quot;</span>&gt;</span><br>    select emp_id empId , emp_name empName , emp_salary empSalary<br>    from t_emp where emp_name = #&#123;nameKey&#125; and emp_salary = #&#123;salaryKey&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h3 id="resultType属性"><a href="#resultType属性" class="headerlink" title="resultType属性"></a>resultType属性</h3><p>当使用查询SQL语句时，我们需要使用resultType属性来配置返回结果的数据类型</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;queryEmployeeById&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.xiaobai.pojo.Employee&quot;</span>&gt;</span><br>    ……<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>类全名</li><li>别名简称</li></ul><p>MyBatis提供了72种默认的别名，这些都是我们常用的Java数据类型<a href="https://mybatis.org/mybatis-3/zh_CN/configuration.html#typeAliases">mybatis – MyBatis 3 | 配置</a></p><p>除此之外，用户可以自定义别名和使用类全名</p><hr><h5 id="自定义别名"><a href="#自定义别名" class="headerlink" title="自定义别名"></a>自定义别名</h5><p>在MyBatis配置文件（mybatis-config.xml）中配置别名</p><p>使用typeAlias标签为 Java 类型设置一个缩写名字</p><p><em>Aliases中文释义：别名</em></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">typeAlias</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">&quot;Employee&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.xiaobai.pojo.Employee&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><p>也可以指定一个包名，MyBatis会将这个包下所有的类分配别名，这个别名为类名的首字母小写形式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.xiaobai.pojo&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span><br></code></pre></td></tr></table></figure><p>当使用package批量管理时，可以使用注解@Alias为类起另外的名字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Alias(&quot;em&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span> &#123;<br>……<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="指定结果类型为Map"><a href="#指定结果类型为Map" class="headerlink" title="指定结果类型为Map"></a>指定结果类型为Map</h5><p>当我们返回结果是单个实体类对象但没有对应的实体类可以接值时，</p><p>我们可以使用map集合来接，key为列名，value为值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;String, Object&gt; <span class="hljs-title function_">queryMaxSalaryAndAverageSalary</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;queryEmployeeById&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;map&quot;</span>&gt;</span><br>    ……<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h5 id="指定结果类型为List"><a href="#指定结果类型为List" class="headerlink" title="指定结果类型为List"></a>指定结果类型为List</h5><p>当我们返回结果是多个实体类对象，但没有对应的实体类可以接值时，我们可以使用List集合来接</p><p><em><strong>注：当返回值为列表时，resultType属性只写List中的具体数据类型</strong></em></p><p>这是因为底层的iBatis的查询方法有两个：selectOne和selectList</p><p>但selectOne方法的本质时调用selectList方法查询集合后取第一个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; <span class="hljs-title function_">queryNamesBySalary</span><span class="hljs-params">(Double salary)</span>;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;queryNamesBySalary&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;string&quot;</span>&gt;</span><br>    select emp_name<br>    from t_emp<br>    where emp_salary &gt; #&#123;salary&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h3 id="insert标签及相关问题"><a href="#insert标签及相关问题" class="headerlink" title="insert标签及相关问题"></a>insert标签及相关问题</h3><h5 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h5><p>之前在配置文件中讲过，MyBaits会关闭自动提交（开启事务）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 在获取sqlSession时开启自动提交（关闭事务）</span><br></code></pre></td></tr></table></figure><p>或者在关闭连接之前手动提交事务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">sqlSession.commit(); <span class="hljs-comment">// 手动提交事务</span><br></code></pre></td></tr></table></figure><hr><h5 id="主键回显"><a href="#主键回显" class="headerlink" title="主键回显"></a>主键回显</h5><p>主键回显就是将数据库自动增长的主键会显到实体类中，业务层可获取到这个值</p><p>在insert标签中，使用属性配置主键回显</p><ul><li>useGeneratedKeys：开启主键回显</li><li>keyColumn：要回显的列名</li><li>keyProperty：对应回显的属性名</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertEmployee&quot;</span> <span class="hljs-attr">useGeneratedKeys</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">keyColumn</span>=<span class="hljs-string">&quot;emp_id&quot;</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;empId&quot;</span>&gt;</span><br>    insert into t_emp (emp_name , emp_salary) values (#&#123;empName&#125;,#&#123;empSalary&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h5 id="Mybatis维护主键自增"><a href="#Mybatis维护主键自增" class="headerlink" title="Mybatis维护主键自增"></a>Mybatis维护主键自增</h5><p>方案一：通过Java自带的工具类UUID随机生成id值，作为用户的唯一约束也就是主键值 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">TeacherMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(TeacherMapper.class);<br><span class="hljs-type">String</span> <span class="hljs-variable">uuid</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString().replaceAll(<span class="hljs-string">&quot;-&quot;</span>, <span class="hljs-string">&quot; &quot;</span>);<br>mapper.insert(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>(uuid,<span class="hljs-string">&quot;xiaobai&quot;</span>));<br></code></pre></td></tr></table></figure><hr><p>方案二：在mapper.xml中，使用insert子标签selectKey运行sql代码</p><ul><li>order属性：after|before      selectKey中代码在在sql语句之前还是之后执行</li><li>resultType属性：返回值类型</li><li>keyProperty属性：给实体类中哪一个属性赋值</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insert&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">selectKey</span> <span class="hljs-attr">order</span>=<span class="hljs-string">&quot;BEFORE&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;string&quot;</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;tId&quot;</span>&gt;</span><br>        select replace(uuid(),&quot;-&quot;,&quot; &quot;)<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">selectKey</span>&gt;</span><br>    insert into teacher (t_id,t_name)<br>    value (#&#123;tId&#125;,#&#123;tName&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure><p>先通过selectKey执行uuid()再使用replace()替换”-“为” “，然后将sql执行的结果以String接收后赋值给实体类的tId属性</p><p>这样再执行insert命令时，实体类的tId属性存在一个sql生成的uuid了</p><hr><h3 id="列名和属性名映射"><a href="#列名和属性名映射" class="headerlink" title="列名和属性名映射"></a>列名和属性名映射</h3><p>之前的学习中，我们针对属性名和别名不同的处理方式是起别名，但MyBatis为我们提供了更好的解决方式</p><p>在MyBatis配置文件（mybatis-config.xml）中配置settings项</p><p>开启mapUnderscoreToCamelCase为true，即可自动映射数据库列名和实体类属性名</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p><em>mapUnderscoreToCamelCase中文释义：映射下划线至驼峰</em></p><p><em>学到今天终于解决了这个问题了，开心！！！</em> 😊</p><hr><h3 id="ResultMap"><a href="#ResultMap" class="headerlink" title="ResultMap"></a>ResultMap</h3><p>resultType的是按照规则自动映射，如果开启驼峰转换后，resultType也只是按照驼峰转换的规则自动映射</p><p>resultType只能映射一层结构，多表查询的结果无法自动映射！！！</p><p>所以，我们可以使用resultMap标签新建自定义映射规则</p><ul><li>id属性：规则集别名</li><li>type：映射类型（命名方式与resultType相同，使用类全名或者 别名）</li></ul><h5 id="id标签"><a href="#id标签" class="headerlink" title="id标签"></a>id标签</h5><p>resultMap的子标签id，用来做主键列映射关系</p><h5 id="result标签"><a href="#result标签" class="headerlink" title="result标签"></a>result标签</h5><p>resultMap的子标签result，用来做非主键列映射关系</p><hr><p>在select标签中设置resultMap映射规则，值为其别名</p><p>这样就完成了利用resultMap去配置 列名和属性名映射</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;tMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.xiaobai.pojo.Teacher&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;t_id&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;tId&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;t_name&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;tName&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;queryById&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;tMap&quot;</span>&gt;</span><br>    select * from teacher where t_id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p><em>resultMap的功能远不止如此，我们在这里只是学习他的其中一种功能</em></p><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>SSM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MyBatis</title>
    <link href="/2024/06/03/MyBatis/"/>
    <url>/2024/06/03/MyBatis/</url>
    
    <content type="html"><![CDATA[<h1 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h1><p><a href="https://mybatis.net.cn/index.html">MyBatis中文网</a></p><p><a href="https://mybatis.org/mybatis-3/zh_CN/index.html">mybatis – MyBatis 3 | 简介</a></p><p>MyBatis最初是Apache的一个开源项目IBatis</p><p>2010年迁移到了Google Code，并且在iBatis3.x版本时正式更名为MyBatis，2013年迁移到Githubs</p><p><em>在Mybatis使用过程中，如果导包iBatis也属于正常现象</em></p><hr><h3 id="持久性框架对比"><a href="#持久性框架对比" class="headerlink" title="持久性框架对比"></a>持久性框架对比</h3><p>JDBC：</p><ul><li>SQL夹杂在Java代码中，耦合度高，导致硬编码内伤</li><li>维护不易且实际开发需求中SQL有变化，修改源码的情况多见</li><li>代码冗长，开发效率低</li></ul><p>Hibernate和JPA：</p><ul><li>操作简单，开发效率高</li><li>程序中长难复杂的SQL需要绕过框架</li><li>内部自动生成的SQL，不容易做特殊优化</li><li>基于全映射的全自动框架，大量字段的POJO部分进行映射比较困难</li><li>反射操作太多，导致数据库性能下降</li></ul><p>MyBatis：</p><ul><li>轻量级，性能出色</li><li>SQL和Java编码分开，功能边界清晰（Java代码专注于业务，SQL语句服务于数据）</li><li>开发效率稍逊色于Hibernate，但是能接受</li></ul><p>开发效率： Hibernate &gt; Mybatis &gt; JDBC</p><p>运行效率：JDBC &gt; Mybatis &gt;Hibernate</p><hr><h3 id="Mapper接口-MapperXML文件"><a href="#Mapper接口-MapperXML文件" class="headerlink" title="Mapper接口&amp;MapperXML文件"></a>Mapper接口&amp;MapperXML文件</h3><p>对比于之前学习的JDBC使用方式，MyBatis自带连接池，需要导入的依赖如下</p><ul><li>mybatis：MyBatis使用的核心依赖</li><li>mysql：MySQL数据库的驱动依赖</li></ul><p>在使用JDBC时，我们对数据库的操作是使用Dao和DaoImpl</p><p>在MyBatis中，对数据库操作使用Mapper和MapperXMl</p><p>其中，Mapper接口中不再有SQL语句，而是对数据库操作的功能方法，而MapperXML专门用来写SQL语句</p><blockquote><p>在com.xiaobai下新建软件包名为mapper，用以存放Mapper接口</p><p>在resources下建立目录名为mappers，用以存放MapperXML文件</p></blockquote><hr><h3 id="mybatis-config-xml"><a href="#mybatis-config-xml" class="headerlink" title="mybatis-config.xml"></a>mybatis-config.xml</h3><p>MyBatis不需要使用连接池，因为他自己内置了连接池</p><p>那么就需要为MyBatis配置一些参数（例如JDBC四大件）</p><p>以下代码是由尚硅谷提供的原生mybatis配置文件的写法</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">configuration</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- environments表示配置Mybatis的开发环境，可以配置多个环境，在众多具体环境中，使用default属性指定实际运行时使用的环境。default属性的取值是environment标签的id属性的值。 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- environment表示配置Mybatis的一个具体的环境 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- Mybatis的内置的事务管理器 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br>            <span class="hljs-comment">&lt;!-- 配置数据源 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>                <span class="hljs-comment">&lt;!-- 建立数据库连接的具体信息 --&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/mybatis-example&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- Mapper注册：指定Mybatis映射文件的具体位置 --&gt;</span><br>        <span class="hljs-comment">&lt;!-- mapper标签：配置一个具体的Mapper映射文件 --&gt;</span><br>        <span class="hljs-comment">&lt;!-- resource属性：指定Mapper映射文件的实际存储位置，这里需要使用一个以类路径根目录为基准的相对路径 --&gt;</span><br>        <span class="hljs-comment">&lt;!-- 对Maven工程的目录结构来说，resources目录下的内容会直接放入类路径，所以这里我们可以以resources目录为基准 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;mappers/EmployeeMapper.xml&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h3 id="MyBatis原生调用"><a href="#MyBatis原生调用" class="headerlink" title="MyBatis原生调用"></a>MyBatis原生调用</h3><p>在之前原生JDBC的学习中，我们最后通过Dao调用JDBC的的过程是：</p><p>DAO -&gt; BaseDao -&gt; JDBCUtil</p><p>其实使用起来也是比较麻烦，只是两个工具类为我们封装好了对象和方法而已</p><p>后来学习了JDBCTemplate，才简化了这两个类和对JDBC的操作</p><p>原生的MyBatis在调用起来也是一样的麻烦，但后面由SpringIoC接管后，这个过程就会被简化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MybatisTest</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 使用流读取外部配置文件（mybatis-config.xml）</span><br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> Resources.getResourceAsStream(<span class="hljs-string">&quot;mybatis-config.xml&quot;</span>);<br>        <br>        <span class="hljs-comment">// 创建sqlSessionFactory 这个对象是带有配置的模板，全局唯一</span><br>        <span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sqlSessionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(is);<br>        <br>        <span class="hljs-comment">// 使用sqlSessionFactory创建sqlSession 每个业务创建一个sqlSession，相当一次会话，用完释放</span><br>        <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession();<br>        <br>        <span class="hljs-comment">// 获取接口的代理对象，这个接口没有具体的实现类，他代理的是Mapper接口的方法+mapperXMl中的sql语句</span><br>        <span class="hljs-type">EmployeeMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(EmployeeMapper.class);<br>        <span class="hljs-type">Employee</span> <span class="hljs-variable">employee</span> <span class="hljs-operator">=</span> mapper.queryById(<span class="hljs-number">1</span>);<br>        System.out.println(<span class="hljs-string">&quot;employee = &quot;</span> + employee);<br>        <br>        <span class="hljs-comment">// 提交事务（非DQL）和释放资源</span><br>        sqlSession.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>注：mybatis在配置中是针对非查询开启事务的，所以在执行非查询的时候要提交事务</em></p><h5 id="事务管理器"><a href="#事务管理器" class="headerlink" title="事务管理器"></a>事务管理器</h5><p>在 MyBatis 中有两种类型的事务管理器<br>JDBC – 这个配置直接使用了 JDBC 的提交和回滚功能，它依赖从数据源获得的连接来管理事务作用域。默认情况下，为了与某些驱动程序兼容，它在关闭连接时启用自动提交。然而，对于某些驱动程序来说，启用自动提交不仅是不必要的，而且是一个代价高昂的操作。因此，从 3.5.10 版本开始，你可以通过将 “skipSetAutoCommitOnClose” 属性设置为 “true” 来跳过这个步骤。例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;skipSetAutoCommitOnClose&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">transactionManager</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="iBatis"><a href="#iBatis" class="headerlink" title="iBatis"></a>iBatis</h3><p>与MyBatis不同，iBatis没有Mapper接口</p><p>在调用iBatis时，不使用代理模式，sqlSession对象提供了增删改查方法，由此对象直接调用标签中的sql语句完成增删改查</p><p>sqlSession在调用增删改查的方法时，将mapper标签的namespace + crud标签的id值作为参数传递进去</p><p>缺点：</p><ul><li>传入的标签定位参数是一个字符串，没有报错提示，容易写错</li><li>sql的参数需要整合，每次只能传递一个参数</li><li>返回值类型为Object，需要强制转型</li></ul><hr><h5 id="执行逻辑"><a href="#执行逻辑" class="headerlink" title="执行逻辑"></a>执行逻辑</h5><p>iBatis将MapperXML文件中的sql语句，存成类似键值对的形式</p><p>键：mapper标签的namespace + crud标签的id值 ，值：sql语句</p><p>mybatis-config.xml，配置好四大件之后将数据库信息缓存，同时将mapper.xml的sql语句（键值对缓存起来）</p><p>调用iBatis时，通过配置文件读取到四大件和sql，创建SqlSession工厂，创建SqlSession</p><p>调用SqlSession的增删改查时，就是在缓存中通过key找到value，带入对sql的参数并执行</p><hr><h3 id="MyBatis执行逻辑"><a href="#MyBatis执行逻辑" class="headerlink" title="MyBatis执行逻辑"></a>MyBatis执行逻辑</h3><p><img src="/upload/Mybatis.png" alt="Mybatis.png"></p><p>为了解决iBatis存在的问题，多建立一个对应mapper.xml的接口</p><p>Mapper接口中的全限定类名对应mapper标签的namespace属性值</p><p>Mapper接口中的方法名对应crud标签的id值</p><p>这样，全限定类名+方法名的格式，也能找到具体的sql语句</p><hr><h5 id="代理技术"><a href="#代理技术" class="headerlink" title="代理技术"></a>代理技术</h5><p>通过SqlSession对象调用getMapper，将接口的类对象作为参数传入</p><p>底层使用JDK动态代理，为此接口生成一个代理对象，利用反射的机制获取到接口的全类名和要执行的方法名</p><p>这个全类名和方法名拼成字符串（这也是IBatis时调用具体方法的所需参数），再去<strong>调用iBatis对应的方法</strong></p><p>使用代理模式对接口内容进行丰富，将mapper.xml的sql内容填入其中，形成一个对象</p><p>使用对象调用接口的方法，我们发现参数类型和返回值类型早已规定好</p><hr><h3 id="Mybatis日志输出"><a href="#Mybatis日志输出" class="headerlink" title="Mybatis日志输出"></a>Mybatis日志输出</h3><p><a href="https://mybatis.org/mybatis-3/zh_CN/configuration.html">mybatis – MyBatis 3 | 配置</a></p><p>MyBatis的中文官网为我们提供了非常完善的使用说明，其中就包括了MyBatis的配置文件（mybatis-config.xml）的标签含义</p><p>其中，settings标签可以配置 MyBatis 的运行时行为，是个极为重要的标签</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 开启MyBaits日志输出 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;logImpl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;STDOUT_LOGGING&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br>……<br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在之后的学习中，我们会学习更多的settings的配置参数，让MyBatis使用起来更简单</p><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>SSM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring-TX</title>
    <link href="/2024/05/30/Spring-TX/"/>
    <url>/2024/05/30/Spring-TX/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring-TX"><a href="#Spring-TX" class="headerlink" title="Spring-TX"></a>Spring-TX</h1><h3 id="编程式事务"><a href="#编程式事务" class="headerlink" title="编程式事务"></a>编程式事务</h3><blockquote><p>参考 JDBC -&gt; JDBC-事务</p></blockquote><p>编程式事务是指手动编写程序来管理事务，即通过代码的方式直接控制事务的提交和回滚</p><p>在之前的学习中，我们使用JDBC中的连接来控制事务的提交和回滚</p><p>但是编程式实现方式存在缺陷：</p><ul><li>细节没有被屏蔽：具体操作过程各种，所有细节都需要程序员来自己完成，比较繁琐</li><li>代码复用性低</li></ul><hr><h3 id="声明式事务"><a href="#声明式事务" class="headerlink" title="声明式事务"></a>声明式事务</h3><p>声明式事务是指用注解或XML的方式来控制事务的提交和回滚</p><p>我们可以使用AOP的思路来写事务增强，但Spring对事务的AOP进行了再次的封装，更加简化了我们的操作</p><hr><h5 id="Spring事务管理器"><a href="#Spring事务管理器" class="headerlink" title="Spring事务管理器"></a>Spring事务管理器</h5><p><img src="/upload/%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1.PNG" alt="声明式事务.PNG"></p><p>在Spring的底层实现中，创建了一个事务增强，又制作了一个事务管理器统一规范的接口</p><p>通过事务增强去调用事务管理器的接口完成事务的具体操作（开启，提交，回滚）</p><p>又针对于不同的框架制作了不同的事务管理器的具体实现类</p><p>当我们选择某一个具体框架的事务管理器实现类时，Spring会将这个实现类自动注入到事务增强调用的事务管理器的接口</p><ul><li>TransactionManager接口：事务管理器的统一接口</li><li>PlatformTansactionManager：统一接口的子接口，扩展实现<ul><li>DataSourceTransactionManager：实现类<ul><li>JDBC方式</li><li>JdbcTemplate方式</li><li>Mybatis方式</li></ul></li><li>HibernateTransactionManager：实现类<ul><li>hibernate方式</li></ul></li><li>JpaTransactionManager<ul><li>jpa方式</li></ul></li></ul></li></ul><p><em>注：DataSourceTransactionManager由spring-jdbc依赖提供，HibernateTransactionManager和JpaTransactionManager由spring-orm依赖提供</em></p><hr><h5 id="DataSourceTransactionManager"><a href="#DataSourceTransactionManager" class="headerlink" title="DataSourceTransactionManager"></a>DataSourceTransactionManager</h5><p>我们学习的事务管理器实现是DataSourceTransactionManager，用以整合JDBC、jdbcTemplate、Mybatis方式的事务实现</p><p>DataSourceTransactionManager的主要方法：</p><ul><li>doBegin()：开启事务</li><li>doSuspend()：挂起事务</li><li>doResume()：恢复挂起的事务</li><li>doCommit()：提交事务</li><li>doRollback()：回滚事务</li></ul><p><em>然而以上的方法我们都不会自己使用，因为框架帮我们完成了一切，我们只需要使用注解声明即可</em></p><hr><h3 id="基于注解的声明式事务"><a href="#基于注解的声明式事务" class="headerlink" title="基于注解的声明式事务"></a>基于注解的声明式事务</h3><p>导入依赖：</p><ul><li>spring-jdbc</li><li>spring-tx</li></ul><p><em>从6.1.8版本开始，tx为jdbc自动导入的依赖，所以无需导入</em></p><p>首先，我们在配置类中将事务管理器的实现添加到IoC容器中</p><p>事务管理器的实现中，要进行对事务的操作，需要使用<strong>连接池对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> TransactionManager <span class="hljs-title function_">transactionManager</span><span class="hljs-params">(DataSource dataSource)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataSourceTransactionManager</span>(dataSource);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="EnableTransactionManagement"><a href="#EnableTransactionManagement" class="headerlink" title="@EnableTransactionManagement"></a>@EnableTransactionManagement</h5><p>在配置类中加@EnableTransactionManagement注解，开启对事务注解的支持</p><hr><h3 id="Transactional"><a href="#Transactional" class="headerlink" title="@Transactional"></a>@Transactional</h3><p>这个注解的作用就是开启事务，它可以加载方法和类上：</p><ul><li>方法：方法开启事务</li><li>类：类中所有方法开启事务</li></ul><p>此时，方法就被Spring的事务管理器以AOP的方式接管了，如果方法执行有异常，则整个方法回滚，如果方法执行顺利，则事务提交</p><hr><h5 id="readOnly"><a href="#readOnly" class="headerlink" title="readOnly"></a>readOnly</h5><p>只读模式可以提高查询事务的效率，如果事务中只有查询代码，使用只读模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional(readOnly = true)</span><br></code></pre></td></tr></table></figure><p><em>当@Transactional注解到类时，推荐将类中调用查询的方法加入此注解和属性</em></p><hr><h5 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a>timeout</h5><p>事务在执行过程中，有可能因为遇到某些问题，导致程序卡住，从而长时间占用数据库</p><p>使用timeout属性设置事务的超时时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional(timeout = 5)</span> <span class="hljs-comment">// 单位：秒</span><br></code></pre></td></tr></table></figure><p>如果事务超时，则会报异常：TransactionTimedOutException</p><p><em>注：当类的注解有timeout属性时，方法如果也有注解但没有属性，方法的注解会覆盖类的注解！！！</em></p><hr><h5 id="rollbackFor-norollbackFor"><a href="#rollbackFor-norollbackFor" class="headerlink" title="rollbackFor&amp;norollbackFor"></a>rollbackFor&amp;norollbackFor</h5><p>事务的默认是发生运行时异常才会回滚，其他异常不会回滚（比如IO异常）</p><p>使用rollbackFor属性，调整为无论发生什么异常时都回滚事务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional(rollbackFor = Exception.class)</span><br></code></pre></td></tr></table></figure><p>norollbackFor可以放行某些异常，使某些异常发生时不回滚事务</p><hr><h5 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h5><p>数据库事务的隔离级别是指在多个事务并发执行时，数据库系统为了保证数据一致性所遵循的规定。常见的隔离级别包括：</p><ul><li><p>读未提交（Read Uncommitted）：事务可以读取未被提交的数据，容易产生脏读、不可重复读和幻读等问题。实现简单但不太安全，一般不用。</p></li><li><p>读已提交（Read Committed）：事务只能读取已经提交的数据，可以避免脏读问题，但可能引发不可重复读和幻读。</p></li><li><p>可重复读（Repeatable Read）：在一个事务中，相同的查询将返回相同的结果集，不管其他事务对数据做了什么修改。可以避免脏读和不可重复读，但仍有幻读的问题。</p></li><li><p>串行化（Serializable）：最高的隔离级别，完全禁止了并发，只允许一个事务执行完毕之后才能执行另一个事务。可以避免以上所有问题，但效率较低，不适用于高并发场景。</p></li></ul><p>不同的隔离级别适用于不同的场景，需要根据实际业务需求进行选择和调整</p><p><em>MySQL的默认隔离级别是可重复读（Repeatable Read）</em></p><p>使用isolation属性设置隔离级别，推荐设置为<em>读已提交（Read Committed）</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional(isolation = Isolation.READ_COMMITTED)</span><br></code></pre></td></tr></table></figure><hr><h5 id="事务传播行为"><a href="#事务传播行为" class="headerlink" title="事务传播行为"></a>事务传播行为</h5><p>事务之间也存在互相调用的情况，以事务的传播行为来决定事物之间调用的影响程度</p><p>事务传播行为的属性设定，是设置在子事务（方法）上的</p><p>使用propagation 属性设置事务的传播行为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>名称</th><th>含义</th></tr></thead><tbody><tr><td>REQUIRED  默认值</td><td>如果父方法有事务，就加入，如果没有就新建自己独立！</td></tr><tr><td>REQUIRES_NEW</td><td>不管父方法是否有事务，我都新建事务，都是独立的！</td></tr></tbody></table><p>如果父方法调用子方法，父方法有事务，使用REQUIRED时，子方法会加入父方法的事务中，形成一个事务</p><p>如果使用REQUIRES_NEW属性，方法之间事务独立，相互不影响</p><p><em>事务的传播行为一般都推荐用默认值，只有面试的情况下才会问相关问题！！！</em></p><p>在同一个类中，事务的传播行为不会生效，这是因为Spring框架中实际上是使用了代理模式实现事务机制</p><p>而代理是根据类来生成增强类，同一个类间的调用就不经过代理</p><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>SSM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring-AOP</title>
    <link href="/2024/05/28/Spring-AOP/"/>
    <url>/2024/05/28/Spring-AOP/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring-SpringAOP"><a href="#Spring-SpringAOP" class="headerlink" title="Spring-SpringAOP"></a>Spring-SpringAOP</h1><p>如果想使用注解的方式配置SpringAOP，需要导入以下依赖</p><ul><li>spring-aop：SpringAOP框架核心依赖，此依赖被spring-context导入，无需额外导入</li><li><strong>spring-aspectj</strong>：SpringAOP和AspectJ注解层联合依赖，需要导入</li><li>aspectj：Aspect J注解使用所需核心依赖，此依赖被spring-aspectj导入，无需额外导入</li></ul><p>Aspect J是早期AOP实现的框架，SpringAOP借用了AspectJ中AOP的注解</p><hr><h3 id="开启AspectJ注解支持"><a href="#开启AspectJ注解支持" class="headerlink" title="开启AspectJ注解支持"></a>开启AspectJ注解支持</h3><h5 id="配置类"><a href="#配置类" class="headerlink" title="配置类*"></a>配置类*</h5><p>在配置类中，使用@EnableAspectJAutoProxy注解开启AspectJ的注解支持</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableAspectJAutoProxy</span><br></code></pre></td></tr></table></figure><h5 id="xml配置文件"><a href="#xml配置文件" class="headerlink" title="xml配置文件"></a>xml配置文件</h5><p>使用aop:aspectj-autoproxy标签开启对AspectJ的注解支持</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:aspectj-autoproxy</span>/&gt;</span><br></code></pre></td></tr></table></figure><hr><h3 id="接入点"><a href="#接入点" class="headerlink" title="接入点"></a>接入点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-comment">// 前置</span><br><span class="hljs-comment">// 目标方法执行</span><br><span class="hljs-comment">// 返回</span><br>&#125;<span class="hljs-keyword">catch</span>()&#123;<br>    <span class="hljs-comment">// 异常</span><br>&#125;<span class="hljs-keyword">finally</span>&#123;<br><span class="hljs-comment">// 后置</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="增强类（通知）"><a href="#增强类（通知）" class="headerlink" title="增强类（通知）"></a>增强类（通知）</h3><p>为增强类配置两个注解：</p><ul><li>@Comonent：增强类同样要被IoC容器接管才可以生效</li><li>@Aspect：配置切面：切点+增强类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Comonent</span><br><span class="hljs-meta">@Aspect</span><br></code></pre></td></tr></table></figure><hr><h5 id="增强方法"><a href="#增强方法" class="headerlink" title="增强方法"></a>增强方法</h5><p>创建增强方法后，为每一个增强方法加注解确定切点位置</p><ul><li>前置通知：@Before</li><li>返回通知：@AfterReturning</li><li>异常通知：@AfterThrowing</li><li>后置通知：@After</li><li>环绕通知：@Around</li></ul><hr><p><strong>我们需要获取到增强的目标方法的信息：方法名、参数、访问修饰符、所属类的信息</strong></p><p>在增强方法的形参中，添加(JoinPoint joinPoint)，该参数为目标方法的封装对象，<strong>此形参适用于所有增强方法</strong></p><p><em>Signature中文释义：签名</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Before(&quot;execution(* com..impl.*.*(..))&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">(JoinPoint joinPoint)</span> &#123;<br>    <span class="hljs-comment">// 获取方法所属类的信息(获取方法所属对象 -&gt; 获取对象所属类 -&gt; 获取类名)</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">classname</span> <span class="hljs-operator">=</span> joinPoint.getTarget().getClass().getName();<br>    <span class="hljs-comment">// 获取方法名的信息(获取方法 -&gt; 获取方法名)</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> joinPoint.getSignature().getName();<br>    <span class="hljs-comment">// 获取方法的参数</span><br>    Object[] args = joinPoint.getArgs();<br>    <span class="hljs-comment">// 获取方法的访问修饰符（获取访问修饰符代码 -&gt; 映射访问修饰符字符串）</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">modifiers</span> <span class="hljs-operator">=</span> joinPoint.getSignature().getModifiers();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> Modifier.toString(modifiers);<br>&#125;<br></code></pre></td></tr></table></figure><hr><p><strong>在增强方法（AfterReturning）后，获取目标方法的执行结果</strong></p><p>通过@AfterReturning注释的属性returning配置接受返回结果的形参名</p><p>在形参列表中加(Object returnValue)，该参数为目标方法的返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AfterReturning(value = &quot;execution(* com..impl.*.*(..))&quot;,returning = &quot;returnValue&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterReturning</span><span class="hljs-params">(Object returnValue)</span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><p><strong>在出现异常（AfterThrowing）后，获取目标方法的异常信息</strong></p><p>通过@AfterThrowing注释的属性throwing配置接受异常信息的形参名</p><p>在形参列表中加(Throwable throwable)，该参数为目标方法的异常信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AfterThrowing(value = &quot;execution(* com..impl.*.*(..))&quot;,throwing = &quot;throwable&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterThrowing</span><span class="hljs-params">(Throwable throwable)</span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="切点表达式"><a href="#切点表达式" class="headerlink" title="切点表达式"></a>切点表达式</h3><p>AOP切点表达式（Pointcut Expression）是一种用于指定切点的语言</p><p>它可以通过定义匹配规则，来选择需要被切入的目标对象</p><p>在增强方法的注解之中，写切点表达式，表明在何位置进行代码的织入</p><hr><h5 id="具体写法"><a href="#具体写法" class="headerlink" title="具体写法"></a>具体写法</h5><p><em>excution中文释义：执行</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">execution(<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> com.xiaobai.spring.aop.target.Calculator.div(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>))<br></code></pre></td></tr></table></figure><ul><li>execution：关键字，固定格式</li><li>public：类的访问修饰符<ul><li>如果不考虑访问修饰符和返回值，这两位整合成一起，写成*</li></ul></li><li>int：方法的返回值<ul><li>如果不考虑返回值和访问修饰符，这两位必须一起忽略</li></ul></li><li>com.xiaobai.spring.aop.target：包名<ul><li>单层模糊：com.xiaobai.spring.aop.*，包含到aop包的所有包</li><li>多层模糊：com..impl 任意层的模糊，不能以..开头，这句话的意思是找到所有层的impl的包</li><li>查询全部包：*..（单层模糊+多层模糊）</li></ul></li><li>Calculator：类名<ul><li>模糊：*，即不考虑具体的类，表示包含当前包下的所有类</li><li>部分模糊：*Impl，表示寻找当前包下以Impl结尾的所有类</li></ul></li><li>div：方法名<ul><li>规则以类名一致，可以模糊与部分模糊</li></ul></li><li>()：参数列表<ul><li>没有参数：()</li><li>有具体参数：(int , String)</li><li>模糊参数：(..)</li><li>部分模糊：<ul><li>(String..)：以String开头，后面有没有都可以</li><li>(..int)：以int结尾，前面有没有都可以</li><li>(String..int)：以String开头，以int结尾，中间有没有都可以</li></ul></li></ul></li></ul><p><em>当在增强类上使用@Aspect切面注解之后，切点表达式带自动补全功能</em></p><hr><h3 id="切点表达式的重用"><a href="#切点表达式的重用" class="headerlink" title="切点表达式的重用"></a>切点表达式的重用</h3><p>切点表达式的提取和复用</p><h5 id="提取到当前增强类"><a href="#提取到当前增强类" class="headerlink" title="提取到当前增强类"></a>提取到当前增强类</h5><p>新建一个方法，在方法上使用注解@Pointcut，切点表达式作为注解的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Pointcut(&quot;execution(* com..impl.*.*(..))&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pointcut</span><span class="hljs-params">()</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>将增强方法的注解的切点表达式值，改为引用此方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAdvice</span> &#123;<br>    <span class="hljs-meta">@Pointcut(&quot;execution(* com..impl.*.*(..))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pointcut</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-meta">@Before(&quot;pointcut()&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">(JoinPoint joinPoint)</span> &#123;<br>    &#125;<br><br>    <span class="hljs-meta">@AfterReturning(value = &quot;pointcut()&quot;,returning = &quot;returnValue&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterReturning</span><span class="hljs-params">(Object returnValue)</span> &#123;<br>    &#125;<br>    <br>    <span class="hljs-meta">@AfterThrowing(value = &quot;pointcut()&quot;,throwing = &quot;throwable&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterThrowing</span><span class="hljs-params">(Throwable throwable)</span> &#123;<br>    &#125;<br>    <br>    <span class="hljs-meta">@After(&quot;pointcut()&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">after</span><span class="hljs-params">()</span>&#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="切点表达式的存储类"><a href="#切点表达式的存储类" class="headerlink" title="切点表达式的存储类"></a>切点表达式的存储类</h5><p>创建Pointcut包 -&gt; 建立MyPointcut类用以存储切点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPointcut</span> &#123;<br>    <span class="hljs-meta">@Pointcut(&quot;execution(* com..impl.*.*(..))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pointcut</span><span class="hljs-params">()</span> &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用全类名+方法名的方式应用切点表达式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAdvice</span> &#123;<br>    <span class="hljs-meta">@Before(&quot;com.xiaobai.Pointcut.MyPointcut.pointcut()&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">(JoinPoint joinPoint)</span> &#123;<br>        ……<br>    &#125;<br>    ……<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="环绕通知"><a href="#环绕通知" class="headerlink" title="环绕通知"></a>环绕通知</h3><p>个人理解：环绕通知的写法和动态代理的写法就很相似了</p><p>与其他增强方法不同点</p><ul><li>ProceedingJoinPoint接口下的joinPoint对象多了一个proceed方法，这个方法用以执行目标方法</li><li>环绕通知方法需要有返回值，该方法的返回值是目标方法的返回值</li></ul><p>使用@Around注解表示环绕通知</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AroundAdvice</span> &#123;<br>    <span class="hljs-meta">@Around(&quot;com.xiaobai.Pointcut.MyPointcut.pointcut()&quot;)</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">around</span><span class="hljs-params">(ProceedingJoinPoint joinPoint)</span> &#123;<br>        Object[] args = joinPoint.getArgs(); <span class="hljs-comment">// 通过jointPoint获取方法的参数</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 增强代码 -&gt; before</span><br>            result = joinPoint.proceed(args); <span class="hljs-comment">// 调用proceed执行方法</span><br>            <span class="hljs-comment">// 增强代码 -&gt; afterReturning</span><br>        &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            <span class="hljs-comment">// 增强代码 -&gt; afterThrowing</span><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 增强代码 -&gt; After</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="增强优先级"><a href="#增强优先级" class="headerlink" title="增强优先级"></a>增强优先级</h3><p>当有多个增强作用与同一个目标时，我们针对于增强类设置优先级</p><p>使用@Order注解，标识增强类的优先级</p><p>@Order(1) -&gt; @Order(10)，数字越小，优先级越高</p><p>优先级别越高，离核心代码越近，反之越小</p><hr><h3 id="使用cglib底层代理"><a href="#使用cglib底层代理" class="headerlink" title="使用cglib底层代理"></a>使用cglib底层代理</h3><p>如果存在于接口的话，SpringAOP框架底层默认使用JDK动态代理的方式</p><p>当没有接口的时候，SpringAOP框架底层默认使用cglib动态代理的方式</p><p>cglib会为目标类生成代理类为其子类，这样就不用受迫于接口的限制</p><p><em>注：因为没有接口，所以在测试类注入时是直接注入目标类类型的代理对象，而不再是接口类型</em></p><hr><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>当开启AOP时，存储到IoC容器里的不再是实现类本身的对象，而是代理增强类的对象</p><p>当底层使用JDK动态代理时，自动装配需要使用接口类型，而不能用实现类型，因为实现类没有对象存储到IoC容器中</p><hr><h3 id="XML方式实现AOP框架"><a href="#XML方式实现AOP框架" class="headerlink" title="XML方式实现AOP框架"></a>XML方式实现AOP框架</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="hljs-attr">xmlns:aop</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/aop&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--    扫描包--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.xiaobai&quot;</span>/&gt;</span><br>    <br><span class="hljs-comment">&lt;!--    添加注解支持--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:aspectj-autoproxy</span>/&gt;</span><br>    <br><span class="hljs-comment">&lt;!--    使用标签配置AOP--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br><span class="hljs-comment">&lt;!--        @Pointcut--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pointcut&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com..impl.*.*(..))&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!--        @Aspect + @Order(1)--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:aspect</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;myAdvice&quot;</span> <span class="hljs-attr">order</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!--            @Before(&quot;pointcut()&quot;)--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">aop:before</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;before&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;pointcut&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!--            @AfterReturning(value = &quot;pointcut()&quot;,returning = &quot;returnValue&quot;)--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">aop:after-returning</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;afterReturning&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;pointcut&quot;</span> <span class="hljs-attr">returning</span>=<span class="hljs-string">&quot;returnValue&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!--            @AfterThrowing(value = &quot;pointcut()&quot;,throwing = &quot;throwable&quot;)--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">aop:after-throwing</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;afterThrowing&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;pointcut&quot;</span> <span class="hljs-attr">throwing</span>=<span class="hljs-string">&quot;throwable&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!--            @After(&quot;pointcut()&quot;)--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">aop:after</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;after&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;pointcut&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">aop:aspect</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>SSM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring-代理</title>
    <link href="/2024/05/28/Spring-%E4%BB%A3%E7%90%86/"/>
    <url>/2024/05/28/Spring-%E4%BB%A3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring-代理"><a href="#Spring-代理" class="headerlink" title="Spring-代理"></a>Spring-代理</h1><p>存在一个类，实现两个数的加减乘除功能，并想在功能实现的前后加上日志，日志内容为进行了什么操作，输出结果是什么</p><p>我们可以在每一个方法中，使用print的方式来打印日志，但这十分麻烦且有大量的冗余代码</p><p>使用代理模式来解决这个问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Calculator</span> &#123;<br>    <br>    <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>;<br>    <br>    <span class="hljs-type">int</span> <span class="hljs-title function_">sub</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>;<br>    <br>    <span class="hljs-type">int</span> <span class="hljs-title function_">mul</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>;<br>    <br>    <span class="hljs-type">int</span> <span class="hljs-title function_">div</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CalculatorPureImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Calculator</span> &#123;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>    <br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> i + j;<br>    <br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sub</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>    <br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> i - j;<br>    <br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">mul</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>    <br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> i * j;<br>    <br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">div</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>    <br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> i / j;<br>    <br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>新建一个代理类同样实现功能接口，但代理类不做具体的功能实现，只负责日志的打印</p><p>将实现类作为代理类的属性，并在构造方法将实现类注入到代理类中</p><p>在重写的功能方法中，先打印所需要的日志，再调用实现类中的方法去完成具体的功能实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CalculatorStaticProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Calculator</span> &#123;<br><br>    <span class="hljs-type">Calculator</span> <span class="hljs-variable">calculator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CalculatorPureImpl</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CalculatorStaticProxy</span><span class="hljs-params">(Calculator calculator)</span> &#123;<br>        <span class="hljs-built_in">this</span>.calculator = calculator;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;i = &quot;</span> + i + <span class="hljs-string">&quot;, j = &quot;</span> + j);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> calculator.add(i, j);<br>        System.out.println(<span class="hljs-string">&quot;result = &quot;</span> + result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sub</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;i = &quot;</span> + i + <span class="hljs-string">&quot;, j = &quot;</span> + j);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> calculator.sub(i, j);<br>        System.out.println(<span class="hljs-string">&quot;result = &quot;</span> + result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">mul</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;i = &quot;</span> + i + <span class="hljs-string">&quot;, j = &quot;</span> + j);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> calculator.mul(i, j);<br>        System.out.println(<span class="hljs-string">&quot;result = &quot;</span> + result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">div</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;i = &quot;</span> + i + <span class="hljs-string">&quot;, j = &quot;</span> + j);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> calculator.div(i, j);<br>        System.out.println(<span class="hljs-string">&quot;result = &quot;</span> + result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>JDK动态代理：JDK提供了原生的动态代理的实现方式，他必须需要被代理的实现类的接口，会根据接口动态生成一个代理对象</p><p>cglib：第三方技术（被Spring集成），通过被代理的实现类直接生成一个代理类，不需要实现类的接口</p><hr><h5 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h5><p>尚硅谷提供了一个基于JDK动态代理的生成工具类</p><p>和静态代理类一样，将实现类对象作为代理类的属性注入，在这里为了实现动态，类的类型是Object</p><p>Proxy.newProxyInstance()方法需要三个参数</p><ul><li>classLoader：实现类的类加载器</li><li>interfaces：实现类的接口</li><li>invocationHandler：具体的代理类的功能类，其参数需要重写抽象方法，其中具体的实现使用到反射<ul><li>抽象方法提供了三个参数，proxy（实现类的对象），method（实现类的功能方法），args（方法所对应的参数）</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.lang.reflect.Proxy;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyFactory</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Object target;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ProxyFactory</span><span class="hljs-params">(Object target)</span> &#123;<br>        <span class="hljs-built_in">this</span>.target = target;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getProxy</span><span class="hljs-params">()</span>&#123;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * newProxyInstance()：创建一个代理实例</span><br><span class="hljs-comment">         * 其中有三个参数：</span><br><span class="hljs-comment">         * 1、classLoader：加载动态生成的代理类的类加载器</span><br><span class="hljs-comment">         * 2、interfaces：目标对象实现的所有接口的class对象所组成的数组</span><br><span class="hljs-comment">         * 3、invocationHandler：设置代理对象实现目标对象方法的过程，即代理类中如何重写接口中的抽象方法</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> target.getClass().getClassLoader(); <span class="hljs-comment">// 获取到实现类的类加载器</span><br>        Class&lt;?&gt;[] interfaces = target.getClass().getInterfaces(); <span class="hljs-comment">// 获取实现类的接口</span><br>        <span class="hljs-type">InvocationHandler</span> <span class="hljs-variable">invocationHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvocationHandler</span>() &#123;<br>            <span class="hljs-comment">// 通过匿名内部类的方式重写了InvocationHandler的抽象方法invoke</span><br>            <span class="hljs-comment">// 这个方法就是代理类具体要做的事</span><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>                <span class="hljs-comment">/**</span><br><span class="hljs-comment">                 * proxy：代理对象</span><br><span class="hljs-comment">                 * method：代理对象需要实现的方法，即其中需要重写的方法</span><br><span class="hljs-comment">                 * args：method所对应方法的参数</span><br><span class="hljs-comment">                 */</span><br>                <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot;[动态代理][日志] &quot;</span>+method.getName()+<span class="hljs-string">&quot;，参数：&quot;</span>+ Arrays.toString(args));<br>                    result = method.invoke(target, args);<br>                    System.out.println(<span class="hljs-string">&quot;[动态代理][日志] &quot;</span>+method.getName()+<span class="hljs-string">&quot;，结果：&quot;</span>+ result);<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    e.printStackTrace();<br>                    System.out.println(<span class="hljs-string">&quot;[动态代理][日志] &quot;</span>+method.getName()+<span class="hljs-string">&quot;，异常：&quot;</span>+e.getMessage());<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot;[动态代理][日志] &quot;</span>+method.getName()+<span class="hljs-string">&quot;，方法执行完毕&quot;</span>);<br>                &#125;<br>                <span class="hljs-keyword">return</span> result;<br>            &#125;<br>        &#125;;<br>        <span class="hljs-keyword">return</span> Proxy.newProxyInstance(classLoader, interfaces, invocationHandler);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p><em><strong>AOP框架就是封装了动态代理技术</strong></em> </p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>SSM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring-SpringTest</title>
    <link href="/2024/05/27/Spring-SpringTest/"/>
    <url>/2024/05/27/Spring-SpringTest/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring-SpringIoC-SpringTest"><a href="#Spring-SpringIoC-SpringTest" class="headerlink" title="Spring-SpringIoC-SpringTest"></a>Spring-SpringIoC-SpringTest</h1><p>我们在测试代码的过程中，每一次都要创建容器 -&gt; 获取Bean -&gt; 调用方法</p><p>使用Spring提供的测试工具可以更方便我们进行代码的测试</p><p>依赖需求：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-test --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.junit.jupiter/junit-jupiter-api --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-jupiter-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;junit.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h3 id="SpringJUnitConfig"><a href="#SpringJUnitConfig" class="headerlink" title="@SpringJUnitConfig"></a>@SpringJUnitConfig</h3><p>在测试类上加入注解@SpringJUnitConfig，此类由Spring接管并且标记为测试类</p><p>使用组件时，无需创建容器，直接声明组件后使用@Autowired注入即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.xiaobai.config.JavaConfiguration;<br><span class="hljs-keyword">import</span> com.xiaobai.controller.StudentController;<br><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.test.context.junit.jupiter.SpringJUnitConfig;<br><br><span class="hljs-meta">@SpringJUnitConfig(value = JavaConfiguration.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringTest</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    StudentController studentController;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        studentController.queryAll();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就省去了创建容器和获取Bean组件对象的两个步骤，由IoC将组件直接注入到我们的测试类中</p><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>SSM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring-SpringIoC-配置类</title>
    <link href="/2024/05/27/Spring-SpringIoC-%E9%85%8D%E7%BD%AE%E7%B1%BB/"/>
    <url>/2024/05/27/Spring-SpringIoC-%E9%85%8D%E7%BD%AE%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring-SpringIoC-配置类"><a href="#Spring-SpringIoC-配置类" class="headerlink" title="Spring-SpringIoC-配置类"></a>Spring-SpringIoC-配置类</h1><p>我们使用注解方式解放了很大一部分xml的功能，但仍然存在三个功能必须要在xml文件配置</p><ul><li>使用&lt;context:component-scan base-package&#x3D;””&#x2F;&gt;标签配置扫描包</li><li>使用&lt;context:property-placeholder location&#x3D;””&#x2F;&gt;引入外部的配置文件<ul><li>location属性中的classpath表示相对路径，在项目中查找资源文件，再查找jar包</li></ul></li><li>第三方类的IoC配置</li></ul><p>XML格式的解析效率很低，为了解决这个问题，实现完全注解的配置，Spring提供了配置类</p><p>配置类是使用 方法+注解 来替代xml标签，最后实现完全注解开发，配置类的作用是替代xml</p><hr><h3 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h3><p><em>configuration中文释义：配置</em></p><p>创建config包下建立一个java文件，作为配置类</p><p>在类上加Configuration注解，声明此类为配置类</p><hr><h3 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h3><p>在配置类上加此注解，代替context:component-scan标签，扫描包中组件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ComponentScan(&quot;com.xiaobai.ioc_01&quot;)</span><br></code></pre></td></tr></table></figure><p>当扫描多个包时，用大括号包含，逗号隔开</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ComponentScan(&#123;&quot;com.xiaobai.ioc_01&quot;,&quot;com.xiaobai.ioc_02&quot;&#125;)</span><br></code></pre></td></tr></table></figure><hr><h3 id="PropertySource"><a href="#PropertySource" class="headerlink" title="@PropertySource"></a>@PropertySource</h3><p>在配置类上加此注解，代替context:property-placeholder标签，导入外部文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span><br></code></pre></td></tr></table></figure><hr><h3 id="使用配置类创建IoC容器"><a href="#使用配置类创建IoC容器" class="headerlink" title="使用配置类创建IoC容器"></a>使用配置类创建IoC容器</h3><p>使用ApplicationContext子接口的实现类AnnotationCofigApplicationContext读取Java配置类创建IoC容器对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>(JavaConfiguration.class);<br></code></pre></td></tr></table></figure><h5 id="手动引入后刷新"><a href="#手动引入后刷新" class="headerlink" title="手动引入后刷新"></a>手动引入后刷新</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">AnnotationConfigApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>();<br>context.register(JavaConfiguration.class);<br>context.refresh();<br></code></pre></td></tr></table></figure><p><em>区别于ClassPathXmlApplicationContext实现类的setConfigLocations方法，在这里使用的时register方法引入外部文件</em></p><hr><h3 id="Bean"><a href="#Bean" class="headerlink" title="@Bean"></a>@Bean</h3><p>第三方类的引用在配置类中是通过方法实现的</p><ul><li>方法的返回值类型 &#x3D; bean组件的类型或者其接口父类</li><li>方法的名字 &#x3D; bean Id</li><li>方法体自定义实现过程，最后将组件对象返回即可</li></ul><p>使用@Bean注解标识该方法，即使用配置类的方法创建组件对象储存到IoC容器中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ComponentScan(&quot;com.xiaobai.ioc_01&quot;)</span><br><span class="hljs-meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JavaConfiguration</span> &#123;<br>    <span class="hljs-meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String driver;<br>    <span class="hljs-meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String url;<br>    <span class="hljs-meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String username;<br>    <span class="hljs-meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String password;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> DataSource <span class="hljs-title function_">dataSource</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">DruidDataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DruidDataSource</span>();<br>        dataSource.setDriverClassName(driver);<br>        dataSource.setUrl(url);<br>        dataSource.setUsername(username);<br>        dataSource.setPassword(password);<br>        <span class="hljs-keyword">return</span> dataSource;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>拿Druid连接池距离，我们首先使用@PropertySource导入配置文件，使用@value映射配置文件内容到类中属性</p><p>创建返回值类型为DataSource的方法，将类中属性作为Jdbc四大件参数填写在对象中</p><p>使用@Bean标签标识后，该方法的返回对象就会被存放到IoC容器中，Bean Id为方法名</p><hr><h5 id="形参列表"><a href="#形参列表" class="headerlink" title="形参列表"></a>形参列表</h5><p>@Value注解可做用到形参列表中，如果参数只在该方法内使用一次，则可直接使用此注解映射参数到形参列表，不需要创建类中属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ComponentScan(&quot;com.xiaobai.ioc_01&quot;)</span><br><span class="hljs-meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JavaConfiguration</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> DataSource <span class="hljs-title function_">dataSource</span><span class="hljs-params">(</span><br><span class="hljs-params">            <span class="hljs-meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span></span><br><span class="hljs-params">            String driver,</span><br><span class="hljs-params">            <span class="hljs-meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="hljs-params">            String url,</span><br><span class="hljs-params">            <span class="hljs-meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="hljs-params">            String username,</span><br><span class="hljs-params">            <span class="hljs-meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span></span><br><span class="hljs-params">            String password</span><br><span class="hljs-params">    )</span> &#123;<br>        <span class="hljs-type">DruidDataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DruidDataSource</span>();<br>        dataSource.setDriverClassName(driver);<br>        dataSource.setUrl(url);<br>        dataSource.setUsername(username);<br>        dataSource.setPassword(password);<br>        <span class="hljs-keyword">return</span> dataSource;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="BeanId"><a href="#BeanId" class="headerlink" title="BeanId"></a>BeanId</h5><p>@Bean注解的默认BeanId是方法名，我们也可以在注解中手工配置Bean Id</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean(&quot;dataSource&quot;)</span><br><span class="hljs-meta">@Bean(value = &quot;dataSource&quot;)</span><br><span class="hljs-meta">@Bean(name = &quot;dataSource&quot;)</span><br></code></pre></td></tr></table></figure><hr><h5 id="周期方法"><a href="#周期方法" class="headerlink" title="周期方法"></a>周期方法</h5><p>在配置类接管后，我们仍可以用 @PostConstrct + @ProDestroy来指定初始化和销毁方法</p><p>也可以使用@Bean注解中的initMethod和destoryMethod属性来指定初始化和销毁方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean(initMethod = &quot;&quot;,destroyMethod = &quot;&quot;)</span><br></code></pre></td></tr></table></figure><hr><h5 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h5><p>与普通组件的作用域设置方法相同，同样是使用Scope注解（Scope可以作用于类或方法）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Scope(scopeName = ConfigurableBeanFactory.SCOPE_SINGLETON)</span> <span class="hljs-comment">//单例 默认值</span><br><span class="hljs-meta">@Scope(scopeName = ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span> <span class="hljs-comment">//多例</span><br></code></pre></td></tr></table></figure><hr><h5 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h5><p>在使用三方类JdbcTemplate时，需要把Druid连接池DataSource注入到JdbcTemplate中</p><p>使用配置类，需要设置形参为所需组件对象，在加上@Bean注释后，IoC容器会自动查找容器内部的组件对象，完成注入</p><p><em>这个自动注入的过程与Autowired是相同的</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> JdbcTemplate <span class="hljs-title function_">jdbcTemplate</span><span class="hljs-params">(DataSource dataSource)</span> &#123;<br>    <span class="hljs-type">JdbcTemplate</span> <span class="hljs-variable">jdbcTemplate</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JdbcTemplate</span>();<br>    jdbcTemplate.setDataSource(dataSource);<br>    <span class="hljs-keyword">return</span> jdbcTemplate;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h3><p>这个配置类中就包含了Druid连接池和JdbcTemplate的第三方注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.alibaba.druid.pool.DruidDataSource;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Value;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.config.ConfigurableBeanFactory;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.*;<br><span class="hljs-keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;<br><br><span class="hljs-keyword">import</span> javax.sql.DataSource;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 此类为Spring配置类，用以替换xml文件实现完全注解开发</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@ComponentScan(&quot;com.xiaobai.ioc_01&quot;)</span><br><span class="hljs-meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JavaConfiguration</span> &#123;<br>    <span class="hljs-meta">@Scope(scopeName = ConfigurableBeanFactory.SCOPE_SINGLETON)</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> DataSource <span class="hljs-title function_">dataSource</span><span class="hljs-params">(</span><br><span class="hljs-params">            <span class="hljs-meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span></span><br><span class="hljs-params">            String driver,</span><br><span class="hljs-params">            <span class="hljs-meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="hljs-params">            String url,</span><br><span class="hljs-params">            <span class="hljs-meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="hljs-params">            String username,</span><br><span class="hljs-params">            <span class="hljs-meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span></span><br><span class="hljs-params">            String password</span><br><span class="hljs-params">    )</span> &#123;<br>        <span class="hljs-type">DruidDataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DruidDataSource</span>();<br>        dataSource.setDriverClassName(driver);<br>        dataSource.setUrl(url);<br>        dataSource.setUsername(username);<br>        dataSource.setPassword(password);<br>        <span class="hljs-keyword">return</span> dataSource;<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> JdbcTemplate <span class="hljs-title function_">jdbcTemplate</span><span class="hljs-params">(DataSource dataSource)</span> &#123;<br>        <span class="hljs-type">JdbcTemplate</span> <span class="hljs-variable">jdbcTemplate</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JdbcTemplate</span>();<br>        jdbcTemplate.setDataSource(dataSource);<br>        <span class="hljs-keyword">return</span> jdbcTemplate;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="Import"><a href="#Import" class="headerlink" title="@Import"></a>@Import</h3><p>当有多个配置类存在时，我们在加载配置类时，需要分别再加每一个配置类</p><p>使用@Import注解可以解决此问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Import(JavaConfigurationB.class)</span> <span class="hljs-comment">//将配置类B导入</span><br></code></pre></td></tr></table></figure><p>在实际开发中，会存在很多很多个配置类，如果在使用时一一导入的话会非常麻烦</p><p>我们可以准备一个根配置类，在这个配置类中只做整合使用，最后使用时只使用这一个配置类创建容器即可</p><p><em>这个整合思路有点像vue中的App.vue</em></p><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>SSM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring-SpringIoC-注解</title>
    <link href="/2024/05/27/Spring-SpringIoC-%E6%B3%A8%E8%A7%A3/"/>
    <url>/2024/05/27/Spring-SpringIoC-%E6%B3%A8%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring-SpringIoC-注解"><a href="#Spring-SpringIoC-注解" class="headerlink" title="Spring-SpringIoC-注解"></a>Spring-SpringIoC-注解</h1><p>xml配置组件到IoC容器的方式十分麻烦，我们可以在组件中使用注解的方式将组件添加到IoC容器中</p><p>我们可以通过配置其value属性的形式完成对id值的修改，value&#x3D; 可缺省不写</p><p><em>注：使用注解添加组件到IoC时，组件默认的id值会直接使用类名的首字母小写形式</em></p><table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td>@Component</td><td>该注解用于描述 Spring 中的 Bean，它是一个泛化的概念，仅仅表示容器中的一个组件（Bean），并且可以作用在应用的任何层次，例如 Service 层、Dao 层等。 使用时只需将该注解标注在相应类上即可。</td></tr><tr><td>@Repository</td><td>该注解用于将数据访问层（Dao 层）的类标识为 Spring 中的 Bean，其功能与 @Component 相同。</td></tr><tr><td>@Service</td><td>该注解通常作用在业务层（Service 层），用于将业务层的类标识为 Spring 中的 Bean，其功能与 @Component 相同。</td></tr><tr><td>@Controller</td><td>该注解通常作用在控制层（如SpringMVC 的 Controller），用于将控制层的类标识为 Spring 中的 Bean，其功能与 @Component 相同。</td></tr></tbody></table><p><em>Repository中文释义：存储库</em></p><p><em>注：三层中有自己特有的注解，component更多的是将工具类或者别的组件放入IoC容器中，这四个注解在功能上没有任何区别</em></p><hr><h3 id="配置扫描包"><a href="#配置扫描包" class="headerlink" title="配置扫描包"></a>配置扫描包</h3><p>在标记注解之后，我们还要在配置文件中增加被容器扫描的包</p><p>在spring配置文件中，我们使用context:component-scan标签进行扫描</p><ul><li>base-package：此属性用以配置被扫描的包，可以填写多个包名用逗号隔开，包中子包和所有类都会被递归扫描</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.xiaobai.ioc_01&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p><em>我们在软编码jdbc配置文件时，使用context:property-placeholder标签导入了jdbc.properties</em></p><hr><h5 id="context-exclude-filter"><a href="#context-exclude-filter" class="headerlink" title="context:exclude-filter"></a>context:exclude-filter</h5><p>在使用context:component-scan标签时，可以使用其子标签context:exclude-filter进行包的排除</p><ul><li>type：排除的类型</li><li>expression：排除具体的类</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.xiaobai&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:exclude-filter</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;annotation&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;org.springframework.stereotype.Repository&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br></code></pre></td></tr></table></figure><p>以上代码就是，使用spring接管了com.xiaobai包下所有带注解的组件，但排除注解为Repository的组件</p><hr><h5 id="context-include-filter"><a href="#context-include-filter" class="headerlink" title="context:include-filter"></a>context:include-filter</h5><p>在使用context:component-scan标签时，为其添加属性use-default-filters为false，指定包不生效</p><p>再使用其子标签context:include-filter进行指定包的扫描</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.xiaobai&quot;</span> <span class="hljs-attr">use-default-filters</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:include-filter</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;annotation&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;org.springframework.stereotype.Repository&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br></code></pre></td></tr></table></figure><p>以上代码就是，spring不扫描com.xiaobai包下所有带注解的组件，只扫描注解为Repository的组件</p><hr><h3 id="周期方法"><a href="#周期方法" class="headerlink" title="周期方法"></a>周期方法</h3><p>与xml配置周期方法的方式大同小异，使用注解即可配置生命周期方法</p><ul><li>@PostConstrct：指定初始化方法</li><li>@ProDestroy：指定销毁方法</li></ul><p><em>注：这两个注解必须要导入javax.annotation依赖，才可以使用</em><br><em>注：这个依赖已经更新为jakarta.annotation依赖，javax是过去式了</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-keyword">import</span> javax.annotation.PostConstruct;<br><span class="hljs-keyword">import</span> javax.annotation.PreDestroy;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JavaBean</span> &#123;<br><br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@PreDestroy</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span>&#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="作用域配置"><a href="#作用域配置" class="headerlink" title="作用域配置"></a>作用域配置</h3><p>与xml配置作用域方式大同小异，使用注解可配置组件的作用域</p><ul><li>@Scope(scopeName &#x3D; ConfigurableBeanFactory.SCOPE_SINGLETON)：配置单例作用域（默认值）</li><li>@Scope(scopeName &#x3D; ConfigurableBeanFactory.SCOPE_PROTOTYPE)：配置多例作用域</li></ul><blockquote><p>具体的作用域信息可在 笔记 -&gt; Spring-SpringIoC -&gt; 组件的作用域和周期方法 -&gt; 作用域 找到</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Scope(scopeName = ConfigurableBeanFactory.SCOPE_SINGLETON)</span> <span class="hljs-comment">//单例 默认值</span><br><span class="hljs-meta">@Scope(scopeName = ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span> <span class="hljs-comment">//多例</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JavaBean</span> &#123;<br> ……<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="DI"><a href="#DI" class="headerlink" title="DI"></a>DI</h3><h5 id="AutoWired"><a href="#AutoWired" class="headerlink" title="@AutoWired"></a>@AutoWired</h5><p>与xml配置DI的方式不同，注解配置DI的方式是使用@AutoWired实现自动装配</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserService userService;<br>&#125;<br></code></pre></td></tr></table></figure><p>@Autowired注解会在IoC容器中寻找组件，寻找到符合UserService接口的实现类（或者类本身），就将组件对象自动装配到此属性中</p><p>所以，@Autowired注解是直接对属性进行的操作，不需要有setter就可以实现</p><p>这个注解不止可以加在属性上，也可以加在构造方法或setter方法上，实现自动装配</p><p><em>在实际开发当中，我们最常使用的就是Autowired自动装配到属性</em> 😊</p><hr><h5 id="佛系装配"><a href="#佛系装配" class="headerlink" title="佛系装配"></a>佛系装配</h5><p>自动装配时，@AutoWired注解的required值默认为true，也就是要求有对应的接口实现类来装配</p><p>而我们可以手动设置required值为false，则不强制要求有对应的接口实现类来装配</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired(required = false)</span><br></code></pre></td></tr></table></figure><p><em>但如果有调用容器，则会报空指针异常！！！！</em></p><p>所以不推荐使用佛系装配，除非你装配的属性不会被使用</p><hr><h5 id="Qualifier"><a href="#Qualifier" class="headerlink" title="@Qualifier"></a>@Qualifier</h5><p>以上的自动装配情况有一个前提，这一个属性只对应一个组件，即根据接口的属性类型只查找到一个接口的实现类</p><p>当根据属性类型查找到多个组件时，再去通过属性名找组件</p><p>那如果接口下有两个实现类，我们也可以通过成员属性名的方式来进行区分</p><ul><li>方式1：将成员属性名改成实现类的名字，在自动装配时会根据这个属性名去找实现类组件对象进行装配（更改需求）</li><li>方式2：将组件id值改成接口的名字的首字母小写的名字，在自动装配时也会根据属性名找到被更改的组件ID，进行装配（更改供给）</li></ul><p>这两个方案都不够好，IoC容器提供了一个新的注解@Qualifier来解决此问题</p><p><em>qualifier中文释义：入围者</em></p><p>接口的属性值value可以指定组件对象进行装配，必须配合Autowired进行使用,value可以省略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-meta">@Qualifier(&quot;userServiceImpl&quot;)</span><br>    <span class="hljs-keyword">private</span> UserService userService;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h5><p>JSR（Java Specification Requests）是Java平台标准化进程中的一种技术规范，而JSR注解是其中一部分重要的内容</p><p>JSR-250提供了@Resource注解，这个注解由java提供，由spring实现</p><p><em>注：这个注解也必须要导入jakarta.annotation依赖，才可以使用</em></p><p>@Resource注解 &#x3D; @Autowired注解 + @qualifire注解</p><p>它提供了一个属性name，作用与@qualifire注解的属性value相同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br>    <span class="hljs-meta">@Resource(name = &quot;userServiceImpl&quot;)</span><br>    <span class="hljs-keyword">private</span> UserService userService;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="Value"><a href="#Value" class="headerlink" title="@Value"></a>@Value</h5><p>基本数据类型也可以通过注解的方式来赋值，使用@Value注解即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JavaBean</span> &#123;<br>    <span class="hljs-meta">@Value(&quot;xiaobai&quot;)</span><br>    String name;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们也可以使用properties外部文件，在spring配置文件中使用context加载配置文件后，在注解里使用${}获取值赋值给属性</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">jdbc.user</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">jdbc.password</span>=<span class="hljs-string">Zhuwenxue2002</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.xiaobai.ioc_03&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;classpath:jdbc.properties&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JavaBean</span> &#123;<br>    <span class="hljs-meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span><br>    String username; <span class="hljs-comment">// root</span><br><br>    <span class="hljs-meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span><br>    String userPwd; <span class="hljs-comment">// Zhuwenxue2002</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以在使用:默认值语法来为数据添加默认值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JavaBean</span> &#123;<br>    <span class="hljs-meta">@Value(&quot;$&#123;jdbc.username:root&#125;&quot;)</span><br>    String username;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码为：当jdbc.username为空时，username的值为默认值root</p><hr><h3 id="xml"><a href="#xml" class="headerlink" title="xml"></a>xml</h3><p>当使用注解替代xml之后，xml的作用就变得更精简了</p><ul><li>使用&lt;context:component-scan base-package&#x3D;””&#x2F;&gt;标签配置扫描包</li><li>使用&lt;context:property-placeholder location&#x3D;””&#x2F;&gt;引入外部的配置文件<ul><li>location属性中的classpath表示相对路径，在项目中查找资源文件，再查找jar包</li></ul></li><li>第三方类的IoC配置</li></ul><p>注解也没办法将第三方jar包放到IoC容器，也无法为这个jar包实现DI</p><p>比如之前我们学习的Druid和JdbcTemplate使用</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;classpath:jdbc.properties&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClassName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;jdbcTemplate&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>我们无法在Druid和JdbcTemplate添加注解，将其放入IoC容器</p><p>也无法为JdbcTemplate配置@Autowired注解，让其实现自动注入连接池</p><p>所以目前来说，我们只能使用xml完成第三方类的配置</p><p>**当然，第三方类也是被放入IoC容器中，在Dao使用JdbcTemplate时也是可以直接使用@Automired自动装配的方式 ** 😐</p><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>SSM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring-SpringIoC-JdbcTemplate</title>
    <link href="/2024/05/26/Spring-SpringIoC-JdbcTemplate/"/>
    <url>/2024/05/26/Spring-SpringIoC-JdbcTemplate/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring-SpringIoC-JdbcTemplate"><a href="#Spring-SpringIoC-JdbcTemplate" class="headerlink" title="Spring-SpringIoC-JdbcTemplate"></a>Spring-SpringIoC-JdbcTemplate</h1><p>在JDBC的学习中，我们学会了Druid连接池的使用，并且会用软编码和硬编码的形式来实现</p><blockquote><p>笔记中的 JDBC -&gt; JDBC连接池 </p></blockquote><h3 id="硬编码"><a href="#硬编码" class="headerlink" title="硬编码"></a>硬编码</h3><p>硬编码形式的Druid连接池也是通过new DruidDataSource()的方式来实例化对象的</p><p>我们同样可以交给Spring接管Druid连接池的实例化</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://127.0.0.1/studb&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClassName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Zhuwenxue2002&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这样就完成了对连接池四大件的配置</p><p>JdbcTemplate功能也需要实例化使用，并且在实例化之后需要设置连接池作为参数，那么我们同样可以由Spring接管</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">JdbcTemplate</span> <span class="hljs-variable">jdbcTemplate</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JdbcTemplate</span>();<br>jdbcTemplate.setDataSource(dataSource); <span class="hljs-comment">// 参数为Druid连接池</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;jdbcTemplate&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h3 id="软编码"><a href="#软编码" class="headerlink" title="软编码"></a>软编码</h3><p>软编码就是将jdbc四大件写在配置文件中，由程序来读取</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">jdbc.url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/studb</span><br><span class="hljs-attr">jdbc.driver</span>=<span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br><span class="hljs-attr">jdbc.username</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">jdbc.password</span>=<span class="hljs-string">Zhuwenxue2002</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;classpath:jdbc.properties&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClassName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>使用context:property-placeholder标签，读取properties配置文件，使用${}的方式直接获取值</strong></p><hr><h3 id="jdbc-template"><a href="#jdbc-template" class="headerlink" title="jdbc-template"></a>jdbc-template</h3><p>jdbcTemplate是Spring提供的对jdbc的简化操作，类似于我们自己编写的BaseDao，其中也有增删改的方法</p><ul><li>update</li><li>queryForObject</li><li>query</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testJdbcTemplate</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 创建IoC容器</span><br>    <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;spring-01.xml&quot;</span>);<br>    <span class="hljs-comment">// 从容器中获取JdbcTemplate组件</span><br>    <span class="hljs-type">JdbcTemplate</span> <span class="hljs-variable">jdbcTemplate</span> <span class="hljs-operator">=</span> context.getBean(JdbcTemplate.class);<br><br>    <span class="hljs-comment">// 插入一条数据</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;insert into students (id,name,gender,age,class) values(default,?,?,?,?);&quot;</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">rows</span> <span class="hljs-operator">=</span> jdbcTemplate.update(sql, <span class="hljs-string">&quot;xiaobai&quot;</span>, <span class="hljs-string">&quot;男&quot;</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&quot;高中一班&quot;</span>);<br>    System.out.println(rows);<br><br>    <span class="hljs-comment">// 查找数据</span><br>    sql = <span class="hljs-string">&quot;select id,name,gender,age,class classes from students;&quot;</span>;<br>    List&lt;Student&gt; students = jdbcTemplate.query(sql, <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanPropertyRowMapper</span>&lt;&gt;(Student.class));<br>    <span class="hljs-keyword">for</span> (Student student : students) &#123;<br>        System.out.println(student);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>与我们手写的BaseDao不同，jdbcTemplate的查询映射过程使用了RowMapper接口</p><p>RowMapper 列名和属性名的映射器接口，需要自己写实现类，可以通过lambda表达式写一个内部类实现接口重写方法</p><p>BeanPropertyRowMapper为RowMapper的实现类，通过列名反射属性名，然后映射</p><p><em>这个实现类的使用，就很像BaseDao中直接传入.class类对象作为参数了</em></p><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>SSM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring-SpringIoC</title>
    <link href="/2024/05/25/Spring-SpringIoC/"/>
    <url>/2024/05/25/Spring-SpringIoC/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring-SpringIoC"><a href="#Spring-SpringIoC" class="headerlink" title="Spring-SpringIoC"></a>Spring-SpringIoC</h1><p><strong>IoC</strong>是inverse of control的简写，译为控制反转，是一种创建对象的思想</p><p>是控制反转就是将创建对象的权力交给Spring容器，其实就是让Spring容器帮你创建对象，而你不需要在java代码中new对象了</p><p><strong>DI</strong>是Dependency Injection，译为依赖注入</p><p>当容器中对象与对象之间关系，是通过DI完成的</p><p>SpringIoC容器的配置方式有三种：</p><ul><li><p>XML配置方式</p></li><li><p>注解方式</p></li><li><p>Java配置类方式</p></li></ul><hr><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>我们在使用框架之前，完成业务逻辑的步骤是：</p><p>controller层 -&gt; service层 -&gt; dao层</p><p>这三层中的每一个有关于具体业务的类，都是可以看作为组件，组件就是可以复用的java对象</p><p>就分为三层组件：controller层组件 -&gt; service层组件 -&gt; dao层组件</p><p>而这些组件可以被Spring接管，缺省组件中相互调用</p><p>Spring组件管理动作包含：</p><ul><li>组件对象实例化</li><li>组件属性的赋值</li><li>组件对象的引用</li><li>组件对象存活周期管理</li><li>……</li></ul><p>Spring提供了组件的容器，由他接手创建、管理、存储组件</p><p>只有Spring接手管理的组件，才能使用Spring框架的其他功能</p><hr><h3 id="SpringIoC的接口和实现类"><a href="#SpringIoC的接口和实现类" class="headerlink" title="SpringIoC的接口和实现类"></a>SpringIoC的接口和实现类</h3><h5 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h5><ul><li><p>BeanFactory：是SpringIoC的标准化接口</p></li><li><p>ApplicationContext：基于BeanFactory的子接口，拓展了功能，使用的实现类都是此接口的实现类</p></li></ul><h5 id="实现类"><a href="#实现类" class="headerlink" title="实现类"></a>实现类</h5><p>常用的实现类有四个：</p><table><thead><tr><th>类名</th><th>说明</th></tr></thead><tbody><tr><td>ClassPathXmlApplicationContext</td><td>通过读取类路径下的XML格式的配置文件创建IoC容器对象</td></tr><tr><td>FileSystemXmlApplicationContext</td><td>通过文件系统路径读取XML格式的配置文件创建IoC容器对象</td></tr><tr><td>AnnotationCofigApplicationContext</td><td>通过读取Java配置类创建IoC容器对象</td></tr><tr><td>WebApplicationContext</td><td>专门为Web应用准备，基于web环境创建IoC对象，并将对象引入存入ServletContext域中</td></tr></tbody></table><hr><h3 id="SpringIoC的实践与应用"><a href="#SpringIoC的实践与应用" class="headerlink" title="SpringIoC的实践与应用"></a>SpringIoC的实践与应用</h3><ul><li>写配置文件</li><li>创建IoC容器</li><li>通过容器获取组件对象</li></ul><p>在使用Spring之前，我们实例化对象的方式有：</p><ul><li>构造函数实例化<ul><li>有参构造函数实例化</li><li>无参构造函数实例化</li></ul></li><li>工厂模式实例化<ul><li>静态工厂实例化</li><li>非静态工厂实例化</li></ul></li></ul><p>在Spring中，不同方式的实例化有不同方法的配置方式</p><hr><h3 id="xml文件配置SpringIoC"><a href="#xml文件配置SpringIoC" class="headerlink" title="xml文件配置SpringIoC"></a>xml文件配置SpringIoC</h3><p>在resources文件夹下新建xml文件作为IoC的配置文件</p><blockquote><p>当导入了Spring依赖之后，idea右键新建xml配置文件中，会出现Spring配置文件，创建即可</p></blockquote><hr><h5 id="配置无参构造函数的组件类"><a href="#配置无参构造函数的组件类" class="headerlink" title="配置无参构造函数的组件类"></a>配置无参构造函数的组件类</h5><p>使用bean标签，即可根据组件类创建其对象，有两个标签属性：</p><ul><li>id：别名（全局唯一）</li><li>class：类全限定符（类全名）</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;happyComponent&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.xiaobai.ioc_01.HappyComponent&quot;</span>/&gt;</span><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>我们也可以根据组件类实例化多个组件对象</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;happyComponent1&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.xiaobai.ioc_01.HappyComponent&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;happyComponent2&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.xiaobai.ioc_01.HappyComponent&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><hr><h5 id="配置静态工厂组件类"><a href="#配置静态工厂组件类" class="headerlink" title="配置静态工厂组件类"></a>配置静态工厂组件类</h5><p>静态工厂组件类其实就是使用了饿汉式的单例模式，私有化构造方法后，通过调用方法返回其类本身的静态对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClientService</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">ClientService</span> <span class="hljs-variable">clientService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClientService</span>();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">ClientService</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ClientService <span class="hljs-title function_">createInstance</span><span class="hljs-params">()</span> &#123;<br><br>        <span class="hljs-keyword">return</span> clientService;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;clientService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.xiaobai.ioc_01.ClientService&quot;</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">&quot;createInstance&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>使用bean标签创建静态工厂组件类的对象时，有三个标签属性：</p><ul><li>id：别名</li><li>class：<strong>工厂类</strong>的全限定符</li><li>factory-method：<strong>静态</strong>工厂方法</li></ul><hr><h5 id="配置非静态工厂组件类"><a href="#配置非静态工厂组件类" class="headerlink" title="配置非静态工厂组件类"></a>配置非静态工厂组件类</h5><p>非静态工厂组件类，是通过调用类中非静态方法返回非本身的静态对象</p><p>区别是：调用方法是非静态方法，需要实例化才能调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FactoryClientService</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">ClientService</span> <span class="hljs-variable">clientService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClientService</span>();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">FactoryClientService</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> ClientService <span class="hljs-title function_">createInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> clientService;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;factoryClientService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.xiaobai.ioc_01.FactoryClientService&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;clientService&quot;</span> <span class="hljs-attr">factory-bean</span>=<span class="hljs-string">&quot;factoryClientService&quot;</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">&quot;createInstance&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>首先是使用bean标签创建了FactoryClientService的组件对象factoryClientService</p><p>bean中标签有三个属性：</p><ul><li>id：别名</li><li>factory-bean：工厂类的对象名（别名）</li><li>factory-method：工厂方法（非静态）</li></ul><hr><h3 id="DI"><a href="#DI" class="headerlink" title="DI"></a>DI</h3><p>在JavaWeb中，多层结构之间的调用是通过实例化对象后调用方法的方式实现的</p><p>比如说，controller层调用service层，需要实例化一个对象，这个对象作为controller中的全局变量赋值给属性，再调用其方法</p><p>而Spring直接通过依赖注入的方式，将service层的对象，通过<strong>构造方法或setter方法</strong>注入到controller的全局变量（属性）中</p><p><em>注：引用与被引用的组件，都必须被IoC容器接管</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br><br>    <span class="hljs-keyword">private</span> UserDao userDao;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserService</span><span class="hljs-params">(UserDao userDao)</span> &#123;<br>        <span class="hljs-built_in">this</span>.userDao = userDao;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.xiaobai.ioc_02.UserDao&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.xiaobai.ioc_02.UserService&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;userDao&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在bean标签内使用constructor-arg标签，完成构造中参数的注入（DI）</p><ul><li>value：直接属性值，比如基本类型属性值（String，int）</li><li>ref：引用其他的对象，使用其他Bean的Id（别名）</li></ul><p><em>SpringIoC是一个高级容器，会先创建对象，再去进行属性赋值，所以先后顺序无所谓</em></p><hr><h5 id="多个构造参数注入（顺序赋值）"><a href="#多个构造参数注入（顺序赋值）" class="headerlink" title="多个构造参数注入（顺序赋值）"></a>多个构造参数注入（顺序赋值）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br><br>    <span class="hljs-keyword">private</span> UserDao userDao;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserService</span><span class="hljs-params">(<span class="hljs-type">int</span> age, String name, UserDao userDao)</span> &#123;<br>        <span class="hljs-built_in">this</span>.userDao = userDao;<br>        <span class="hljs-built_in">this</span>.age = age;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.xiaobai.ioc_02.UserDao&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.xiaobai.ioc_02.UserService&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;18&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;xiaobai&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;userDao&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>当构造方法有多个参数需要传值时，使用多个constructor-arg标签按照顺序赋值即可，不推荐使用这种方法</p><hr><h5 id="多个构造参数注入（按照属性名赋值）"><a href="#多个构造参数注入（按照属性名赋值）" class="headerlink" title="多个构造参数注入（按照属性名赋值）*"></a>多个构造参数注入（按照属性名赋值）*</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.xiaobai.ioc_02.UserService&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;18&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;xiaobai&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;userDao&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>使用constructor-arg的name属性，给构造方法中的属性赋值，推荐使用这种方法</p><hr><h5 id="多个构造参数注入（按照下角标方式）"><a href="#多个构造参数注入（按照下角标方式）" class="headerlink" title="多个构造参数注入（按照下角标方式）"></a>多个构造参数注入（按照下角标方式）</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.xiaobai.ioc_02.UserDao&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.xiaobai.ioc_02.UserService&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;18&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;xiaobai&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;2&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;userDao&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>使用constructor-arg的index属性，给构造方法中的属性赋值，不推荐使用这种方法</p><hr><h5 id="以set方法的方式注入"><a href="#以set方法的方式注入" class="headerlink" title="以set方法的方式注入*"></a>以set方法的方式注入*</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleMovieLister</span> &#123;<br><br>    <span class="hljs-keyword">private</span> MovieFinder movieFinder;<br><br>    <span class="hljs-keyword">private</span> String movieName;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMovieFinder</span><span class="hljs-params">(MovieFinder movieFinder)</span> &#123;<br>        <span class="hljs-built_in">this</span>.movieFinder = movieFinder;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMovieName</span><span class="hljs-params">(String movieName)</span> &#123;<br>        <span class="hljs-built_in">this</span>.movieName = movieName;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;movieFinder&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.xiaobai.ioc_02.MovieFinder&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;simpleMovieLister&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.xiaobai.ioc_02.SimpleMovieLister&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;movieName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;三体&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;movieFinder&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;movieFinder&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>使用bean标签中的property标签，完成对set方法的依赖注入</p><ul><li>name：set方法去掉set并首字母小写的方法，以此名调用set方法</li><li>value&#x2F;ref：参数</li></ul><p><em>注：name属性中的值并不是属性名，而是set方法名经过变化得来的，但一般情况下与属性名相同</em></p><hr><h3 id="SpringIoC容器的创建和读取"><a href="#SpringIoC容器的创建和读取" class="headerlink" title="SpringIoC容器的创建和读取"></a>SpringIoC容器的创建和读取</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;Spring-03.xml&quot;</span>);<br></code></pre></td></tr></table></figure><p>使用实现类的构造方法直接创建容器对象，一般情况下直接使用这种</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ClassPathXmlApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>();<br>context.setConfigLocations(<span class="hljs-string">&quot;spring-03.xml&quot;</span>);<br>context.refresh();<br></code></pre></td></tr></table></figure><p>源码的配置过程：先指定配置文件之后，再刷新</p><hr><h5 id="Bean组件的读取"><a href="#Bean组件的读取" class="headerlink" title="Bean组件的读取"></a>Bean组件的读取</h5><p>使用容器调用getBean方法即可读取容器中组件（对象）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getBeanFromIoC</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">ClassPathXmlApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>();<br>    context.setConfigLocations(<span class="hljs-string">&quot;spring-03.xml&quot;</span>);<br>    context.refresh();<br>    <span class="hljs-comment">//方案1：直接根据组件名称（beanID）获取即可，返回值是Object，需要强转</span><br>    <span class="hljs-type">HappyComponent</span> <span class="hljs-variable">happyComponent</span> <span class="hljs-operator">=</span> (HappyComponent) context.getBean(<span class="hljs-string">&quot;happyComponent&quot;</span>);<br><br>    <span class="hljs-comment">//方案2：根据beanID获取对象的同时，将类对象作为参数传入</span><br>    context.getBean(<span class="hljs-string">&quot;happyComponent&quot;</span>, HappyComponent.class);<br><br>    <span class="hljs-comment">//方案3：根据类型直接获取（单例模式的好处）</span><br>    context.getBean(HappyComponent.class);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>方案3在使用时，要保证容器中只有一个同类型的bean，如果存在多个，则会出现NoUniqueBeanDefinitionException（不唯一异常）</strong></p><p><em>getBean方法只是将容器中的组件取出来，而不是生成一个对象</em></p><hr><h5 id="接口问题"><a href="#接口问题" class="headerlink" title="接口问题"></a>接口问题</h5><p>在IoC容器的创建中，是不可以对接口进行创建的</p><p>但是在读取IoC容器时，是可以直接根据接口类型来获取到具体的对象的（getBean的参数可以为接口名）</p><p>这是因为，getBean的底层实现是通过类对象（.class）和调用instanceof的反射机制</p><p>instanceof在判断接口类型的类对象的结果依然为true，即为通过判断，就可以获取到具体的类对象啦 😊</p><hr><h3 id="组件的作用域和周期方法"><a href="#组件的作用域和周期方法" class="headerlink" title="组件的作用域和周期方法"></a>组件的作用域和周期方法</h3><h5 id="周期方法"><a href="#周期方法" class="headerlink" title="周期方法"></a>周期方法</h5><p>Spring组件的周期方法有初始化方法和销毁方法，配置好后，会在特定的时间节点自动回调方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JavaBean</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;JavaBean.init&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;JavaBean.destroy&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;javaBean&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.xiaobai.ioc_04.JavaBean&quot;</span> <span class="hljs-attr">init-method</span>=<span class="hljs-string">&quot;init&quot;</span> <span class="hljs-attr">destroy-method</span>=<span class="hljs-string">&quot;destroy&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>使用bean标签的属性配置指定的初始化方法和销毁方法</p><ul><li>init-method：初始化方法</li><li>destroy-method：销毁方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test04</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">ClassPathXmlApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;spring-04.xml&quot;</span>);<span class="hljs-comment">// JavaBean.init</span><br>    <span class="hljs-type">JavaBean</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> context.getBean(JavaBean.class);<br>    context.close();<span class="hljs-comment">// JavaBean.destroy</span><br>&#125;<br></code></pre></td></tr></table></figure><p><em>注：如果不调用close方法，则容器非自然死亡，不会进入生命周期的destroy，也就不会执行销毁方法</em></p><hr><h5 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h5><p>组件被bean标签声明后，被SpringIoC容器接管，在IoC容器内，会产生一个BeanDefinition，这个类包裹了Bean标签的所有属性，例：</p><ul><li>id</li><li>class</li><li>init-method</li><li>destory-method</li><li>……</li></ul><p>SpringIoC容器会根据BeanDefinition对象反射创建多个Bean对象实例</p><p>容器的作用域由Bean标签的scope属性决定，默认是单例模式，一个Bean标签对应一个组件对象</p><ul><li>ingleton：单例（默认值）</li><li>protorype：多例</li><li>request：每次请求时创建对象</li><li>session：每次会话时创建对象</li></ul><p>可以设置为多例模式，一个Bean标签对应一个BeanDefinition对象，但对应多个组件对象</p><p><em>一般情况下都是用单例模式</em></p><hr><h3 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h3><p>标准化工厂，重写getObject方法，编写自己的实例化逻辑</p><ul><li>T getObject()：返回此工厂创建对象的实例</li><li>boolean isSingleton：判断是否为单例模式</li><li>class&lt;?&gt; getObjectType：返回对象类型，如果不知道类型则返回null</li></ul><p>FactoryBean使用场景：</p><ul><li>代理类的创建</li><li><strong>第三方框架整合</strong></li><li>复杂对象实例化</li><li>……</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;javaBean&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.xiaobai.ioc_04.JavaBeanFactoryBean&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p><em>FactoryBean也会被放在BeanDefinition中，名字为&amp;Id</em></p><hr><h5 id="FactoryBean传参问题"><a href="#FactoryBean传参问题" class="headerlink" title="FactoryBean传参问题"></a>FactoryBean传参问题</h5><p>当我们直接使用property标签给工厂Bean传参时，传到的是&amp;Id对象中（也就是工厂Bean对象）</p><p>如果想给工厂Bean中的JavaBean对象传参，则需要包裹一层set，给工厂Bean设置一个属性，再将这个属性传到里面的JavaBean中</p><p><em>注：FactoryBean和BeanFactory不同！！！</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JavaBean</span> &#123;<br><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JavaBeanFactoryBean</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">FactoryBean</span>&lt;JavaBean&gt; &#123;<br><br>    String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">JavaBeanFactoryBean</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Class&lt;?&gt; getObjectType() &#123;<br>        <span class="hljs-keyword">return</span> JavaBean.class;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> JavaBean <span class="hljs-title function_">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">JavaBean</span> <span class="hljs-variable">javaBean</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JavaBean</span>();<br>        javaBean.setName(name);<br>        <span class="hljs-keyword">return</span> javaBean;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;javaBean&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.xiaobai.ioc_04.JavaBeanFactoryBean&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;xiaobai&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>SSM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring</title>
    <link href="/2024/05/25/Spring/"/>
    <url>/2024/05/25/Spring/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h3 id="再谈框架"><a href="#再谈框架" class="headerlink" title="再谈框架"></a>再谈框架</h3><p>之前我们学习到：框架 &#x3D; 反射 + 注解 + 设计模式</p><p>而今天还有一个新增的框架概念：框架 &#x3D; jar + 配置文件</p><p>单独的一个jar包为工具类，而jar包+对其进行配置的配置文件，即可看作为框架</p><hr><h5 id="单一架构"><a href="#单一架构" class="headerlink" title="单一架构"></a>单一架构</h5><p>一个项目，一个工程，导出为一个war包，在一个Tomcat上运行，也叫all in one</p><p>项目主要应用技术框架为：Spring , SpringMVC , Mybatis</p><p><img src="https://secure2.wostatic.cn/static/bnm9zUQo34z7FgXA9vAmfm/image.png?auth_key=1716638713-aT8aDDd9vA176aygHoTtuA-0-6460278f226be5db8f6c698514ee8784&image_process=resize,w_647&file_size=85984"></p><hr><h5 id="分布式架构"><a href="#分布式架构" class="headerlink" title="分布式架构"></a>分布式架构</h5><p>一个项目（对应 IDEA 中的一个 project）</p><p>拆分成很多个模块（对应IDEA 中的一个 module）</p><p>每一个工程都是运行在自己的 Tomcat</p><p>模块之间可以互相调用。每一个模块内部可以看成是一个单一架构的应用</p><p>项目主要应用技术框架：SpringBoot (SSM), SpringCloud , 中间件等</p><p><img src="https://secure2.wostatic.cn/static/9NxDdZATsg76FfXNgskTFE/image.png?auth_key=1716638713-5WxhnUEUqEmeqbJ3v23FgD-0-5ac761a55723a7183cc3ae9387e86829&image_process=resize,w_647&file_size=55677"></p><hr><h3 id="Spring全家桶"><a href="#Spring全家桶" class="headerlink" title="Spring全家桶"></a>Spring全家桶</h3><p>我们一直所说的Spring，其实指的是以Spring Framework为基础的Spring技术栈</p><p>但实际上在SSM中，Spring特指Spring Framework</p><p>而全家桶中的其他成员也都是基于Spring Framework</p><p>他提供了很多功能：</p><ul><li>依赖注入（Dependency Injection）</li><li>面向切面编程（AOP）</li><li>声明式事务管理（TX）</li><li>……</li></ul><hr><h3 id="Spring-Framework"><a href="#Spring-Framework" class="headerlink" title="Spring Framework"></a>Spring Framework</h3><p><em>framework中文释义：管理架构；框架</em></p><p>Spring全家桶是以Spring Framework的基础上开发</p><p>所以，如果想使用其他Spring框架，必须使用Spring Framework框架</p><p>Spring Framework主要有以下四个功能：</p><ul><li>Core Container：核心容器，在Spring环境下使用任何功能都必须基于IOC容器</li><li>AOP&amp;Aspect：面向切面编程</li><li>TX：声明式事务管理</li><li>SpringMVC：提供了面向Web的应用程序的集成功能</li></ul><p><em>我们会发现，SpringMVC也在其中，但将其独立成SSM的第二个S的部分</em></p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>SSM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Maven-继承与聚合</title>
    <link href="/2024/05/25/Maven-%E7%BB%A7%E6%89%BF%E4%B8%8E%E8%81%9A%E5%90%88/"/>
    <url>/2024/05/25/Maven-%E7%BB%A7%E6%89%BF%E4%B8%8E%E8%81%9A%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h1 id="Maven-继承"><a href="#Maven-继承" class="headerlink" title="Maven-继承"></a>Maven-继承</h1><p>Maven继承是指在Maven项目中，让一个项目继承另一个项目的配置信息（pom.xml），是一种依赖管理的简化手段</p><p>在同一个项目中，可以有不同的多个模块来组成</p><p>模块之间会使用相同的框架，部分相同的依赖</p><p>我们可以选择在父工程中直接引入依赖，让子模块继承</p><hr><h3 id="父工程"><a href="#父工程" class="headerlink" title="父工程"></a>父工程</h3><p>我们建立一个模块，作为所有模块的父工程</p><p>在父工程中我们不写代码，不做具体的功能实现，所以将打包方式改为pom，并删除src文件夹</p><p>在idea中，父工程模块下建立一个新的模块，建立时设置好父项即可</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.xiaobai<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-pom-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br></code></pre></td></tr></table></figure><p>我们发现子工程模块的pom配置文件中多了一个parent标签</p><p>这个标签使用gav的方式标记了具体的父工程模块，同时继承了父工程的g和v属性</p><hr><h3 id="dependencyManagement"><a href="#dependencyManagement" class="headerlink" title="dependencyManagement"></a>dependencyManagement</h3><p>当我们在父工程模块中使用dependencies标签导入的依赖，会直接被所有子工程导入依赖</p><p>为了解决这个问题，我们在父工程中使用dependencyManagement标签</p><p>这个标签下的dependencies不会直接导入依赖，也不会让子工程导入依赖</p><p>他的作用只是声明了如果使用该依赖时，需要用到的版本号</p><p>当子工程导入依赖时，只需要依赖的ga属性，不需要再写v属性，这样就可以保证项目中所有模块的依赖版本统一</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>当项目使用父工程 -&gt; 子工程的管理方式之后，我们就可以制作出类似于node.js&amp;npm的全局依赖和项目依赖的管理方式</p><p>在父工程中使用dependencies导入的依赖，就相当于全局依赖</p><p>使用dependencyManagement声明的依赖，则提前约定好此依赖被导入时的版本号</p><p>当具体的模块导入该依赖时，不需要使用version标签，解决了各个模块中导入依赖版本不统一的问题</p><hr><h1 id="Maven-聚合"><a href="#Maven-聚合" class="headerlink" title="Maven-聚合"></a>Maven-聚合</h1><p>在父工程的配置文件中，存在modules标签</p><p>这个标签的作用就是聚合所有继承于该工程的子工程，是构建管理的简化手段</p><p><em>在module标签中的是子工程的artifactId</em></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">modules</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>shop-order<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>shop-user<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">modules</span>&gt;</span><br></code></pre></td></tr></table></figure><p>当子工程被聚合后，父工程执行构建的生命周期时会自动按照依赖关系的正确顺序依次执行子工程的构建生命周期</p><p>这样就实现了，子工程模块的统一构建</p><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>SSM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Maven-构建</title>
    <link href="/2024/05/20/Maven-%E6%9E%84%E5%BB%BA/"/>
    <url>/2024/05/20/Maven-%E6%9E%84%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="Maven-构建"><a href="#Maven-构建" class="headerlink" title="Maven-构建"></a>Maven-构建</h1><p>项目构建是指将源代码、依赖库和资源文件等转换成可执行或可部署的应用程序的过程</p><blockquote><p>清理 -&gt; 编译 -&gt; 测试 -&gt; 报告 -&gt; 打包 -&gt; 部署</p></blockquote><p>Maven项目将构建的过程全部暴露出来，让程序员可以主动触发</p><ul><li>重新编译：当编译不充分，或者部分文件没有被编译时</li><li>打包：独立部署到外部服务器软件，打包部署</li><li>部署本地或私服仓库：当我们的Maven项目要被别的项目作为依赖时，把我们的项目部署到仓库中供别人拉区</li></ul><hr><h3 id="命令方式"><a href="#命令方式" class="headerlink" title="命令方式"></a>命令方式</h3><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>mvn clean</td><td>清理编译或打包后的项目结构，删除target文件夹（类似out文件夹）</td></tr><tr><td>mvn compile</td><td>编译项目，生成target文件夹</td></tr><tr><td>mvn test</td><td>执行测试源码</td></tr><tr><td>mvn site</td><td>生成项目的所有依赖信息</td></tr><tr><td>mvn package</td><td>打包项目，生成war&#x2F;jar文件</td></tr><tr><td>mvn install</td><td>打包后上传到maven本地仓库</td></tr><tr><td>mvn depoly</td><td>打包后上传到maven私服仓库</td></tr></tbody></table><p><em>注：install和deploy命令执行的时候，项目的打包方式必须是jar</em></p><hr><h3 id="图形界面方式"><a href="#图形界面方式" class="headerlink" title="图形界面方式"></a>图形界面方式</h3><p>idea提供了maven gui，可通过图形界面的方式对项目执行生命周期中的操作</p><hr><h3 id="构建命令周期"><a href="#构建命令周期" class="headerlink" title="构建命令周期"></a>构建命令周期</h3><p>构建的生命周期有三个</p><h5 id="清理周期"><a href="#清理周期" class="headerlink" title="清理周期"></a>清理周期</h5><p>主要是对项目编译生成文件进行清理</p><p>执行命令：clean</p><h5 id="默认周期"><a href="#默认周期" class="headerlink" title="默认周期"></a>默认周期</h5><p>定义了真正构建时所需要执行的所有步骤，他是生命周期中最核心的部分</p><p>执行命令：complie -&gt; test -&gt; package -&gt; install&#x2F;deploy</p><p>当执行命令时，会自动将前置命令执行</p><h5 id="报告周期"><a href="#报告周期" class="headerlink" title="报告周期"></a>报告周期</h5><p>执行命令：site</p><h5 id="最佳使用方案："><a href="#最佳使用方案：" class="headerlink" title="最佳使用方案："></a>最佳使用方案：</h5><ul><li>打包：mvn clean package</li><li>重新编译：mvn clean compile</li><li>本地部署：mvn clean install</li></ul><hr><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>总的来说，命令对应多个插件，周期执行多个命令</p><p>真正执行构建的工具，是插件</p><p>当插件版本过低，或者需要新增插件时，在pom.xml中使用build标签添加插件，同样也是使用gav</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-war-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>SSM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Maven-setting.xml</title>
    <link href="/2024/05/20/Maven-setting.xml/"/>
    <url>/2024/05/20/Maven-setting.xml/</url>
    
    <content type="html"><![CDATA[<h1 id="setting-xml"><a href="#setting-xml" class="headerlink" title="setting.xml"></a>setting.xml</h1><p>我们同样也可以使用idea自带的maven</p><p>在.m2文件夹下创建setting.xml文件即可完成配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><br><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">Licensed to the Apache Software Foundation (ASF) under one</span><br><span class="hljs-comment">or more contributor license agreements.  See the NOTICE file</span><br><span class="hljs-comment">distributed with this work for additional information</span><br><span class="hljs-comment">regarding copyright ownership.  The ASF licenses this file</span><br><span class="hljs-comment">to you under the Apache License, Version 2.0 (the</span><br><span class="hljs-comment">&quot;License&quot;); you may not use this file except in compliance</span><br><span class="hljs-comment">with the License.  You may obtain a copy of the License at</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    http://www.apache.org/licenses/LICENSE-2.0</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Unless required by applicable law or agreed to in writing,</span><br><span class="hljs-comment">software distributed under the License is distributed on an</span><br><span class="hljs-comment">&quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY</span><br><span class="hljs-comment">KIND, either express or implied.  See the License for the</span><br><span class="hljs-comment">specific language governing permissions and limitations</span><br><span class="hljs-comment">under the License.</span><br><span class="hljs-comment">--&gt;</span><br><br><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment"> | This is the configuration file for Maven. It can be specified at two levels:</span><br><span class="hljs-comment"> |</span><br><span class="hljs-comment"> |  1. User Level. This settings.xml file provides configuration for a single user,</span><br><span class="hljs-comment"> |                 and is normally provided in $&#123;user.home&#125;/.m2/settings.xml.</span><br><span class="hljs-comment"> |</span><br><span class="hljs-comment"> |                 <span class="hljs-doctag">NOTE:</span> This location can be overridden with the CLI option:</span><br><span class="hljs-comment"> |</span><br><span class="hljs-comment"> |                 -s /path/to/user/settings.xml</span><br><span class="hljs-comment"> |</span><br><span class="hljs-comment"> |  2. Global Level. This settings.xml file provides configuration for all Maven</span><br><span class="hljs-comment"> |                 users on a machine (assuming they&#x27;re all using the same Maven</span><br><span class="hljs-comment"> |                 installation). It&#x27;s normally provided in</span><br><span class="hljs-comment"> |                 $&#123;maven.conf&#125;/settings.xml.</span><br><span class="hljs-comment"> |</span><br><span class="hljs-comment"> |                 <span class="hljs-doctag">NOTE:</span> This location can be overridden with the CLI option:</span><br><span class="hljs-comment"> |</span><br><span class="hljs-comment"> |                 -gs /path/to/global/settings.xml</span><br><span class="hljs-comment"> |</span><br><span class="hljs-comment"> | The sections in this sample file are intended to give you a running start at</span><br><span class="hljs-comment"> | getting the most out of your Maven installation. Where appropriate, the default</span><br><span class="hljs-comment"> | values (values used when the setting is not specified) are provided.</span><br><span class="hljs-comment"> |</span><br><span class="hljs-comment"> |--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">settings</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/SETTINGS/1.2.0&quot;</span></span><br><span class="hljs-tag">          <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">          <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/SETTINGS/1.2.0 https://maven.apache.org/xsd/settings-1.2.0.xsd&quot;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- localRepository</span><br><span class="hljs-comment">   | The path to the local repository maven will use to store artifacts.</span><br><span class="hljs-comment">   |</span><br><span class="hljs-comment">   | Default: $&#123;user.home&#125;/.m2/repository</span><br><span class="hljs-comment">  &lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt;</span><br><span class="hljs-comment">  --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">localRepository</span>&gt;</span>D:\.m2\repository<span class="hljs-tag">&lt;/<span class="hljs-name">localRepository</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- interactiveMode</span><br><span class="hljs-comment">   | This will determine whether maven prompts you when it needs input. If set to false,</span><br><span class="hljs-comment">   | maven will use a sensible default value, perhaps based on some other setting, for</span><br><span class="hljs-comment">   | the parameter in question.</span><br><span class="hljs-comment">   |</span><br><span class="hljs-comment">   | Default: true</span><br><span class="hljs-comment">  &lt;interactiveMode&gt;true&lt;/interactiveMode&gt;</span><br><span class="hljs-comment">  --&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- offline</span><br><span class="hljs-comment">   | Determines whether maven should attempt to connect to the network when executing a build.</span><br><span class="hljs-comment">   | This will have an effect on artifact downloads, artifact deployment, and others.</span><br><span class="hljs-comment">   |</span><br><span class="hljs-comment">   | Default: false</span><br><span class="hljs-comment">  &lt;offline&gt;false&lt;/offline&gt;</span><br><span class="hljs-comment">  --&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- pluginGroups</span><br><span class="hljs-comment">   | This is a list of additional group identifiers that will be searched when resolving plugins by their prefix, i.e.</span><br><span class="hljs-comment">   | when invoking a command line like &quot;mvn prefix:goal&quot;. Maven will automatically add the group identifiers</span><br><span class="hljs-comment">   | &quot;org.apache.maven.plugins&quot; and &quot;org.codehaus.mojo&quot; if these are not already contained in the list.</span><br><span class="hljs-comment">   |--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">pluginGroups</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- pluginGroup</span><br><span class="hljs-comment">     | Specifies a further group identifier to use for plugin lookup.</span><br><span class="hljs-comment">    &lt;pluginGroup&gt;com.your.plugins&lt;/pluginGroup&gt;</span><br><span class="hljs-comment">    --&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">pluginGroups</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- TODO Since when can proxies be selected as depicted? --&gt;</span><br>  <span class="hljs-comment">&lt;!-- proxies</span><br><span class="hljs-comment">   | This is a list of proxies which can be used on this machine to connect to the network.</span><br><span class="hljs-comment">   | Unless otherwise specified (by system property or command-line switch), the first proxy</span><br><span class="hljs-comment">   | specification in this list marked as active will be used.</span><br><span class="hljs-comment">   |--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">proxies</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- proxy</span><br><span class="hljs-comment">     | Specification for one proxy, to be used in connecting to the network.</span><br><span class="hljs-comment">     |</span><br><span class="hljs-comment">    &lt;proxy&gt;</span><br><span class="hljs-comment">      &lt;id&gt;optional&lt;/id&gt;</span><br><span class="hljs-comment">      &lt;active&gt;true&lt;/active&gt;</span><br><span class="hljs-comment">      &lt;protocol&gt;http&lt;/protocol&gt;</span><br><span class="hljs-comment">      &lt;username&gt;proxyuser&lt;/username&gt;</span><br><span class="hljs-comment">      &lt;password&gt;proxypass&lt;/password&gt;</span><br><span class="hljs-comment">      &lt;host&gt;proxy.host.net&lt;/host&gt;</span><br><span class="hljs-comment">      &lt;port&gt;80&lt;/port&gt;</span><br><span class="hljs-comment">      &lt;nonProxyHosts&gt;local.net|some.host.com&lt;/nonProxyHosts&gt;</span><br><span class="hljs-comment">    &lt;/proxy&gt;</span><br><span class="hljs-comment">    --&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">proxies</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- servers</span><br><span class="hljs-comment">   | This is a list of authentication profiles, keyed by the server-id used within the system.</span><br><span class="hljs-comment">   | Authentication profiles can be used whenever maven must make a connection to a remote server.</span><br><span class="hljs-comment">   |--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">servers</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- server</span><br><span class="hljs-comment">     | Specifies the authentication information to use when connecting to a particular server, identified by</span><br><span class="hljs-comment">     | a unique name within the system (referred to by the &#x27;id&#x27; attribute below).</span><br><span class="hljs-comment">     |</span><br><span class="hljs-comment">     | <span class="hljs-doctag">NOTE:</span> You should either specify username/password OR privateKey/passphrase, since these pairings are</span><br><span class="hljs-comment">     |       used together.</span><br><span class="hljs-comment">     |</span><br><span class="hljs-comment">    &lt;server&gt;</span><br><span class="hljs-comment">      &lt;id&gt;deploymentRepo&lt;/id&gt;</span><br><span class="hljs-comment">      &lt;username&gt;repouser&lt;/username&gt;</span><br><span class="hljs-comment">      &lt;password&gt;repopwd&lt;/password&gt;</span><br><span class="hljs-comment">    &lt;/server&gt;</span><br><span class="hljs-comment">    --&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- Another sample, using keys to authenticate.</span><br><span class="hljs-comment">    &lt;server&gt;</span><br><span class="hljs-comment">      &lt;id&gt;siteServer&lt;/id&gt;</span><br><span class="hljs-comment">      &lt;privateKey&gt;/path/to/private/key&lt;/privateKey&gt;</span><br><span class="hljs-comment">      &lt;passphrase&gt;optional; leave empty if not used.&lt;/passphrase&gt;</span><br><span class="hljs-comment">    &lt;/server&gt;</span><br><span class="hljs-comment">    --&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">servers</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- mirrors</span><br><span class="hljs-comment">   | This is a list of mirrors to be used in downloading artifacts from remote repositories.</span><br><span class="hljs-comment">   |</span><br><span class="hljs-comment">   | It works like this: a POM may declare a repository to use in resolving certain artifacts.</span><br><span class="hljs-comment">   | However, this repository may have problems with heavy traffic at times, so people have mirrored</span><br><span class="hljs-comment">   | it to several places.</span><br><span class="hljs-comment">   |</span><br><span class="hljs-comment">   | That repository definition will have a unique id, so we can create a mirror reference for that</span><br><span class="hljs-comment">   | repository, to be used as an alternate download site. The mirror site will be the preferred</span><br><span class="hljs-comment">   | server for that repository.</span><br><span class="hljs-comment">   |--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">mirrors</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- mirror</span><br><span class="hljs-comment">     | Specifies a repository mirror site to use instead of a given repository. The repository that</span><br><span class="hljs-comment">     | this mirror serves has an ID that matches the mirrorOf element of this mirror. IDs are used</span><br><span class="hljs-comment">     | for inheritance and direct lookup purposes, and must be unique across the set of mirrors.</span><br><span class="hljs-comment">     |</span><br><span class="hljs-comment">    &lt;mirror&gt;</span><br><span class="hljs-comment">      &lt;id&gt;mirrorId&lt;/id&gt;</span><br><span class="hljs-comment">      &lt;mirrorOf&gt;repositoryId&lt;/mirrorOf&gt;</span><br><span class="hljs-comment">      &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt;</span><br><span class="hljs-comment">      &lt;url&gt;http://my.repository.com/repo/path&lt;/url&gt;</span><br><span class="hljs-comment">    &lt;/mirror&gt;</span><br><span class="hljs-comment">     --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>alimaven<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>aliyun maven<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>https://maven.aliyun.com/repository/public/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>central<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>maven-default-http-blocker<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>external:http:*<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Pseudo repository to mirror external repositories initially using HTTP.<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://0.0.0.0/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">blocked</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">blocked</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">mirrors</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- profiles</span><br><span class="hljs-comment">   | This is a list of profiles which can be activated in a variety of ways, and which can modify</span><br><span class="hljs-comment">   | the build process. Profiles provided in the settings.xml are intended to provide local machine-</span><br><span class="hljs-comment">   | specific paths and repository locations which allow the build to work in the local environment.</span><br><span class="hljs-comment">   |</span><br><span class="hljs-comment">   | For example, if you have an integration testing plugin - like cactus - that needs to know where</span><br><span class="hljs-comment">   | your Tomcat instance is installed, you can provide a variable here such that the variable is</span><br><span class="hljs-comment">   | dereferenced during the build process to configure the cactus plugin.</span><br><span class="hljs-comment">   |</span><br><span class="hljs-comment">   | As noted above, profiles can be activated in a variety of ways. One way - the activeProfiles</span><br><span class="hljs-comment">   | section of this document (settings.xml) - will be discussed later. Another way essentially</span><br><span class="hljs-comment">   | relies on the detection of a property, either matching a particular value for the property,</span><br><span class="hljs-comment">   | or merely testing its existence. Profiles can also be activated by JDK version prefix, where a</span><br><span class="hljs-comment">   | value of &#x27;1.4&#x27; might activate a profile when the build is executed on a JDK version of &#x27;1.4.2_07&#x27;.</span><br><span class="hljs-comment">   | Finally, the list of active profiles can be specified directly from the command line.</span><br><span class="hljs-comment">   |</span><br><span class="hljs-comment">   | <span class="hljs-doctag">NOTE:</span> For profiles defined in the settings.xml, you are restricted to specifying only artifact</span><br><span class="hljs-comment">   |       repositories, plugin repositories, and free-form properties to be used as configuration</span><br><span class="hljs-comment">   |       variables for plugins in the POM.</span><br><span class="hljs-comment">   |</span><br><span class="hljs-comment">   |--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">profiles</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>jdk-17<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">activation</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">activeByDefault</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">activeByDefault</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">jdk</span>&gt;</span>17<span class="hljs-tag">&lt;/<span class="hljs-name">jdk</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">activation</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>17<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>17<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.compilerVersion</span>&gt;</span>17<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.compilerVersion</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- profile</span><br><span class="hljs-comment">     | Specifies a set of introductions to the build process, to be activated using one or more of the</span><br><span class="hljs-comment">     | mechanisms described above. For inheritance purposes, and to activate profiles via &lt;activatedProfiles/&gt;</span><br><span class="hljs-comment">     | or the command line, profiles have to have an ID that is unique.</span><br><span class="hljs-comment">     |</span><br><span class="hljs-comment">     | An encouraged best practice for profile identification is to use a consistent naming convention</span><br><span class="hljs-comment">     | for profiles, such as &#x27;env-dev&#x27;, &#x27;env-test&#x27;, &#x27;env-production&#x27;, &#x27;user-jdcasey&#x27;, &#x27;user-brett&#x27;, etc.</span><br><span class="hljs-comment">     | This will make it more intuitive to understand what the set of introduced profiles is attempting</span><br><span class="hljs-comment">     | to accomplish, particularly when you only have a list of profile id&#x27;s for debug.</span><br><span class="hljs-comment">     |</span><br><span class="hljs-comment">     | This profile example uses the JDK version to trigger activation, and provides a JDK-specific repo.</span><br><span class="hljs-comment">    &lt;profile&gt;</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">      &lt;id&gt;jdk-1.4&lt;/id&gt;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">      &lt;activation&gt;</span><br><span class="hljs-comment">        &lt;jdk&gt;1.4&lt;/jdk&gt;</span><br><span class="hljs-comment">      &lt;/activation&gt;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">      &lt;repositories&gt;</span><br><span class="hljs-comment">        &lt;repository&gt;</span><br><span class="hljs-comment">          &lt;id&gt;jdk14&lt;/id&gt;</span><br><span class="hljs-comment">          &lt;name&gt;Repository for JDK 1.4 builds&lt;/name&gt;</span><br><span class="hljs-comment">          &lt;url&gt;http://www.myhost.com/maven/jdk14&lt;/url&gt;</span><br><span class="hljs-comment">          &lt;layout&gt;default&lt;/layout&gt;</span><br><span class="hljs-comment">          &lt;snapshotPolicy&gt;always&lt;/snapshotPolicy&gt;</span><br><span class="hljs-comment">        &lt;/repository&gt;</span><br><span class="hljs-comment">      &lt;/repositories&gt;</span><br><span class="hljs-comment">    &lt;/profile&gt;</span><br><span class="hljs-comment">    --&gt;</span><br><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">     | Here is another profile, activated by the property &#x27;target-env&#x27; with a value of &#x27;dev&#x27;, which</span><br><span class="hljs-comment">     | provides a specific path to the Tomcat instance. To use this, your plugin configuration might</span><br><span class="hljs-comment">     | hypothetically look like:</span><br><span class="hljs-comment">     |</span><br><span class="hljs-comment">     | ...</span><br><span class="hljs-comment">     | &lt;plugin&gt;</span><br><span class="hljs-comment">     |   &lt;groupId&gt;org.myco.myplugins&lt;/groupId&gt;</span><br><span class="hljs-comment">     |   &lt;artifactId&gt;myplugin&lt;/artifactId&gt;</span><br><span class="hljs-comment">     |</span><br><span class="hljs-comment">     |   &lt;configuration&gt;</span><br><span class="hljs-comment">     |     &lt;tomcatLocation&gt;$&#123;tomcatPath&#125;&lt;/tomcatLocation&gt;</span><br><span class="hljs-comment">     |   &lt;/configuration&gt;</span><br><span class="hljs-comment">     | &lt;/plugin&gt;</span><br><span class="hljs-comment">     | ...</span><br><span class="hljs-comment">     |</span><br><span class="hljs-comment">     | <span class="hljs-doctag">NOTE:</span> If you just wanted to inject this configuration whenever someone set &#x27;target-env&#x27; to</span><br><span class="hljs-comment">     |       anything, you could just leave off the &lt;value/&gt; inside the activation-property.</span><br><span class="hljs-comment">     |</span><br><span class="hljs-comment">    &lt;profile&gt;</span><br><span class="hljs-comment">      &lt;id&gt;env-dev&lt;/id&gt;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">      &lt;activation&gt;</span><br><span class="hljs-comment">        &lt;property&gt;</span><br><span class="hljs-comment">          &lt;name&gt;target-env&lt;/name&gt;</span><br><span class="hljs-comment">          &lt;value&gt;dev&lt;/value&gt;</span><br><span class="hljs-comment">        &lt;/property&gt;</span><br><span class="hljs-comment">      &lt;/activation&gt;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">      &lt;properties&gt;</span><br><span class="hljs-comment">        &lt;tomcatPath&gt;/path/to/tomcat/instance&lt;/tomcatPath&gt;</span><br><span class="hljs-comment">      &lt;/properties&gt;</span><br><span class="hljs-comment">    &lt;/profile&gt;</span><br><span class="hljs-comment">    --&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">profiles</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- activeProfiles</span><br><span class="hljs-comment">   | List of profiles that are active for all builds.</span><br><span class="hljs-comment">   |</span><br><span class="hljs-comment">  &lt;activeProfiles&gt;</span><br><span class="hljs-comment">    &lt;activeProfile&gt;alwaysActiveProfile&lt;/activeProfile&gt;</span><br><span class="hljs-comment">    &lt;activeProfile&gt;anotherAlwaysActiveProfile&lt;/activeProfile&gt;</span><br><span class="hljs-comment">  &lt;/activeProfiles&gt;</span><br><span class="hljs-comment">  --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>SSM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Maven-依赖管理</title>
    <link href="/2024/05/20/Maven-%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/"/>
    <url>/2024/05/20/Maven-%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Maven-依赖管理"><a href="#Maven-依赖管理" class="headerlink" title="Maven-依赖管理"></a>Maven-依赖管理</h1><p>在pom.xml中，可以通过标签的方式添加第三方依赖的声明</p><p>第三方依赖的本质也是一个打包为jar的maven工程文件，他也有自己的gav标识</p><p>所以我们在标签中使用gav来确定寻找依赖即可</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.17.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p><em>如果出现报红：找不到依赖项的问题，可以刷新maven工程重新获取依赖解决</em></p><p>第三方依赖的信息我们可以通过以下两种方式获取：</p><ul><li>maven提供的查询官网：<a href="https://mvnrepository.com/">Maven Repository: Search&#x2F;Browse&#x2F;Explore (mvnrepository.com)</a></li><li>通过maven-search插件：工具 -&gt; maven-search</li></ul><p><em>通过插件的方式是使用国内的镜像源，版本偶尔会低一点而且看不到用户使用量，官网的方式也很好用</em></p><hr><h3 id="版本号声明"><a href="#版本号声明" class="headerlink" title="版本号声明"></a>版本号声明</h3><p>除了在gav的version中配置版本号，我们在properties标签中可以声明依赖的版本号</p><p>命名方式以依赖名.version的方式即可，这个标签就成为了一个变量名</p><p>使用${}去获取变量的值</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">jackson.verson</span>&gt;</span>2.17.1<span class="hljs-tag">&lt;/<span class="hljs-name">jackson.verson</span>&gt;</span><br>……<br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;jackson.verson&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h3 id="scope"><a href="#scope" class="headerlink" title="scope"></a>scope</h3><p>在dependency标签中，除了gav三条属性，还有scope属性</p><p>scope可以配置属性的作用域：</p><ul><li>compile（默认）：全局可用</li><li>test：测试可用<ul><li>Junit测试</li></ul></li><li>runtime：运行时有效<ul><li>MySql驱动</li></ul></li><li>provided：非运行时有效<ul><li>Tomcat相关：Servlet</li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.13.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><em>如果不知道依赖应该何时生效，就使用默认的全局生效</em></p><hr><h3 id="依赖冲突和依赖传递"><a href="#依赖冲突和依赖传递" class="headerlink" title="依赖冲突和依赖传递"></a>依赖冲突和依赖传递</h3><p>当出现A依赖B，B依赖C的时候，在正常项目中，我们需要导入ABC三个依赖</p><p>比如JSON的处理工具Jackson，需要导入：Jackson Databind、Jackson Core、Jackson Annotations三个依赖</p><p>这样每次导入大量依赖的方式特别繁琐，而且很有可能会出现版本问题</p><h5 id="依赖传递"><a href="#依赖传递" class="headerlink" title="依赖传递"></a>依赖传递</h5><p>而Maven项目中，使用依赖传递的特性来解决这个问题</p><p>我们在Maven官网中查询到Jackson Databind的Compile Dependencies（全局依赖）中存在Jackson Core、Jackson Annotations</p><p>而后面两个依赖没有Compile Dependencies</p><p>所以我们在导入依赖时，只导入Jackson Databind即可，其他两个依赖会作为其全局依赖被Maven导入</p><h5 id="依赖冲突"><a href="#依赖冲突" class="headerlink" title="依赖冲突"></a>依赖冲突</h5><p>当ABC循环依赖时，会出现依赖无限导入的问题</p><p>Maven在导入依赖时，发现依赖重复导入时，即刻停止导入</p><p>依赖冲突的解决原则：</p><ul><li>引用路径的长度，更短的优先</li><li>当引用路径的长度相同时，先被导入的优先</li></ul><hr><h3 id="依赖导入的问题"><a href="#依赖导入的问题" class="headerlink" title="依赖导入的问题"></a>依赖导入的问题</h3><ul><li>仓库或网络问题</li><li>pom.xml的标签配置问题</li><li>本地仓库被污染或损坏</li></ul><p>前两个问题很好解决，第三个问题多半是因为下载过程中出现错误，导致依赖存在但不完全</p><p>找到本地仓库，查看依赖是否存在lastupdate文件，如果有删掉即可</p><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>SSM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Maven</title>
    <link href="/2024/05/20/Maven/"/>
    <url>/2024/05/20/Maven/</url>
    
    <content type="html"><![CDATA[<h1 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h1><p>Maven是一款Java项目构建管理、依赖管理的工具</p><p><em>在学习前端工程化时，我们接触到了npm&amp;node.js，maven就相当于后端的项目管理，依赖管理的软件</em></p><p>同样的，Maven也有两个核心功能：</p><ul><li>依赖管理</li><li>构建管理</li></ul><p>构建这个词对于我们来说并不陌生，但不同的平台中，项目结构并不相同</p><p>比如idea和eclipse的项目结构就不同</p><p>为了解决这个问题，我们使用Maven来构建项目，让idea就作为编辑器使用，就可以解决项目结构不同的问题</p><hr><h3 id="Maven的安装"><a href="#Maven的安装" class="headerlink" title="Maven的安装"></a>Maven的安装</h3><p><a href="https://maven.apache.org/download.cgi">Maven – Download Apache Maven</a></p><p><em>注：Maven3.9.x需要JDK8以上的支持</em></p><p>Maven在解压完成后，同样需要配置环境变量Maven_HOME 和 PATH</p><hr><h3 id="Maven的配置"><a href="#Maven的配置" class="headerlink" title="Maven的配置"></a>Maven的配置</h3><p>在安装Maven之后，我们需要修改Maven的配置文件的以下三项：</p><ul><li>依赖本地缓存位置</li><li>Maven下载镜像</li><li>Maven选用编译项目的JDK版本</li></ul><p><em>在学习过Node.js之后，这些知识点的掌握则不在困难</em></p><blockquote><p>配置文件地址： maven&#x2F;conf&#x2F;settings.xml</p></blockquote><hr><h5 id="依赖本地缓存位置"><a href="#依赖本地缓存位置" class="headerlink" title="依赖本地缓存位置"></a>依赖本地缓存位置</h5><p>maven的默认依赖缓存位置时用户文件夹下的.m2文件夹中</p><p>我们可以通过修改配置文件实现修改缓存地址</p><p>在大概50行中的localRepository</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- localRepository</span><br><span class="hljs-comment">| The path to the local repository maven will use to store artifacts.</span><br><span class="hljs-comment">|</span><br><span class="hljs-comment">| Default: $&#123;user.home&#125;/.m2/repository</span><br><span class="hljs-comment">&lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt;</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">localRepository</span>&gt;</span>D:\.m2\repository<span class="hljs-tag">&lt;/<span class="hljs-name">localRepository</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h5 id="配置阿里镜像"><a href="#配置阿里镜像" class="headerlink" title="配置阿里镜像"></a>配置阿里镜像</h5><p>和npm相同，maven的中央仓库同样在国外，我们可以修改为阿里的仓库</p><p>在大概160行中的mirrors标签中</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mirrors</span>&gt;</span><br>    ……<br>    <span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>alimaven<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>aliyun maven<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>central<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span><br>    ……<br><span class="hljs-tag">&lt;/<span class="hljs-name">mirrors</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h5 id="配置JDK编译版本"><a href="#配置JDK编译版本" class="headerlink" title="配置JDK编译版本"></a>配置JDK编译版本</h5><p>在大概200行左右的profiles的标签中</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">profiles</span>&gt;</span><br>    ……<br>    <span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>jdk-17<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">activation</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">activeByDefault</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">activeByDefault</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">jdk</span>&gt;</span>17<span class="hljs-tag">&lt;/<span class="hljs-name">jdk</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">activation</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>17<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>17<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.compilerVersion</span>&gt;</span>17<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.compilerVersion</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span><br>    ……<br><span class="hljs-tag">&lt;/<span class="hljs-name">profiles</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h3 id="idea"><a href="#idea" class="headerlink" title="idea"></a>idea</h3><p>在idea中，他自带了最新版本的Maven，我们可以通过修改设置的方式配置成自己的Maven</p><blockquote><p>设置 -&gt; 构建、执行、部署 -&gt; 构建工具 -&gt; Maven -&gt; Maven主路径</p></blockquote><h5 id="GAVP"><a href="#GAVP" class="headerlink" title="GAVP"></a>GAVP</h5><p>Maven工程会多出一组gavp属性，gav需要我们在创建项目时指定，p有默认值，后期可以通过配置文件修改</p><p>gav是用来标识项目，类似人的姓、名组成的方式</p><ul><li>GroupID：com.公司名.业务线.子业务线 例如：com.xiaobai.java，一般不超过四级</li><li>ArtifactID：产品线名 例如：top-news</li><li>Version：版本号<ul><li>主版本号：当做了不兼容的API修改，或者增加了改变产品方向的新功能</li><li>次版本号：当做了向下兼容的功能性新增</li><li>修订号：修复bug，没有修改方法签名的功能加强，保持API兼容性</li></ul></li><li>Packaging：项目的包格式<ul><li>jar：默认值，代表普通的Java工程</li><li>war：代表Java的web工程</li><li>pom：代表不会打包，用来做继承的父工程</li></ul></li></ul><p><em>artifact中文释义：人工制品，手工艺品</em></p><hr><h5 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h5><p>在新建好Maven项目之后，项目中会存在src文件夹和pom.xml文件</p><p>这个文件就是对Maven的配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.xiaobai<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-javaee-project<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>war<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>17<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>17<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h3 id="JavaWeb项目"><a href="#JavaWeb项目" class="headerlink" title="JavaWeb项目"></a>JavaWeb项目</h3><p>我们可以通过手动的方式去创建maven工程下的JavaWeb项目</p><ul><li>建立项目结构</li></ul><blockquote><p>src -&gt; main -&gt; webapp -&gt; WEB-INF -&gt; web.xml</p></blockquote><ul><li>在pom.xml中改变打包类型为war</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>war<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br></code></pre></td></tr></table></figure><p>刷新maven工程之后，当webapp的图标上出现小蓝点即完成创建</p><h5 id="JBLJavaToWeb"><a href="#JBLJavaToWeb" class="headerlink" title="JBLJavaToWeb"></a>JBLJavaToWeb</h5><p>使用此插件可快速创建maven工程下的JavaWeb项目</p><hr><h3 id="Maven项目结构"><a href="#Maven项目结构" class="headerlink" title="Maven项目结构"></a>Maven项目结构</h3><p><em>Project Object Model 项目对象模型</em></p><ul><li>pom.xml：maven的配置文件</li><li>src：项目的源文件<ul><li>main：程序的主代码<ul><li>java：java源代码</li><li>resources：存放项目资源文件</li><li>webapp：存放web相关配置和资源</li></ul></li><li>test：项目的测试代码<ul><li>java：单元测试目录</li><li>测试资源目录</li></ul></li></ul></li></ul><p><em>maven工程的JavaWeb其实和普通项目的JavaWeb项目结构大同小异，在使用中并没有很大的区别</em></p><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>SSM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SSM</title>
    <link href="/2024/05/20/SSM/"/>
    <url>/2024/05/20/SSM/</url>
    
    <content type="html"><![CDATA[<h1 id="SSM"><a href="#SSM" class="headerlink" title="SSM"></a>SSM</h1><p>SSM包括Spring、MyBatis、SpringMVC</p><p>在学习SSM之前，我们会学习Maven工具</p><p>在学习SSM之后，我们会学习SpringBoot与MyBatisPlus</p><p>我们学习的版本是：Spring6+SpringBoot3</p><p><a href="https://www.wolai.com/v5Kuct5ZtPeVBk4NBUGBWF">快速掌握：全新SSM+Spring Boot+MyBatis-Plus实战精讲 (wolai.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>SSM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>微头条项目开发</title>
    <link href="/2024/05/14/%E5%BE%AE%E5%A4%B4%E6%9D%A1%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"/>
    <url>/2024/05/14/%E5%BE%AE%E5%A4%B4%E6%9D%A1%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<h1 id="微头条项目开发"><a href="#微头条项目开发" class="headerlink" title="微头条项目开发"></a>微头条项目开发</h1><p>在进行微头条项目开发的时候，学习到了新的知识点，在此记录下来</p><hr><h3 id="Postman测试工具"><a href="#Postman测试工具" class="headerlink" title="Postman测试工具"></a>Postman测试工具</h3><p><a href="https://www.postman.com/">Postman API Platform | Sign Up for Free</a></p><h5 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h5><p>不同与java中的interface接口文件，我们在这里要提到的是前端 -&gt; 后端的业务接口</p><p>在我们目前编写的微头条项目中，前端访问业务接口的形式是通过不同的URI来实现的</p><p>在后端中，Controller层定义了不同的业务接口，通过BaseController工具类反射到WebServlet注解上</p><p>通过注解的模糊匹配的方式，实现不同的URI访问不同的业务方法</p><p>我们在后端代码编写时，可通过postman测试工具来测试接口功能</p><hr><h3 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h3><p><em>toker中文释义：令牌</em></p><p>使用传统的Session和Cookie的模式，在并发问题中会有大量的服 务器开销，我们选择Token来解决问题</p><p>在验证用户名和密码正确无误后，后端将业务码（200）响应给客户端的同时，将用户信息加密成Token，一起响应给客户端</p><p>当客户端再发送请求时，就拿着加密的token解析用户信息，这样客户端就完全不知道用户的信息了</p><hr><h5 id="JWT工具类"><a href="#JWT工具类" class="headerlink" title="JWT工具类"></a>JWT工具类</h5><p>我们使用JWT工具类对Token进行加密和解析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xiaobai.headline.util;<br><br><span class="hljs-keyword">import</span> com.alibaba.druid.util.StringUtils;<br><span class="hljs-keyword">import</span> io.jsonwebtoken.*;<br><br><span class="hljs-keyword">import</span> java.util.Date;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JwtUtil</span> &#123;<br>    <span class="hljs-comment">//Token超时时间</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-variable">tokenExpiration</span> <span class="hljs-operator">=</span> <span class="hljs-number">24</span>*<span class="hljs-number">60</span>*<span class="hljs-number">60</span>*<span class="hljs-number">1000</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">tokenSignKey</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;827724&quot;</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生成Token</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> userId Long类型的userId</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 一个被加密的串（String）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">createToken</span><span class="hljs-params">(Long userId)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> Jwts.builder()<br><br>                .setSubject(<span class="hljs-string">&quot;YYGH-USER&quot;</span>)<br>                .setExpiration(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(System.currentTimeMillis() + tokenExpiration))<br>                .claim(<span class="hljs-string">&quot;userId&quot;</span>, userId)<br>                .signWith(SignatureAlgorithm.HS512, tokenSignKey)<br>                .compressWith(CompressionCodecs.GZIP)<br>                .compact();<br>        <span class="hljs-keyword">return</span> token;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 解析Token</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> token 加密的字符串Token</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 原本的userId</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Long <span class="hljs-title function_">getUserId</span><span class="hljs-params">(String token)</span> &#123;<br>        <span class="hljs-keyword">if</span>(StringUtils.isEmpty(token)) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        Jws&lt;Claims&gt; claimsJws = Jwts.parser().setSigningKey(tokenSignKey).parseClaimsJws(token);<br>        <span class="hljs-type">Claims</span> <span class="hljs-variable">claims</span> <span class="hljs-operator">=</span> claimsJws.getBody();<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> (Integer)claims.get(<span class="hljs-string">&quot;userId&quot;</span>);<br>        <span class="hljs-keyword">return</span> userId.longValue();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断token是否过期</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> token 加密的字符串Token</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> true：过期（无效） false：没过期（有效）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isExpiration</span><span class="hljs-params">(String token)</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">isExpire</span> <span class="hljs-operator">=</span> Jwts.parser()<br>                    .setSigningKey(tokenSignKey)<br>                    .parseClaimsJws(token)<br>                    .getBody()<br>                    .getExpiration().before(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>            <span class="hljs-comment">//没有过期，有效，返回false</span><br>            <span class="hljs-keyword">return</span> isExpire;<br>        &#125;<span class="hljs-keyword">catch</span>(Exception e) &#123;<br>            <span class="hljs-comment">//过期出现异常，返回true</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="GET和Post"><a href="#GET和Post" class="headerlink" title="GET和Post"></a>GET和Post</h3><p>GET方式发送请求，也可以使用请求体里装JSON的格式</p><p>POST方式发送请求，也可以使用URI后面的键值对形式</p><p>只不过在html的form表单中，get使用键值对，post使用JSON串</p><hr><h3 id="值对象"><a href="#值对象" class="headerlink" title="值对象"></a>值对象</h3><p>值对象（Value Object）</p><p>当我们发现，前端请求中的数据中，有不完全符合pojo层的实体类的数据，也就是不完全与数据库表中列完全对应的数据</p><p>这个时候我们接受数据，就要新建一个类，这个类就是值类（值对象）</p><p>他用于接受前端业务接口中传过来的请求参数，在操作数据库时，也可以将值对象中的不同属性分别放到不同的表中</p><p>甚至可以不放在任何一个表里</p><hr><h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>这是我们第一次接触到分页的问题</p><p>前端利用响应式数据绑定了一些分页所需要的参数，这些参数大致有：</p><ul><li><p>pageData：本页数据</p></li><li><p>pageNum：当前页码数</p></li><li><p>pageSize：每页显示数量</p></li><li><p>totalPage：总页数</p></li><li><p>totalSize：数据的总数</p></li></ul><p>这五个参数也是大部分分页写法的五大参数，将这些参数以键值对（JSON）的方式返回给前端</p><p>但很显然，数据库中并没有这些数据，这些是由后端调用数据库获取数据进行处理后的参数</p><p>我们需要用到VO（值对象）去包装这些参数，最后转成JSON返回前端</p><p><em>其中，pageNum（当前页码）和pageSize（每页显示数量）由前端提供，直接返回即可</em></p><hr><h5 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h5><p>这里就体现出来Controller什么都不管的性质了</p><p>Controller只负责调用Service，并且把请求中的类封装好扔进来，再接受封装好的响应类，打个包扔回前端</p><p>在Service层中，我们要给这分页五大项赋值</p><p>通过数据库查询到pageData 和 totalSize，再通过totalSize和pageSize就能算出totalPage</p><p><em>注：如果总条目数&#x2F;每页多少条能整除，那就正好分多少页，如果不能整除，要取整除的商后加1</em></p><p>将五大项打包，发给Controller处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NewsHeadlineServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">NewsHeadlineService</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">NewsHeadLineDao</span> <span class="hljs-variable">newsHeadLineDao</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NewsHeadlineDaoImpl</span>();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Map <span class="hljs-title function_">findNewsPage</span><span class="hljs-params">(HeadlineQueryVo headlineQueryVo)</span> &#123;<br>        <span class="hljs-comment">// 每页显示多少条数据和第几页都是前端给的数据，这里不需要再去处理</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">pageNum</span> <span class="hljs-operator">=</span> headlineQueryVo.getPageNum();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">pageSize</span> <span class="hljs-operator">=</span> headlineQueryVo.getPageSize();<br><br>        <span class="hljs-comment">// 调用Dao去数据库查询每条头条的所有信息</span><br>        <span class="hljs-comment">// 注：因为要返回头条发布距现在已经过了多少小时，所以不能用NewsHeadLine 用HeadlinePageVo</span><br>        List&lt;HeadlinePageVo&gt; pageData = newsHeadLineDao.findPageList(headlineQueryVo);<br><br>        <span class="hljs-comment">// 查询数据总条数，然后将数据计算后算出能分多少页</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">totalSize</span> <span class="hljs-operator">=</span> newsHeadLineDao.findPageCount(headlineQueryVo);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">totalPage</span> <span class="hljs-operator">=</span> totalSize % pageSize == <span class="hljs-number">0</span> ? totalSize / pageSize : totalSize / pageSize + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">Map</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        map.put(<span class="hljs-string">&quot;pageNum&quot;</span>, pageNum);<br>        map.put(<span class="hljs-string">&quot;pageSize&quot;</span>, pageSize);<br>        map.put(<span class="hljs-string">&quot;totalSize&quot;</span>, totalSize);<br>        map.put(<span class="hljs-string">&quot;totalPage&quot;</span>, totalPage);<br>        map.put(<span class="hljs-string">&quot;pageData&quot;</span>, pageData);<br>        <span class="hljs-keyword">return</span> map;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="Dao"><a href="#Dao" class="headerlink" title="Dao"></a>Dao</h5><p>这个sql是我们写过最复杂的sql</p><p>因为要考虑到where参数：type&#x3D;0  ：所有类型都查，</p><p>和关键词没有：不设关键词条件查询</p><p>当这两个条件存在时，我们用concat为sql语句拼串，建立params集合用来存放占位符参数</p><p>要考虑pageData中内容的排序问题</p><p>最重要的是：要考虑limit参数，每次请求只请求这一页的内容，考虑从第几页的数据（条数）开始返回，还有一页返回多少条数据</p><p><em>注：将params列表转换为数组才能给可变长参数传参</em></p><p><em>注：在sql的语句的追加拼串上，要记得前空后空</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xiaobai.headline.dao.impl;<br><br><span class="hljs-keyword">import</span> com.xiaobai.headline.dao.BaseDao;<br><span class="hljs-keyword">import</span> com.xiaobai.headline.dao.NewsHeadLineDao;<br><span class="hljs-keyword">import</span> com.xiaobai.headline.pojo.vo.HeadlinePageVo;<br><span class="hljs-keyword">import</span> com.xiaobai.headline.pojo.vo.HeadlineQueryVo;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NewsHeadlineDaoImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseDao</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">NewsHeadLineDao</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findPageCount</span><span class="hljs-params">(HeadlineQueryVo headlineQueryVo)</span> &#123;<br>        <span class="hljs-type">List</span> <span class="hljs-variable">params</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">                select</span><br><span class="hljs-string">                    count(1)</span><br><span class="hljs-string">                from</span><br><span class="hljs-string">                    news_headline</span><br><span class="hljs-string">                where</span><br><span class="hljs-string">                    is_deleted = 0</span><br><span class="hljs-string">                &quot;&quot;&quot;</span>;<br><br>        <span class="hljs-comment">// 类型和关键词查询问题</span><br>        <span class="hljs-keyword">if</span> (headlineQueryVo.getType() != <span class="hljs-number">0</span>) &#123;<br>            sql = sql.concat(<span class="hljs-string">&quot; and type = ? &quot;</span>);<br>            params.add(headlineQueryVo.getType()); <span class="hljs-comment">// 精确查询类型</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (headlineQueryVo.getKeyWords() != <span class="hljs-literal">null</span> &amp;&amp; !headlineQueryVo.getKeyWords().equals(<span class="hljs-string">&quot;&quot;</span>)) &#123;<br>            sql = sql.concat(<span class="hljs-string">&quot; and title like ? &quot;</span>);<br>            params.add(<span class="hljs-string">&quot;%&quot;</span> + headlineQueryVo.getKeyWords() + <span class="hljs-string">&quot;%&quot;</span>); <span class="hljs-comment">// 模糊查询关键词</span><br>        &#125;<br><br>        <span class="hljs-comment">//param参数是List集合，而这里是可变长参数，需要数组</span><br>        <span class="hljs-keyword">return</span> baseQueryObject(Long.class, sql, params.toArray()).intValue();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> List&lt;HeadlinePageVo&gt; <span class="hljs-title function_">findPageList</span><span class="hljs-params">(HeadlineQueryVo headlineQueryVo)</span> &#123;<br>        <span class="hljs-type">List</span> <span class="hljs-variable">params</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">                select</span><br><span class="hljs-string">                    hid,</span><br><span class="hljs-string">                    title,</span><br><span class="hljs-string">                    type,</span><br><span class="hljs-string">                    page_views pageViews,</span><br><span class="hljs-string">                    TIMESTAMPDIFF(HOUR,create_time,now()) pastHours,</span><br><span class="hljs-string">                    publisher</span><br><span class="hljs-string">                from</span><br><span class="hljs-string">                    news_headline</span><br><span class="hljs-string">                where</span><br><span class="hljs-string">                    is_deleted = 0 </span><br><span class="hljs-string">                &quot;&quot;&quot;</span>;<br><br>        <span class="hljs-comment">// 类型和关键词查询问题</span><br>        <span class="hljs-keyword">if</span> (headlineQueryVo.getType() != <span class="hljs-number">0</span>) &#123;<br>            sql = sql.concat(<span class="hljs-string">&quot; and type = ? &quot;</span>);<br>            params.add(headlineQueryVo.getType()); <span class="hljs-comment">// 精确查询类型</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (headlineQueryVo.getKeyWords() != <span class="hljs-literal">null</span> &amp;&amp; !headlineQueryVo.getKeyWords().equals(<span class="hljs-string">&quot;&quot;</span>)) &#123;<br>            sql = sql.concat(<span class="hljs-string">&quot; and title like ? &quot;</span>);<br>            params.add(<span class="hljs-string">&quot;%&quot;</span> + headlineQueryVo.getKeyWords() + <span class="hljs-string">&quot;%&quot;</span>); <span class="hljs-comment">// 模糊查询关键词</span><br>        &#125;<br><br>        <span class="hljs-comment">// 排序问题：根据发布现在时间升序，根据浏览量降序</span><br>        sql = sql.concat(<span class="hljs-string">&quot; order by pastHours asc , page_views desc &quot;</span>);<br><br>        <span class="hljs-comment">// 请求的每页数据，从哪条数据开始，返回多少条数据</span><br>        sql = sql.concat(<span class="hljs-string">&quot; limit ?,? &quot;</span>);<br>        params.add((headlineQueryVo.getPageNum() - <span class="hljs-number">1</span>) * headlineQueryVo.getPageSize());<span class="hljs-comment">// limit参数：从第几条参数（用页码*每页数据量）</span><br>        params.add(headlineQueryVo.getPageSize());<span class="hljs-comment">// limit参数：返回多少条数据</span><br><br>        <span class="hljs-comment">//param参数是List集合，而这里是可变长参数，需要数组</span><br>        <span class="hljs-keyword">return</span> baseQuery(HeadlinePageVo.class, sql, params.toArray());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="LoginFilter"><a href="#LoginFilter" class="headerlink" title="LoginFilter"></a>LoginFilter</h3><p>在前端接手了一些操作数据的过滤后，我们后端的filter只是用来处理同源禁止策略的预检请求</p><p>但完全交给前端来做登录的验证是否合适呢？</p><p>不合适，因为这对后端，对数据都是不太安全的操作</p><p>我们后端在接收到数据后，也要用token来验证一下是否为登录状态，这样进入数据库的数据才会更加安全</p><p>所以我们编写一个LoginFilter，在进行增删改查的controller之前，做一个登录判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebFilter(&quot;/headline/*&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Filter</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br>        <span class="hljs-type">HttpServletResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> (HttpServletResponse) servletResponse;<br>        <span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> (HttpServletRequest) servletRequest;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> request.getHeader(<span class="hljs-string">&quot;token&quot;</span>);<br><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span> != token  &amp;&amp; !JwtUtil.isExpiration(token); <span class="hljs-comment">// 空串也会返回true，所以无需再判断是否为空串</span><br><br>        <span class="hljs-keyword">if</span> (flag) &#123;<br>            filterChain.doFilter(request, response);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            WebUtil.writeJson(response, Result.build(<span class="hljs-literal">null</span>, ResultCodeEnum.NOTLOGIN));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="is-deleted"><a href="#is-deleted" class="headerlink" title="is_deleted"></a>is_deleted</h3><p>数据无价，我们在数据库中发现这样一个属性：is_deleted</p><p>在进行查询业务的时候，会在判断语句里增加 is_deleted &#x3D; 0，代表着这条数据没有被删除</p><p>删除数据，我们使用一个属性的0和1来代表这此数据是否被删除，而不是真正的从数据库上移除</p><p>这样就能有一个后悔药——从数据库原始数据中再次寻找被删掉的数据，相当于一个永久回收站</p><p><em>相比于随着科技进步的低廉存储价格，数据才是真正的无价</em></p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>微头条项目结束之后，我们在前端框架的帮助下，实现了后端不使用框架完成独立项目</p><p>这个项目主要是用来熟悉业务逻辑</p><p>Controller层不负责处理任何业务，只是负责req和resp</p><p>Service层用来处理具体业务</p><p>Dao层与数据库交互</p><p>以这种业务逻辑去写代码才会顺畅</p><p>接下来就是后端框架的学习，Java学习之路道阻且长，希望一切顺利！</p><hr>]]></content>
    
    
    <categories>
      
      <category>JAVAWEB</category>
      
      <category>前端工程化</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Element-plus组件库</title>
    <link href="/2024/05/13/Element-plus%E7%BB%84%E4%BB%B6%E5%BA%93/"/>
    <url>/2024/05/13/Element-plus%E7%BB%84%E4%BB%B6%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h1 id="Element-plus组件库"><a href="#Element-plus组件库" class="headerlink" title="Element-plus组件库"></a>Element-plus组件库</h1><p>Element Plus 是一套基于 Vue 3 的开源 UI 组件库，是由饿了么前端团队开发的升级版本 Element UI。</p><p>Element Plus 提供了丰富的 UI 组件、易于使用的 API 接口和灵活的主题定制功能，可以帮助开发者快速构建高质量的 Web 应用程序</p><p><em>由于 Vue 3 不再支持 IE11，Element Plus 也不再支持 IE 浏览器。</em></p><p><a href="https://element-plus.org/zh-CN/">一个 Vue 3 UI 框架 | Element Plus (element-plus.org)</a></p><hr><h3 id="Element-plus轻松使用"><a href="#Element-plus轻松使用" class="headerlink" title="Element-plus轻松使用"></a>Element-plus轻松使用</h3><p>按照惯例，我们还是先安装Element-plus的依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install element-plus<br></code></pre></td></tr></table></figure><hr><h5 id="main-js"><a href="#main-js" class="headerlink" title="main.js"></a>main.js</h5><p>我们需要修改main.js的配置文件，让全局使用Element-plus的css样式，并应用组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;createApp&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-comment">//导入ElementPlus组件，导入全局css样式</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">ElementPlus</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;element-plus&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;element-plus/dist/index.css&#x27;</span><br><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span><br><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>)<br>app.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">ElementPlus</span>)<br>app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>)<br></code></pre></td></tr></table></figure><hr><p><em><strong>直接在官网复制Element-plus组件使用即可</strong></em></p>]]></content>
    
    
    <categories>
      
      <category>JAVAWEB</category>
      
      <category>前端工程化</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Pinia</title>
    <link href="/2024/05/11/Pinia/"/>
    <url>/2024/05/11/Pinia/</url>
    
    <content type="html"><![CDATA[<h1 id="Pinia"><a href="#Pinia" class="headerlink" title="Pinia"></a>Pinia</h1><p>实现多个组件中的数据传递</p><ul><li>组件传参</li><li>路由传参</li><li>通过Pinia状态管理定义共享数据</li></ul><p><em>Pinia在使用时，有点像Sevlet中的域对象</em></p><p>Pinia数据无法进行持久化，Pinia结合SessionStorage或者LocalStorage可解决这个问题</p><p><em>Pinia的数据默认为响应式数据，且实时更新</em></p><hr><h3 id="Pinia安装依赖"><a href="#Pinia安装依赖" class="headerlink" title="Pinia安装依赖"></a>Pinia安装依赖</h3><p>在使用Pinia之前，我们按例首先安装他的依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install pinia<br></code></pre></td></tr></table></figure><hr><h3 id="Pinia轻松访问"><a href="#Pinia轻松访问" class="headerlink" title="Pinia轻松访问"></a>Pinia轻松访问</h3><h5 id="store-js"><a href="#store-js" class="headerlink" title="store.js"></a>store.js</h5><blockquote><p> 在src文件夹下建立store文件夹 -&gt; 建立store.js文件用来存放共享数据</p></blockquote><p>从Pinia框架中导入defineStore，此方法用来定义Pinia的共享数据</p><p>defineStore中有以下属性：</p><ul><li>id：当前数据的id，<strong>全局唯一</strong></li><li>state：对象本身的属性</li><li>getters：get方法，调用时直接 对象.方法 的形式调用</li><li>actions：set方法，调用时使用 对象.方法() 的形式调用</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 定义共享数据</span><br><span class="hljs-keyword">import</span> &#123;defineStore&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;pinia&quot;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> definedPerson = <span class="hljs-title function_">defineStore</span>(<br>    &#123;<br>        <span class="hljs-attr">id</span>: <span class="hljs-string">&quot;personPinia&quot;</span>, <span class="hljs-comment">//当前数据的id，必须全局唯一（多个文件中也不可以重复）</span><br>        <span class="hljs-attr">state</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-keyword">return</span> &#123;<br>                <span class="hljs-attr">username</span>: <span class="hljs-string">&quot;xiaobai&quot;</span>,<br>                <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br>                <span class="hljs-attr">hobbies</span>: [<span class="hljs-string">&quot;唱歌&quot;</span>, <span class="hljs-string">&quot;跳舞&quot;</span>]<br>            &#125;<br>        &#125;,<br>        <span class="hljs-attr">getters</span>: &#123;<br>            <span class="hljs-comment">//专门定义一些获得数据，或使用数据计算结果的方法，这里的函数不要修改数据</span><br>            <span class="hljs-title function_">getAge</span>(<span class="hljs-params"></span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>;<br>            &#125;,<br>            <span class="hljs-title function_">getHobbiesCount</span>(<span class="hljs-params"></span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">hobbies</span>.<span class="hljs-property">length</span><br>            &#125;<br>        &#125;,<br>        <span class="hljs-attr">actions</span>: &#123;<br>            <span class="hljs-comment">//专门定义一些修改数据的函数（setter）</span><br>            <span class="hljs-title function_">doubleAge</span>(<span class="hljs-params"></span>) &#123;<br>                <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> * <span class="hljs-number">2</span><br>            &#125;<br>        &#125;<br>    &#125;<br>)<br></code></pre></td></tr></table></figure><hr><h5 id="pinia-js"><a href="#pinia-js" class="headerlink" title="pinia.js"></a>pinia.js</h5><p>在src下建立一个pinia.js，存放一个建立好的pinia对象，方便main.js导入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;createPinia&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;pinia&quot;</span><br><br><span class="hljs-keyword">const</span> pinia = <span class="hljs-title function_">createPinia</span>()<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> pinia<br></code></pre></td></tr></table></figure><h5 id="main-js"><a href="#main-js" class="headerlink" title="main.js"></a>main.js</h5><p>我们需要在main.js中使用全局Pinia，就如同使用router一样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span><br><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>)<br><br><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./routers/router&#x27;</span><br>app.<span class="hljs-title function_">use</span>(router)<br><br><span class="hljs-keyword">import</span> pinia <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./pinia.js&quot;</span>;<br>app.<span class="hljs-title function_">use</span>(pinia)<br><br>app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>)<br></code></pre></td></tr></table></figure><hr><h5 id="组件中使用数据"><a href="#组件中使用数据" class="headerlink" title="组件中使用数据"></a>组件中使用数据</h5><p>导入我们暴露的对象，使用其构建一个对象</p><p><em>这种语法源自于js的原型链，即“函数即对象”一概念，对象方法在调用自身时，会返回自己本身</em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;definedPerson&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../store/store.js&quot;</span><br><span class="hljs-keyword">const</span> person = <span class="hljs-title function_">definedPerson</span>()<br></code></pre></td></tr></table></figure><p>Pinia中有一些自己的API</p><ul><li>$reset：将所有的值恢复默认，即store.js定义的那样</li><li>$patch：批量修改多个属性值</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--    恢复默认值--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;person.$reset()&quot;</span>&gt;</span>恢复默认<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-comment">&lt;!--    一次修改多个属性值--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;person.$patch(&#123;username:&#x27;奥特曼&#x27;,age:20,hobbies:[&#x27;打怪兽&#x27;]&#125;)&quot;</span>&gt;</span>变身奥特曼<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h3 id="语法小细节"><a href="#语法小细节" class="headerlink" title="语法小细节"></a>语法小细节</h3><h5 id="ID外置"><a href="#ID外置" class="headerlink" title="ID外置"></a>ID外置</h5><p>我们可以将Pinia共享数据中的id参数拿出来，作为defineStore的第一个参数使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 定义共享数据</span><br><span class="hljs-keyword">import</span> &#123;defineStore&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;pinia&quot;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> definedPerson = <span class="hljs-title function_">defineStore</span>(<span class="hljs-string">&quot;personPinia&quot;</span>, <br>    &#123;<br>        ……<br>    &#125;<br>)<br></code></pre></td></tr></table></figure><hr><h5 id="改写getters方法使用箭头函数"><a href="#改写getters方法使用箭头函数" class="headerlink" title="改写getters方法使用箭头函数"></a>改写getters方法使用箭头函数</h5><p>当然，我们可以使用箭头函数，但需要注意的是，箭头函数没有自己的this，所以要将state作为参数传进来，使用state去调用对象定义的属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 定义共享数据</span><br><span class="hljs-keyword">import</span> &#123;defineStore&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;pinia&quot;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> definedPerson = <span class="hljs-title function_">defineStore</span>(<span class="hljs-string">&quot;personPinia&quot;</span>, <br>    &#123;<br>        <span class="hljs-attr">state</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-keyword">return</span> &#123;<br>                ……<br>            &#125;<br>        &#125;,<br>        <span class="hljs-attr">getters</span>: &#123;<br>            <span class="hljs-comment">//专门定义一些获得数据，或使用数据计算结果的方法，这里的函数不要修改数据</span><br>            <span class="hljs-attr">getAge</span>:<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> &#123;<br>                <span class="hljs-keyword">return</span> state.<span class="hljs-property">age</span>;<br>            &#125;,<br>            <span class="hljs-attr">getHobbiesCount</span>:<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> &#123;<br>                <span class="hljs-keyword">return</span> state.<span class="hljs-property">hobbies</span>.<span class="hljs-property">length</span><br>            &#125;<br>        &#125;,<br>……<br>    &#125;<br>)<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>JAVAWEB</category>
      
      <category>前端工程化</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>同源禁止策略</title>
    <link href="/2024/05/11/%E5%90%8C%E6%BA%90%E7%A6%81%E6%AD%A2%E7%AD%96%E7%95%A5/"/>
    <url>/2024/05/11/%E5%90%8C%E6%BA%90%E7%A6%81%E6%AD%A2%E7%AD%96%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="同源禁止策略"><a href="#同源禁止策略" class="headerlink" title="同源禁止策略"></a>同源禁止策略</h1><p>同源策略是浏览器的一种安全策略，要求协议、域名、端口都相同才能互相访问</p><p>如果其中有一个不相同，浏览器会禁止页面加载或执行与自身不同域的脚本</p><p>这个策略有助于阻隔恶意文档，减少可能被攻击的媒介</p><blockquote><p>前端：<a href="http://localhost:5173/">http://localhost:5173/</a></p><p>后端：<a href="http://localhost:8080/">http://localhost:8080/</a></p></blockquote><p>我们发现，前后端端口不同，就会被浏览器当成不同的服务器，会触发同源禁止策略，从而浏览器无法直接向后端发送请求</p><h3 id="代理请求"><a href="#代理请求" class="headerlink" title="代理请求"></a>代理请求</h3><p>为了解决这个问题，我们可以直接让前端发送请求到后端，浏览器只需要读取数据，这种处理模式叫代理模式</p><p>但前端本身就会处理很多的业务，再让他自己去往后端发请求，会大大加重前端服务器的负载</p><h3 id="预检请求"><a href="#预检请求" class="headerlink" title="预检请求"></a>预检请求</h3><p>为了确认能够跨域，浏览器提前向后端发送一个预检请求，后端会响应一些告知客户端可以跨域的信息</p><p>预检请求之后，客户端再发送正式的请求</p><p><em>预检请求无需发送多次，只有在浏览器第一次请求后端时发送一次</em></p><h5 id="跨域过滤器"><a href="#跨域过滤器" class="headerlink" title="跨域过滤器"></a>跨域过滤器</h5><p>为了解决这个问题，我们在后端建立跨域过滤器，如果是预检请求，响应允许跨域的信息</p><p>如果不是预检请求，就直接放行</p><p>跨域过滤器并不要求我们自己写，等学到MVC框架之后，直接一个注解即可搞定</p><p>尚硅谷给我们提供了一个跨域过滤器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.xiaobai.schedule.common.Result;<br><span class="hljs-keyword">import</span> com.xiaobai.schedule.util.WebUtil;<br><span class="hljs-keyword">import</span> jakarta.servlet.*;<br><span class="hljs-keyword">import</span> jakarta.servlet.annotation.WebFilter;<br><span class="hljs-keyword">import</span> jakarta.servlet.annotation.WebServlet;<br><span class="hljs-keyword">import</span> jakarta.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> jakarta.servlet.http.HttpServletResponse;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-meta">@WebFilter(&quot;/*&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CrosFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Filter</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br><br>        <span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> (HttpServletRequest) servletRequest;<br>        System.out.println(request.getMethod());<br>        <span class="hljs-type">HttpServletResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> (HttpServletResponse) servletResponse;<br>        response.setHeader(<span class="hljs-string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="hljs-string">&quot;*&quot;</span>);<br>        response.setHeader(<span class="hljs-string">&quot;Access-Control-Allow-Methods&quot;</span>, <span class="hljs-string">&quot;POST, GET, PUT,OPTIONS, DELETE, HEAD&quot;</span>);<br>        response.setHeader(<span class="hljs-string">&quot;Access-Control-Max-Age&quot;</span>, <span class="hljs-string">&quot;3600&quot;</span>);<br>        response.setHeader(<span class="hljs-string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="hljs-string">&quot;access-control-allow-origin, authority, content-type, version-info, X-Requested-With&quot;</span>);<br>        <span class="hljs-comment">// 如果是跨域预检请求，直接做出响应200</span><br>        <span class="hljs-keyword">if</span>(request.getMethod().equalsIgnoreCase(<span class="hljs-string">&quot;OPTIONS&quot;</span>))&#123;<br>            WebUtil.writeJson(response, Result.ok(<span class="hljs-literal">null</span>));<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">// 非预检请求,放行即可</span><br>            filterChain.doFilter(servletRequest, servletResponse);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JAVAWEB</category>
      
      <category>前端工程化</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Axios-拦截器</title>
    <link href="/2024/05/10/Axios-%E6%8B%A6%E6%88%AA%E5%99%A8/"/>
    <url>/2024/05/10/Axios-%E6%8B%A6%E6%88%AA%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Axios-拦截器"><a href="#Axios-拦截器" class="headerlink" title="Axios-拦截器"></a>Axios-拦截器</h1><h3 id="axios-js"><a href="#axios-js" class="headerlink" title="axios.js"></a>axios.js</h3><blockquote><p> 在项目src文件夹下建立axios.js文件</p></blockquote><ul><li><p>建立一个实例对象，这个实例对象可以设置一些异步请求的基本信息</p></li><li><p>使用实例对象配置请求拦截器和响应拦截器</p></li><li><p>把这个实例默认暴露</p></li></ul><p><em>和路由守卫，filter都有一些相似</em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;axios&quot;</span><br><br><span class="hljs-comment">// 使用axios函数创建一个可以发送请求的实例对象</span><br><span class="hljs-keyword">const</span> instance = axios.<span class="hljs-title function_">create</span>(&#123;<br>    <span class="hljs-comment">// 请求的基础路径</span><br>    <span class="hljs-attr">baseURL</span>: <span class="hljs-string">&quot;https://api.uomg.com&quot;</span>,<br>    <span class="hljs-comment">// 超时时间（单位：毫秒）</span><br>    <span class="hljs-attr">timeout</span>: <span class="hljs-number">10000</span><br>&#125;)<br><br><span class="hljs-comment">// 设置请求拦截器</span><br>instance.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(<br>    <span class="hljs-keyword">function</span> (<span class="hljs-params">config</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;请求拦截器&quot;</span>)<br>        config.<span class="hljs-property">headers</span>.<span class="hljs-property">Accept</span> = <span class="hljs-string">&quot;application/json&quot;</span> <span class="hljs-comment">// 设置请求头</span><br>        <span class="hljs-keyword">return</span> config<br>    &#125;,<br>    <span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;请求拦截器异常方法：&quot;</span> + error)<br>        <span class="hljs-comment">// 返回一个失败状态的promise</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error)<br>    &#125;<br>)<br><br><span class="hljs-comment">//设置响应拦截器</span><br>instance.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<br>    <span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) &#123;<br>        <span class="hljs-comment">// 响应状态码为200时执行的方法</span><br>        <span class="hljs-comment">// 处理响应数据</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response)<br>        <span class="hljs-keyword">return</span> response<br>    &#125;,<br>    <span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) &#123;<br>        <span class="hljs-comment">// 状态码非200执行的方法</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error)<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error)<br>    &#125;<br>)<br><br><span class="hljs-comment">// 默认导出暴露instance</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> instance<br></code></pre></td></tr></table></figure><hr><h3 id="App-vue"><a href="#App-vue" class="headerlink" title="App.vue"></a>App.vue</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> request <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./axios.js&quot;</span>;<br></code></pre></td></tr></table></figure><p>导入axios时，导入我们在axios.js中暴露出的对象，不从框架中直接导入</p><p>在处理异步请求的响应时，对promise对象通常是调用await来解析数据，不考虑请求响应失败的问题</p><p>我们可以在请求&#x2F;响应拦截器中来打印异常</p><hr>]]></content>
    
    
    <categories>
      
      <category>JAVAWEB</category>
      
      <category>前端工程化</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Axios</title>
    <link href="/2024/05/10/Axios/"/>
    <url>/2024/05/10/Axios/</url>
    
    <content type="html"><![CDATA[<h1 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h1><h3 id="轻松启动"><a href="#轻松启动" class="headerlink" title="轻松启动"></a>轻松启动</h3><p>在学习axios之前，我们先安装axios的依赖（再一次体现vue是渐进式框架的特点）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install axios<br></code></pre></td></tr></table></figure><hr><p>从axios框架中导入axios</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;axios&quot;</span>;<br></code></pre></td></tr></table></figure><p><em>注：axios使用的是默认暴露，导入时不需要加大括号</em></p><hr><p>使用Axios设置请求的参数（请求三要素）</p><p><em><strong>Axios的返回值是一个promise对象</strong></em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getLoveMessage</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> promise = <span class="hljs-title function_">axios</span>(&#123;<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&quot;get&quot;</span>,<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&quot;https://api.uomg.com/api/rand.qinghua?format=json&quot;</span>,<br>    <span class="hljs-attr">params</span>: &#123;<br>      <span class="hljs-comment">// 如果请求方式是get，使用params中的数据会以键值对形式放入url后</span><br>      <span class="hljs-comment">// 如果请求方式是post，使用params中的数据会以键值对形式放入url后</span><br>    &#125;,<br>    <span class="hljs-attr">data</span>: &#123;<br>      <span class="hljs-comment">// 如果请求方式是post，使用data中的数据会以JSON形式放入请求体中      </span><br>    &#125;<br>  &#125;)<br></code></pre></td></tr></table></figure><p><em>以上的请求方法会在下文简化</em></p><hr><p>使用promise的API去解析响应结果对象</p><blockquote><p>Object.assign(object1, object2) 可以将后一个对象的同名参数赋值给前一个对象的同名参数</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">promise.<span class="hljs-title function_">then</span>(<br>  <span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) &#123;<br>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(message, response.<span class="hljs-property">data</span>)<br>  &#125;<br>).<span class="hljs-title function_">catch</span>(<br>  <span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error)<br>  &#125;<br>)<br></code></pre></td></tr></table></figure><p>这里可以使用await来接受参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> &#123;data&#125; = <span class="hljs-keyword">await</span> promise <span class="hljs-comment">// 使用解构表达式直接接收对象中所需的参数 从response对象中提取出data对象</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(message, data)<br></code></pre></td></tr></table></figure><hr><h5 id="response-响应结果对象"><a href="#response-响应结果对象" class="headerlink" title="response 响应结果对象"></a>response 响应结果对象</h5><ul><li>data：服务端响应回来的结果对象<ul><li>如果data是以JSON串的形式，会自动将其转换为对象</li></ul></li><li>status：响应状态码</li><li>statusText：响应状态描述</li><li>headers：本次响应的所有响应头</li><li>config：本次请求的配置信息</li><li>request：本次请求发送时所使用的XMLHttpRequest对象</li></ul><p><em>Axios本质是使用Ajax的XMLHttpResquest的异步请求</em></p><hr><h3 id="Axios-请求方法"><a href="#Axios-请求方法" class="headerlink" title="Axios 请求方法"></a>Axios 请求方法</h3><h5 id="Axios-get"><a href="#Axios-get" class="headerlink" title="Axios.get()"></a>Axios.get()</h5><p>使用Axios.get方法发送get请求，此方法中可以添加一些参数，返回值为一个promise对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;url&quot;</span>, &#123;<br>  <span class="hljs-attr">param</span>: &#123;键值对参数，被放在url的?后&#125;,<br>  <span class="hljs-attr">headers</span>: &#123;请求头参数&#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p><em>如果通过get请求指定url不添加任何参数时，可直接使用axios.get(“url”)</em></p><hr><h5 id="Axios-post"><a href="#Axios-post" class="headerlink" title="Axios.post()"></a>Axios.post()</h5><p>使用Axios.post方法发送post请求，此方法中可以添加一些参数，返回值为一个promise对象</p><p>与get()方法不同，在url和其他参数中增加一个大括号，在这个大括号里可以写json串中，被放在请求体中作为post方法的参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">axios.<span class="hljs-title function_">post</span>(<br>  <span class="hljs-string">&quot;url&quot;</span>, <br>  &#123;<span class="hljs-title class_">JSON</span>&#125;,<br>  &#123;<br>  <span class="hljs-attr">param</span>: &#123;键值对参数&#125;,<br>  <span class="hljs-attr">headers</span>: &#123;请求头参数&#125;<br>  &#125;<br>)<br></code></pre></td></tr></table></figure><p><em>与get请求一样，如果不添加任何参数可以直接写成axios.post(“url”)</em></p><hr><h5 id="Axios请求方法简写"><a href="#Axios请求方法简写" class="headerlink" title="Axios请求方法简写"></a>Axios请求方法简写</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> promise = axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;https://api.uomg.com/api/rand.qinghua&quot;</span>, &#123;<br>  <span class="hljs-attr">params</span>: &#123;<span class="hljs-attr">format</span>: <span class="hljs-string">&quot;json&quot;</span>&#125;<br>&#125;)<br></code></pre></td></tr></table></figure><hr><h3 id="案例改写：每日情话"><a href="#案例改写：每日情话" class="headerlink" title="案例改写：每日情话"></a>案例改写：每日情话</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;axios&quot;</span>;</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123;reactive&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">let</span> message = <span class="hljs-title function_">reactive</span>(&#123;</span><br><span class="language-javascript">  <span class="hljs-attr">code</span>: <span class="hljs-string">&quot;&quot;</span>,</span><br><span class="language-javascript">  <span class="hljs-attr">content</span>: <span class="hljs-string">&quot;&quot;</span></span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getLoveMessage</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">  <span class="hljs-comment">// 发送请求</span></span><br><span class="language-javascript">  <span class="hljs-keyword">let</span> promise = axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;https://api.uomg.com/api/rand.qinghua&quot;</span>, &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">params</span>: &#123;<span class="hljs-attr">format</span>: <span class="hljs-string">&quot;json&quot;</span>&#125;</span><br><span class="language-javascript">  &#125;)</span><br><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-comment">//接受响应</span></span><br><span class="language-javascript">  <span class="hljs-keyword">let</span> &#123;data&#125; = <span class="hljs-keyword">await</span> promise <span class="hljs-comment">// 使用解构表达式直接接收对象中所需的参数 从response对象中提取出data对象</span></span><br><span class="language-javascript">  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(message, data)</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123; message.content &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;getLoveMessage()&quot;</span>&gt;</span>获取每日情话<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>JAVAWEB</category>
      
      <category>前端工程化</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Promise</title>
    <link href="/2024/05/10/Promise/"/>
    <url>/2024/05/10/Promise/</url>
    
    <content type="html"><![CDATA[<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><p>前端中的异步技术，类似Java中的多线程+线程结果回调</p><p>Promise是异步编程的一种解决方案，ES6将其写进了语言标准，统一语法，提供了Promise对象</p><p>Promise中储存一个未来才会结束的事件（通常是一个异步操作），他提供了统一的API，各种异步操作都可以使用方法处理</p><p>Promise有三种状态：</p><ul><li>Pending（进行中）</li><li>Resolved（已完成，又称Fulfilled）</li><li>Rejected（已失败）</li></ul><hr><h3 id="普通函数与回调函数"><a href="#普通函数与回调函数" class="headerlink" title="普通函数与回调函数"></a>普通函数与回调函数</h3><h5 id="普通函数"><a href="#普通函数" class="headerlink" title="普通函数"></a>普通函数</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun1</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;fun1 invoked&quot;</span>)<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;code1 invoked&quot;</span>)<br><span class="hljs-title function_">fun1</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;code2 invoked&quot;</span>)<br><span class="hljs-comment">//code1 invoked</span><br><span class="hljs-comment">//fun1 invoked</span><br><span class="hljs-comment">//code2 invoked</span><br></code></pre></td></tr></table></figure><h5 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h5><p>回调函数是一个基于事件的自动调用函数</p><p>回调函数其他的代码不会等待回调函数执行完毕</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun1</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<br>      <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;fun1 invoked&quot;</span>)<br>      &#125;, <span class="hljs-number">200</span><br>  )<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;code1 invoked&quot;</span>)<br><span class="hljs-title function_">fun1</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;code2 invoked&quot;</span>)<br><span class="hljs-comment">//code1 invoked</span><br><span class="hljs-comment">//code2 invoked</span><br><span class="hljs-comment">//fun1 invoked</span><br></code></pre></td></tr></table></figure><hr><h3 id="Promise的基本用法"><a href="#Promise的基本用法" class="headerlink" title="Promise的基本用法"></a>Promise的基本用法</h3><p>resolve参数是一个函数，在回调函数中如果调用resolve方法，promise会由pending装换为resolved</p><p>reject参数也是一个函数，在回调函数中如果调用reject方法，promise会由pending装换为reject</p><p><em>在promise对象执行函数时，可将参数传递给promise.then中</em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;function invoke&#x27;</span>)<br>  <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;resolve&quot;</span>)<br>  <span class="hljs-comment">//reject(&quot;reject&quot;)</span><br>&#125;)<br></code></pre></td></tr></table></figure><h5 id="promise-then"><a href="#promise-then" class="headerlink" title="promise.then"></a>promise.then</h5><p>promise.then中有两个函数，这两个函数分别对应着promise状态为resolve和reject的执行函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">promise.<span class="hljs-title function_">then</span>(<br>    <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>      <span class="hljs-comment">// promise转换为resolve状态时，执行的函数</span><br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;promise &quot;</span> + value)<br>    &#125;,<br>    <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>      <span class="hljs-comment">// promise转换为reject状态时，执行的函数</span><br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;promise &quot;</span> + value)<br>    &#125;<br>)<br></code></pre></td></tr></table></figure><hr><h5 id="promise-then-catch"><a href="#promise-then-catch" class="headerlink" title="promise.then.catch"></a>promise.then.catch</h5><p>由promise.then继续调用.catch</p><p>当promise状态为 reject 或者 promise 出现异常或失败时，会执行的函数</p><p><em>使用catch之后，then中只需要写一个函数就行，因为catch中会包含异常和失败</em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">promise.<span class="hljs-title function_">then</span>(<br>    <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>      <span class="hljs-comment">// promise转换为resolve状态时，执行的函数</span><br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;promise &quot;</span> + value)<br>    &#125;<br>).<span class="hljs-title function_">catch</span>(<br>    <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;promise &quot;</span> + value)<br>    &#125;<br>)<br></code></pre></td></tr></table></figure><hr><h3 id="async和await"><a href="#async和await" class="headerlink" title="async和await"></a>async和await</h3><h5 id="async"><a href="#async" class="headerlink" title="async"></a>async</h5><p><em>sync中文释义：同步</em></p><p>async 帮助我们使用简介的语法获得一个promise对象</p><p><strong>async标识的函数返回的结果就是一个promise对象！！！</strong></p><p><em>如果函数本身的返回值就是一个promise，则状态由内部的promise决定</em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//第一种声明方法</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params"></span>) &#123;<br><br>&#125;<br><span class="hljs-keyword">let</span> promise = <span class="hljs-title function_">fun</span>()<br><br><span class="hljs-comment">//第二种声明方法（箭头函数）</span><br><span class="hljs-keyword">let</span> <span class="hljs-title function_">promise</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><p>当方法正常返回值，那么结果就是成功的，并将返回值作为参数传递给 promise.then</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-title function_">promise</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">10</span><br>&#125;<br><br><span class="hljs-title function_">promise</span>().<span class="hljs-title function_">then</span>(<br>    <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;promise resolve:&quot;</span> + value)<br>    &#125;<br>).<span class="hljs-title function_">catch</span>(<br>    <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;promise reject:&quot;</span> + value)<br>    &#125;<br>)<br><span class="hljs-comment">// promise resolve：10</span><br></code></pre></td></tr></table></figure><hr><p>当方法执行失败或者有异常，结果就是失败的，并将错误信息作为参数传递给 promise.then.catch</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-title function_">promise</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-comment">// return 10</span><br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;something went wrong&quot;</span>);<br>&#125;<br><br><span class="hljs-title function_">promise</span>().<span class="hljs-title function_">then</span>(<br>    <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;promise resolve:&quot;</span> + value)<br>    &#125;<br>).<span class="hljs-title function_">catch</span>(<br>    <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;promise reject:&quot;</span> + value)<br>    &#125;<br>)<br><span class="hljs-comment">// promise reject:Error: something went wrong</span><br></code></pre></td></tr></table></figure><hr><h5 id="await"><a href="#await" class="headerlink" title="await"></a>await</h5><ul><li><p><em>右边如果是一个普通值，则直接返回该值</em></p></li><li><p>右边如果是一个成功状态的promise，则会返回成功状态的结果</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-title function_">promise</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">10</span><br>&#125;<br><span class="hljs-keyword">let</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">promise</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)<br><span class="hljs-comment">// 10</span><br></code></pre></td></tr></table></figure><ul><li>右边如果是一个失败状态的promise，那么await会直接抛出异常</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-title function_">promise</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-comment">// return 10</span><br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;something went wrong&quot;</span>);<br>&#125;<br><span class="hljs-keyword">let</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">promise</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)<br><span class="hljs-comment">// Uncaught SyntaxError: await is only valid in async functions and the top level bodies of modules</span><br></code></pre></td></tr></table></figure><ul><li>await必须在async修饰的函数中使用，async函数中可以没有await</li><li>在同一个函数内await后边的代码会等待await执行完毕继续运行</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-title function_">promise</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-comment">// return 10</span><br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;something went wrong&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 这个函数必须使用async修饰，因为await必须在async修饰的函数使用</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">let</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">promise</span>()<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res) <span class="hljs-comment">// 这行代码不会执行，因为await报异常，在同一个函数内，后续代码会等待await执行之后在执行</span><br>    &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;catch: &quot;</span> + e)<br>    &#125;<br>    <span class="hljs-comment">// Uncaught SyntaxError: await is only valid in async functions and the top level bodies of modules</span><br>&#125;<br><br><span class="hljs-title function_">fun</span>()<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>JAVAWEB</category>
      
      <category>前端工程化</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Vue-router-路由守卫</title>
    <link href="/2024/05/09/Vue-router-%E8%B7%AF%E7%94%B1%E5%AE%88%E5%8D%AB/"/>
    <url>/2024/05/09/Vue-router-%E8%B7%AF%E7%94%B1%E5%AE%88%E5%8D%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue-路由守卫"><a href="#Vue-路由守卫" class="headerlink" title="Vue-路由守卫"></a>Vue-路由守卫</h1><p>路由守卫有点像是Java中的Filter过滤器，它可以在路由页面切换前后去执行一些功能代码</p><ul><li>全局前置守卫：在路由切换前被调用，可以用于验证用户登录、中断导航、请求数据等</li><li>全局后置守卫：在路由切换之后被调用，可以用于处理数据、操作Dom、记录日志等</li></ul><blockquote><p>守卫代码写在 router.js文件中</p></blockquote><hr><h3 id="全局守卫"><a href="#全局守卫" class="headerlink" title="全局守卫"></a>全局守卫</h3><p>每次路由切换页面前，都会执行beforeEach中的回调函数</p><p>回调函数提供三个参数：</p><ul><li><p>to：下一个页面，到哪里去</p></li><li><p>from：上一个页面，从哪里来</p></li><li><p>next：放行的方法，只有执行了该方法，才会放行路由</p><ul><li>next()：放行</li><li>next(&#x2F;路径)：路径的重定向</li><li><em>为避免死循环问题，必须在判断分支下使用next(&#x2F;路径)对路由进行重定向</em></li></ul></li></ul><p><em>这三个参数的顺序不能变，一定得是to,from,next</em></p><p><em>next()的作用就像是filter中的filterChain.doFilter(servletRequest, servletResponse);</em></p><p><em>to和from是两个对象，调用其path属性即可打印路径</em></p><h5 id="全局前置守卫"><a href="#全局前置守卫" class="headerlink" title="全局前置守卫"></a>全局前置守卫</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">router.<span class="hljs-title function_">beforeEach</span>(<br>    <span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(to.<span class="hljs-property">path</span>)<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">from</span>.<span class="hljs-property">path</span>)<br>        <span class="hljs-title function_">next</span>()<br>    &#125;<br>)<br></code></pre></td></tr></table></figure><h5 id="全局后置守卫"><a href="#全局后置守卫" class="headerlink" title="全局后置守卫"></a>全局后置守卫</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html">router.afterEach(<br>    (to, from) =&gt; &#123;<br><br>    &#125;<br>)<br></code></pre></td></tr></table></figure><hr><h3 id="守卫练习"><a href="#守卫练习" class="headerlink" title="守卫练习"></a>守卫练习</h3><h5 id="Login-vue"><a href="#Login-vue" class="headerlink" title="Login.vue"></a>Login.vue</h5><p>建立登陆组件，写一些功能</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;</span><br><span class="language-javascript"><span class="hljs-keyword">let</span> username = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&quot;&quot;</span>)</span><br><span class="language-javascript"><span class="hljs-keyword">let</span> password = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&quot;&quot;</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123;useRouter&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue-router&quot;</span></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">useRouter</span>()</span><br><span class="language-javascript"><span class="hljs-comment">// 获取用户名和密码 匹配后则跳转 /home</span></span><br><span class="language-javascript"><span class="hljs-comment">// 登陆失败，不跳转页面</span></span><br><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">login</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">if</span>(username.<span class="hljs-property">value</span> == <span class="hljs-string">&quot;xiaobai&quot;</span> &amp;&amp; password.<span class="hljs-property">value</span> == <span class="hljs-string">&quot;123456&quot;</span>)&#123;</span><br><span class="language-javascript">        <span class="hljs-comment">//路由跳转 /home</span></span><br><span class="language-javascript">        router.<span class="hljs-title function_">push</span>(<span class="hljs-string">&quot;/home&quot;</span>)</span><br><span class="language-javascript">        <span class="hljs-comment">//将用户名保存在浏览器上</span></span><br><span class="language-javascript">        <span class="hljs-variable language_">window</span>.<span class="hljs-property">sessionStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&quot;username&quot;</span>,username.<span class="hljs-property">value</span>)</span><br><span class="language-javascript">    &#125;<span class="hljs-keyword">else</span>&#123;</span><br><span class="language-javascript">        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;用户名或者密码错误&quot;</span>)</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>      账号: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>      密码: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;login()&quot;</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h5 id="Home-vue"><a href="#Home-vue" class="headerlink" title="Home.vue"></a>Home.vue</h5><p>建立一个home组件，写一些功能</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123;useRouter&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue-router&quot;</span></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">useRouter</span>()</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">let</span> username = <span class="hljs-variable language_">window</span>.<span class="hljs-property">sessionStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&quot;username&quot;</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">logout</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">    <span class="hljs-comment">// 清除sessionStore中的用户登录信息</span></span><br><span class="language-javascript">    <span class="hljs-variable language_">window</span>.<span class="hljs-property">sessionStorage</span>.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">&quot;username&quot;</span>)</span><br><span class="language-javascript">    <span class="hljs-comment">// 跳转到Login视图</span></span><br><span class="language-javascript">    router.<span class="hljs-title function_">push</span>(<span class="hljs-string">&quot;/login&quot;</span>)</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>home页面<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>欢迎&#123;&#123;username&#125;&#125;登录<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;logout&quot;</span>&gt;</span>退出登录<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h5 id="router-js"><a href="#router-js" class="headerlink" title="router.js"></a>router.js</h5><p>建立router.js，编写路由规则和路由守卫</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;createRouter,createWebHashHistory&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><br><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Login</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../components/Login.vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Home</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../components/Home.vue&#x27;</span><br><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createRouter</span>(&#123;<br>    <span class="hljs-attr">history</span>:<span class="hljs-title function_">createWebHashHistory</span>(),<br>    <span class="hljs-attr">routes</span>:[<br>        &#123;<br>            <span class="hljs-attr">path</span>:<span class="hljs-string">&quot;/home&quot;</span>,<br>            <span class="hljs-attr">component</span>:<span class="hljs-title class_">Home</span><br>        &#125;,<br>        &#123;<br>            <span class="hljs-attr">path</span>:<span class="hljs-string">&quot;/login&quot;</span>,<br>            <span class="hljs-attr">component</span>:<span class="hljs-title class_">Login</span><br>        &#125;<br>    ]<br>&#125;<br>)<br><br><span class="hljs-comment">//通过路由的前置守卫控制校验登录</span><br>router.<span class="hljs-title function_">beforeEach</span>(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (to.<span class="hljs-property">path</span> == <span class="hljs-string">&#x27;/login&#x27;</span>) &#123;<br>        <span class="hljs-comment">//判断如果是登录，就直接放行即可</span><br>        <span class="hljs-title function_">next</span>();<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-comment">//如果是其他资源，都要在登陆之后才放行，如果没登陆，则重定向到登陆视图</span><br>        <span class="hljs-keyword">const</span> username = <span class="hljs-variable language_">sessionStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&quot;username&quot;</span>)<br>        <span class="hljs-keyword">if</span>(<span class="hljs-literal">null</span> != username)<br>            <span class="hljs-title function_">next</span>()<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-title function_">next</span>(<span class="hljs-string">&quot;/login&quot;</span>)<br>        &#125;<br>    &#125;<br>    <br>&#125;);<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>JAVAWEB</category>
      
      <category>前端工程化</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Vue-router-路由传参</title>
    <link href="/2024/05/09/Vue-router-%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%8F%82/"/>
    <url>/2024/05/09/Vue-router-%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%8F%82/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue-路由传参"><a href="#Vue-路由传参" class="headerlink" title="Vue-路由传参"></a>Vue-路由传参</h1><p>在vue中，页面路由里不再只能由 ?key&#x3D;value 的形式传递参数</p><p>还可以使用路径参数的方式传递参数</p><hr><h3 id="路径参数"><a href="#路径参数" class="headerlink" title="路径参数"></a>路径参数</h3><h5 id="router-js-路由规则"><a href="#router-js-路由规则" class="headerlink" title="router.js 路由规则"></a>router.js 路由规则</h5><p>准备页面ShowDetail，并在路由规则中添加路径映射 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">routes</span>: [<br>    &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/showDetail/:id/:laguage&quot;</span>,<br>        <span class="hljs-attr">component</span>: <span class="hljs-title class_">ShowDetail</span><br>    &#125;,<br>    ……<br>]<br></code></pre></td></tr></table></figure><p>这里的&#x2F;:id&#x2F;:laguage是占位符，而不是路径名</p><hr><h5 id="App-vue-声明式路由传参"><a href="#App-vue-声明式路由传参" class="headerlink" title="App.vue 声明式路由传参"></a>App.vue 声明式路由传参</h5><p>使用router-link标签路由到ShowDetial组件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/showDetail/1/java&quot;</span>&gt;</span>声明式路由路径传参<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这里的&#x2F;1&#x2F;java都是路径传参，与路由规则中的占位符相呼应</p><hr><h5 id="App-vue-编程式路由传参"><a href="#App-vue-编程式路由传参" class="headerlink" title="App.vue 编程式路由传参"></a>App.vue 编程式路由传参</h5><p>无论是声明式路由还是编程式路由，都是针对路由规则中提前编写好的占位符赋值，没有本质区别</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> &#123; useRouter &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue-router&quot;</span></span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> router = <span class="hljs-title function_">useRouter</span>()</span><br><span class="language-javascript">  </span><br><span class="language-javascript">  <span class="hljs-keyword">function</span> <span class="hljs-title function_">showDetail</span>(<span class="hljs-params">id, name</span>)&#123;</span><br><span class="language-javascript">    <span class="hljs-comment">// 两种不同的实现方法</span></span><br><span class="language-javascript">    <span class="hljs-comment">// router.push(`/showDetail/$&#123;id&#125;/$&#123;name&#125;`)</span></span><br><span class="language-javascript">    router.<span class="hljs-title function_">push</span>(&#123;</span><br><span class="language-javascript">      <span class="hljs-attr">path</span>:<span class="hljs-string">`/showDetail/<span class="hljs-subst">$&#123;id&#125;</span>/<span class="hljs-subst">$&#123;name&#125;</span>`</span></span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;showDetail(2,&#x27;php&#x27;)&quot;</span>&gt;</span>编程式路由路径传参<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h5 id="ShowDetail-参数接受"><a href="#ShowDetail-参数接受" class="headerlink" title="ShowDetail 参数接受"></a>ShowDetail 参数接受</h5><p>在ShowDetail组件中，我们使用useRoute方法来接收参数</p><p><em>注：这个方法不是useRouter，那个是编程式路由的API，这个是路由传参的API！！！</em></p><p>使用useRoute生成route对象，用以调用不同的API</p><ul><li>route.params：用以接受路径参数的API</li><li>route.query：用以接受键值对参数的API</li></ul><p><em>使用生命周期的钩子函数可以在传递参数时的页面参数实时变化，个人认为这里可以使用watchEffect监听响应式数据来实现</em></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">// 接受传递过来的路径参数</span></span><br><span class="language-javascript"><span class="hljs-comment">// 这里使用useRoute，而不是useRouter</span></span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> &#123; useRoute &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span>;</span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> &#123; ref ,onUpdated&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;</span><br><span class="language-javascript"></span><br><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> route = <span class="hljs-title function_">useRoute</span>()</span><br><span class="language-javascript">  <span class="hljs-comment">// 定义响应式数据，用以接受参数</span></span><br><span class="language-javascript">  <span class="hljs-keyword">let</span> languageId = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)</span><br><span class="language-javascript">  <span class="hljs-keyword">let</span> languageName = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&quot;&quot;</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript">  languageId.<span class="hljs-property">value</span> = route.<span class="hljs-property">params</span>.<span class="hljs-property">id</span></span><br><span class="language-javascript">  languageName.<span class="hljs-property">value</span> = route.<span class="hljs-property">params</span>.<span class="hljs-property">language</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-comment">// 使用生命周期钩子，当每次更新时对页面上的数据重新赋值</span></span><br><span class="language-javascript">  <span class="hljs-title function_">onUpdated</span>(<span class="hljs-function">()=&gt;</span>&#123;</span><br><span class="language-javascript">    languageId.<span class="hljs-property">value</span> = route.<span class="hljs-property">params</span>.<span class="hljs-property">id</span></span><br><span class="language-javascript">    languageName.<span class="hljs-property">value</span> = route.<span class="hljs-property">params</span>.<span class="hljs-property">language</span></span><br><span class="language-javascript">  &#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>接受路径参数<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>&#123;&#123;languageId&#125;&#125;&#123;&#123;languageName&#125;&#125;是世界上最好的编程语言<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h3 id="键值对参数"><a href="#键值对参数" class="headerlink" title="键值对参数"></a>键值对参数</h3><h5 id="router-js-路由规则-1"><a href="#router-js-路由规则-1" class="headerlink" title="router.js 路由规则"></a>router.js 路由规则</h5><p>准备页面ShowDetail2，并在路由规则中添加路径映射 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">routes</span>: [<br>    &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/showDetail2&quot;</span>,<br>        <span class="hljs-attr">component</span>: <span class="hljs-title class_">ShowDetail2</span><br>    &#125;,<br>    ……<br>]<br></code></pre></td></tr></table></figure><p>与路径参数不同，键值对参数中对路径不做任何修改</p><hr><h5 id="App-vue-声明式路由传参-1"><a href="#App-vue-声明式路由传参-1" class="headerlink" title="App.vue 声明式路由传参"></a>App.vue 声明式路由传参</h5><p>使用router-link标签路由到ShowDetial2组件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/showDetail2?id=1&amp;language=java&quot;</span>&gt;</span>声明式路由键值对传参1<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">v-bind:to</span>=<span class="hljs-string">&quot;&#123;path:&#x27;/showDetail2&#x27;,query:&#123;id:2,language:&#x27;php&#x27;&#125;&#125;&quot;</span>&gt;</span>声明式路由键值对传参2<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br></code></pre></td></tr></table></figure><p>第一种方式就很熟悉了，用常见的?key&#x3D;value就可以传递键值对参数</p><p>第二种方式使用v-bind绑定to属性，就可以以对象的形式对to属性赋值，这种方式对参数个数，内容的使用更加灵活</p><hr><h5 id="App-vue-编程式路由传参-1"><a href="#App-vue-编程式路由传参-1" class="headerlink" title="App.vue 编程式路由传参"></a>App.vue 编程式路由传参</h5><p>与之对应的，编程式路由也有俩种写法</p><p>将router.push的参数写成对象的形式时，query就负责存放传递的键值对</p><p><em>注：为了区分变量名，我们将形参改为paraId和paramLanguage</em></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> &#123; useRouter &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue-router&quot;</span></span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> router = <span class="hljs-title function_">useRouter</span>()</span><br><span class="language-javascript">  </span><br><span class="language-javascript">  <span class="hljs-keyword">function</span> <span class="hljs-title function_">showDetail2</span>(<span class="hljs-params">id, language</span>)&#123;</span><br><span class="language-javascript">    router.<span class="hljs-title function_">push</span>(<span class="hljs-string">`/showDetail2?id=<span class="hljs-subst">$&#123;id&#125;</span>&amp;language=<span class="hljs-subst">$&#123;language&#125;</span>`</span>)</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">    </span><br><span class="language-javascript">  <span class="hljs-keyword">function</span> <span class="hljs-title function_">showDetail2</span>(<span class="hljs-params">paramId, paramLanguage</span>)&#123;</span><br><span class="language-javascript">    router.<span class="hljs-title function_">push</span>(&#123;</span><br><span class="language-javascript">      <span class="hljs-attr">path</span>:<span class="hljs-string">`/showDetail2`</span>，</span><br><span class="language-javascript">      <span class="hljs-attr">query</span>:&#123;<span class="hljs-attr">id</span>:paramId,<span class="hljs-attr">language</span>:paramLanguage&#125;</span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;showDetail2(3,&#x27;python&#x27;)&quot;</span>&gt;</span>编程式路由键值对传参<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h5 id="ShowDetail-参数接受-1"><a href="#ShowDetail-参数接受-1" class="headerlink" title="ShowDetail 参数接受"></a>ShowDetail 参数接受</h5><p>在ShowDetail组件中，我们使用useRoute方法来接收参数</p><p><em>注：这个方法不是useRouter，那个是编程式路由的API，这个是路由传参的API！！！</em></p><p>使用useRoute生成route对象，用以调用不同的API</p><ul><li>route.params：用以接受路径参数的API</li><li>route.query：用以接受键值对参数的API</li></ul><p><em>使用生命周期的钩子函数可以在传递参数时的页面参数实时变化，个人认为这里可以使用watchEffect监听响应式数据来实现</em></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">// 接受传递过来的键值对</span></span><br><span class="language-javascript"><span class="hljs-comment">// 这里使用useRoute，而不是useRouter</span></span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> &#123; useRoute &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span>;</span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> &#123; ref ,onUpdated&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;</span><br><span class="language-javascript"></span><br><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> route = <span class="hljs-title function_">useRoute</span>()</span><br><span class="language-javascript">  <span class="hljs-comment">// 定义响应式数据，用以接受参数</span></span><br><span class="language-javascript">  <span class="hljs-keyword">let</span> languageId = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)</span><br><span class="language-javascript">  <span class="hljs-keyword">let</span> languageName = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&quot;&quot;</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript">  languageId.<span class="hljs-property">value</span> = route.<span class="hljs-property">query</span>.<span class="hljs-property">id</span></span><br><span class="language-javascript">  languageName.<span class="hljs-property">value</span> = route.<span class="hljs-property">query</span>.<span class="hljs-property">language</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-comment">// 使用生命周期钩子，当每次更新时对页面上的数据重新赋值</span></span><br><span class="language-javascript">  <span class="hljs-title function_">onUpdated</span>(<span class="hljs-function">()=&gt;</span>&#123;</span><br><span class="language-javascript">    languageId.<span class="hljs-property">value</span> = route.<span class="hljs-property">query</span>.<span class="hljs-property">id</span></span><br><span class="language-javascript">    languageName.<span class="hljs-property">value</span> = route.<span class="hljs-property">query</span>.<span class="hljs-property">language</span></span><br><span class="language-javascript">  &#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>接受键值对参数<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>&#123;&#123;languageId&#125;&#125;&#123;&#123;languageName&#125;&#125;是世界上最好的编程语言<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><p><em><strong>然而，路由传参其实也算是组件之间的参数传递，我们最后仍然是使用Pinia工具更好的实现组件间传参，仍然白学</strong></em> 😓 </p>]]></content>
    
    
    <categories>
      
      <category>JAVAWEB</category>
      
      <category>前端工程化</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Vue-router-路由机制</title>
    <link href="/2024/05/08/Vue-router-%E8%B7%AF%E7%94%B1%E6%9C%BA%E5%88%B6/"/>
    <url>/2024/05/08/Vue-router-%E8%B7%AF%E7%94%B1%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue-路由机制"><a href="#Vue-路由机制" class="headerlink" title="Vue-路由机制"></a>Vue-路由机制</h1><p>路由（Router）就是根据不同的 URL 地址展示不同的内容或页面</p><ul><li><p>单页应用程序（SPA）中，路由可以实现不同视图之间的无刷新切换，提升用户体验</p></li><li><p>路由还可以利用浏览器的前进与后退，帮助用户更好地回到之前访问过的页面</p></li></ul><hr><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><p>正如我们之前所学的那样，vue是一个渐进式框架，所以在使用路由功能之前，我们需要导入路由所需依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install vue-router<br></code></pre></td></tr></table></figure><hr><h3 id="使用路由"><a href="#使用路由" class="headerlink" title="使用路由"></a>使用路由</h3><p>建立规则文件（router.js） -&gt; 在main.js中将规则文件应用在App.vue文件中 -&gt; 在App.vue中使用标签定义被替换内容</p><hr><h5 id="router-js"><a href="#router-js" class="headerlink" title="router.js"></a>router.js</h5><p>导入API：</p><ul><li>createRouter：创建一个路由规则对象，这个对象最后会被暴露<ul><li>history：存放路由器的历史记录</li><li>routes：记录页面和路径之间的路由关系</li></ul></li><li>createWebHashHistory：创建一个存放路由历史记录的对象，作为Router的第一个参数history的值</li></ul><p><em>这个API的导入框架不再是vue，而是vue-router</em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 导入创建路由对象时所需函数</span><br><span class="hljs-keyword">import</span> &#123; createRouter, createWebHashHistory &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><br><span class="hljs-comment">// 导入.vue组件</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Home</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../components/Home.vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Update</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../components/Update.vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Add</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../components/Add.vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">List</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../components/List.vue&#x27;</span><br><span class="hljs-comment">// 创建一个路由对象</span><br><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createRouter</span>(&#123;<br>    <span class="hljs-comment">// history属性用于记录路由的历史</span><br>    <span class="hljs-attr">history</span>: <span class="hljs-title function_">createWebHashHistory</span>(),<br>    <span class="hljs-comment">// 用于定义多个不同路径和组件之间的对应关系</span><br>    <span class="hljs-attr">routes</span>: [<br>        &#123;<br>            <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/home&quot;</span>,<br>            <span class="hljs-attr">component</span>: <span class="hljs-title class_">Home</span><br>        &#125;,<br>        &#123;<br>            <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/add&quot;</span>,<br>            <span class="hljs-attr">component</span>: <span class="hljs-title class_">Add</span><br>        &#125;,<br>        &#123;<br>            <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/update&quot;</span>,<br>            <span class="hljs-attr">component</span>: <span class="hljs-title class_">Update</span><br>        &#125;,<br>        &#123;<br>            <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/list&quot;</span>,<br>            <span class="hljs-attr">component</span>: <span class="hljs-title class_">List</span><br>        &#125;,<br>        &#123;<br>            <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/&quot;</span>,<br>            <span class="hljs-attr">component</span>: <span class="hljs-title class_">Home</span><br>        &#125;<br>    ]<br>&#125;)<br><br><span class="hljs-comment">// 向外暴露router</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router<br></code></pre></td></tr></table></figure><hr><h5 id="main-js"><a href="#main-js" class="headerlink" title="main.js"></a>main.js</h5><p>将路由规则导入后，挂载对象之前使用路由</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span><br><br><span class="hljs-comment">// 在整个App.vue中可以使用路由</span><br><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./routers/router.js&#x27;</span><br><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>)<br><br><span class="hljs-comment">// 在挂载对象之前，先使用路由</span><br>app.<span class="hljs-title function_">use</span>(router)<br><br>app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>)<br></code></pre></td></tr></table></figure><hr><h5 id="App-vue"><a href="#App-vue" class="headerlink" title="App.vue"></a>App.vue</h5><p>在App.vue中使用router-view标签，定义被替换内容的位置</p><p>使用router-link标签可快速跳转到指定的页面</p><p><em>注：router-link标签并不只应用于App.vue的组件，换句话说，app.vue也仅仅是一个组件而已，其他组件当然也可以使用router-link标签实现页面的跳转</em></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    App开头的内容 <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/home&quot;</span>&gt;</span>Home页<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/list&quot;</span>&gt;</span>List页<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/update&quot;</span>&gt;</span>Update页<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/add&quot;</span>&gt;</span>Add页<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 该标签会被替换成具体的.vue --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br>    App结尾的内容<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-attribute">x</span></span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h3 id="路由的重定向"><a href="#路由的重定向" class="headerlink" title="路由的重定向"></a>路由的重定向</h3><p>我们可以在router.js的路由规则中，加入路由重定向</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/showAll&quot;</span>,<br>    <span class="hljs-attr">redirect</span>:<span class="hljs-string">&quot;/list&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码是：当我们访问showAll这个路径时，不再寻找某个组件，而是将页面重定向&#x2F;list这个url上</p><p>这里并不是将整个页面跳转，仍然是在路由的基础上重定向到url</p><p><em>注：redirect属性的值为字符串，其中为路径</em></p><hr><h3 id="router-view的name属性"><a href="#router-view的name属性" class="headerlink" title="router-view的name属性"></a>router-view的name属性</h3><p>可以存在多个router-view  </p><p>同时也可以通过name属性，设置router-view专门展示某一个页面</p><h5 id="App-vue-1"><a href="#App-vue-1" class="headerlink" title="App.vue"></a>App.vue</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    App开头的内容 <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/home&quot;</span>&gt;</span>Home页<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span> &amp;nbsp<br>    <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/list&quot;</span>&gt;</span>List页<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span> &amp;nbsp<br>    <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/update&quot;</span>&gt;</span>Update页<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span> &amp;nbsp<br>    <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/add&quot;</span>&gt;</span>Add页<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span> &amp;nbsp<br>    <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/list&quot;</span>&gt;</span>showAll页<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 该标签会被替换成具体的.vue --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br>    Home页<span class="hljs-tag">&lt;<span class="hljs-name">router-view</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;homeView&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br>    List页<span class="hljs-tag">&lt;<span class="hljs-name">router-view</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;listView&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br>    update页<span class="hljs-tag">&lt;<span class="hljs-name">router-view</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;updateView&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br>    add页<span class="hljs-tag">&lt;<span class="hljs-name">router-view</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;addView&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br>    App结尾的内容<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br></code></pre></td></tr></table></figure><hr><h5 id="router-js-1"><a href="#router-js-1" class="headerlink" title="router.js"></a>router.js</h5><p>路由规则中的对应关系，把路径 -&gt; 组件 改写成 路径 -&gt; name属性相同的组件</p><p>在routes里的参数，组件属性component改写成components对象，其中内容为：</p><blockquote><p> home值:组件名</p></blockquote><p>对于name值为空的router-view标签，我们可以通过 default:组件名 设置其替换内容</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs js">……<br><span class="hljs-attr">routes</span>: [<br>    &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/home&quot;</span>,<br>        <span class="hljs-attr">components</span>:&#123;<br>            <span class="hljs-attr">default</span>:<span class="hljs-title class_">Home</span>,<br>            <span class="hljs-attr">homeView</span>:<span class="hljs-title class_">Home</span><br>        &#125;<br>    &#125;,<br>    &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/add&quot;</span>,<br>        <span class="hljs-attr">components</span>:&#123;<br>            <span class="hljs-attr">default</span>:<span class="hljs-title class_">Home</span>,<br>            <span class="hljs-attr">addView</span>:<span class="hljs-title class_">Add</span><br>        &#125;<br>    &#125;,<br>    &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/update&quot;</span>,<br>        <span class="hljs-attr">components</span>:&#123;<br>            <span class="hljs-attr">default</span>:<span class="hljs-title class_">Home</span>,<br>            <span class="hljs-attr">updateView</span>:<span class="hljs-title class_">Update</span><br>        &#125; <br>    &#125;,<br>    &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/list&quot;</span>,<br>        <span class="hljs-attr">components</span>:&#123;<br>            <span class="hljs-attr">default</span>:<span class="hljs-title class_">Home</span>,<br>            <span class="hljs-attr">listView</span>:<span class="hljs-title class_">List</span><br>        &#125; <br>    &#125;,<br>    &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/&quot;</span>,<br>        <span class="hljs-attr">component</span>: <span class="hljs-title class_">Home</span><br>    &#125;,<br>    &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/showAll&quot;</span>,<br>        <span class="hljs-attr">redirect</span>:<span class="hljs-string">&quot;/list&quot;</span><br>    &#125;<br>]<br>……<br></code></pre></td></tr></table></figure><p><em><strong>然而，一个普通的项目中，一个router-view即可解决百分之99的问题，所以这个知识点我们只需要了解，还是白学</strong></em> 😓</p><hr><h3 id="Vue-声明式路由和编程式路由"><a href="#Vue-声明式路由和编程式路由" class="headerlink" title="Vue-声明式路由和编程式路由"></a>Vue-声明式路由和编程式路由</h3><p>使用router-link的方式是声明式路由，to属性为要跳转的路径，这种方式是固定跳转页面</p><p>我们也可以使用编程式路由，在js代码中跳转页面，搭配双向绑定的响应式数据，可实现灵活的页面跳转</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-comment">// 从vue-router框架中导入useRouterAPI</span></span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> &#123; useRouter &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue-router&quot;</span></span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> &#123;ref&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span></span><br><span class="language-javascript">  <span class="hljs-comment">// 这个对象就是router.js暴露出来的对象</span></span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> router = <span class="hljs-title function_">useRouter</span>()</span><br><span class="language-javascript">  </span><br><span class="language-javascript">  <span class="hljs-keyword">let</span> myPath = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&quot;&quot;</span>)</span><br><span class="language-javascript">  </span><br><span class="language-javascript">  <span class="hljs-comment">//router的push方法，可以跳转页面</span></span><br><span class="language-javascript">  <span class="hljs-keyword">function</span> <span class="hljs-title function_">goMyPage</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">    <span class="hljs-comment">// 以下两种写法都可以</span></span><br><span class="language-javascript">    <span class="hljs-comment">// router.push(myPath)</span></span><br><span class="language-javascript">    router.<span class="hljs-title function_">push</span>(&#123;</span><br><span class="language-javascript">      <span class="hljs-attr">path</span>:myPath.<span class="hljs-property">value</span></span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 声明式路由 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/home&quot;</span>&gt;</span>Home页<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span> &amp;nbsp<br>    <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/list&quot;</span>&gt;</span>List页<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span> &amp;nbsp<br>    <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/update&quot;</span>&gt;</span>Update页<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span> &amp;nbsp<br>    <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/add&quot;</span>&gt;</span>Add页<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span> &amp;nbsp<br>    <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 编程式路由 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;myPath&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;goMyPage()&quot;</span>&gt;</span>GO<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><p>当我们需要固定跳转页面时，选择声明式路由</p><p>如果需要灵活的页面跳转，就选择编程式路由</p>]]></content>
    
    
    <categories>
      
      <category>JAVAWEB</category>
      
      <category>前端工程化</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Vue-组件</title>
    <link href="/2024/05/08/Vue-%E7%BB%84%E4%BB%B6/"/>
    <url>/2024/05/08/Vue-%E7%BB%84%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue-组件"><a href="#Vue-组件" class="headerlink" title="Vue-组件"></a>Vue-组件</h1><p>前文有关于组件，我们提到了SFC（Single File Component）单文件组件</p><hr><h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p>在components（组件库）中，建立三个组件（.vue文件）</p><h5 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    欢迎：xxx <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>退出登录<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="Navigator"><a href="#Navigator" class="headerlink" title="Navigator"></a>Navigator</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>学员管理<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>图书管理<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>请假管理<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>考试管理<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>班级管理<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>教师管理<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="Content"><a href="#Content" class="headerlink" title="Content"></a>Content</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><br><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    这里是展示主要内容<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h5 id="App-vue"><a href="#App-vue" class="headerlink" title="App.vue"></a>App.vue</h5><p>在App.vue文件中，将这三个文件组合</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">//引入多个.vue组件</span></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Header</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/Header.vue&#x27;</span></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Navigator</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/Navigator.vue&#x27;</span></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Content</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/Content.vue&#x27;</span></span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 直接将引入的.vue组件作为标签使用 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Header</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;header&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Header</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Navigator</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;navigator&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Navigator</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">content</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">content</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-comment">/* 在css中调整组件位置和大小，完成布局 */</span></span><br><span class="language-css"><span class="hljs-selector-class">.header</span>&#123;</span><br><span class="language-css">  <span class="hljs-attribute">height</span>: <span class="hljs-number">80px</span>;</span><br><span class="language-css">  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid red;</span><br><span class="language-css">&#125;</span><br><span class="language-css"><span class="hljs-selector-class">.navigator</span>&#123;</span><br><span class="language-css">  <span class="hljs-attribute">width</span>: <span class="hljs-number">15%</span>;</span><br><span class="language-css">  <span class="hljs-attribute">height</span>: <span class="hljs-number">500px</span>;</span><br><span class="language-css">  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid green;</span><br><span class="language-css">  <span class="hljs-attribute">float</span>: left;</span><br><span class="language-css">  <span class="hljs-comment">/* 利用浮动，使两个元素在一行 */</span></span><br><span class="language-css">&#125;</span><br><span class="language-css"><span class="hljs-selector-class">.content</span>&#123;</span><br><span class="language-css">  <span class="hljs-attribute">width</span>: <span class="hljs-number">84%</span>;</span><br><span class="language-css">  <span class="hljs-attribute">height</span>: <span class="hljs-number">500px</span>;</span><br><span class="language-css">  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid blue;</span><br><span class="language-css">  <span class="hljs-attribute">float</span>: right;</span><br><span class="language-css">    <span class="hljs-comment">/* 利用浮动，使两个元素在一行 */</span></span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h5><p><img src="/upload/vue%E7%BB%84%E4%BB%B6.PNG" alt="vue组件.PNG"></p><hr><h3 id="组件中的参数传递"><a href="#组件中的参数传递" class="headerlink" title="组件中的参数传递"></a>组件中的参数传递</h3><p>组件中的参数传递有三种方式</p><ul><li>子传父</li><li>父传子</li><li>兄弟传参（基于以上两种实现）</li></ul><blockquote><p>defineEmits方法：用于定义向父组件提交数据的事件以及正式的提交数据</p><p>defineProps方法：用于定义接受父组件传递的响应式数据和数据类型</p></blockquote><p>当子组件Content和Navigator 传递数据时，需要经过App.vue父组件</p><hr><h5 id="Navigator-1"><a href="#Navigator-1" class="headerlink" title="Navigator"></a>Navigator</h5><p>个人理解就是，使用defineEmits方法定义了emits对象的key值（可以有多个key），这个key值自定义</p><p>再用emits对象为其key设置value，就完成数据的子传父</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">//向父组件发送参数</span></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; defineEmits &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;</span><br><span class="language-javascript"><span class="hljs-comment">//定义一个向父组件提交数据的事件，事件名称自定义</span></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> emits = <span class="hljs-title function_">defineEmits</span>([<span class="hljs-string">&quot;sendMenu&quot;</span>])</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">//定义一个提交数据的方法</span></span><br><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">send</span>(<span class="hljs-params">data</span>)&#123;</span><br><span class="language-javascript">  <span class="hljs-title function_">emits</span>(<span class="hljs-string">&quot;sendMenu&quot;</span>,data)</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;send(&#x27;学员管理&#x27;)&quot;</span>&gt;</span>学员管理<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      ……<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br></code></pre></td></tr></table></figure><hr><h5 id="App-vue-1"><a href="#App-vue-1" class="headerlink" title="App.vue"></a>App.vue</h5><p><em>注：在使用事件接受子组件传过来的参数时，事件执行的函数不加 ()</em></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">//引入多个.vue组件</span></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Header</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/Header.vue&#x27;</span></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Navigator</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/Navigator.vue&#x27;</span></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Content</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/Content.vue&#x27;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">//定义响应式数据，接受子传父的参数</span></span><br><span class="language-javascript"><span class="hljs-keyword">let</span> menu = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&quot;&quot;</span>)</span><br><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">receiver</span>(<span class="hljs-params">data</span>)&#123;</span><br><span class="language-javascript">  menu.<span class="hljs-property">value</span> = data</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br>……<br>    <span class="hljs-comment">&lt;!-- 用定义好的sendMenu（key）接收子组件传上来的data --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Navigator</span> @<span class="hljs-attr">sendMenu</span>=<span class="hljs-string">&quot;receiver&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;navigator&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Navigator</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 将接收到的data 通过message属性发送给子组件 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">content</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span> <span class="hljs-attr">:message</span>=<span class="hljs-string">&quot;menu&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">content</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><br>……<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h5 id="Content-1"><a href="#Content-1" class="headerlink" title="Content"></a>Content</h5><p>content类似一个自定义标签，组件中使用v-bind:属性 就相当于绑定数据到属性中</p><p>在子组件使用defineProps直接接受属性，参数类型</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">//接受父组件的参数</span></span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> &#123; defineProps &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;</span><br><span class="language-javascript">  <span class="hljs-title function_">defineProps</span>(&#123;</span><br><span class="language-javascript">    <span class="hljs-attr">message</span>:<span class="hljs-title class_">String</span></span><br><span class="language-javascript">  &#125;)</span><br><span class="language-javascript"></span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    &#123;&#123;message&#125;&#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><p><em><strong>这种组件中的数据传递有很大的限制，他仅限于父子之间的数据传递，而且数据复杂后写起来十分麻烦</strong></em></p><p><em><strong>后续的学习中，我们会学习Pinia定义.vue共享的数据，实现数据传递，所以仍然是白学</strong></em> 😓 </p><hr>]]></content>
    
    
    <categories>
      
      <category>JAVAWEB</category>
      
      <category>前端工程化</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Caddy</title>
    <link href="/2024/05/08/Caddy/"/>
    <url>/2024/05/08/Caddy/</url>
    
    <content type="html"><![CDATA[<h1 id="Caddy"><a href="#Caddy" class="headerlink" title="Caddy"></a>Caddy</h1><p><a href="https://caddy2.dengxiaolong.com/docs/install#debian-ubuntu-raspbian">安装 — Caddy v2中文文档 (dengxiaolong.com)</a></p><p>与Nginx一样，Caddy也可以实现域名反代</p><p>我们通过使用CaddyFile的方式，来实现域名反代</p><p><a href="https://caddy2.dengxiaolong.com/docs/quick-starts/caddyfile">Caddyfile 快速入门 — Caddy v2中文文档 (dengxiaolong.com)</a></p><blockquote><p>Caddy的配置文件： &#x2F;etc&#x2F;caddy&#x2F;caddyfile</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># The Caddyfile is an easy way to configure your Caddy web server.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Unless the file starts with a global options block, the first</span><br><span class="hljs-comment"># uncommented line is always the address of your site.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># To use your own domain name (with automatic HTTPS), first make</span><br><span class="hljs-comment"># sure your domain&#x27;s A/AAAA DNS records are properly pointed to</span><br><span class="hljs-comment"># this machine&#x27;s public IP, then replace &quot;:80&quot; below with your</span><br><span class="hljs-comment"># domain name.</span><br><br><span class="hljs-string">blog.170827.xyz:80</span> &#123;<br>    <span class="hljs-string">encode</span> <span class="hljs-string">gzip</span><br>    <span class="hljs-string">reverse_proxy</span> <span class="hljs-string">localhost:8090</span><br>&#125;<br><span class="hljs-string">webdav.170827.xyz:80</span> &#123;<br>    <span class="hljs-string">encode</span> <span class="hljs-string">gzip</span><br>    <span class="hljs-string">reverse_proxy</span> <span class="hljs-string">localhost:8060</span><br>&#125;<br><span class="hljs-string">zfile.170827.xyz:80</span> &#123;<br>    <span class="hljs-string">encode</span> <span class="hljs-string">gzip</span><br>    <span class="hljs-string">reverse_proxy</span> <span class="hljs-string">localhost:8100</span><br>&#125;<br><span class="hljs-comment"># Refer to the Caddy docs for more information:</span><br><span class="hljs-comment"># https://caddyserver.com/docs/caddyfile</span><br></code></pre></td></tr></table></figure><p>在<a href="https://www.cloudflare-cn.com/">Cloudflare</a>中，我们将三个二级域名解析到同一台服务器</p><p>通过Caddy，我们将不同端口的应用分别反代到不同的二级域名上</p><hr>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
      <category>server</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Vue-生命周期</title>
    <link href="/2024/05/07/Vue-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <url>/2024/05/07/Vue-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue-生命周期"><a href="#Vue-生命周期" class="headerlink" title="Vue-生命周期"></a>Vue-生命周期</h1><p><a href="https://cn.vuejs.org/guide/essentials/lifecycle.html">生命周期钩子 | Vue.js (vuejs.org)</a></p><p><img src="https://cn.vuejs.org/assets/lifecycle_zh-CN.W0MNXI0C.png"></p><hr><h3 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h3><p>有四组（八个）钩子函数，分别在vue的生命周期中被执行</p><ul><li>beforeCreate|created</li><li>beforeMount|mounted</li><li>beforeUpdate|updated</li><li>breforeUnmount|unmounted</li></ul><p>在组合式API的生命周期函数中，钩子函数会更改</p><p><a href="https://cn.vuejs.org/api/composition-api-lifecycle.html">组合式 API：生命周期钩子 | Vue.js (vuejs.org)</a></p><hr><h3 id="钩子函数的测试"><a href="#钩子函数的测试" class="headerlink" title="钩子函数的测试"></a>钩子函数的测试</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123;ref,onBeforeMount,onMounted,onBeforeUpdate,onUpdated&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span><br><span class="language-javascript"><span class="hljs-comment">//挂载之前</span></span><br><span class="language-javascript"><span class="hljs-title function_">onBeforeMount</span>(<span class="hljs-function">()=&gt;</span>&#123;</span><br><span class="language-javascript">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;----------------------onBeforeMount------------------&quot;</span>)</span><br><span class="language-javascript">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;s1&quot;</span>)) <span class="hljs-comment">//null</span></span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript"><span class="hljs-comment">//挂载之后</span></span><br><span class="language-javascript"><span class="hljs-title function_">onMounted</span>(<span class="hljs-function">()=&gt;</span>&#123;</span><br><span class="language-javascript">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;----------------------onMounted------------------&quot;</span>)</span><br><span class="language-javascript">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;s1&quot;</span>)) <span class="hljs-comment">//&lt;span id=&quot;s1&quot;&gt;1&lt;/span&gt;</span></span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript"><span class="hljs-comment">//更新之前</span></span><br><span class="language-javascript"><span class="hljs-title function_">onBeforeUpdate</span>(<span class="hljs-function">()=&gt;</span>&#123;</span><br><span class="language-javascript">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;----------------------onBeforeUpdate------------------&quot;</span>)</span><br><span class="language-javascript">  <span class="hljs-keyword">let</span> ele = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;s1&quot;</span>)</span><br><span class="language-javascript">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message.<span class="hljs-property">value</span>,ele.<span class="hljs-property">innerText</span>) <span class="hljs-comment">//2 &#x27;1&#x27;</span></span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript"><span class="hljs-comment">//更新之后</span></span><br><span class="language-javascript"><span class="hljs-title function_">onUpdated</span>(<span class="hljs-function">()=&gt;</span>&#123;</span><br><span class="language-javascript">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;----------------------onUpdated------------------&quot;</span>) <span class="hljs-comment">//2 &#x27;2&#x27;</span></span><br><span class="language-javascript">  <span class="hljs-keyword">let</span> ele = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;s1&quot;</span>)</span><br><span class="language-javascript">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message.<span class="hljs-property">value</span>,ele.<span class="hljs-property">innerText</span>)</span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript"><span class="hljs-keyword">let</span> message = <span class="hljs-title function_">ref</span>(<span class="hljs-number">1</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;s1&quot;</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;message++&quot;</span>&gt;</span>update<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span> <br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>JAVAWEB</category>
      
      <category>前端工程化</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Vue-数据监听</title>
    <link href="/2024/05/07/Vue-%E6%95%B0%E6%8D%AE%E7%9B%91%E5%90%AC/"/>
    <url>/2024/05/07/Vue-%E6%95%B0%E6%8D%AE%E7%9B%91%E5%90%AC/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue-数据监听"><a href="#Vue-数据监听" class="headerlink" title="Vue-数据监听"></a>Vue-数据监听</h1><p>从vue框架中导入watch方法，可使用watch方法实现对响应式数据的监听</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; reactive, ref, watch &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;</span><br><span class="language-javascript"><span class="hljs-keyword">let</span> fullname = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&quot;&quot;</span>);</span><br><span class="language-javascript"><span class="hljs-keyword">let</span> firstname = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&quot;&quot;</span>);</span><br><span class="language-javascript"><span class="hljs-keyword">let</span> lastname = <span class="hljs-title function_">reactive</span>(&#123;</span><br><span class="language-javascript">  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;&quot;</span>,</span><br><span class="language-javascript">&#125;);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    姓氏：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;firstname&quot;</span> /&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>    名字：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;lastname.name&quot;</span> /&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>    全名：&#123;&#123; fullname &#125;&#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h3 id="ref响应式数据的监听"><a href="#ref响应式数据的监听" class="headerlink" title="ref响应式数据的监听"></a>ref响应式数据的监听</h3><p>使用watch监听ref修饰的响应式数据时，watch中应该有两个参数：</p><ul><li>一个变量：被监听的变量名称</li><li>一个函数：当响应式数据发生改变时，要执行的函数（推荐使用箭头函数）</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//这段代码为：监听响应式数据firstname，当该数据发生变化时将字符串拼接到fullname中</span><br><span class="hljs-title function_">watch</span>(firstname, <span class="hljs-function">(<span class="hljs-params">newValue, oldValue</span>) =&gt;</span> &#123;<br>  fullname.<span class="hljs-property">value</span> = newValue + lastname.<span class="hljs-property">name</span>;<br>&#125;);<br></code></pre></td></tr></table></figure><p><em>要执行的函数中，能接到两个参数：newValue时更改后的数据，oldValue是更改前的数据</em></p><h3 id="reactive响应式数据的监听"><a href="#reactive响应式数据的监听" class="headerlink" title="reactive响应式数据的监听"></a>reactive响应式数据的监听</h3><p>使用watch监听reactive修饰的响应式数据时，watch中应该有两个参数：</p><ul><li>一个函数，该函数返回被监听的变量&#x2F;对象</li><li>一个函数，当响应式数据发生变化时，要执行的函数</li></ul><h5 id="监听属性"><a href="#监听属性" class="headerlink" title="监听属性"></a>监听属性</h5><p>当第一个参数返回值为对象中的属性时：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//这段代码为：监听响应式数据对象lastname中的name属性，当该数据发生变化时将字符串拼接到fullname中</span><br><span class="hljs-title function_">watch</span>(<br>  <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> lastname.<span class="hljs-property">name</span>;<br>  &#125;,<br>  <span class="hljs-function">(<span class="hljs-params">newValue, oldValue</span>) =&gt;</span> &#123;<br>    fullname.<span class="hljs-property">value</span> = firstname.<span class="hljs-property">value</span> + newValue;<br>  &#125;<br>);<br></code></pre></td></tr></table></figure><h5 id="监听对象"><a href="#监听对象" class="headerlink" title="监听对象"></a>监听对象</h5><p>当第一个参数返回值为对象本身时（也就是直接监听此对象），watch需要再增加一个参数：</p><ul><li>{deep:true}：增加此键值对对象，表明设置该watch为深度监听，即可实现监听对象</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//这段代码为：监听响应式数据对象lastname，当对象中的任何数据发生变化时将字符串拼接到fullname中</span><br><span class="hljs-title function_">watch</span>(<br>  <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> lastname;<br>  &#125;,<br>  <span class="hljs-function">() =&gt;</span> &#123;<br>    fullname.<span class="hljs-property">value</span> = firstname.<span class="hljs-property">value</span> + lastname.<span class="hljs-property">name</span>;<br>  &#125;,<br>  &#123; <span class="hljs-attr">deep</span>: <span class="hljs-literal">true</span> &#125;<br>);<br></code></pre></td></tr></table></figure><p><em>注：当监听对象时，newValue和oldValue参数都为对象本身，没有意义</em></p><hr><h3 id="原始数据的immediate参数"><a href="#原始数据的immediate参数" class="headerlink" title="原始数据的immediate参数"></a>原始数据的immediate参数</h3><p>当监听的响应式数据有原始数据时，因为数据没有发生改变，所以函数也不会执行</p><p>immediate参数的默认值为false，当他为true时，将会在页面加载时立刻执行一次函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">watch</span>(<br>  <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> lastname;<br>  &#125;,<br>  <span class="hljs-function">() =&gt;</span> &#123;<br>    fullname.<span class="hljs-property">value</span> = firstname.<span class="hljs-property">value</span> + lastname.<span class="hljs-property">name</span>;<br>  &#125;,<br>  &#123; <span class="hljs-attr">deep</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">immediate</span>: <span class="hljs-literal">true</span> &#125;<br>);<br></code></pre></td></tr></table></figure><hr><h3 id="watchEffect"><a href="#watchEffect" class="headerlink" title="watchEffect"></a>watchEffect</h3><p>此API从vue框架中导入</p><p>此API中只有一个参数：</p><ul><li>一个函数：当响应式数据发生改变时，要执行的函数（推荐使用箭头函数）</li></ul><p><em>此API无需区分ref和reactive的用法</em></p><p>watchEffect并不是监听所有响应式数据，他只监听<strong>在函数中使用过的响应式数据</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; reactive, ref, watchEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;</span><br><span class="language-javascript"><span class="hljs-keyword">let</span> fullname = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&quot;&quot;</span>);</span><br><span class="language-javascript"><span class="hljs-keyword">let</span> firstname = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&quot;xiao&quot;</span>);</span><br><span class="language-javascript"><span class="hljs-keyword">let</span> lastname = <span class="hljs-title function_">reactive</span>(&#123;</span><br><span class="language-javascript">  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;bai&quot;</span>,</span><br><span class="language-javascript">&#125;);</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-title function_">watchEffect</span>(<span class="hljs-function">()=&gt;</span>&#123;</span><br><span class="language-javascript">  fullname.<span class="hljs-property">value</span> = firstname.<span class="hljs-property">value</span> + lastname.<span class="hljs-property">name</span>;</span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    姓氏：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;firstname&quot;</span> /&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>    名字：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;lastname.name&quot;</span> /&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>    全名：&#123;&#123; fullname &#125;&#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span> <br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><p><em><strong>然而，在实际开发中，使用双向绑定即可完成大部分的需求，这章仍然是白学</strong></em> 😓</p>]]></content>
    
    
    <categories>
      
      <category>JAVAWEB</category>
      
      <category>前端工程化</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Vue-计算属性</title>
    <link href="/2024/05/07/Vue-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/"/>
    <url>/2024/05/07/Vue-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue-计算属性"><a href="#Vue-计算属性" class="headerlink" title="Vue-计算属性"></a>Vue-计算属性</h1><p>从vue框架中导入方法computed，其修饰一个响应式数据的属性</p><p><em>compute中文释义：计算</em></p><p>使用computed修饰一个函数，其返回值为该属性的值，该属性为响应式属性，该属性被称之为计算属性</p><p>通过计算属性获得数据，每次使用时，对比上次使用时的数据变化，如果改变就重新计算，如果没有改变则直接使用上一次的结果</p><p><em>当结果需要大量且复杂的运算时，就需要用到computed的计算属性</em></p><p><em><strong>我们后端程序员在写前端代码时，更贴近业务，不需要复杂大量的运算，所以大概率用不到他</strong></em> 😓</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; reactive, computed &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;</span><br><span class="language-javascript"><span class="hljs-keyword">const</span> boy = <span class="hljs-title function_">reactive</span>(&#123;</span><br><span class="language-javascript">  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;xiaobai&quot;</span>,</span><br><span class="language-javascript">  <span class="hljs-attr">girlfriends</span>: [<span class="hljs-string">&quot;lili&quot;</span>, <span class="hljs-string">&quot;feifei&quot;</span>, <span class="hljs-string">&quot;xuexue&quot;</span>, <span class="hljs-string">&quot;cuihua&quot;</span>],</span><br><span class="language-javascript">&#125;);</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">hasGirlfriends</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">  <span class="hljs-keyword">return</span> boy.<span class="hljs-property">girlfriends</span>.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span> ? <span class="hljs-string">&quot;是&quot;</span> : <span class="hljs-string">&quot;否&quot;</span>;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"><span class="hljs-keyword">let</span> gfNumber = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-keyword">return</span> boy.<span class="hljs-property">girlfriends</span>.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span> ? <span class="hljs-string">&quot;是&quot;</span> : <span class="hljs-string">&quot;否&quot;</span>;</span><br><span class="language-javascript">&#125;);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    &#123;&#123; hasGirlfriends() &#125;&#125;<br>    &#123;&#123; gfNumber &#125;&#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JAVAWEB</category>
      
      <category>前端工程化</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Vue-双向绑定</title>
    <link href="/2024/05/07/Vue-%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/"/>
    <url>/2024/05/07/Vue-%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue-双向绑定"><a href="#Vue-双向绑定" class="headerlink" title="Vue-双向绑定"></a>Vue-双向绑定</h1><p>我们之前学过有关vue的命令，都是单向绑定：当响应式数据发生变化时，更新Dom树</p><p><em>单向绑定时，用户的操作如果造成页面内容的改变也不会影响响应式数据</em></p><p>双向绑定：页面上的数据由于用户的操作造成了改变，也会同步修改对应的响应式数据</p><p><em>双向绑定一般都用于表单标签</em></p><p><em>双向绑定也被称呼为收集表单信息的命令</em></p><blockquote><p>v-model:value&#x3D;”数据” 但vue3中强制缺省了value&#x3D; 写成 v-model&#x3D;”数据”</p></blockquote><hr><h3 id="input标签的双向绑定"><a href="#input标签的双向绑定" class="headerlink" title="input标签的双向绑定"></a>input标签的双向绑定</h3><h5 id="text和password的双向绑定"><a href="#text和password的双向绑定" class="headerlink" title="text和password的双向绑定"></a>text和password的双向绑定</h5><p>这里的v-model命令其实是将input标签的value值与对象的属性进行绑定  </p><p>当用户输入数据时，响应式数据修饰的对象的属性也会随之改变</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; reactive &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">let</span> user = <span class="hljs-title function_">reactive</span>(&#123;</span><br><span class="language-javascript">  <span class="hljs-attr">username</span>:<span class="hljs-string">&quot;&quot;</span>,</span><br><span class="language-javascript">  <span class="hljs-attr">userPwd</span>:<span class="hljs-string">&quot;&quot;</span></span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;user.username&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;user.userPwd&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>      <br>    &#123;&#123;user&#125;&#125; <br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h5 id="多选框的双向绑定"><a href="#多选框的双向绑定" class="headerlink" title="多选框的双向绑定"></a>多选框的双向绑定</h5><p>当复选框使用v-model命令时，实质上使用的是 v-model:name&#x3D;”数据”</p><p>这里强制缺省:name，所以写成v-model&#x3D;”数据”</p><p><em>注：这里的数据要写成原本name的属性值，也就是多选框的所属组，value的值需要额外的属性来写</em></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; reactive,ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">let</span> user = <span class="hljs-title function_">reactive</span>(&#123;</span><br><span class="language-javascript">  <span class="hljs-attr">username</span>:<span class="hljs-string">&quot;&quot;</span>,</span><br><span class="language-javascript">  <span class="hljs-attr">userPwd</span>:<span class="hljs-string">&quot;&quot;</span></span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">let</span> hbs = <span class="hljs-title function_">ref</span>([])</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;user.username&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;user.userPwd&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><br>    爱好：<br>    唱<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;hbs&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;sing&quot;</span>&gt;</span><br>    跳<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;hbs&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;dance&quot;</span>&gt;</span><br>    rap<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;hbs&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;rap&quot;</span>&gt;</span><br><br>    &#123;&#123;user&#125;&#125; <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    &#123;&#123;hbs&#125;&#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h5 id="单选框的双向绑定"><a href="#单选框的双向绑定" class="headerlink" title="单选框的双向绑定"></a>单选框的双向绑定</h5><p>这里的v-model仍然使用v-model:name&#x3D;”数据” 的方式</p><p>当使用v-model命令时，name依旧可以省略</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html">爱好：<br>唱<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span>  <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;hbs&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;sing&quot;</span>&gt;</span><br>跳<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span>  <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;hbs&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;dance&quot;</span>&gt;</span><br>rap<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;hbs&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;rap&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h3 id="文本域的双向绑定"><a href="#文本域的双向绑定" class="headerlink" title="文本域的双向绑定"></a>文本域的双向绑定</h3><p>这里的v-model就没有与任何属性进行绑定，与input不同，textare没有value属性</p><p>而写法仍然不变 v-model&#x3D;”数据”，将会把文本域中数据与”数据”进行绑定</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; reactive &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">let</span> user = <span class="hljs-title function_">reactive</span>(&#123;</span><br><span class="language-javascript">  <span class="hljs-attr">intro</span>:<span class="hljs-string">&quot;&quot;</span></span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    &#123;&#123;user.intro&#125;&#125;<br>    <span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">cols</span>=<span class="hljs-string">&quot;30&quot;</span> <span class="hljs-attr">rows</span>=<span class="hljs-string">&quot;10&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;user.intro&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h3 id="下拉框的双向绑定"><a href="#下拉框的双向绑定" class="headerlink" title="下拉框的双向绑定"></a>下拉框的双向绑定</h3><p>与文本域大概相同，这里的v-model同样没有与任何属性进行绑定</p><p>将下拉菜单的单选项与 v-model&#x3D;”数据”中的 “数据” 进行绑定</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; reactive &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">let</span> user = <span class="hljs-title function_">reactive</span>(&#123;</span><br><span class="language-javascript">  <span class="hljs-attr">pro</span>:<span class="hljs-string">&quot;&quot;</span></span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript"></span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;user.pro&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>京<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span>津<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;3&quot;</span>&gt;</span>冀<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h3 id="清空按钮-事件-函数"><a href="#清空按钮-事件-函数" class="headerlink" title="清空按钮 -&gt; 事件 -&gt;函数"></a>清空按钮 -&gt; 事件 -&gt;函数</h3><p><em>注：响应式数据在删除时，不能直接通过user &#x3D; {} 或者hbs &#x3D; []的声明方式清除数据</em></p><p>对象可以通过将其属性重新赋值的方式删除数据</p><p>数组可以通过API：splice删除数据</p><p><em>注：ref修饰的数据在操作时别忘加上.value</em></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    ……</span><br><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">clearForm</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">  user.<span class="hljs-property">username</span> = <span class="hljs-string">&quot;&quot;</span>;</span><br><span class="language-javascript">  user.<span class="hljs-property">userPwd</span> = <span class="hljs-string">&quot;&quot;</span>;</span><br><span class="language-javascript">  user.<span class="hljs-property">intro</span> = <span class="hljs-string">&quot;&quot;</span>;</span><br><span class="language-javascript">  user.<span class="hljs-property">pro</span> = <span class="hljs-string">&quot;&quot;</span>;</span><br><span class="language-javascript">  hbs.<span class="hljs-property">value</span>.<span class="hljs-title function_">splice</span>(<span class="hljs-number">0</span>, hbs.<span class="hljs-property">value</span>.<span class="hljs-property">length</span>);</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>      ……<br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;clearForm()&quot;</span>&gt;</span>清空<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>JAVAWEB</category>
      
      <category>前端工程化</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Vue-条件渲染和列表渲染</title>
    <link href="/2024/05/06/Vue-%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93%E5%92%8C%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93/"/>
    <url>/2024/05/06/Vue-%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93%E5%92%8C%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue-条件渲染和列表渲染"><a href="#Vue-条件渲染和列表渲染" class="headerlink" title="Vue-条件渲染和列表渲染"></a>Vue-条件渲染和列表渲染</h1><h3 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h3><h5 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h5><p>v-if&#x3D;”表达式&#x2F;数据”</p><p>使用v-if属性来选择是否渲染该元素到Dom树中</p><p>当数据为true，则该元素被渲染到Dom树中</p><hr><h5 id="v-else"><a href="#v-else" class="headerlink" title="v-else"></a>v-else</h5><p>使用v-else对与之对应的v-if取反</p><hr><h5 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h5><p>使用v-show实现与v-if相同的效果</p><p>与v-if不同的是，即使v-show的值为false，也仍然将该元素渲染到Dom树中</p><p>通过css样式：style&#x3D;”display: none” 来实现不显示在页面上，但该元素仍然被渲染</p><p><em>总的来说：v-if有更高的切换开销，v-show有更高的初始渲染开销</em></p><hr><h3 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h3><p>使用v-for遍历对象&#x2F;数组，使其内容绑定列表项</p><blockquote><p> v-for&#x3D;”(item, index) in items” :key&#x3D;”item.id”</p></blockquote><p>其中，index为遍历时索引，item为遍历项</p><p>将v-for放到li&#x2F;td上，将遍历数组&#x2F;对象，在li&#x2F;td中使用插值表达式访问内容</p><p><em>在vue中，需要告知其属性key，这个属性并不会被渲染，但在编辑器中不写会报红</em></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; reactive, ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">let</span> pro = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&quot;产品&quot;</span>);</span><br><span class="language-javascript"><span class="hljs-keyword">let</span> items = <span class="hljs-title function_">reactive</span>([</span><br><span class="language-javascript">  &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">id</span>: <span class="hljs-string">&quot;item1&quot;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;薯片&quot;</span>,</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">id</span>: <span class="hljs-string">&quot;item2&quot;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;可乐&quot;</span>,</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">id</span>: <span class="hljs-string">&quot;item3&quot;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;炸鸡&quot;</span>,</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">]);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item, index) in items&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.id&quot;</span>&gt;</span><br>        &#123;&#123; pro &#125;&#125;&#123;&#123; index + 1 &#125;&#125;&#123;&#123; item.message &#125;&#125;<br>      <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h3 id="购物车练习"><a href="#购物车练习" class="headerlink" title="购物车练习"></a>购物车练习</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; reactive &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;</span><br><span class="language-javascript"><span class="hljs-keyword">let</span> carts = <span class="hljs-title function_">reactive</span>([</span><br><span class="language-javascript">  &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;可乐&quot;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">price</span>: <span class="hljs-number">3</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">number</span>: <span class="hljs-number">10</span>,</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;薯片&quot;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">price</span>: <span class="hljs-number">6</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">number</span>: <span class="hljs-number">12</span>,</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;炸鸡&quot;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">price</span>: <span class="hljs-number">12</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">number</span>: <span class="hljs-number">2</span>,</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">]);</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">//购物车总金额功能</span></span><br><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">compute</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">  <span class="hljs-keyword">let</span> total = <span class="hljs-number">0</span>;</span><br><span class="language-javascript">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index <span class="hljs-keyword">in</span> carts) &#123;</span><br><span class="language-javascript">    total = total + carts[index].<span class="hljs-property">price</span> * carts[index].<span class="hljs-property">number</span>;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">  <span class="hljs-keyword">return</span> total;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">//购物车删除功能</span></span><br><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">removeCart</span>(<span class="hljs-params">index</span>) &#123;</span><br><span class="language-javascript">  carts.<span class="hljs-title function_">splice</span>(index, <span class="hljs-number">1</span>);</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">//购物车一键清空功能</span></span><br><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">clearCart</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">  <span class="hljs-comment">//调用API清除</span></span><br><span class="language-javascript">  carts.<span class="hljs-title function_">splice</span>(<span class="hljs-number">0</span>,carts.<span class="hljs-property">length</span>)</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript"></span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>您的购物车如下<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1px&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">thead</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>序号<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>名称<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>单价<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>数量<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>小计<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>操作<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">thead</span>&gt;</span><br>      <span class="hljs-comment">&lt;!-- 当购物车中有购物项时，展示这个tbody--&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">tbody</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;carts.length &gt; 0&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(cart, index) in carts&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;index&quot;</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>&#123;&#123; index + 1 &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>&#123;&#123; cart.name &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>&#123;&#123; cart.price &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>&#123;&#123; cart.number &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>&#123;&#123; cart.number * cart.price &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;removeCart()&quot;</span>&gt;</span>删除<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span><br>      <span class="hljs-comment">&lt;!-- 当购物车中没有购物项时，展示这个tbody--&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">tbody</span> <span class="hljs-attr">v-else</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">&quot;6&quot;</span>&gt;</span>购物车空啦<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;clearCart()&quot;</span>&gt;</span>一键清空购物车<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    购物车总金额：&#123;&#123; compute() &#125;&#125;元<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>JAVAWEB</category>
      
      <category>前端工程化</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>响应式基础</title>
    <link href="/2024/05/06/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/05/06/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="响应式基础"><a href="#响应式基础" class="headerlink" title="响应式基础"></a>响应式基础</h1><p>在vue中，让一个普通数据转换成响应式数据的两种方式：</p><ul><li><p>ref函数：更适合单个变量</p></li><li><p>reactive函数：更适合对象</p></li></ul><h3 id="响应式关键字ref"><a href="#响应式关键字ref" class="headerlink" title="响应式关键字ref"></a>响应式关键字ref</h3><p>经过ref修饰的变量在script中需要通过.value获取操作其值</p><p>而在template中不需要.value，可以直接操作变量的值</p><h3 id="响应式关键字reactive"><a href="#响应式关键字reactive" class="headerlink" title="响应式关键字reactive"></a>响应式关键字reactive</h3><p>经过reactive修饰的对象，在操作其属性的值时，都直接使用对象名.属性名的方式即可</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123;reactive,&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;</span><br><span class="language-javascript"><span class="hljs-keyword">let</span> person = <span class="hljs-title function_">reactive</span>(&#123;</span><br><span class="language-javascript">  <span class="hljs-attr">name</span>:<span class="hljs-string">&quot;xiaobai&quot;</span>,</span><br><span class="language-javascript">  <span class="hljs-attr">age</span>:<span class="hljs-string">&quot;18&quot;</span></span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="API"><a href="#API" class="headerlink" title="API"></a>API</h5><p>toRef函数：将reactive响应式数据中的某个属性转换为ref响应式数据</p><p>toRefs函数：reactive响应式数据中的多个属性转换为ref响应式数据</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html">let p_name = toRef(person,&quot;name&quot;)<br>let &#123;name,age&#125; = toRefs(person)<br></code></pre></td></tr></table></figure><p><em>这两个API实在不常用，因为在实际开发环境中，reactive修饰的对象使用比ref修饰的变量使用起来方便得多</em> 😓</p><hr>]]></content>
    
    
    <categories>
      
      <category>JAVAWEB</category>
      
      <category>前端工程化</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Vue-视图渲染技术</title>
    <link href="/2024/05/06/Vue-%E8%A7%86%E5%9B%BE%E6%B8%B2%E6%9F%93%E6%8A%80%E6%9C%AF/"/>
    <url>/2024/05/06/Vue-%E8%A7%86%E5%9B%BE%E6%B8%B2%E6%9F%93%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue-视图渲染技术"><a href="#Vue-视图渲染技术" class="headerlink" title="Vue-视图渲染技术"></a>Vue-视图渲染技术</h1><p>Vue是一种基于HTML的模板语法，使我们能够声明式的将其组件实例的数据绑定到呈现的DOM上</p><p>Vue会将模板编译成高度优化的JavaScript，将.vue文件编译出html+css+js的过程就是渲染</p><p>结合响应式系统，当应用状态变更时，Vue能够智能地推断出需要重新渲染的组件的最少数量，并应用最少的Dom操作</p><p><em>个人理解就是将变量给到元素的文本，变量给到元素的属性</em></p><hr><h3 id="插值表达式"><a href="#插值表达式" class="headerlink" title="插值表达式"></a>插值表达式</h3><p><em>个人感觉,${}的作用，在模板字符串中可获得变量内容进行拼接，在JSP中作为EL表达式获取值，插值表达式也能与他俩作类比</em></p><p>语法格式：NaN</p><ul><li>插值表达式不依赖标签，可以单独使用</li><li>插值表达式可以调用函数，渲染该函数的返回值</li><li>插值表达式支持一些常见的运算符</li><li>插值表达式支持对象调用其API，渲染其返回值</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">//定义一些常见数据</span></span><br><span class="language-javascript"><span class="hljs-keyword">let</span> msg = <span class="hljs-string">&quot;hello vue3&quot;</span>;</span><br><span class="language-javascript"><span class="hljs-keyword">let</span> <span class="hljs-title function_">getMsg</span> = (<span class="hljs-params"></span>) =&gt; &#123;</span><br><span class="language-javascript">  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello vue3 message&quot;</span>;</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"><span class="hljs-keyword">let</span> age = <span class="hljs-number">18</span>;</span><br><span class="language-javascript"><span class="hljs-keyword">let</span> bee = <span class="hljs-string">&quot;蜜 蜂&quot;</span>;</span><br><span class="language-javascript"><span class="hljs-keyword">let</span> carts = [</span><br><span class="language-javascript">  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;可乐&quot;</span>, <span class="hljs-attr">price</span>: <span class="hljs-string">&quot;3&quot;</span>, <span class="hljs-attr">number</span>: <span class="hljs-string">&quot;10&quot;</span> &#125;,</span><br><span class="language-javascript">  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;薯片&quot;</span>, <span class="hljs-attr">price</span>: <span class="hljs-string">&quot;6&quot;</span>, <span class="hljs-attr">number</span>: <span class="hljs-string">&quot;8&quot;</span> &#125;,</span><br><span class="language-javascript">];</span><br><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">computer</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;</span><br><span class="language-javascript">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index <span class="hljs-keyword">in</span> carts) &#123;</span><br><span class="language-javascript">    count += carts[index].<span class="hljs-property">price</span> * carts[index].<span class="hljs-property">number</span>;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">  <span class="hljs-keyword">return</span> count;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 将数据绑定到下列元素上 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    &#123;&#123; getMsg() &#125;&#125;<br>    &#123;&#123; age &gt; 18 ? &quot;是&quot; : &quot;否&quot; &#125;&#125;<br>    &#123;&#123; bee.split(&quot; &quot;).reverse().join(&quot; &quot;) &#125;&#125;<br>    &#123;&#123; carts[0].price * carts[0].number + carts[1].price * carts[1].number &#125;&#125;<br>    &#123;&#123; computer() &#125;&#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h3 id="v-text-v-html-文本渲染命令"><a href="#v-text-v-html-文本渲染命令" class="headerlink" title="v-text&amp;v-html 文本渲染命令"></a>v-text&amp;v-html 文本渲染命令</h3><p>与插值表达式不同，v-xxx 为vue的指令 </p><ul><li>命令必须依赖标签，作为标签的属性存在</li><li>命令支持模板字符串吗，作为v-text的值直接使用</li><li>命令支持常见的运算符，作为v-text的值直接使用</li><li>命令支持常见的API的调用，作为v-text的值直接使用</li><li>命令支持函数的调用</li></ul><p>v-text和v-html的区别就是：v-text不能识别html文本，但v-html可以识别</p><p><em>就如同Dom编程中的innerText和innerHTML</em></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">let</span> msg = <span class="hljs-string">&quot;hello vue&quot;</span>;</span><br><span class="language-javascript"><span class="hljs-keyword">let</span> age = <span class="hljs-number">19</span>;</span><br><span class="language-javascript"><span class="hljs-keyword">let</span> bee = <span class="hljs-string">&quot;蜜 蜂&quot;</span></span><br><span class="language-javascript"><span class="hljs-keyword">let</span> <span class="hljs-title function_">getMsg</span> = (<span class="hljs-params"></span>)=&gt;&#123;</span><br><span class="language-javascript">  <span class="hljs-keyword">return</span> msg;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"><span class="hljs-keyword">let</span> fontMsg = <span class="hljs-string">&quot;&lt;font color=&#x27;red&#x27;&gt;hello&lt;/font&gt;&quot;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-text</span>=<span class="hljs-string">&quot;msg&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-text</span>=<span class="hljs-string">&quot;`哈哈 $&#123;msg&#125;`&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-text</span>=<span class="hljs-string">&quot;age &gt; 18 ? &#x27;成年&#x27; : &#x27;未成年&#x27;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-text</span>=<span class="hljs-string">&quot;bee.split(&#x27; &#x27;).reverse().join(&#x27; &#x27;)&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-text</span>=<span class="hljs-string">&quot;getMsg()&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-text</span>=<span class="hljs-string">&quot;fontMsg&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-html</span>=<span class="hljs-string">&quot;fontMsg&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><p><img src="/upload/v-text&v-html.PNG" alt="v-text&amp;v-html.PNG"></p><hr><h3 id="v-bind-属性渲染命令"><a href="#v-bind-属性渲染命令" class="headerlink" title="v-bind 属性渲染命令"></a>v-bind 属性渲染命令</h3><p>v-bind:属性名 来绑定属性</p><blockquote><p>可以简写成 :属性名 的方式绑定属性</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> data = &#123;</span><br><span class="language-javascript">  <span class="hljs-attr">logo</span>: <span class="hljs-string">&quot;http://8.210.71.55:8090/upload/QQ%E5%9B%BE%E7%89%8720220921142622.jpg&quot;</span>,</span><br><span class="language-javascript">  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;xiaobailogo&quot;</span>,</span><br><span class="language-javascript">  <span class="hljs-attr">url</span>: <span class="hljs-string">&quot;http://8.210.71.55:8090&quot;</span>,</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">:href</span>=<span class="hljs-string">&quot;data.url&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">:src</span>=<span class="hljs-string">&quot;data.logo&quot;</span> <span class="hljs-attr">:title</span>=<span class="hljs-string">&quot;data.name&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h3 id="v-on-事件渲染命令"><a href="#v-on-事件渲染命令" class="headerlink" title="v-on 事件渲染命令"></a>v-on 事件渲染命令</h3><p>v-on:事件名称 &#x3D; “函数名()”</p><blockquote><p>可以简写成 @事件名称&#x3D;”函数名”</p></blockquote><p>原生js的事件名称是：onclick、ondbclick、onblur、onfocus</p><p>在vue中绑定事件时，去掉on前缀：click、dbclick、blur、focus</p><hr><h5 id="内联事件处理器"><a href="#内联事件处理器" class="headerlink" title="内联事件处理器"></a>内联事件处理器</h5><p>在vue进行事件渲染时，事件执行函数可直接写到@事件名称的属性中去，这称之为内联事件处理器</p><p><em>注：经过ref修饰的变量在script中需要通过.value获取操作其值，而在template中不需要.value</em></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;</span><br><span class="language-javascript"><span class="hljs-keyword">let</span> <span class="hljs-title function_">fun</span> = (<span class="hljs-params"></span>) =&gt; &#123;</span><br><span class="language-javascript">  <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;hello&quot;</span>);</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">let</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">1</span>);</span><br><span class="language-javascript"><span class="hljs-keyword">let</span> <span class="hljs-title function_">fun2</span> = (<span class="hljs-params"></span>) =&gt; &#123;</span><br><span class="language-javascript">  count.<span class="hljs-property">value</span>++;</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;fun()&quot;</span>&gt;</span>say hello<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;fun2()&quot;</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 内联事件处理器,将fun2的内容直接作@click的属性值 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;count++&quot;</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    &#123;&#123; count &#125;&#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h5 id="事件的修饰符"><a href="#事件的修饰符" class="headerlink" title="事件的修饰符"></a>事件的修饰符</h5><p>通过 @事件名称.修饰符:函数名()的方式 ，给事件加修饰符</p><ul><li>once：事件只执行第一次，执行后失效</li><li>prevent：阻止组件的默认行为</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">//利用js原生的方式阻止页面访问</span></span><br><span class="language-javascript"><span class="hljs-keyword">let</span> <span class="hljs-title function_">fun3</span> = (<span class="hljs-params">event</span>)=&gt;&#123;</span><br><span class="language-javascript">  <span class="hljs-keyword">let</span> flag = <span class="hljs-title function_">confirm</span>(<span class="hljs-string">&quot;确定要访问目标链接吗&quot;</span>)</span><br><span class="language-javascript">  <span class="hljs-keyword">if</span>(!flag)&#123;</span><br><span class="language-javascript">    event.<span class="hljs-title function_">preventDefault</span>()</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">let</span> <span class="hljs-title function_">fun4</span> = (<span class="hljs-params"></span>)=&gt;&#123;&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://8.210.71.55:8090&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;fun3( $event)&quot;</span>&gt;</span>XIAOBAI的个人博客<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">br</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 不进行任何提示，直接阻止原本标签的访问行为 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://8.210.71.55:8090&quot;</span> @<span class="hljs-attr">click.prevent</span>=<span class="hljs-string">&quot;fun4()&quot;</span>&gt;</span>XIAOBAI的个人博客<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>JAVAWEB</category>
      
      <category>前端工程化</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Vue3&amp;Vite</title>
    <link href="/2024/05/04/Vue3&amp;Vite/"/>
    <url>/2024/05/04/Vue3&amp;Vite/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue3"><a href="#Vue3" class="headerlink" title="Vue3"></a>Vue3</h1><p>Vue 是一款用于构建用户界面的<strong>渐进式</strong> JavaScript 框架，它基于标准 HTML、CSS 和 JavaScript 构建</p><p>并提供了一套声明式的、组件化的编程模型，<strong>帮助你高效地开发用户界面</strong></p><p>Vue的两个核心功能：</p><ul><li>声明式渲染：Vue 基于标准 HTML 拓展了一套模板语法，使得我们可以声明式地描述最终输出的 HTML 和 JavaScript 状态之间的关系</li><li>响应性：Vue 会自动跟踪 JavaScript 状态并在其发生变化时响应式地更新 DOM</li></ul><p><em>声明式：我们之前写的代码都是编程式，例如利用Dom编程来实时更改页面数据，而声明式则可以直接绑定变量和标签</em></p><hr><h3 id="以非工程化的方式打开Vue3"><a href="#以非工程化的方式打开Vue3" class="headerlink" title="以非工程化的方式打开Vue3"></a>以非工程化的方式打开Vue3</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 这里也可以用浏览器打开连接,然后将获得的文本单独保存进入一个vue.js的文件,导入vue.js文件即可 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/vue@3/dist/vue.global.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- 给style属性绑定colorStyle数据 --&gt;</span><br>            <span class="hljs-comment">&lt;!-- &#123;&#123;插值表达式 直接将数据放在该位置&#125;&#125; --&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-bind:style</span>=<span class="hljs-string">&quot;colorStyle&quot;</span>&gt;</span>&#123;&#123;headline&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>           <span class="hljs-comment">&lt;!-- v-text设置双标签中的文本 --&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-text</span>=<span class="hljs-string">&quot;article&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>           <span class="hljs-comment">&lt;!-- 给type属性绑定inputType数据 --&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-bind:type</span> =<span class="hljs-string">&quot;inputType&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;helloVue3&quot;</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>           <span class="hljs-comment">&lt;!-- 给按钮单击事件绑定函数 --&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">button</span>  @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;sayHello()&quot;</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">            <span class="hljs-comment">//组合api</span></span><br><span class="language-javascript">            <span class="hljs-keyword">const</span> app = <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>(&#123;</span><br><span class="language-javascript">                <span class="hljs-comment">// 在setup内部自由声明数据和方法即可!最终返回!</span></span><br><span class="language-javascript">                <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">                    <span class="hljs-comment">//定义数据</span></span><br><span class="language-javascript">                    <span class="hljs-comment">//在VUE中实现DOM的思路是: 通过修改修数据而影响页面元素</span></span><br><span class="language-javascript">                    <span class="hljs-comment">// vue3中,数据默认不是响应式的,需要加ref或者reactive处理,后面会详细讲解</span></span><br><span class="language-javascript">                    <span class="hljs-keyword">let</span> inputType =<span class="hljs-string">&#x27;text&#x27;</span></span><br><span class="language-javascript">                    <span class="hljs-keyword">let</span> headline =<span class="hljs-string">&#x27;hello vue3&#x27;</span></span><br><span class="language-javascript">                    <span class="hljs-keyword">let</span> article =<span class="hljs-string">&#x27;vue is awesome&#x27;</span>  </span><br><span class="language-javascript">                    <span class="hljs-keyword">let</span> colorStyle =&#123;<span class="hljs-string">&#x27;color&#x27;</span>:<span class="hljs-string">&#x27;red&#x27;</span>&#125;        </span><br><span class="language-javascript">                    <span class="hljs-comment">// 定义函数</span></span><br><span class="language-javascript">                    <span class="hljs-keyword">let</span> <span class="hljs-title function_">sayHello</span> =(<span class="hljs-params"></span>)=&gt;&#123;</span><br><span class="language-javascript">                        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;hello Vue&quot;</span>)</span><br><span class="language-javascript">                    &#125;</span><br><span class="language-javascript">                    <span class="hljs-comment">//在setup函数中,return返回的数据和函数可以在html使用</span></span><br><span class="language-javascript">                    <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">                       inputType,</span><br><span class="language-javascript">                       headline,</span><br><span class="language-javascript">                       article,</span><br><span class="language-javascript">                       colorStyle,</span><br><span class="language-javascript">                       sayHello</span><br><span class="language-javascript">                    &#125;</span><br><span class="language-javascript">                &#125;</span><br><span class="language-javascript">            &#125;);</span><br><span class="language-javascript">            <span class="hljs-comment">//挂载到视图</span></span><br><span class="language-javascript">            app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&quot;#app&quot;</span>);</span><br><span class="language-javascript">        </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><p>前端的一些关键字：</p><ul><li><code>&#123;&#123;&#125;&#125;</code>：插值表达式</li><li>v-bind:style属性：绑定css样式</li><li>v-text属性：绑定双标签中的文本</li><li>v-bind:type属性：绑定标签中type属性</li><li>@click：绑定单击事件触发的函数</li></ul><p>后端的写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> app = <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>(&#123;<br>    <span class="hljs-comment">// 在setup内部自由声明数据和方法即可!最终返回!</span><br>    <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-comment">// 定义type属性</span><br>        <span class="hljs-keyword">let</span> inputType =<span class="hljs-string">&#x27;text&#x27;</span> <br>        <span class="hljs-comment">// 定义style属性</span><br>        <span class="hljs-keyword">let</span> colorStyle =&#123;<span class="hljs-string">&#x27;color&#x27;</span>:<span class="hljs-string">&#x27;red&#x27;</span>&#125;        <br>        <span class="hljs-comment">// 定义函数</span><br>        <span class="hljs-keyword">let</span> <span class="hljs-title function_">sayHello</span> =(<span class="hljs-params"></span>)=&gt;&#123;<br>            <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;hello Vue&quot;</span>)<br>        &#125;<br>        <span class="hljs-comment">//在setup函数中,return返回的数据和函数可以在html使用</span><br>        <span class="hljs-keyword">return</span> &#123;<br>           inputType,<br>           colorStyle,<br>           sayHello<br>        &#125;<br>    &#125;<br>&#125;);<br><span class="hljs-comment">//挂载到视图</span><br>app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&quot;#app&quot;</span>);<span class="hljs-comment">//通过id选择器挂载到id为app的div上</span><br></code></pre></td></tr></table></figure><p><em>在这里我们只需要大概的体会一下vue框架中的功能以及他的固定写法</em></p><hr><h1 id="Vite"><a href="#Vite" class="headerlink" title="Vite"></a>Vite</h1><p>Vite工具主要是用来管理&#x2F;建立前端工程化的项目模板&#x2F;规范</p><p><em>Vite和npm组合起来就相当于后端的Maven</em></p><p>Vite的特点与优势：</p><ul><li><p>快速创建项目：使用脚手架可以快速搭建项目基本框架，避免从零开始搭建项目的重复劳动和繁琐操作，从而节省时间和精力。</p></li><li><p>统一的工程化规范：前端脚手架可以预设项目目录结构、代码规范、git提交规范等统一的工程化规范，让不同开发者在同一个项目上编写出风格一致的代码，提高协作效率和质量。</p></li><li><p>代码模板和组件库：前端脚手架可以包含一些常用的代码模板和组件库，使开发者在实现常见功能时不再重复造轮子，避免因为轮子质量不高带来的麻烦，能够更加专注于项目的业务逻辑。</p></li><li><p>自动化构建和部署：前端脚手架可以自动进行代码打包、压缩、合并、编译等常见的构建工作，可以通过集成自动化部署脚本，自动将代码部署到测试、生产环境等。</p></li></ul><p>简单的说，Vite工具的功能就是便于前端项目的创建、编写、管理、部署</p><hr><h3 id="使用Vite创建前端工程化项目"><a href="#使用Vite创建前端工程化项目" class="headerlink" title="使用Vite创建前端工程化项目"></a>使用Vite创建前端工程化项目</h3><ul><li>npm create vite：新建Vite项目</li></ul><p>新建好Vite项目后，我们会发现pakage.json目录下记录了本项目所需的依赖，所以我们根据文件的记录给依赖安装一下</p><ul><li>npm install：根据pakage.json目录安装依赖</li></ul><p><em>注：我们需要先使用cd命令进入项目的目录，再安装依赖</em></p><ul><li>npm run：使用dev&#x2F;build&#x2F;preview运行该项目</li></ul><p><em>在学习Vite之前，我们针对于前端代码的预览是使用vscode的golive插件，而从今天开始，我们使用npm run dev来进入开发模式</em></p><hr><h5 id="关于JS和TS的选择问题"><a href="#关于JS和TS的选择问题" class="headerlink" title="关于JS和TS的选择问题"></a>关于JS和TS的选择问题</h5><p>TS（Typescript）是JS的一个超集，使用TS之后，JS的语法更加的像JAVA</p><p>在实际开发之中，TS的使用更多一点，但我们不着急去学习TS，原因如下：</p><ul><li><p>为了降低难度,提高前端工程化的效率</p></li><li><p>对于学JAVA的我们来说,学习TS非常容易,但是还是需要一些时间</p></li><li><p>TS不是非学不可,不用TS仍然可以正常开发工程化的前端项目</p></li></ul><hr><h3 id="Vite项目的目录结构"><a href="#Vite项目的目录结构" class="headerlink" title="Vite项目的目录结构"></a>Vite项目的目录结构</h3><p><img src="/upload/Vite%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.PNG" alt="Vite项目目录结构.PNG"></p><ul><li><p><strong>node_modules</strong>：npm安装的框架及所需依赖的目录</p></li><li><p><strong>public</strong>：用于存放一些公共资源，例如：HTML文件、图像、子图，这些资源会被直接复制到构建出的目标目录中</p></li><li><p><strong>src</strong>：存放项目的源代码，包括 JavaScript、CSS、Vue 组件、图像和字体等资源。在开发过程中，这些文件会被 Vite 实时编译和处理，并在浏览器中进行实时预览和调试</p><ul><li><strong>assets</strong>：于存放一些项目中用到的静态资源，如图片、字体、样式文件等</li><li><strong>components</strong>：用于存放组件相关的文件，组件是代码复用的一种方式，用于抽象出一个可复用的 UI 部件，方便在不同的场景中进行重复使用</li><li>layouts：用于存放布局组件的文件，布局组件通常负责整个应用程序的整体布局，如头部、底部、导航菜单等</li><li>pages：用于存放页面级别的组件文件，通常是路由对应的组件文件，在这个目录下，可以创建对应的文件夹，用于存储不同的页面组件</li><li>plugins：用于存放 Vite 插件相关的文件，可以按需加载不同的插件来实现不同的功能，如自动化测试、代码压缩等</li><li>router：用于存放 Vue.js 的路由配置文件，负责管理视图和 URL 之间的映射关系，方便实现页面之间的跳转和数据传递</li><li>store：用于存放 Vuex 状态管理相关的文件，负责管理应用程序中的数据和状态，方便统一管理和共享数据，提高开发效率</li><li>utils：用于存放一些通用的工具函数，如日期处理函数、字符串操作函数等</li></ul></li><li><p><strong>package.json</strong>：node.js配置文件，包含了项目的基本信息和依赖关系</p></li><li><p><strong>vite.config.js</strong>：Vite 的配置文件，可以通过该文件配置项目的参数、插件、打包优化等</p></li></ul><hr><h5 id="设置运行时端口号"><a href="#设置运行时端口号" class="headerlink" title="设置运行时端口号"></a>设置运行时端口号</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//修改vite项目配置文件 vite.config.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(&#123;<br>  <span class="hljs-attr">plugins</span>: [<span class="hljs-title function_">vue</span>()],<br>  <span class="hljs-attr">server</span>:&#123;<br>    <span class="hljs-attr">port</span>:<span class="hljs-number">3000</span><br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><hr><h3 id="Vite项目组件（SFC入门）"><a href="#Vite项目组件（SFC入门）" class="headerlink" title="Vite项目组件（SFC入门）"></a>Vite项目组件（SFC入门）</h3><p><em>Component中文释义：元件</em></p><p>SFC（Single-File Component）单文件组件</p><p>Vue组件：</p><ul><li>一个页面作为整体,是由多个部分组成的,每个部分在这里就可以理解为一个组件</li><li>每个.vue文件就可以理解为一个组件,多个.vue文件可以构成一个整体页面</li><li>组件化给我们带来的另一个好处就是组件的复用和维护非常的方便</li></ul><p>Vue文件：</p><ul><li><p>传统的页面有.html文件.css文件和.js文件三个文件组成（多文件组件）</p></li><li><p>vue将这文件合并成一个.vue文件（单文件组件）</p></li><li><p>.vue文件对js&#x2F;css&#x2F;html统一封装，该文件有三个部分构成：</p><ul><li>template标签：代表组件的html部分代码（代替传统的.html文件）</li><li>script标签：代表组件的js代码（代替传统的.js文件）</li><li>style标签：代表组件的css样式代码（代替传统的.css文件）</li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p><em>template中文释义：模板</em></p><hr><h3 id="工程文件的关系"><a href="#工程文件的关系" class="headerlink" title="工程文件的关系"></a>工程文件的关系</h3><h5 id="index-html"><a href="#index-html" class="headerlink" title="index.html"></a>index.html</h5><p>按照我们之前的思路，查看index.html文件，发现其中内容如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!doctype <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;icon&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;image/svg+xml&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/vite.svg&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Vite + Vue<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/src/main.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>我们发现，其中并没有实质性的内容能展现丰富的内容页，但存在关键两行代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 以模块化方式导入js文件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/src/main.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h5 id="main-js"><a href="#main-js" class="headerlink" title="main.js"></a>main.js</h5><p>我们查看这个被导入的js文件，内容如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//从vue框架中导入函数：createApp</span><br><span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-comment">//导入全局样式文件，该文件中的样式或作用到所有的.vue元素上</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./style.css&#x27;</span><br><span class="hljs-comment">//导入App.vue组件 并起别名为App</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span><br><span class="hljs-comment">//使用App.vue(别名APP)作为形参，使用createApp的函数生成一个对象，再将这个对象挂载到id值为app的元素上</span><br><span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>).<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>)<br></code></pre></td></tr></table></figure><p>这个文件的作用，就是将App.vue的组件，挂载到id值为app的元素上</p><hr><h5 id="App-vue"><a href="#App-vue" class="headerlink" title="App.vue"></a>App.vue</h5><p>相同的，App.vue中也可以导入别的.vue组件，实现组件嵌套</p><p>其导入方式和ES6的模块化导入大致相同</p><p>在使用时，直接将<strong>导入的vue模块当作HTML中的单标签使用</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">HelloWorld</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/HelloWorld.vue&#x27;</span></span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>……<br>  <span class="hljs-tag">&lt;<span class="hljs-name">HelloWorld</span> <span class="hljs-attr">msg</span>=<span class="hljs-string">&quot;Vite + Vue&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><br>    ……<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p><em><strong>注：.vue组件中，语法上要求template只能有一个一级子标签，但语法报错并不影响vue3的正确运行</strong></em></p><blockquote><p>[vue&#x2F;no-multiple-template-root]</p><p>The template root requires exactly one element.eslint-plugin-vue</p></blockquote><hr><h3 id="Css样式的导入方式"><a href="#Css样式的导入方式" class="headerlink" title="Css样式的导入方式"></a>Css样式的导入方式</h3><p>我们可以在.vue组件的style标签下直接编写为该组件修饰的css样式</p><p>同时，我们也可以<strong>在src下建立style目录，专门存放css样式文件</strong>，有哪个组件需要用，则由该组件调用</p><p>相当于把css样式文件也<strong>模块化</strong></p><p>正如我们在main.js中导入全局css文件那样，直接在script中使用import标签导入css文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./style/style.css&#x27;</span><br></code></pre></td></tr></table></figure><p>如果是在.vue文件中，除了上述方法（script外部文件导入），也可以在script标签中使用@import方式导入css文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-keyword">@import</span> <span class="hljs-string">&#x27;./style/style.css&#x27;</span></span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h3 id="响应式入门和setup函数"><a href="#响应式入门和setup函数" class="headerlink" title="响应式入门和setup函数"></a>响应式入门和setup函数</h3><p>响应式数据：在数据变化时，vue框架会将变量最新的值实时更新到dom中</p><ul><li><p>在vue2中，数据不做特殊处理，默认就是响应式数据</p></li><li><p>在vue3中，数据经过ref&#x2F;reactive函数的处理才是响应式数据</p><ul><li>ref&#x2F;reactive函数是vue3中给我们提供的方法，导入进来即可使用</li></ul></li></ul><p><em><strong>注：ref处理的响应式数据，在操作时需要注意：</strong></em></p><p><em>在script中操作时，要使用.value的形式操作</em></p><p><em>在template中操作时，无需使用.value的形式操作</em></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123;ref&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">let</span> counter = <span class="hljs-title function_">ref</span>(<span class="hljs-number">1</span>);</span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">counterIncr</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      counter.<span class="hljs-property">value</span>++;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">counterDecr</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      counter.<span class="hljs-property">value</span>--;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">      counter,</span><br><span class="language-javascript">      counterIncr,</span><br><span class="language-javascript">      counterDecr,</span><br><span class="language-javascript">    &#125;;</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;counterIncr&quot;</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-text</span>=<span class="hljs-string">&quot;counter&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;counterDecr&quot;</span>&gt;</span>-<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;showCounter&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h5><p>在vue3的非工程化打开中，我们大致知道了vue3的固定写法</p><p>我们将vue3则setup函数作为模块化处理的默认导出</p><p>再被<code>import App from &#39;./App.vue&#39;</code>导入到main.js文件中</p><p>最后通过<code>createApp(App).mount(&#39;#app&#39;)</code>挂载到<code>#app</code>元素使用</p><p>这样就实现了使用.vue文件（vite项目结构），工程化的实现了vue框架的使用</p><p><em>但是，vue&amp;vite提供了setup关键字作为语法糖（类似注解），解决了每次需要默认暴露和setup函数的冗余代码，所以以上仍然是白学</em> 😓 </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123;ref&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span></span><br><span class="language-javascript">    <span class="hljs-keyword">let</span> counter = <span class="hljs-title function_">ref</span>(<span class="hljs-number">1</span>);</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">counterIncr</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      counter.<span class="hljs-property">value</span>++;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">counterDecr</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      counter.<span class="hljs-property">value</span>--;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;counterIncr&quot;</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-text</span>=<span class="hljs-string">&quot;counter&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;counterDecr&quot;</span>&gt;</span>-<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;showCounter&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>JAVAWEB</category>
      
      <category>前端工程化</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Node.js&amp;npm</title>
    <link href="/2024/04/29/Node.js&amp;npm/"/>
    <url>/2024/04/29/Node.js&amp;npm/</url>
    
    <content type="html"><![CDATA[<h1 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h1><p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行时环境，可以使 JavaScript 运行在服务器端。使用 Node.js，可以方便地开发服务器端应用程序，如 Web 应用、API、后端服务，还可以通过 Node.js 构建命令行工具等</p><p>比于传统的服务器端语言（如 PHP、Java、Python 等），Node.js 具有以下特点：</p><ul><li>单线程：但是采用了事件驱动、异步 I&#x2F;O 模型，可以处理高并发请求</li><li>轻量级：使用 C++ 编写的 V8 引擎让 Node.js 的运行速度很快</li><li>模块化：Node.js 内置了大量模块，同时也可以通过第三方模块扩展功能</li><li>跨平台：可以在 Windows、Linux、Mac 等多种平台下运行</li></ul><p><em>Node.js的核心是其对本地磁盘的读写能力，它赋予了在服务端的JS代码对文件的I&#x2F;O</em></p><p><em>也就是说，Node.js让JS代码变成能够同时运行在客户端和服务端的全栈语言</em></p><hr><h3 id="框架的概念"><a href="#框架的概念" class="headerlink" title="框架的概念"></a>框架的概念</h3><p>我们在学习npm之前，先学习有关框架的概念</p><p>框架：针对特定问题的一套固定的解决方案，软件的半成品（极大提升开发效率）</p><blockquote><p> 前端框架的表现形式：一大堆jar包</p><p> 后端框架的表现形式：一大堆css，js，……文件</p></blockquote><p>有一个功德无量的人做了一个几乎包含所有开源前端框架的仓库，而npm就是管理这个仓库的软件</p><hr><h1 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h1><p>NPM（Node Package Manager），是Node.js包管理工具，是全球最大的模块生态系统，里面所有的模块都是开源免费的；也是Node.js的包管理工具，<em>相当于后端的Maven</em></p><ul><li>前端框架的下载工具<ul><li>拉取插件&#x2F;框架到本地仓库中</li></ul></li><li>前端项目的管理工具<ul><li>项目的初始化</li><li>依赖管理</li><li>研发模式运行</li><li>编译</li></ul></li></ul><hr><h3 id="npm的安装调试"><a href="#npm的安装调试" class="headerlink" title="npm的安装调试"></a>npm的安装调试</h3><h5 id="配置阿里镜像"><a href="#配置阿里镜像" class="headerlink" title="配置阿里镜像"></a>配置阿里镜像</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">配置镜像源为阿里</span><br>npm config set registry https://registry.npmmirror.com<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看配置是否生效</span><br>npm config get registry<br><span class="hljs-meta prompt_"># </span><span class="language-bash">恢复镜像源为官方镜像</span><br>npm config set registry https://registry.npmjs.org/<br></code></pre></td></tr></table></figure><hr><h5 id="配置全局依赖下载地址"><a href="#配置全局依赖下载地址" class="headerlink" title="配置全局依赖下载地址*"></a>配置全局依赖下载地址*</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">配置下载地址为 D:\GlobalNodeModules</span><br>npm config set prefix &quot;D:\GlobalNodeModules&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看配置是否生效</span><br>npm config get prefix<br></code></pre></td></tr></table></figure><p><em>前端依赖的大小很大，所以不推荐在默认地址下安装依赖（C盘）</em> 😓</p><hr><h5 id="升级npm"><a href="#升级npm" class="headerlink" title="升级npm"></a>升级npm</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install -g npm # 升级为最新的npm版本<br></code></pre></td></tr></table></figure><hr><h3 id="npm常用命令"><a href="#npm常用命令" class="headerlink" title="npm常用命令"></a>npm常用命令</h3><p><em><strong>注:npm的所有命令都需要在package.json的目录下运行！！！</strong></em></p><h5 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h5><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>npm init</td><td>生成一个package.json 文件，package.json信息会包含项目基本信息（例如项目名称、版本号、作者、许可证）</td></tr><tr><td>npm init -y</td><td>生成一个package.json 文件，所有信息使用当前文件夹的默认值</td></tr></tbody></table><hr><h5 id="安装-卸载-查看依赖"><a href="#安装-卸载-查看依赖" class="headerlink" title="安装&#x2F;卸载&#x2F;查看依赖"></a>安装&#x2F;卸载&#x2F;查看依赖</h5><p>查询npm所有依赖  <a href="https://www.npmjs.com/">npm | Home (npmjs.com)</a></p><p>安装完依赖后，在package.json中添加一条参数</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;dependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;jquery&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^3.7.1&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><em>注：如果单独使用npm install命令，则会根据package.json中的dependencies参数自动下载所有对应依赖</em></p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>npm install</td><td>根据dependencies参数安装项目所需依赖</td></tr><tr><td>npm install 包名</td><td>安装包或者指定版本的依赖包(安装到当前项目中)</td></tr><tr><td>npm install -g 包名</td><td>安装全局依赖包</td></tr><tr><td>npm uninstall 包名</td><td>卸载依赖</td></tr><tr><td>npm ls</td><td>查看当前项目已安装的依赖</td></tr><tr><td>npm ls  -g</td><td>查看已安装的全局依赖</td></tr></tbody></table><p><em>全局依赖包在安装后并不会在package.json中更改dependencies参数</em></p><hr><h5 id="执行脚本"><a href="#执行脚本" class="headerlink" title="执行脚本"></a>执行脚本</h5><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>npm run 脚本名</td><td>执行 npm 脚本</td></tr></tbody></table><p>在 package.json 文件中，scripts 字段是一个对象，其中包含一组键值对，键是要运行的脚本的名称，值是要执行的命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">&quot;scripts&quot;: &#123;<br>&quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>在vscode中同样可以使用切换面板方式打开终端窗口</em></p><p>scripts 对象通常包含 start、test 和 build 三个脚本：</p><ul><li>npm run start：运行 node index.js，并启动应用程序</li><li>运行 Jest 测试套件</li><li>运行 webpack 命令以生成最终的构建输出</li></ul><hr>]]></content>
    
    
    <categories>
      
      <category>JAVAWEB</category>
      
      <category>前端工程化</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ES6-模块化处理</title>
    <link href="/2024/04/29/ES6-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%A4%84%E7%90%86/"/>
    <url>/2024/04/29/ES6-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="ES6-模块化处理"><a href="#ES6-模块化处理" class="headerlink" title="ES6-模块化处理"></a>ES6-模块化处理</h1><p>模块化是一种组织和管理前端代码的方式，将代码分成小的模块单元，使代码更易于维护、扩展和复用</p><p>它包括了定义、导入、导出以及管理模块的方法和规范</p><p>目前，前端模块化有多种规范和实现，包括CommonJS、AMD和ES6模块化</p><p>ES6模块化是js语言的模块标准，使用import 和 export进行导入和导出</p><p>大部分浏览器都支持了ES6模块化，因此他成为了最为广泛使用的前端模块化标准</p><p><strong>ES6有三种导出方法：分别导出、统一导出、默认导出 ，并且这三种语法是可以同时使用的</strong> 😊</p><hr><h3 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h3><p>js默认不支持这种模块化的语法，所以需要设置script的标签属性type的值为module</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>*代表module.js的所有成员，无论何种方式导入，导入的内容都会被当成一个对象处理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> m1 <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./module.js&quot;</span> <span class="hljs-comment">//导入同一目录下的module.js文件 作为m1对象来使用</span><br></code></pre></td></tr></table></figure><hr><h5 id="使用解构表达式按需导入"><a href="#使用解构表达式按需导入" class="headerlink" title="使用解构表达式按需导入"></a>使用解构表达式按需导入</h5><p>可以使用解构表达式直接对导入对象分别赋值，在导入的同时可以起别名</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;<span class="hljs-variable constant_">PI</span> <span class="hljs-keyword">as</span> pi,sum,<span class="hljs-title class_">Person</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./module.js&quot;</span><br></code></pre></td></tr></table></figure><hr><h3 id="分别导出"><a href="#分别导出" class="headerlink" title="分别导出"></a>分别导出</h3><p>在需要被暴露的属性&#x2F;类&#x2F;方法中，添加export关键字即按需暴露</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//module.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PI</span> = <span class="hljs-number">3.14</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">a,b</span>)&#123;<br>    <span class="hljs-keyword">return</span> a+b<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="全部导入"><a href="#全部导入" class="headerlink" title="全部导入"></a>全部导入</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> m1 <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./module.js&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(m1.<span class="hljs-property">PI</span>)<span class="hljs-comment">//访问暴露的属性</span><br><span class="hljs-comment">//使用不被暴露的方法</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(m1.<span class="hljs-title function_">sum</span>(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>)) <span class="hljs-comment">//Uncaught TypeError: m1.sum is not a function</span><br></code></pre></td></tr></table></figure><h5 id="分别导入"><a href="#分别导入" class="headerlink" title="分别导入"></a>分别导入</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;<span class="hljs-variable constant_">PI</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./module.js&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable constant_">PI</span>)<br><span class="hljs-comment">//使用不被暴露的方法</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sum</span>(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>)) <span class="hljs-comment">//Uncaught TypeError: m1.sum is not a function</span><br></code></pre></td></tr></table></figure><hr><h3 id="统一导出"><a href="#统一导出" class="headerlink" title="统一导出"></a>统一导出</h3><p>在文件的最后使用export{}按需暴露</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//module.js</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PI</span> = <span class="hljs-number">3.14</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">a,b</span>)&#123;<br>    <span class="hljs-keyword">return</span> a+b<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name,age</span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age<br>    &#125;<br>    <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`hello,my name is <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>,<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.age&#125;</span> years old`</span>)<br>    &#125;<br>&#125;<br><span class="hljs-keyword">export</span>&#123;<span class="hljs-variable constant_">PI</span>,sum,<span class="hljs-title class_">Person</span>&#125;<br></code></pre></td></tr></table></figure><h5 id="全部导入-1"><a href="#全部导入-1" class="headerlink" title="全部导入"></a>全部导入</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> m1 <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./module.js&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(m1.<span class="hljs-property">PI</span>) <span class="hljs-comment">//3.14</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(m1.<span class="hljs-title function_">sum</span>(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>)) <span class="hljs-comment">//30</span><br><span class="hljs-keyword">let</span> person = <span class="hljs-keyword">new</span> m1.<span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;xiaobai&quot;</span>,<span class="hljs-number">18</span>)<br>person.<span class="hljs-title function_">sayHello</span>() <span class="hljs-comment">//hello,my name is xiaobai,18 years old</span><br></code></pre></td></tr></table></figure><h5 id="分别导入-1"><a href="#分别导入-1" class="headerlink" title="分别导入"></a>分别导入</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;<span class="hljs-variable constant_">PI</span>,sum&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./module.js&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable constant_">PI</span>) <span class="hljs-comment">//3.14</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sum</span>(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>)) <span class="hljs-comment">//30</span><br></code></pre></td></tr></table></figure><p><em>虽然导出了Person类，但是使用分别导入可以不导入Person类</em></p><hr><h3 id="默认导出"><a href="#默认导出" class="headerlink" title="默认导出"></a>默认导出</h3><p>在文件的最后使用export default定义一个默认暴露</p><p>在一个文件中，默认暴露只能有一个</p><p>在导入时，可直接使用default替换其属性名&#x2F;方法名&#x2F;类名使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PI</span> = <span class="hljs-number">3.14</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">a,b</span>)&#123;<br>    <span class="hljs-keyword">return</span> a+b<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name,age</span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age<br>    &#125;<br>    <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`hello,my name is <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>,<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.age&#125;</span> years old`</span>)<br>    &#125;<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-variable constant_">PI</span><br></code></pre></td></tr></table></figure><h5 id="全部导入-2"><a href="#全部导入-2" class="headerlink" title="全部导入"></a>全部导入</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> m1 <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./module.js&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(m1.<span class="hljs-property">default</span>)<span class="hljs-comment">//default替换PI属性名使用</span><br></code></pre></td></tr></table></figure><hr><h5 id="分别导入-2"><a href="#分别导入-2" class="headerlink" title="分别导入"></a>分别导入</h5><p><em>default为switch的关键字，所以我们直接使用其之前起一个别名</em></p><p>也可以简化其写法，缺省default as关键字</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//import &#123;default as PI&#125;  from &quot;./module.js&quot;</span><br><span class="hljs-keyword">import</span> <span class="hljs-variable constant_">PI</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./module.js&quot;</span> <span class="hljs-comment">//简化写法</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable constant_">PI</span>)<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>JAVAWEB</category>
      
      <category>前端工程化</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ES6</title>
    <link href="/2024/04/29/ES6/"/>
    <url>/2024/04/29/ES6/</url>
    
    <content type="html"><![CDATA[<h1 id="ECMA6Script"><a href="#ECMA6Script" class="headerlink" title="ECMA6Script"></a>ECMA6Script</h1><p>ECMAScript 6，简称ES6，是JavaScript语言的一次重大更新</p><p>由于VUE3中大量使用了ES6的语法，所以ES6成为了学习VUE3的门槛之一</p><ul><li>更加简洁：</li><li>更强大的功能</li><li>更好的实用性</li></ul><hr><h3 id="ES6的变量和模板字符串"><a href="#ES6的变量和模板字符串" class="headerlink" title="ES6的变量和模板字符串"></a>ES6的变量和模板字符串</h3><p>ES6中新增了<strong>let</strong>和<strong>const</strong>，用来<strong>声明变量</strong>，使用的细节存在差异</p><hr><h5 id="let和var的区别"><a href="#let和var的区别" class="headerlink" title="let和var的区别"></a>let和var的区别</h5><ul><li>let不能重复声明</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> i = <span class="hljs-number">10</span><br><span class="hljs-keyword">var</span> i =<span class="hljs-string">&quot;hello&quot;</span><br><br><span class="hljs-keyword">let</span> j = <span class="hljs-number">10</span><br><span class="hljs-keyword">let</span> j = <span class="hljs-string">&quot;hello&quot;</span><span class="hljs-comment">//报错，let不能重复声明  Uncaught SyntaxError: Identifier &#x27;j&#x27; has already been</span><br></code></pre></td></tr></table></figure><ul><li>let有块级作用域，非函数的花括号遇见let也会有块级作用域</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>    <span class="hljs-keyword">var</span> i = <span class="hljs-number">10</span><br>    <span class="hljs-keyword">let</span> j = <span class="hljs-number">10</span><br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i) <span class="hljs-comment">//10</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(j) <span class="hljs-comment">//变量j未被定义  Uncaught ReferenceError: j is not defined</span><br></code></pre></td></tr></table></figure><ul><li>let不会预解析进行变量提升</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a) <span class="hljs-comment">//undefined</span><br><span class="hljs-keyword">var</span> a =<span class="hljs-number">10</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(j) <span class="hljs-comment">//变量j未被预解析 Uncaught ReferenceError: Cannot access &#x27;j&#x27; before initialization</span><br><span class="hljs-keyword">let</span> j =<span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><ul><li>let定义的全局变量不会作为windows（Bom编程）的属性</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span> <span class="hljs-comment">//a会变成window的属性</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">a</span>) <span class="hljs-comment">//10</span><br><br><span class="hljs-keyword">let</span> b =<span class="hljs-number">10</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">b</span>) <span class="hljs-comment">//undefined</span><br></code></pre></td></tr></table></figure><ul><li>let在es6中推荐优先使用</li></ul><hr><h5 id="const"><a href="#const" class="headerlink" title="const"></a>const</h5><p><em>const中文释义：常数；恒量</em></p><p>const就是不可修改的let</p><p><em>类似于java中被final修饰的数（常量）</em></p><ul><li>const的值不可被修改</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> a = <span class="hljs-number">10</span><br>a = <span class="hljs-number">20</span>  <span class="hljs-comment">// Uncaught TypeError: Assignment to constant variable.</span><br></code></pre></td></tr></table></figure><ul><li>const的值不可为空</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> a <span class="hljs-comment">//Uncaught SyntaxError: Missing initializer in const declaration</span><br></code></pre></td></tr></table></figure><ul><li>const可以设置常量值</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PI</span> = <span class="hljs-number">3.14</span>;<br></code></pre></td></tr></table></figure><ul><li>const内容为对象时，不可以修改其值的本质是不可修改引用，其内容还是可以发生变化的</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> techers = [<span class="hljs-string">&quot;张老师&quot;</span>, <span class="hljs-string">&quot;王老师&quot;</span>, <span class="hljs-string">&quot;李老师&quot;</span>];<br><span class="hljs-comment">//techers = [&quot;&quot;,&quot;&quot;,&quot;&quot;] //无法修改 Uncaught TypeError: Assignment to constant variable.</span><br>techers.<span class="hljs-title function_">push</span>(<span class="hljs-string">&quot;赵老师&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(techers); <span class="hljs-comment">//[&#x27;张老师&#x27;, &#x27;王老师&#x27;, &#x27;李老师&#x27;, &#x27;赵老师&#x27;]</span><br></code></pre></td></tr></table></figure><hr><h5 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h5><p>模板字符串用以处理字符串换行和字符串拼接问题</p><p>“ “或者’ ‘中的传统字符串是不支持多行 </p><p>&#96;&#96;中的字符支持多行且拼接变量可以直接用${}的方式</p><p><em>&#96; 反单引号（backquote），又称反引号，是西文字符中的附加符号，主要用于计算机领域</em></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-handlebars"><span class="language-xml"></span></span><br><span class="language-xml"><span class="language-handlebars">let city = &quot;长春&quot;;</span></span><br><span class="language-xml"><span class="language-handlebars">let str = </span></span><br><span class="language-xml"><span class="language-handlebars">`<span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars">    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>$&#123;city&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars">    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars">    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars">    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars">    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>`;</span></span><br><span class="language-xml"><span class="language-handlebars">console.log(str);</span></span><br><span class="language-xml"><span class="language-handlebars"></span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><em>${变量}在字符串中的使用是获取变量内容并进行字符串拼接</em></p><p><em>${表达式}在JSP中是EL表达式，作用是获取表达式的值</em></p><hr><h3 id="ES6的解构表达式"><a href="#ES6的解构表达式" class="headerlink" title="ES6的解构表达式"></a>ES6的解构表达式</h3><h5 id="解构数组和对象"><a href="#解构数组和对象" class="headerlink" title="解构数组和对象"></a>解构数组和对象</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>    <span class="hljs-keyword">let</span> arr = [<span class="hljs-number">11</span>,<span class="hljs-number">22</span>,<span class="hljs-number">33</span>,<span class="hljs-number">44</span>]<br>    <span class="hljs-comment">//解构表达式取出数组中的元素</span><br>    <span class="hljs-keyword">let</span> [a,b,c,d,e = <span class="hljs-number">10</span>] = arr<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a,b,c,d,e) <span class="hljs-comment">//11 22 33 44 10</span><br><br><br>    <span class="hljs-keyword">let</span> person = &#123;<br>        name : <span class="hljs-string">&quot;xiaobai&quot;</span>,<br>        age : <span class="hljs-number">18</span><br>    &#125;<br>    <span class="hljs-comment">//使用解构表达式获取对象的属性值</span><br>    <span class="hljs-keyword">let</span> &#123;name,age&#125; = person<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name,age)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>当使用解构表达式解构对象时，其属性值的获取是根据属性名获取的（不同于数组的索引）</p><p>所以无法给非属性名的变量赋值解构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">let</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> &#123;<br>    name : <span class="hljs-string">&quot;xiaobai&quot;</span>,<br>    age : <span class="hljs-number">18</span><br>&#125;<br><span class="hljs-comment">//使用解构表达式获取对象的属性值</span><br>let &#123;x,y&#125; = person<br>console.log(x,y) <span class="hljs-comment">//undefined undefined</span><br></code></pre></td></tr></table></figure><hr><h5 id="解构表达式作为方法的形参"><a href="#解构表达式作为方法的形参" class="headerlink" title="解构表达式作为方法的形参"></a>解构表达式作为方法的形参</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>    <span class="hljs-keyword">let</span> arr = [<span class="hljs-number">11</span>,<span class="hljs-number">22</span>,<span class="hljs-number">33</span>,<span class="hljs-number">44</span>]<br>    <span class="hljs-comment">//解构表达式作为形参使用</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">showArr</span>(<span class="hljs-params">[a,b,c=<span class="hljs-number">10</span>]</span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a,b,c)<br>    &#125;<br>    <span class="hljs-title function_">showArr</span>(arr)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><hr><h3 id="ES6的箭头函数"><a href="#ES6的箭头函数" class="headerlink" title="ES6的箭头函数"></a>ES6的箭头函数</h3><p>ES6允许使用”箭头”函数，语法类似Java中的Lambda表达式</p><p><em>在java中，lambda表达式多用于结合函数式接口实现匿名内部类的功能，而js中多用于定义函数（方法）</em></p><p><em><strong>其中括号内是形参，大括号是执行体，而js是弱类型无需函数返回类型和形参类型，函数名即为赋值给的变量名</strong></em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>    <span class="hljs-keyword">let</span> fun1 = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125; <span class="hljs-comment">//普通的函数声明</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-title function_">fun2</span> = (<span class="hljs-params"></span>) =&gt; &#123;&#125; <span class="hljs-comment">//箭头表达式（lambda）</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-title function_">fun3</span> = (<span class="hljs-params">x</span>) =&gt; &#123; <span class="hljs-keyword">return</span> x+<span class="hljs-number">1</span> &#125;<br>    <span class="hljs-keyword">let</span> <span class="hljs-title function_">fun4</span> = x =&gt; &#123; <span class="hljs-keyword">return</span> x+<span class="hljs-number">1</span> &#125; <span class="hljs-comment">//当参数只有一个的时候 小括号省略</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-title function_">fun5</span> = x =&gt; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x) <span class="hljs-comment">//当执行语句只有一条的时候 大括号省略</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-title function_">fun6</span> = x =&gt; x+<span class="hljs-number">1</span> <span class="hljs-comment">//当执行语句只有一条且时return时 大括号和return都省略</span><br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><hr><h5 id="箭头函数中的this问题"><a href="#箭头函数中的this问题" class="headerlink" title="箭头函数中的this问题"></a>箭头函数中的this问题</h5><p>箭头函数中，没有自己的this</p><p>箭头函数中的this时外层上下文环境的this</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> person =&#123;<br>    name : <span class="hljs-string">&quot;xiaobai&quot;</span>,<br>    <span class="hljs-attr">showName</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>    &#125;,<br>    <span class="hljs-attr">viewName</span>:<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>    &#125;,<br>    <span class="hljs-attr">viewThis</span>:<span class="hljs-function">() =&gt;</span>&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>    &#125;<br>&#125;<br>person.<span class="hljs-title function_">showName</span>() <span class="hljs-comment">//xiaobai</span><br>person.<span class="hljs-title function_">viewName</span>() <span class="hljs-comment">//空白</span><br>person.<span class="hljs-title function_">viewThis</span>() <span class="hljs-comment">//Window对象</span><br></code></pre></td></tr></table></figure><p>每当使用箭头函数时，其this为上一层对象，如果实在找不到this就直接打印出来</p><hr><h3 id="rest和spread"><a href="#rest和spread" class="headerlink" title="rest和spread"></a>rest和spread</h3><h5 id="rest剩余参数"><a href="#rest剩余参数" class="headerlink" title="rest剩余参数"></a>rest剩余参数</h5><p><em>rest中文释义：剩余的</em></p><p>rest在js的用法相当于java的可变参数，其在形参中的最后使用且只能有一个，写法是… arr</p><p>无论参数的类型是什么，有多少，都以数组的形式接受剩余参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-title function_">fun1</span> = (<span class="hljs-params">... arr</span>) =&gt; &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr) &#125;<br><span class="hljs-title function_">fun1</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-string">&quot;str&quot;</span>)<br></code></pre></td></tr></table></figure><hr><h5 id="spread实参传递"><a href="#spread实参传递" class="headerlink" title="spread实参传递"></a>spread实参传递</h5><p><em>spread中文释义：扩散；展开</em></p><p>和rest的写法相同，在调用方法时作为实参使用</p><p>在传入实参时将数组内容扩散展开分别为形参赋值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br><span class="hljs-keyword">let</span> <span class="hljs-title function_">fun</span> = (<span class="hljs-params">a,b,c</span>) =&gt; &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a,b,c) <br>&#125;<br><span class="hljs-title function_">fun</span>(arr) <span class="hljs-comment">//[1, 2, 3] undefined undefined</span><br><span class="hljs-title function_">fun</span>(...arr) <span class="hljs-comment">//1 2 3</span><br></code></pre></td></tr></table></figure><p><em>在形参中使用解构表达式，直接将数组作为实参也能完成此功能</em></p><hr><h5 id="spread合并数组"><a href="#spread合并数组" class="headerlink" title="spread合并数组"></a>spread合并数组</h5><p>spread可以快速合并数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br><span class="hljs-keyword">let</span> b = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br><span class="hljs-keyword">let</span> c = [<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]<br><span class="hljs-keyword">let</span> d = [...a,...b,...c]<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(d) <span class="hljs-comment">//[1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br></code></pre></td></tr></table></figure><hr><h5 id="spread合并对象"><a href="#spread合并对象" class="headerlink" title="spread合并对象"></a>spread合并对象</h5><p>spread可以快速合并对象</p><p><em>注：如果有重名对象，后者会覆盖前者</em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> person1 = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-attr">age</span>:<span class="hljs-string">&quot;10&quot;</span>&#125;<br><span class="hljs-keyword">let</span> person2 = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;小白&quot;</span>,<span class="hljs-attr">age</span>:<span class="hljs-string">&quot;18&quot;</span>,<span class="hljs-attr">gender</span>:<span class="hljs-string">&quot;boy&quot;</span>&#125;<br><span class="hljs-keyword">let</span> person3 = &#123;<span class="hljs-attr">salary</span>:<span class="hljs-string">&quot;3000&quot;</span>&#125;<br><span class="hljs-keyword">let</span> person4 = &#123;...person1,...person2,...person3&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person4)<span class="hljs-comment">//&#123;name: &#x27;小白&#x27;, age: &#x27;18&#x27;, gender: &#x27;boy&#x27;, salary: &#x27;3000&#x27;&#125;</span><br></code></pre></td></tr></table></figure><hr><h3 id="对象创建的语法糖"><a href="#对象创建的语法糖" class="headerlink" title="对象创建的语法糖"></a>对象创建的语法糖</h3><p>ES6中新增了对象创建的语法糖，支持了class extends constructor等关键字，让ES6的语法和面向对象的语法更加接近</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br>    <span class="hljs-comment">//属性</span><br>    name;<br>    #age;<br>    <span class="hljs-comment">//getter/setter</span><br>    <span class="hljs-keyword">get</span> <span class="hljs-title function_">name</span>()&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span><br>    &#125;<br>    <span class="hljs-keyword">set</span> <span class="hljs-title function_">name</span>(<span class="hljs-params">name</span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>    &#125;<br>    <span class="hljs-keyword">get</span> <span class="hljs-title function_">setage</span>()&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.#age<br>    &#125;<br>    <span class="hljs-keyword">set</span> <span class="hljs-title function_">setage</span>(<span class="hljs-params">age</span>)&#123;<br>        <span class="hljs-variable language_">this</span>.#age = age<br>    &#125;<br>    <span class="hljs-comment">//实例方法</span><br>    <span class="hljs-title function_">eat</span>(<span class="hljs-params">food</span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.age&#125;</span>岁的<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>正在吃<span class="hljs-subst">$&#123;food&#125;</span>`</span>)<br>    &#125;<br>    <span class="hljs-comment">//静态方法</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">a,b</span>)&#123;<br>        <span class="hljs-keyword">return</span> a+b<br>    &#125;<br>    <span class="hljs-comment">//构造方法</span><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name,age</span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>        <span class="hljs-variable language_">this</span>.#age = age<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>js中没有private关键字，要在私有属性前加#，但要注意的是，所有对此属性的操作时，属性名都有#</em></p><hr><h5 id="类的方法"><a href="#类的方法" class="headerlink" title="类的方法"></a>类的方法</h5><p>在调用get&#x2F;set方法时和调用普通的实例方法不同，相当于直接.属性赋值的形式调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()<br>person.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;xiaobai&quot;</span><br>person.<span class="hljs-property">setage</span> = <span class="hljs-number">18</span> <span class="hljs-comment">//调用set方法</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person) <span class="hljs-comment">//Person &#123;name: &#x27;xiaobai&#x27;, age: 18&#125;</span><br><span class="hljs-comment">//私有属性无法通过.属性名的方式访问</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.#age)<span class="hljs-comment">//Uncaught SyntaxError: Private field &#x27;#age&#x27; must be declared in an enclosing class</span><br><span class="hljs-comment">//调用实例方法</span><br>person.<span class="hljs-title function_">eat</span>(<span class="hljs-string">&quot;火锅&quot;</span>) <span class="hljs-comment">//18岁的xiaobai正在吃火锅</span><br><span class="hljs-comment">//调用静态方法</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-title function_">sum</span>(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>)) <span class="hljs-comment">//30</span><br><span class="hljs-comment">//调用构造方法</span><br><span class="hljs-keyword">let</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;xiaoming&quot;</span>,<span class="hljs-number">20</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person1)<br></code></pre></td></tr></table></figure><hr><h5 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h5><p> 在ES6的语法糖中，继承也是可以使用的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Person</span>&#123;<br>    score<br>    <span class="hljs-title function_">study</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.getage&#125;</span>岁的<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>正在努力学习，考试获得了<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.score&#125;</span>分`</span>)<br>    &#125;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name,age,score</span>)&#123;<br>        <span class="hljs-variable language_">super</span>(name,age)<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">score</span> = score<br>    &#125;<br>&#125;<br><span class="hljs-keyword">let</span> stu = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;xiaobai&quot;</span>,<span class="hljs-number">18</span>,<span class="hljs-number">100</span>)<br>stu.<span class="hljs-title function_">study</span>() <span class="hljs-comment">//18岁的xiaobai正在努力学习，考试获得了100分</span><br></code></pre></td></tr></table></figure><hr><h3 id="对象拷贝的语法糖"><a href="#对象拷贝的语法糖" class="headerlink" title="对象拷贝的语法糖"></a>对象拷贝的语法糖</h3><h5 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h5><p>浅拷贝是多一个引用指向同一个对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br><span class="hljs-keyword">let</span> arr2 = arr<br>arr[<span class="hljs-number">0</span>] = <span class="hljs-number">100</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr2) <span class="hljs-comment">// [100, 2, 3]</span><br><br>person = &#123;name : <span class="hljs-string">&quot;xiaobai&quot;</span>,age : <span class="hljs-number">18</span>&#125;<br>person2 = person<br>person.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;xiaohei&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person2) <span class="hljs-comment">//&#123;name: &#x27;xiaohei&#x27;, age: 18&#125;</span><br></code></pre></td></tr></table></figure><hr><h5 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h5><p>深拷贝是完全一个全新的对象</p><p>可以通过spread展开赋值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br><span class="hljs-keyword">let</span> arr2 = [...arr]<br>arr[<span class="hljs-number">0</span>] = <span class="hljs-number">100</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr2) <span class="hljs-comment">// [1, 2, 3]</span><br><br>person = &#123;name : <span class="hljs-string">&quot;xiaobai&quot;</span>,age : <span class="hljs-number">18</span>&#125;<br>person2 = &#123;...person&#125;<br>person.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;xiaohei&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person2) <span class="hljs-comment">//&#123;name: &#x27;xiaobai&#x27;, age: 18&#125;</span><br></code></pre></td></tr></table></figure><hr><p>还可以通过json字符串的转换来给对象重新赋值</p><p><em>先将对象转为JSON串，再转换回变量</em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">person = &#123;name : <span class="hljs-string">&quot;xiaobai&quot;</span>,age : <span class="hljs-number">18</span>&#125;<br>person2 = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(person))<br>person.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;xiaohei&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person2) <span class="hljs-comment">//&#123;name: &#x27;xiaobai&#x27;, age: 18&#125;</span><br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>JAVAWEB</category>
      
      <category>前端工程化</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>前端工程化</title>
    <link href="/2024/04/26/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    <url>/2024/04/26/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="前端工程化"><a href="#前端工程化" class="headerlink" title="前端工程化"></a>前端工程化</h1><blockquote><p>后端的工程化是使用maven处理</p><p>前端的工程化是使用nodejs npm vite处理</p></blockquote><p>但前后端处理的两种方式冲突，为解决此问题，我们将app中的前端相关的代码剥离出来，形成一个独立的工程</p><p>使用相关的专门技术来实现前端代码的<strong>模块化、组件化、规范化、自动化</strong>，这就是前端工程化</p><p>而此时，项目的研发模式就变成了<strong>前后端分离模式</strong>（开发分离、部署分离）</p><hr><h3 id="前端工程化实现的技术栈"><a href="#前端工程化实现的技术栈" class="headerlink" title="前端工程化实现的技术栈"></a>前端工程化实现的技术栈</h3><p>前端工程化实现的技术栈有很多，我们采用sES6+nodejs+npm+Vite+VUE3+router+pinia+axios+Element-plus组合实现</p><table><thead><tr><th>技术栈</th><th>说明</th></tr></thead><tbody><tr><td>ECMAScript6</td><td>VUE3中大量使用ES6语法</td></tr><tr><td>nodejs</td><td>前端项目运行环境</td></tr><tr><td>npm</td><td>依赖下载工具</td></tr><tr><td>vite</td><td>前端项目构建工具</td></tr><tr><td>VUE3</td><td>优秀的渐进式前端框架</td></tr><tr><td>router</td><td>通过路由实现页面切换</td></tr><tr><td>pinia</td><td>通过状态管理实现组件数据传递</td></tr><tr><td>axios</td><td>ajax异步请求封装技术实现前后端数据交互</td></tr><tr><td>Element-plus</td><td>可以提供丰富的快速构建网页的组件仓库</td></tr></tbody></table><hr>]]></content>
    
    
    <categories>
      
      <category>JAVAWEB</category>
      
      <category>前端工程化</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu的软件安装</title>
    <link href="/2024/04/25/Ubuntu%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
    <url>/2024/04/25/Ubuntu%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h1 id="Ubuntu的软件安装"><a href="#Ubuntu的软件安装" class="headerlink" title="Ubuntu的软件安装"></a>Ubuntu的软件安装</h1><h3 id="系统地址"><a href="#系统地址" class="headerlink" title="系统地址"></a>系统地址</h3><p><a href="https://cn.ubuntu.com/download">Ubuntu系统下载 | Ubuntu</a></p><hr><h3 id="更换阿里源"><a href="#更换阿里源" class="headerlink" title="更换阿里源"></a>更换阿里源</h3><h5 id="备份源"><a href="#备份源" class="headerlink" title="备份源"></a>备份源</h5><blockquote><p>cd &#x2F;etc&#x2F;apt<br>sudo mv sources.list sources.list.bak</p></blockquote><h5 id="写入源"><a href="#写入源" class="headerlink" title="写入源"></a>写入源</h5><blockquote><p>vi sources.list<br><a href="https://developer.aliyun.com/mirror/ubuntu">ubuntu镜像_ubuntu下载地址_ubuntu安装教程-阿里巴巴开源镜像站 (aliyun.com)</a></p></blockquote><h5 id="更新源"><a href="#更新源" class="headerlink" title="更新源"></a>更新源</h5><p>apt-get update</p><hr><h3 id="Docker的安装"><a href="#Docker的安装" class="headerlink" title="Docker的安装"></a>Docker的安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">apt install docker.io<br></code></pre></td></tr></table></figure><h3 id="Docker-compose的安装"><a href="#Docker-compose的安装" class="headerlink" title="Docker-compose的安装"></a>Docker-compose的安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">apt install docker-compose<br></code></pre></td></tr></table></figure><h3 id="Docker更换阿里云软件源"><a href="#Docker更换阿里云软件源" class="headerlink" title="Docker更换阿里云软件源"></a>Docker更换阿里云软件源</h3><p><a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors">容器镜像服务 (aliyun.com)</a></p><hr><h3 id="VrayA的安装"><a href="#VrayA的安装" class="headerlink" title="VrayA的安装"></a>VrayA的安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install v2raya xray<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
      <category>server</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JDBC-Util和BaseDAO</title>
    <link href="/2024/04/25/JDBC-Util%E5%92%8CBaseDAO/"/>
    <url>/2024/04/25/JDBC-Util%E5%92%8CBaseDAO/</url>
    
    <content type="html"><![CDATA[<h1 id="JDBC-Util和BaseDAO"><a href="#JDBC-Util和BaseDAO" class="headerlink" title="JDBC-Util和BaseDAO"></a>JDBC-Util和BaseDAO</h1><p>以下是尚硅谷给提供的Util和BaseDAO，相比我们写的更完美一些，在资源回收和异常处理方面做的更好</p><p><strong>无需在业务Dao的实现类中处理异常</strong></p><h3 id="Util"><a href="#Util" class="headerlink" title="Util"></a>Util</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.alibaba.druid.pool.DruidDataSourceFactory;<br><br><span class="hljs-keyword">import</span> javax.sql.DataSource;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.InputStream;<br><span class="hljs-keyword">import</span> java.sql.Connection;<br><span class="hljs-keyword">import</span> java.sql.SQLException;<br><span class="hljs-keyword">import</span> java.util.Properties;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * JDBC工具类</span><br><span class="hljs-comment"> * 创建一个连接池引用，提供给当前项目的全局使用</span><br><span class="hljs-comment"> * 同时，维护了一个线程绑定变量的ThreadLocal对象</span><br><span class="hljs-comment"> * 后续，加入了对事务回收线程的判定，方便事务的使用</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JDBCUtil</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;Connection&gt; threadLocal =<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> DataSource dataSource;<br>    <span class="hljs-comment">// 初始化连接池</span><br>    <span class="hljs-keyword">static</span>&#123;<br>        <span class="hljs-comment">// 可以帮助我们读取.properties配置文件</span><br>        <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">resourceAsStream</span> <span class="hljs-operator">=</span> JDBCUtil.class.getClassLoader().getResourceAsStream(<span class="hljs-string">&quot;jdbc.properties&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            properties.load(resourceAsStream);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            dataSource = DruidDataSourceFactory.createDataSource(properties);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br><br><br>    &#125;<br>    <span class="hljs-comment">/*1 向外提供连接池的方法*/</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DataSource <span class="hljs-title function_">getDataSource</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> dataSource;<br>    &#125;<br><br>    <span class="hljs-comment">/*2 向外提供连接的方法*/</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> threadLocal.get();<br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == connection) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                connection = dataSource.getConnection();<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>            threadLocal.set(connection);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> connection;<br>    &#125;<br><br><br>    <span class="hljs-comment">/*定义一个归还连接的方法 (解除和ThreadLocal之间的关联关系) */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">releaseConnection</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> threadLocal.get();<br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != connection) &#123;<br>            threadLocal.remove();<br>            <span class="hljs-comment">// 把连接设置回自动提交的连接</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                connection.setAutoCommit(<span class="hljs-literal">true</span>);<br>                <span class="hljs-comment">// 自动归还到连接池</span><br>                connection.close();<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="BaseDAO"><a href="#BaseDAO" class="headerlink" title="BaseDAO"></a>BaseDAO</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.xiaobai.util.JDBCUtil;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.sql.*;<br><span class="hljs-keyword">import</span> java.time.LocalDateTime;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 此类是封装JDBC中 预编译Sql -&gt; 为占位符赋值 -&gt; 处理结果三个步骤的代码</span><br><span class="hljs-comment"> * 此类直接作为Dao实现类的父类，不重写代码直接继承封装好的方法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseDao</span> &#123;<br>    <span class="hljs-comment">//通过调用查询方法，获取单行数据返回</span><br>    <span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">baseQueryBean</span><span class="hljs-params">(Class&lt;T&gt; clazz, String sql, Object... params)</span>  &#123;<br>        List&lt;T&gt; list = baseQuery(clazz, sql, params);<br>        <span class="hljs-keyword">if</span> (list != <span class="hljs-literal">null</span> &amp;&amp; list.size() &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> list.get(<span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 公共的查询方法  返回的是单个对象</span><br>    <span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">baseQueryObject</span><span class="hljs-params">(Class&lt;T&gt; clazz, String sql, Object ... args)</span> &#123;<br>        <span class="hljs-type">T</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> JDBCUtil.getConnection();<br>        <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">preparedStatement</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ResultSet</span> <span class="hljs-variable">resultSet</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rows</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 准备语句对象</span><br>            preparedStatement = connection.prepareStatement(sql);<br>            <span class="hljs-comment">// 设置语句上的参数</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; args.length; i++) &#123;<br>                preparedStatement.setObject(i + <span class="hljs-number">1</span>, args[i]);<br>            &#125;<br><br>            <span class="hljs-comment">// 执行 查询</span><br>            resultSet = preparedStatement.executeQuery();<br>            <span class="hljs-keyword">if</span> (resultSet.next()) &#123;<br>                t = (T) resultSet.getObject(<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != resultSet) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    resultSet.close();<br>                &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != preparedStatement) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    preparedStatement.close();<br>                &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br><br>            &#125;<br>            JDBCUtil.releaseConnection();<br>        &#125;<br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 公共的查询方法  返回的是对象的集合</span><br>    <span class="hljs-keyword">public</span> &lt;T&gt; List&lt;T&gt; <span class="hljs-title function_">baseQuery</span><span class="hljs-params">(Class clazz, String sql, Object ... args)</span>&#123;<br>        List&lt;T&gt; list =<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> JDBCUtil.getConnection();<br>        PreparedStatement preparedStatement=<span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ResultSet</span> <span class="hljs-variable">resultSet</span> <span class="hljs-operator">=</span><span class="hljs-literal">null</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rows</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 准备语句对象</span><br>            preparedStatement = connection.prepareStatement(sql);<br>            <span class="hljs-comment">// 设置语句上的参数</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; args.length; i++) &#123;<br>                preparedStatement.setObject(i+<span class="hljs-number">1</span>,args[i]);<br>            &#125;<br><br>            <span class="hljs-comment">// 执行 查询</span><br>            resultSet = preparedStatement.executeQuery();<br><br>            <span class="hljs-type">ResultSetMetaData</span> <span class="hljs-variable">metaData</span> <span class="hljs-operator">=</span> resultSet.getMetaData();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">columnCount</span> <span class="hljs-operator">=</span> metaData.getColumnCount();<br><br>            <span class="hljs-comment">// 将结果集通过反射封装成实体类对象</span><br>            <span class="hljs-keyword">while</span> (resultSet.next()) &#123;<br>                <span class="hljs-comment">// 使用反射实例化对象</span><br>                <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span>clazz.getDeclaredConstructor().newInstance();<br><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= columnCount; i++) &#123;<br>                    <span class="hljs-type">String</span> <span class="hljs-variable">columnName</span> <span class="hljs-operator">=</span> metaData.getColumnLabel(i);<br>                    <span class="hljs-type">Object</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> resultSet.getObject(columnName);<br>                    <span class="hljs-comment">// 处理datetime类型字段和java.util.Data转换问题</span><br>                    <span class="hljs-keyword">if</span>(value.getClass().equals(LocalDateTime.class))&#123;<br>                        value= Timestamp.valueOf((LocalDateTime) value);<br>                    &#125;<br>                    <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> clazz.getDeclaredField(columnName);<br>                    field.setAccessible(<span class="hljs-literal">true</span>);<br>                    field.set(obj,value);<br>                &#125;<br><br>                list.add((T)obj);<br>            &#125;<br><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> !=resultSet) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    resultSet.close();<br>                &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != preparedStatement) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    preparedStatement.close();<br>                &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>                &#125;<br>            &#125;<br>            JDBCUtil.releaseConnection();<br>        &#125;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br><br>    <span class="hljs-comment">// 通用的增删改方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">baseUpdate</span><span class="hljs-params">(String sql,Object ... args)</span> &#123;<br>        <span class="hljs-comment">// 获取连接</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> JDBCUtil.getConnection();<br>        PreparedStatement preparedStatement=<span class="hljs-literal">null</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rows</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 准备语句对象</span><br>            preparedStatement = connection.prepareStatement(sql);<br>            <span class="hljs-comment">// 设置语句上的参数</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; args.length; i++) &#123;<br>                preparedStatement.setObject(i+<span class="hljs-number">1</span>,args[i]);<br>            &#125;<br><br>            <span class="hljs-comment">// 执行 增删改 executeUpdate</span><br>            rows = preparedStatement.executeUpdate();<br>            <span class="hljs-comment">// 释放资源(可选)</span><br><br><br>        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != preparedStatement) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    preparedStatement.close();<br>                &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>                &#125;<br><br>            &#125;<br>            JDBCUtil.releaseConnection();<br>        &#125;<br>        <span class="hljs-comment">// 返回的是影响数据库记录数</span><br>        <span class="hljs-keyword">return</span> rows;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据库相关</category>
      
      <category>JDBC</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Ajax</title>
    <link href="/2024/04/25/Ajax/"/>
    <url>/2024/04/25/Ajax/</url>
    
    <content type="html"><![CDATA[<h1 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h1><p>Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）</p><p>最大的优点是在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容</p><p>不需要任何浏览器插件，但需要用户允许 JavaScript 在浏览器上执行</p><hr><h3 id="发送请求的方式-标签"><a href="#发送请求的方式-标签" class="headerlink" title="发送请求的方式&#x2F;标签"></a>发送请求的方式&#x2F;标签</h3><p>方式一：浏览器输入地址，回车</p><p>方式二：在html中，使用script&#x2F;link&#x2F;img请求外部资源时，会自动发送请求</p><p>方式三：a标签，form表单标签，需要手动控制提交产生请求，往往需要在<strong>新的页面上获得响应信息</strong></p><p><strong>方式四：运行js代码产生请求</strong></p><p>我们通过事件触发JS代码运行发送请求，响应后我们可以通过JS代码动态处理是否要跳转页面，还是将要响应的信息通过DOM编程显示在dom树中</p><hr><h3 id="Ajax的实现方式"><a href="#Ajax的实现方式" class="headerlink" title="Ajax的实现方式"></a>Ajax的实现方式</h3><p>原生JS的实现方式，代码繁琐，涉及到回调函数问题</p><p>使用第三方封装好的工具 jquery</p><p>使用框架 VUE axios</p><hr><h3 id="使用原生JS的实现方式"><a href="#使用原生JS的实现方式" class="headerlink" title="使用原生JS的实现方式"></a>使用原生JS的实现方式</h3><p>借助于XMLHttpRequest类实异步请求（xhr）</p><p>其对象有以下方法：</p><ul><li>readState 返回xhr的状态，其中4为正常响应</li><li>status 返回xhr的响应状态码，其中200为正常响应</li><li>responseText 返回后端响应体中的数据，可选择使用Dom编程直接显示或使用Bom编程跳转页面</li><li>open 设置请求的发送方式和请求资源的路径和参数</li><li>send 发送请求</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-keyword">function</span> <span class="hljs-title function_">getMessage</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-comment">//实例化一个xmlHttpRequest</span></span><br><span class="language-javascript">            <span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();</span><br><span class="language-javascript"></span><br><span class="language-javascript">            <span class="hljs-comment">//设置XMLHttpRequest对象的回调函数</span></span><br><span class="language-javascript">            <span class="hljs-comment">//xhr.readState 1 2 3 4</span></span><br><span class="language-javascript">            <span class="hljs-comment">//xhr.status 响应状态码 响应行状态码</span></span><br><span class="language-javascript">            xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">                <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">readyState</span> == <span class="hljs-number">4</span> &amp;&amp; xhr.<span class="hljs-property">status</span> == <span class="hljs-number">200</span>) &#123;</span><br><span class="language-javascript">                    <span class="hljs-comment">//xhr.responseText 后端响应回来的响应体中的数据</span></span><br><span class="language-javascript">                    <span class="hljs-comment">//使用Dom编程在页面中显示信息</span></span><br><span class="language-javascript">                    <span class="hljs-keyword">var</span> inputEle = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;message&quot;</span>)</span><br><span class="language-javascript">                    inputEle.<span class="hljs-property">value</span> = xhr.<span class="hljs-property">responseText</span></span><br><span class="language-javascript">                    <span class="hljs-comment">//使用Bom编程的window对象跳转指定位置</span></span><br><span class="language-javascript">                    <span class="hljs-comment">// window.location.href=&quot;http://www.baidu.com&quot;</span></span><br><span class="language-javascript">                &#125;</span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">            <span class="hljs-comment">//设置请求的发送方式和请求资源的路径及参数</span></span><br><span class="language-javascript">            xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;/hello?username=zhangshan&quot;</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript">            <span class="hljs-comment">//发送请求</span></span><br><span class="language-javascript">            xhr.<span class="hljs-title function_">send</span>()</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;getMessage()&quot;</span>&gt;</span>按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>java-web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Listener</title>
    <link href="/2024/04/24/Listener/"/>
    <url>/2024/04/24/Listener/</url>
    
    <content type="html"><![CDATA[<h1 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h1><p>监听器使用的感受类似于JS中的事件，被观察的对象发生某些情况时，自动触发代码的执行</p><p>监听器监听的对象只有三大域对象，不监听web项目的其他组件</p><hr><h3 id="监听器的分类"><a href="#监听器的分类" class="headerlink" title="监听器的分类"></a>监听器的分类</h3><p>web中定义八个监听器接口作为监听器的规范</p><ul><li><p>Application域</p><ul><li>ServletContextListener：监听Application域的创建和销毁</li><li>ServletContextAttributeListener：监听Application域中数据变化</li></ul></li><li><p>session域</p><ul><li>HttpSessionListener：监听Session域的创建和销毁</li><li>HttpSessionAttributeListener：监听Session域中数据变化</li><li>HttpSessionBindingListener：绑定行为的监听器接口</li><li>HttpSessionActivationListener：钝化和活化监听器接口</li></ul></li><li><p>request域</p><ul><li>ServletRequestListener：监听Request域的创建和销毁</li><li>ServletRequestAttributeListener：：监听Request域中数据变化</li></ul></li></ul><hr><h3 id="Application域的监听器"><a href="#Application域的监听器" class="headerlink" title="Application域的监听器"></a>Application域的监听器</h3><h5 id="ServletContextListener"><a href="#ServletContextListener" class="headerlink" title="ServletContextListener"></a>ServletContextListener</h5><p>监听ServletContext对象的创建与销毁</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>contextInitialized(ServletContextEvent sce)</td><td>ServletContext创建时调用</td></tr><tr><td>contextDestroyed(ServletContextEvent sce)</td><td>ServletContext销毁时调用</td></tr></tbody></table><p><em>ServletContextEvent对象代表从ServletContext对象身上捕获到的事件，通过这个事件对象我们可以获取到ServletContext对象</em></p><hr><h5 id="ServletContextAttributeListener"><a href="#ServletContextAttributeListener" class="headerlink" title="ServletContextAttributeListener"></a>ServletContextAttributeListener</h5><p>监听ServletContext中属性的添加、移除和修改</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>attributeAdded(ServletContextAttributeEvent scab)</td><td>向ServletContext中添加属性时调用</td></tr><tr><td>attributeRemoved(ServletContextAttributeEvent scab)</td><td>从ServletContext中移除属性时调用</td></tr><tr><td>attributeReplaced(ServletContextAttributeEvent scab)</td><td>当ServletContext中的属性被修改时调用</td></tr></tbody></table><p><em>注：当调用attributeReplaced方法时，使用scae对象获取的值时被修改前的值</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attributeReplaced</span><span class="hljs-params">(ServletContextAttributeEvent scae)</span> &#123;<br>    <span class="hljs-type">ServletContext</span> <span class="hljs-variable">application</span> <span class="hljs-operator">=</span> scae.getServletContext(); <br>    System.out.println(scae.getName() + scae.getValue() + <span class="hljs-string">&quot;的值被修改为&quot;</span> + application.getAttribute(scae.getName()));<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="ServletContextAttributeEvent对象"><a href="#ServletContextAttributeEvent对象" class="headerlink" title="ServletContextAttributeEvent对象"></a>ServletContextAttributeEvent对象</h5><p>代表属性变化事件</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>getName()</td><td>获取修改或添加的属性名</td></tr><tr><td>getValue()</td><td>获取被修改或添加的属性值</td></tr><tr><td>getServletContext()</td><td>获取ServletContext对象</td></tr></tbody></table><hr><h3 id="注解启动监听器"><a href="#注解启动监听器" class="headerlink" title="注解启动监听器"></a>注解启动监听器</h3><p>在监听器类上添加注解WebListener即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebListener</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyApplicationListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ServletContextListener</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">contextInitialized</span><span class="hljs-params">(ServletContextEvent sce)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;contextInitialized&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">contextDestroyed</span><span class="hljs-params">(ServletContextEvent sce)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;contextDestroyed&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>同一个监听器可实现多个接口，实现监听多个功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebListener</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyApplicationListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ServletContextListener</span>, ServletContextAttributeListener &#123;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="HttpSessionActivationListener"><a href="#HttpSessionActivationListener" class="headerlink" title="HttpSessionActivationListener"></a>HttpSessionActivationListener</h3><p>session对象在服务端是以对象的形式存储于内存的，session过多，服务器内存也不够</p><p>为了分摊内存压力并且为了保证session重启不丢失，我们可以设置将session进行钝化处理</p><blockquote><p>钝化（序列化）：内存 -&gt; 硬盘</p><p>活化（反序列化）：硬盘 -&gt;内存</p></blockquote><p>我们要监听某个session的钝化和活化，就将其属性作为参数存入session对象中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">session.setAttribute(<span class="hljs-string">&quot;activationListener&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">ActivationListener</span>()); <span class="hljs-comment">//添加钝化活化监听器</span><br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>java-web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Filter</title>
    <link href="/2024/04/24/Filter/"/>
    <url>/2024/04/24/Filter/</url>
    
    <content type="html"><![CDATA[<h1 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h1><p>Filter，即过滤器，是JAVAEE技术规范之一，作用目标资源的请求进行过滤的一套技术规范，是Java Web项目中最为实用的技术之一</p><ul><li>Filter接口定义了过滤器的开发规范,<strong>所有的过滤器都要实现该接口</strong></li><li>Filter的工作位置是项目中所有目标资源之前,容器在创建HttpServletRequest和HttpServletResponse对象后,会<strong>先调用Filter的doFilter方法</strong></li><li>Filter的doFilter方法可以控制请求是否继续,如果放行,则请求继续,如果拒绝,则请求到此为止,由过滤器本身做出响应</li><li>Filter不仅可以对请求做出过滤,也可以在目标资源做出响应前,对响应再次进行处理</li><li>Filter是GOF中责任链模式的典型案例</li><li>Filter的常用应用包括但不限于: 日志的记录、性能的分析、乱码的处理、事务的控制、登录的控制、跨域的处理</li></ul><blockquote><p>在软件包下建立filters目录作为过滤器的文件夹</p></blockquote><ul><li><p>继承Filter接口</p></li><li><p>重写过滤方法（doFilter）</p></li><li><p>配置过滤器</p><ul><li>web.xml配置</li><li>注解配置</li></ul></li></ul><hr><h3 id="配置过滤器"><a href="#配置过滤器" class="headerlink" title="配置过滤器"></a>配置过滤器</h3><p>使用web.xml配置过滤器的过程大致与servlet相同</p><p>但是在mapping的位置上，过滤器有两种写法</p><h5 id="写法："><a href="#写法：" class="headerlink" title="&lt;url-pattern&gt;写法："></a>&lt;url-pattern&gt;写法：</h5><ul><li>&#x2F;* 过滤全部资源</li><li>&#x2F;a&#x2F;* 过滤以a开头的资源</li><li>*.html 过滤以html为后缀的资源</li><li>&#x2F;ServletA 对ServletA的请求进行过滤（精确写法）</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>LoggingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>com.xiaobai.filters.LoggingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>LoggingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h5 id="写法：-1"><a href="#写法：-1" class="headerlink" title="&lt;servlet-name&gt;写法："></a>&lt;servlet-name&gt;写法：</h5><p>以xml文件的servlet-name别名或者以注解的name属性别名为参数，可以针对某个Servlet做出过滤</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(value = &quot;/ServletA&quot;,name = &quot;ServletA&quot;)</span> <span class="hljs-comment">//注解的name属性别名</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>LoggingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>com.xiaobai.filters.LoggingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>LoggingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>ServletA<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><p><em>注：servlet-name 和 url-pattern都可存在多个，并且可以共存</em></p><h5 id="注解的写法"><a href="#注解的写法" class="headerlink" title="注解的写法"></a>注解的写法</h5><p>Filter注解的写法与Servlet大致相同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebFilter(&quot;/*&quot;)</span><br></code></pre></td></tr></table></figure><p>与web.xml相同，注解中也有servletNames属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">WebInitParam[] initParams() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br>... ...<br><br>String[] servletNames() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br>String[] value() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br>String[] urlPatterns() <span class="hljs-keyword">default</span> &#123;&#125;;<br></code></pre></td></tr></table></figure><p><em>我们可以使用WebInitParam[] initParams()注解属性对其初始参数进行配置</em></p><hr><h3 id="doFilter"><a href="#doFilter" class="headerlink" title="doFilter"></a>doFilter</h3><p>请求到达目标资源之前，先经过该方法，该方法有能力控制请求是否继续向后到达目标资源，可以在该方法内直接向客户端做响应处理</p><p>请求在将目标资源相应回去之前，会再次经过该方法</p><ul><li>请求到达目标之前的功能代码<ul><li>判断是否登录</li><li>校验权限是否满足</li><li>……</li></ul></li><li>放行代码</li><li>HttpServletResponse在转换为响应报文之前的功能代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xiaobai.filters;<br><br><span class="hljs-keyword">import</span> jakarta.servlet.*;<br><span class="hljs-keyword">import</span> jakarta.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> jakarta.servlet.http.HttpServletResponse;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.text.SimpleDateFormat;<br><span class="hljs-keyword">import</span> java.util.Date;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 日志过滤器，记录请求的历史 将日志打印到控制台</span><br><span class="hljs-comment"> * 请求到达之前打印日志   yyyy-MM-dd HH:mm:ss</span><br><span class="hljs-comment"> * 请求结束之后打印访问资源的耗时 xxx资源在xxx的请求耗时x毫秒</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggingFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Filter</span> &#123;<br>    <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">simpleDateFormat</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<span class="hljs-comment">//使用dateFormate格式化时间</span><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br>        <span class="hljs-comment">//将请求相应的两个对象向下转型，以便能够使用HttpServletRequest和HttpServletResponse的方法</span><br>        <span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">req</span> <span class="hljs-operator">=</span> (HttpServletRequest) servletRequest;<br>        <span class="hljs-type">HttpServletResponse</span> <span class="hljs-variable">resp</span> <span class="hljs-operator">=</span> (HttpServletResponse) servletResponse;<br><br>        <span class="hljs-comment">//请求到达目标资源之前的功能代码（打印日志）</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">requestURI</span> <span class="hljs-operator">=</span> req.getRequestURI();<span class="hljs-comment">//获取URI</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">dataTime</span> <span class="hljs-operator">=</span> simpleDateFormat.format(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<span class="hljs-comment">//获取系统时间</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">beforeLogging</span> <span class="hljs-operator">=</span> requestURI + <span class="hljs-string">&quot;在&quot;</span> + dataTime + <span class="hljs-string">&quot;被访问了&quot;</span>;<br>        System.out.println(beforeLogging);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<span class="hljs-comment">//获取资源前</span><br>        <span class="hljs-comment">//放行代码</span><br>        filterChain.doFilter(servletRequest, servletResponse);<br><br>        <span class="hljs-type">long</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<span class="hljs-comment">//获取资源后</span><br>        <span class="hljs-comment">//相应之前的功能代码</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">afterLogging</span> <span class="hljs-operator">=</span> requestURI + <span class="hljs-string">&quot;资源在&quot;</span> + dataTime + <span class="hljs-string">&quot;的请求耗时：&quot;</span> + (t2 - t1) + <span class="hljs-string">&quot;毫秒&quot;</span>;<br>        System.out.println(afterLogging);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><em><strong>注：我们写的过滤器直接实现了Filter的接口，形参对象是ServletRequest servletRequest, ServletResponse servletResponse</strong></em></p><p><em><strong>如果想要使用HttpServletRequest和HttpServletResponse的方法，需要向下转型</strong></em> 😶</p><hr><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>Filter的生命周期也与Servlet大致相同</p><table><thead><tr><th>步骤</th><th>使用方法</th><th>执行时间</th></tr></thead><tbody><tr><td>实例化</td><td>构造器</td><td>第一次请求&#x2F;随服务器启动</td></tr><tr><td>初始化</td><td>init</td><td>构造完毕</td></tr><tr><td>接受请求，处理请求，服务</td><td>service</td><td>每次请求</td></tr><tr><td>销毁</td><td>destory</td><td>关闭服务</td></tr></tbody></table><p>不同的是，我们写的过滤器直接实现了Filter接口</p><p>Filter接口中的init和destory是使用了default修饰，即不重写也不会报错</p><p>并且Filter中<strong>没有无参构造方法</strong></p><hr><h3 id="过滤器链"><a href="#过滤器链" class="headerlink" title="过滤器链"></a>过滤器链</h3><p>Filter可以存在多个，分别配置到不同的资源前，同一个资源可以有多个过滤器，将会形成<strong>过滤器链</strong></p><hr><h5 id="web-xml配置多个过滤器"><a href="#web-xml配置多个过滤器" class="headerlink" title="web.xml配置多个过滤器"></a>web.xml配置多个过滤器</h5><p>web.xml配置的过滤器链会按照&lt;filter-mapping&gt;配置的先后顺序执行，但<strong>响应的顺序是从后到前</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>Filter1<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>com.xiaobai.filters.Filter1<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>Filter1<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>Filter2<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>com.xiaobai.filters.Filter2<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>Filter2<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>Filter3<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>com.xiaobai.filters.Filter1<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>Filter3<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><p>以上过滤器的执行流程是:</p><blockquote><p>Filter1请求 -&gt; Filter1放行 -&gt; Filter2请求 -&gt; Filter2放行 -&gt; Filter3请求 -&gt; Filter3放行 -&gt; Filter3响应 -&gt; Filter2响应 -&gt; Filter1响应</p></blockquote><hr><h5 id="注解的方式配置多个过滤器"><a href="#注解的方式配置多个过滤器" class="headerlink" title="注解的方式配置多个过滤器"></a>注解的方式配置多个过滤器</h5><p>通过注解配置的多个过滤器时，是通过<strong>类名</strong>决定过滤器链（过滤器顺序）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebFilter(&quot;/*&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Filter1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Filter</span> &#123;<br>&#125;<br><span class="hljs-meta">@WebFilter(&quot;/*&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Filter2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Filter</span> &#123;<br>&#125;<br><span class="hljs-meta">@WebFilter(&quot;/*&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Filter3</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Filter</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Filter1请求 -&gt; Filter1放行 -&gt; Filter2请求 -&gt; Filter2放行 -&gt; Filter3请求 -&gt; Filter3放行 -&gt; Filter3响应 -&gt; Filter2响应 -&gt; Filter1响应</p></blockquote><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>java-web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Servlet-会话管理</title>
    <link href="/2024/04/24/Servlet-%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86/"/>
    <url>/2024/04/24/Servlet-%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="会话管理"><a href="#会话管理" class="headerlink" title="会话管理"></a>会话管理</h1><blockquote><p>HTTP是无状态协议</p></blockquote><p>无状态即不保存状态，HTTP协议自身不对请求和响应之间的通信状态进行保存</p><hr><h3 id="会话管理的实现的手段"><a href="#会话管理的实现的手段" class="headerlink" title="会话管理的实现的手段"></a>会话管理的实现的手段</h3><blockquote><p>使用Cookie和Session配合解决</p></blockquote><p>Cookie是在<strong>客户端</strong>保留少量数据的技术，主要是通过<strong>响应头</strong>向客户端响应一些客户端要保留的信息</p><p>Session是在<strong>服务端</strong>保留更多数据的技术，主要通过HttpSession对象保存一些和客户端相关的信息</p><p>Cookie和Session配合记录请求状态</p><hr><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><h5 id="Cookie的创建"><a href="#Cookie的创建" class="headerlink" title="Cookie的创建"></a>Cookie的创建</h5><p>服务端创建Cookie，将Cookie放入响应对象中，Tomcat容器将Cookie转化为set-cookie响应头，响应给客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(&quot;/ServletA&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServletA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-comment">//创建Cookie</span><br>        <span class="hljs-type">Cookie</span> <span class="hljs-variable">cookieA</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cookie</span>(<span class="hljs-string">&quot;keyA&quot;</span>,<span class="hljs-string">&quot;valueA&quot;</span>);<br>        <span class="hljs-type">Cookie</span> <span class="hljs-variable">cookieB</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cookie</span>(<span class="hljs-string">&quot;keyB&quot;</span>,<span class="hljs-string">&quot;valueB&quot;</span>);<br>        <span class="hljs-comment">//将Cookie放入response对象</span><br>        resp.addCookie(cookieA);<br>        resp.addCookie(cookieB);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="Cookie的获取"><a href="#Cookie的获取" class="headerlink" title="Cookie的获取"></a>Cookie的获取</h5><p>在获取Cookie时，如果没有Cookie，Cookie数组为null 而不是 0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(&quot;/ServletB&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServletB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-comment">//获取请求中携带的Cookie（以Cookie数组的形式储存）</span><br>        Cookie[] cookies = req.getCookies();<br>        <span class="hljs-keyword">if</span> (cookies != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">for</span> (Cookie cookie : cookies) &#123;<br>                System.out.println(cookie.getName() + <span class="hljs-string">&quot; : &quot;</span> + cookie.getValue());<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="Cookie的时效性"><a href="#Cookie的时效性" class="headerlink" title="Cookie的时效性"></a>Cookie的时效性</h5><blockquote><p>默认情况下Cookie的有效期是一次会话范围内，我们可以通过Cookie的setMaxAge()方法让Cookie持久化保存到浏览器上</p></blockquote><ul><li>会话级cookie<ul><li>服务端没有明确指定Cookie的存在时间</li><li>在浏览器端，Cookie数据存在于内存中</li><li>只要浏览器还开着，Cookie数据都一直在</li><li>浏览器关闭，内存中的Cookie数据就会被释放</li></ul></li><li>持久化Cookie<ul><li>服务端明确设置了Cookie的存在时间</li><li>在浏览器端，Cookie数据会被保存到硬盘上</li><li>Cookie 在硬盘上的存在时间根据服务端限定的时间来管控，不受浏览器关闭的影响</li><li>持久化Cookie到达了预设的时间会被释放</li></ul></li></ul><p><em>setMaxAge方法的参数设置单位时间是秒，如果参数为0，则表示要将此cookie删除</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">cookieA.setMaxAge(<span class="hljs-number">60</span> * <span class="hljs-number">60</span>); <span class="hljs-comment">//设置Cookie的时效时间为1小时</span><br></code></pre></td></tr></table></figure><hr><h5 id="Cookie的提交路径"><a href="#Cookie的提交路径" class="headerlink" title="Cookie的提交路径"></a>Cookie的提交路径</h5><p>我们设置的Cookie在浏览器中保存，但无论是访问哪一个网页都会携带这个Cookie</p><p>为了解决这个问题，我们使用setPath()方法设置Cookie的携带路径</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">cookieB.setPath(<span class="hljs-string">&quot;/ServletB&quot;</span>); <span class="hljs-comment">//只有访问ServletB页面才携带此Cookie</span><br></code></pre></td></tr></table></figure><hr><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p><em>Session是搭配Cookie使用的</em></p><p>Session用来在服务端记录客户端的某个状态，在用户访问服务端时被创建&#x2F;找到</p><p>服务端在为客户端创建Session时，会同时将Session对象的id，即<strong>JSESSIONID</strong>以Cookie的形式放入响应对象</p><p><strong>客户端在下次请求时携带JSESSIONID，服务端收到后，根据JSESSIONID找到相应的session对象</strong></p><p>Session通常应用于记录用户的登录状态和用户的操作历史</p><p><em>Session也是域对象</em></p><hr><h5 id="Session的获取"><a href="#Session的获取" class="headerlink" title="Session的获取"></a>Session的获取</h5><p>在Servlet中获取Session的方法与Cookie不同，需要使用req调用getSession方法获取Session对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">HttpSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> req.getSession(); <span class="hljs-comment">//获取Session</span><br></code></pre></td></tr></table></figure><p>这个方法的执行步骤：</p><ul><li>判断请求中有没有一个名为JSESSIONID的特殊Cookie<ul><li>如果有，则根据JSESSIONID找对应的Session对象<ul><li>找到对象后，将此对象返回</li><li>如果没找到，则创建一个新的Session返回，并且向response对象中存放一个JSESSIONID的Cookie</li></ul></li><li>如果没有，则创建一个新的Session返回，并且向response对象中存放一个JSESSIONID的Cookie</li></ul></li></ul><hr><h5 id="SessionAPI"><a href="#SessionAPI" class="headerlink" title="SessionAPI"></a>SessionAPI</h5><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>getId()</td><td>获取JSESSIONID</td></tr><tr><td>isNew()</td><td>判断该Session是否为新建，而不是被找到</td></tr><tr><td>setAttribute()</td><td>存放键值对在Session中</td></tr><tr><td>getAttribute(String key)</td><td>根据键获取值的对象</td></tr></tbody></table><p><em>注：Session中的值可以存放object类型，当我们知晓存入值类型可将他安全强转</em></p><hr><h5 id="Session的时效性"><a href="#Session的时效性" class="headerlink" title="Session的时效性"></a>Session的时效性</h5><p>Session的时效性是30分钟，但有人访问后，会重新计时</p><p>我们可以在web.xml中设置Session的时效性 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">session-config</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">session-timeout</span>&gt;</span>30<span class="hljs-tag">&lt;/<span class="hljs-name">session-timeout</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">session-config</span>&gt;</span><br></code></pre></td></tr></table></figure><p>我们可以在Sevlet中单独设置Session的时效性（以秒为单位）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">session.setMaxInactiveInterval(<span class="hljs-number">60</span> * <span class="hljs-number">60</span>); <span class="hljs-comment">//设置Session的时效性为1小时</span><br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>java-web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MVC架构模式-各层的写法要求</title>
    <link href="/2024/04/23/MVC%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F-%E5%90%84%E5%B1%82%E7%9A%84%E5%86%99%E6%B3%95%E8%A6%81%E6%B1%82/"/>
    <url>/2024/04/23/MVC%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F-%E5%90%84%E5%B1%82%E7%9A%84%E5%86%99%E6%B3%95%E8%A6%81%E6%B1%82/</url>
    
    <content type="html"><![CDATA[<h1 id="MVC架构模式-各层的写法要求"><a href="#MVC架构模式-各层的写法要求" class="headerlink" title="MVC架构模式-各层的写法要求"></a>MVC架构模式-各层的写法要求</h1><p>M层中大概包括：pojo层、Dao层、Service层</p><p>C层中包括：Controller层</p><p><strong>注意事项：</strong></p><ul><li>要在接口上写明方法的文档</li><li>无论哪个层在调用其他层对象时，最好将其实例化对象为类中属性，这样做可以不用在每个方法中都实例化对象</li><li>写代码的逻辑可以选择为：Controller -&gt; service -&gt; Dao （由前向后），<em><strong>先写调用 再写 方法内容</strong></em></li></ul><hr><h3 id="pojo层"><a href="#pojo层" class="headerlink" title="pojo层"></a>pojo层</h3><ul><li><strong>实体类中的类名与表格名称应该对应</strong></li><li><strong>实体类的属性名与表格的列明应该对应</strong></li><li><strong>遇到下划线应以驼峰命名进行转换</strong></li><li><strong>每个属性都应该是私有的</strong></li><li>每个属性都应该具备get&#x2F;set方法</li><li>必须具备无参构造器</li><li>应该实现序列化接口（缓存 分布式项目数据传递 可能会将对象序列化）</li><li>应该重写hashcode和equals方法</li><li>toString是否重写都可以</li></ul><p><em><strong>以上我们只需要注意加粗部分，其余部分使用Lombok注解即可在编译时自动生成</strong></em>😓</p><h5 id="Lombok的使用方法"><a href="#Lombok的使用方法" class="headerlink" title="Lombok的使用方法"></a>Lombok的使用方法</h5><ul><li>检查idea是否已经安装了Lombok插件</li><li>检查是否勾选了enable annotation precessing</li></ul><blockquote><p>在汉化后的idea中，此设置在 构建、执行、部署 -&gt; 编译器 -&gt; 注解处理器 -&gt; 启用注解处理</p></blockquote><ul><li>导入Lombok的依赖添加jar包</li><li>在实体类中添加Lombok注解</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AllArgsConstructor</span> <span class="hljs-comment">//添加全参构造</span><br><span class="hljs-meta">@NoArgsConstructor</span> <span class="hljs-comment">//添加无参构造</span><br><span class="hljs-meta">@Data</span> <span class="hljs-comment">//添加get/set/hashcode/equals</span><br></code></pre></td></tr></table></figure><hr><h3 id="DAO层"><a href="#DAO层" class="headerlink" title="DAO层"></a>DAO层</h3><p><em>参考JDBC模块知识点进行编写</em></p><ul><li>dao<ul><li>impl目录：用于存放接口的实现类</li><li>BaseDAO类</li><li>xxxDao接口：用于定义Dao类功能的接口</li></ul></li></ul><hr><h3 id="Service层"><a href="#Service层" class="headerlink" title="Service层"></a>Service层</h3><ul><li>service<ul><li>impl目录：用于存放接口的实现类</li><li>xxxService接口：用于定义service功能的接口（调用Dao层实现功能）</li></ul></li></ul><hr><h3 id="Controller层"><a href="#Controller层" class="headerlink" title="Controller层"></a>Controller层</h3><p>为了区分功能的调用，我们将功能接在URI后的新增一层</p><p>例如：本Servlet的访问路径为&#x2F;xxx，可以在URI加一级路径</p><blockquote><p>增加的请求 ：&#x2F;xxx&#x2F;add</p><p>删除的请求 ：&#x2F;xxx&#x2F;remove</p><p>修改的请求 ：&#x2F;xxx&#x2F;update</p><p>查询的请求 ：&#x2F;xxx&#x2F;find</p></blockquote><hr><p>在service方法中，通过分割URI的方式，提取出要请求的功能，分别调用</p><p><em><strong>注：WebServlet注解要写成(“&#x2F;xxx&#x2F;*“)</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] split = req.getRequestURI().split(<span class="hljs-string">&quot;/&quot;</span>);<span class="hljs-comment">//URI：/schedule/xxx</span><br><span class="hljs-keyword">switch</span> (split[split.length - <span class="hljs-number">1</span>]) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;add&quot;</span>: add(req, resp); <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;update&quot;</span>: update(req, resp); <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;remove&quot;</span>: remove(req, resp); <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;find&quot;</span>: find(req, resp); <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>: <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出，URI中的功能名和我们调用的方法名一致</p><p><em><strong>所以，以上代码我们可以通过反射，使用分割URI的方式提取出功能名，再使用功能名调用方法！！！</strong></em> 😊</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] split = req.getRequestURI().split(<span class="hljs-string">&quot;/&quot;</span>);<span class="hljs-comment">//URI：/schedule/xxx</span><br><br>Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SysScheduleController</span>&gt; clazz = getClass();<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">Method</span> <span class="hljs-variable">declaredMethod</span> <span class="hljs-operator">=</span> clazz.getDeclaredMethod(split[split.length - <span class="hljs-number">1</span>], HttpServletRequest.class, HttpServletResponse.class);<span class="hljs-comment">//通过反射，使用功能名获得即将要执行的方法</span><br>    declaredMethod.setAccessible(<span class="hljs-literal">true</span>);<span class="hljs-comment">//设置方法穿透</span><br>    declaredMethod.invoke(<span class="hljs-built_in">this</span>,req,resp);<span class="hljs-comment">//调用方法啊，传参</span><br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><p>这种编程思想使得代码的泛用性更高，只需要增加方法即可</p><hr><p>再将增删改查的方法封装</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>    System.out.println(<span class="hljs-string">&quot;add&quot;</span>);<br>&#125;<br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>    System.out.println(<span class="hljs-string">&quot;remove&quot;</span>);<br>&#125;<br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>    System.out.println(<span class="hljs-string">&quot;update&quot;</span>);<br>&#125;<br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">find</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>    System.out.println(<span class="hljs-string">&quot;find&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="BaseController"><a href="#BaseController" class="headerlink" title="BaseController"></a>BaseController</h5><p>基于以上思想，我们将公共代码提取出一个BaseController的父类，提高代码的复用性</p><p>与BaseDAO类似，我们可以将实现类继承此类，并且不再需要继承HttpServlet类</p><p>实现类中可以不用重写service方法，直接写功能方法即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> jakarta.servlet.ServletException;<br><span class="hljs-keyword">import</span> jakarta.servlet.http.HttpServlet;<br><span class="hljs-keyword">import</span> jakarta.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> jakarta.servlet.http.HttpServletResponse;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 注：WebServlet注解要写成(&quot;/xxx/*&quot;)</span><br><span class="hljs-comment"> * 此类封装：通过URI分割获取功能名反射到Controller层执行方法的功能实现</span><br><span class="hljs-comment"> * 其他Controller类直接继承此类即可（不需要再额外继承HttpServlet类，因为本类已经继承）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseController</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        String[] split = req.getRequestURI().split(<span class="hljs-string">&quot;/&quot;</span>);<br>        <br>        Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseController</span>&gt; clazz = getClass();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Method</span> <span class="hljs-variable">declaredMethod</span> <span class="hljs-operator">=</span> clazz.getDeclaredMethod(split[split.length - <span class="hljs-number">1</span>], HttpServletRequest.class, HttpServletResponse.class);<br>            declaredMethod.setAccessible(<span class="hljs-literal">true</span>);<br>            declaredMethod.invoke(<span class="hljs-built_in">this</span>,req,resp);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="MD5加密工具类"><a href="#MD5加密工具类" class="headerlink" title="MD5加密工具类"></a>MD5加密工具类</h3><p>MD5 常被用于对密码等敏感信息进行单向加密，以便存储在数据库中，而不需要存储原始明文密码</p><p><em>他是一个常量类（静态方法），通常用于在service层，对明文密码进行处理再发到数据库储存</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.security.MessageDigest;<br><span class="hljs-keyword">import</span> java.security.NoSuchAlgorithmException;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MD5Util</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">encrypt</span><span class="hljs-params">(String strSrc)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">char</span> hexChars[] = &#123; <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span>,<br>                    <span class="hljs-string">&#x27;9&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span> &#125;;<br>            <span class="hljs-type">byte</span>[] bytes = strSrc.getBytes();<br>            <span class="hljs-type">MessageDigest</span> <span class="hljs-variable">md</span> <span class="hljs-operator">=</span> MessageDigest.getInstance(<span class="hljs-string">&quot;MD5&quot;</span>);<br>            md.update(bytes);<br>            bytes = md.digest();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> bytes.length;<br>            <span class="hljs-type">char</span>[] chars = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[j * <span class="hljs-number">2</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; bytes.length; i++) &#123;<br>                <span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> bytes[i];<br>                chars[k++] = hexChars[b &gt;&gt;&gt; <span class="hljs-number">4</span> &amp; <span class="hljs-number">0xf</span>];<br>                chars[k++] = hexChars[b &amp; <span class="hljs-number">0xf</span>];<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(chars);<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchAlgorithmException e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;MD5加密出错!!!&quot;</span>)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>java-web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JDBC-事务</title>
    <link href="/2024/04/21/JDBC-%E4%BA%8B%E5%8A%A1/"/>
    <url>/2024/04/21/JDBC-%E4%BA%8B%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="JDBC-事务"><a href="#JDBC-事务" class="headerlink" title="JDBC-事务"></a>JDBC-事务</h1><p>MySQL 事务主要用于处理操作量大，复杂度高的数据</p><p>事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行</p><p>数据库中有很多关于事务的命令</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>SHOW VARIABLES LIKE ‘autocommit’</td><td>查看当前连接中事物的提交方式（ON自动提交 OFF关闭自动提交）</td></tr><tr><td>SET autocommit &#x3D; FALSE</td><td>设置当前连接事务提交方式为手动提交</td></tr><tr><td>COMMIT</td><td>提交事务</td></tr><tr><td>ROLLBACK</td><td>回滚事务</td></tr></tbody></table><hr><h3 id="事务的回滚"><a href="#事务的回滚" class="headerlink" title="事务的回滚"></a>事务的回滚</h3><p>如果有两条语句要执行，可以看数据的受影响行数</p><p>如果当前连接受影响行数小于预期受影响行数，就说明有语句执行失败，需要<strong>事务回滚</strong></p><hr><h3 id="JDBC工具类的优化"><a href="#JDBC工具类的优化" class="headerlink" title="JDBC工具类的优化"></a>JDBC工具类的优化</h3><p>对工具类进行修改，在回收连接前开启自动提交（关闭事务），再将连接回收</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//从theadlocal中获取到连接，判断是否有线程</span><br>        <span class="hljs-comment">//如果有，该连接回收到连接池，并将threadlocal中的连接移除</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> threadLocal.get();<br>        <span class="hljs-keyword">if</span> (connection != <span class="hljs-literal">null</span>) &#123;<br>            threadLocal.remove();<br>            <span class="hljs-comment">//开启自动提交（关闭事务）</span><br>            connection.setAutoCommit(<span class="hljs-literal">true</span>);<br>            connection.close();<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对BaseDAO进行修改，在两个方法中对工具类的连接的回收加以判定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (connection.getAutoCommit())<br>&#123;<br>    JDBCUtilV2.close();<br>&#125;<br></code></pre></td></tr></table></figure><p>这样操作之后，开启事务（关闭自动提交）时，将不会由BaseDAO接管连接的回收</p><p>即不会再执行完SQL方法时自动回收链接，需要在业务层自己操作回收链接</p><hr><h3 id="业务层代码"><a href="#业务层代码" class="headerlink" title="业务层代码"></a>业务层代码</h3><p>在业务层中，我们有三个关键的操作</p><ul><li>开启事务（关闭自动提交）：connection.setAutoCommit(false)</li><li>提交事务：connection.commit()</li><li>回滚事务：connection.rollback()</li></ul><p><em>注：事务的开启，connection.setAutoCommit是针对这一连接的，要保证业务连接的唯一性，我们需要用到JDBCUtilV2中的threadLocal</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testTransaction</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">UserDao</span> <span class="hljs-variable">userDao</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDaoImpl</span>();<br>    <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        connection = JDBCUtilV2.getConnection();<br>        connection.setAutoCommit(<span class="hljs-literal">false</span>);<span class="hljs-comment">//关闭自动提交（开启事务）</span><br><br>        userDao.addMoney(<span class="hljs-number">1</span>,<span class="hljs-number">200</span>);<br>        userDao.addMoney(<span class="hljs-number">2</span>,<span class="hljs-number">200</span>);<br>        <br>        connection.commit();<span class="hljs-comment">//提交事务</span><br>    &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            connection.rollback();<span class="hljs-comment">//当出现异常时，事务自动回滚</span><br>        &#125; <span class="hljs-keyword">catch</span> (SQLException ex) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">//BaseDAO检测到事务开启（自动提交关闭），则不会自动回收连接，所以在Finally中回收连接</span><br>        JDBCUtilV2.close();<br>    &#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>数据库相关</category>
      
      <category>JDBC</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JDBC-DAO</title>
    <link href="/2024/04/21/JDBC-DAO/"/>
    <url>/2024/04/21/JDBC-DAO/</url>
    
    <content type="html"><![CDATA[<h1 id="JDBC-DAO"><a href="#JDBC-DAO" class="headerlink" title="JDBC-DAO"></a>JDBC-DAO</h1><p>DAO：Data Access Object，数据访问对象</p><p>DAO就是将JAVA对表的操作封装成对象</p><p>一张表对应一个实体类，那么一张表的操作对应一个DAO对象</p><p>在Java操作数据库时，我们将对同一张表的操作封装起来，供业务层Service去调用，这个类就是DAO层</p><blockquote><p>在dao目录下建立xxxDao接口</p><p>在dao目录下建立impl目录建立实现类</p><p>在dao目录下建立BaseDAO父类</p></blockquote><hr><h3 id="BaseDAO"><a href="#BaseDAO" class="headerlink" title="BaseDAO"></a>BaseDAO</h3><p>基本上每一个数据表都应该有一个对应的DAO接口及其实现类</p><p>我们发现所有表的CURD代码重复率很高，所以我们可以将这些重复的代码设计一个公共的父类</p><p><em><strong>注：BaseDAO中是不写SQL代码的，而DAO的实现类是需要写具体的SQL功能的</strong></em></p><p>DAO处理一共分为六步</p><ol><li>注册驱动</li><li>获取链接</li><li>预编译SQL语句</li><li>为占位符赋值，执行SQL，接受返回结果</li><li>处理结果</li><li>释放资源</li></ol><p>其中，1、2、6三部我们通过JDBCUtil完成，需要编写BaseDao提取出3、4、5的代码冗余部分</p><p>在这里，我们设计三个方法去完成公共部分的增删改查功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.xiaobai.schedule.util.JDBCUtilV2;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.sql.*;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 此类是封装JDBC中 预编译Sql -&gt; 为占位符赋值 -&gt; 处理结果三个步骤的代码</span><br><span class="hljs-comment"> * 此类直接作为Dao实现类的父类，不重写代码直接继承封装好的方法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseDAO</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 通用的增删改操作，形参使用可变长参数</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> sql    传入增删改的sql语句</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> params 传入对应sql语句的参数</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 返回数据库受操作改变的行数</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> SQLException</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">executeUpdate</span><span class="hljs-params">(String sql, Object... params)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-comment">//获取连接（通过封装好的工具类JDBCUtilV2）</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> JDBCUtilV2.getConnection();<br>        <span class="hljs-comment">//预编译SQL语句，来源于形参</span><br>        <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">preparedStatement</span> <span class="hljs-operator">=</span> connection.prepareStatement(sql);<br>        <span class="hljs-comment">//为SQL语句的占位符提供参数</span><br>        <span class="hljs-keyword">if</span> (params != <span class="hljs-literal">null</span> &amp;&amp; params.length &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; params.length; i++) &#123;<br>                <span class="hljs-comment">//占位符从1开始，数组下表从0开始</span><br>                preparedStatement.setObject(i + <span class="hljs-number">1</span>, params[i]);<span class="hljs-comment">//这里可以用setObject通配所有参数类型</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> preparedStatement.executeUpdate();<br>        <span class="hljs-comment">//释放资源</span><br>        preparedStatement.close();<br>        JDBCUtilV2.close();<br>        <span class="hljs-comment">//将返回来的行数，直接作为方法的返回值</span><br>        <span class="hljs-keyword">return</span> i;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 查询的返回的结果的类型不唯一，使用泛型方法</span><br><span class="hljs-comment">     * 结果的封装使用反射：告诉调用者告知BaseDao要封装对象的类对象</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> clazz  传入实体类的class类（通过.class即可获取）</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> sql    传入查询的sql语句</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> params 传入对应sql语句的参数</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &lt;T&gt;    结果集合（List）中参数的类型</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 返回一个结果集合，这个结果集合是被查询的结果（单行单列、单行多列、多行多列）</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> &lt;T&gt; List&lt;T&gt; <span class="hljs-title function_">executeQuery</span><span class="hljs-params">(Class&lt;T&gt; clazz, String sql, Object... params)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//获取连接（通过封装好的工具类JDBCUtilV2）</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> JDBCUtilV2.getConnection();<br>        <span class="hljs-comment">//预编译SQL语句，来源于形参</span><br>        <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">preparedStatement</span> <span class="hljs-operator">=</span> connection.prepareStatement(sql);<br>        <span class="hljs-comment">//为SQL语句的占位符提供参数</span><br>        <span class="hljs-keyword">if</span> (params != <span class="hljs-literal">null</span> &amp;&amp; params.length &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; params.length; i++) &#123;<br>                <span class="hljs-comment">//占位符从1开始，数组下表从0开始</span><br>                preparedStatement.setObject(i + <span class="hljs-number">1</span>, params[i]);<span class="hljs-comment">//这里可以用setObject通配所有参数类型</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//执行SQL，处理结果</span><br>        <span class="hljs-type">ResultSet</span> <span class="hljs-variable">resultSet</span> <span class="hljs-operator">=</span> preparedStatement.executeQuery();<br>        <span class="hljs-comment">//处理结果的元数据对象（包含列的名称和数量）</span><br>        <span class="hljs-type">ResultSetMetaData</span> <span class="hljs-variable">metaData</span> <span class="hljs-operator">=</span> resultSet.getMetaData();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">columnCount</span> <span class="hljs-operator">=</span> metaData.getColumnCount();<span class="hljs-comment">//列的数量</span><br>        List&lt;T&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;T&gt;();<span class="hljs-comment">//建立一个集合存放遍历并返回</span><br>        <span class="hljs-comment">//循环行</span><br>        <span class="hljs-keyword">while</span> (resultSet.next()) &#123;<br>            <span class="hljs-type">T</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> clazz.newInstance();<span class="hljs-comment">//每行都是一个T类型的对象t</span><br>            <span class="hljs-comment">//遍历列（注意，结果集的属性从1开始）</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= columnCount; i++) &#123;<br>                <span class="hljs-type">Object</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> resultSet.getObject(i);<span class="hljs-comment">//通过下标获取值</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">fieldName</span> <span class="hljs-operator">=</span> metaData.getColumnLabel(i);<span class="hljs-comment">//通过下标获取列的名称</span><br><br>                <span class="hljs-comment">//以下代码使用反射，获取到T类的私有属性</span><br>                <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> clazz.getDeclaredField(fieldName);<br>                field.setAccessible(<span class="hljs-literal">true</span>);<br>                field.set(t, value);<br>            &#125;<br>            list.add(t);<span class="hljs-comment">//每获取一行变量的对象，就放在集合中</span><br>        &#125;<br><br>        <span class="hljs-comment">//释放资源</span><br>        resultSet.close();<br>        preparedStatement.close();<br>        JDBCUtilV2.close();<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 通用查询单行单列，单行多列的结果集处理。</span><br><span class="hljs-comment">     * 通过调用executeQuery方法获得List，对List进行处理</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> clazz  传入实体类的class类（通过.class即可获取）</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> sql    传入查询的sql语句</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> params 传入对应sql语句的参数</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &lt;T&gt;    结果集合（List）中参数的类型</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 返回一个结果（单行单列、单行多列），这个结果不再是集合，而是一个实体类对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">executeQueryBean</span><span class="hljs-params">(Class&lt;T&gt; clazz, String sql, Object... params)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        List&lt;T&gt; list = executeQuery(clazz, sql, params);<br>        <span class="hljs-keyword">if</span> (list != <span class="hljs-literal">null</span> &amp;&amp; list.size() &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> list.get(<span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="DAO实现类"><a href="#DAO实现类" class="headerlink" title="DAO实现类"></a>DAO实现类</h3><p>在编写BaseDAO 查询的时候，我们注意到一个事情</p><p>当利用反射获取到该类的属性时，我们传入的参数时结果集中列的名字</p><p>但是Java中使用的是驼峰命名法，也就是说：<strong>类中属性名≠结果集列名</strong></p><p>我们可以通过给结果集列名起别名的方法解决这个问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xiaobai.dao.impl;<br><br><span class="hljs-keyword">import</span> com.xiaobai.dao.BaseDAO;<br><span class="hljs-keyword">import</span> com.xiaobai.dao.UserDao;<br><span class="hljs-keyword">import</span> com.xiaobai.pojo.User;<br><br><span class="hljs-keyword">import</span> java.sql.SQLException;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserDaoImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseDAO</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserDao</span> &#123;<br><br>    <span class="hljs-comment">//查询所有</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title function_">selectAll</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select u_id userId,u_name userName,u_salary userSalary,u_age userAge from user&quot;</span>;<span class="hljs-comment">//起别名解决反射问题</span><br>            <span class="hljs-keyword">return</span> executeQuery(User.class, sql, <span class="hljs-literal">null</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//根据id查询一条数据</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">selectByUserId</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select u_id userId,u_name userName,u_salary userSalary,u_age userAge from user where u_id = ?&quot;</span>;<br>            <span class="hljs-keyword">return</span> executeQueryBean(User.class, sql, id);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//插入一条数据</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(User user)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;INSERT INTO user(u_name, u_salary, u_age) VALUES (?, ?, ?)&quot;</span>;<br>            <span class="hljs-keyword">return</span> executeUpdate(sql, user.getUserName(), user.getUserSalary(), user.getUserAge());<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//修改员工的薪资</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">update</span><span class="hljs-params">(User user)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;UPDATE user SET u_salary = ? WHERE u_id = ?&quot;</span>;<br>            <span class="hljs-keyword">return</span> executeUpdate(sql, user.getUserSalary(), user.getUserId());<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//根据id删除一条数据</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;DELETE FROM user WHERE u_id = ?&quot;</span>;<br>            <span class="hljs-keyword">return</span> executeUpdate(sql, id);<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>数据库相关</category>
      
      <category>JDBC</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JDBC-Util</title>
    <link href="/2024/04/20/JDBC-Util/"/>
    <url>/2024/04/20/JDBC-Util/</url>
    
    <content type="html"><![CDATA[<h1 id="JDBC-Util"><a href="#JDBC-Util" class="headerlink" title="JDBC-Util"></a>JDBC-Util</h1><h3 id="JDBC连接池工具类的封装-V1-0"><a href="#JDBC连接池工具类的封装-V1-0" class="headerlink" title="JDBC连接池工具类的封装 V1.0"></a>JDBC连接池工具类的封装 V1.0</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xiaobai.util;<br><br><span class="hljs-keyword">import</span> com.alibaba.druid.pool.DruidDataSourceFactory;<br><br><span class="hljs-keyword">import</span> javax.sql.DataSource;<br><span class="hljs-keyword">import</span> java.io.InputStream;<br><span class="hljs-keyword">import</span> java.sql.Connection;<br><span class="hljs-keyword">import</span> java.sql.SQLException;<br><span class="hljs-keyword">import</span> java.util.Properties;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JDBCUtil</span> &#123;<br>    <span class="hljs-comment">//JDBC工具类 V1.0</span><br>    <span class="hljs-comment">//创建一个连接池引用，提供给当前项目的全局使用</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> DataSource dataSource;<br><br>    <span class="hljs-comment">//static代码块中的内容随项目启动而加载，当项目启动时，自动建立连接池</span><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>            <span class="hljs-type">InputStream</span> <span class="hljs-variable">resourceAsStream</span> <span class="hljs-operator">=</span> JDBCUtil.class.getClassLoader().getResourceAsStream(<span class="hljs-string">&quot;db.properties&quot;</span>);<br>            properties.load(resourceAsStream);<br>            dataSource = DruidDataSourceFactory.createDataSource(properties);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//对外开放一个获取连接的方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> dataSource.getConnection();<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//对外开放一个回收链接的方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">(Connection conn)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            conn.close();<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="TreadLocal"><a href="#TreadLocal" class="headerlink" title="TreadLocal"></a>TreadLocal</h3><p>java.lang.TreadLocal,为解决多线程程序的并发问题的工具类</p><p>通常用来在多线程中管理、共享数据库连接、Session等</p><p>在Java中，每一个线程对象都有TreadLocalMap&lt;Threadlocal, Object&gt; ，其key是ThreadLocal，Object为该线程的共享对象 </p><hr><h3 id="JDBC连接池工具类的封装-V2-0"><a href="#JDBC连接池工具类的封装-V2-0" class="headerlink" title="JDBC连接池工具类的封装 V2.0"></a>JDBC连接池工具类的封装 V2.0</h3><p>使用Treadlocal改写工具类的意义就是：</p><p><strong>同一个线程在多次操作数据库的过程中，用到的是同一个连接</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.alibaba.druid.pool.DruidDataSourceFactory;<br><br><span class="hljs-keyword">import</span> javax.sql.DataSource;<br><span class="hljs-keyword">import</span> java.io.InputStream;<br><span class="hljs-keyword">import</span> java.sql.Connection;<br><span class="hljs-keyword">import</span> java.sql.SQLException;<br><span class="hljs-keyword">import</span> java.util.Properties;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * JDBC工具类 V2.0</span><br><span class="hljs-comment"> * 创建一个连接池引用，提供给当前项目的全局使用</span><br><span class="hljs-comment"> * 同时，维护了一个线程绑定变量的ThreadLocal对象</span><br><span class="hljs-comment"> * 后续，加入了对事务回收线程的判定，方便事务的使用</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JDBCUtilV2</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> DataSource dataSource;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;Connection&gt; threadLocal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();<br>    ;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">      static代码块中的内容随项目启动而加载，当项目启动时，自动建立连接池</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>            <span class="hljs-type">InputStream</span> <span class="hljs-variable">resourceAsStream</span> <span class="hljs-operator">=</span> JDBCUtilV2.class.getClassLoader().getResourceAsStream(<span class="hljs-string">&quot;jdbc.properties&quot;</span>);<br>            properties.load(resourceAsStream);<br>            dataSource = DruidDataSourceFactory.createDataSource(properties);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 对外开放一个获取连接的方法</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 返回一个从连接池中获取到的连接</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//在threadlocal中获取Connection</span><br>            <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> threadLocal.get();<br>            <span class="hljs-keyword">if</span> (connection == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">//此时，threadLocal中没有连接，是第一次获取</span><br>                connection = dataSource.getConnection();<br>                threadLocal.set(connection);<br>            &#125;<br>            <span class="hljs-keyword">return</span> connection;<br>            <span class="hljs-comment">//如果是第一次获取，则从连接池中拿一个连接，先放到threadlocal中，再把该连接返回</span><br>            <span class="hljs-comment">//如果不是第一次获取，则从threadlocal中获取到这个连接，把该链接返回</span><br>        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 这是一个回收连接的方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//从theadlocal中获取到连接，判断是否有线程</span><br>            <span class="hljs-comment">//如果有，该连接回收到连接池，并将threadlocal中的连接移除</span><br>            <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> threadLocal.get();<br>            <span class="hljs-keyword">if</span> (connection != <span class="hljs-literal">null</span>) &#123;<br>                connection.close();<br>                threadLocal.remove();<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>数据库相关</category>
      
      <category>JDBC</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JDBC-连接池</title>
    <link href="/2024/04/20/JDBC-%E8%BF%9E%E6%8E%A5%E6%B1%A0/"/>
    <url>/2024/04/20/JDBC-%E8%BF%9E%E6%8E%A5%E6%B1%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="JDBC-连接池"><a href="#JDBC-连接池" class="headerlink" title="JDBC-连接池"></a>JDBC-连接池</h1><p>如果每次要操作数据库时都获取新的链接，使用完毕就释放掉资源，会频繁的创建和销毁，造成资源的浪费</p><ul><li>连接池就是数据库连接对象的缓冲区，通过配置，由连接池负责创建连接、管理连接、释放连接等操作</li><li>预先创建连接，放到连接池中，用户在请求时，从连接池中获取连接，使用完毕后，将连接放回连接池中</li><li>当池中无连接可用（未达到连接池上限），连接池会新建连接</li><li>当池中无连接可用（达到连接池上限），用户会请求等待，可以设置超时时间</li></ul><hr><h3 id="常见的连接池"><a href="#常见的连接池" class="headerlink" title="常见的连接池"></a>常见的连接池</h3><p>JDBC的数据库连接池使用javax.sql.DataSource 接口进行规范，所有第三方连接池都实现了此接口</p><p>所有连接池的获取和回收方法都相同，不同的只有扩展功能和性能</p><ul><li><p>Druid是阿里提供的数据库连接池，是集百家之长的连接池，性能、扩展性、易用性都更好，功能丰富</p></li><li><p>Hikari，是SpringBoot2.x之后内置的一款连接池，口号是快速、简单、可靠</p></li></ul><p><em>Druid扩展性要比Hikari更强，但Hikari的性能是Druid的三倍</em></p><hr><h3 id="配置Druid连接池"><a href="#配置Druid连接池" class="headerlink" title="配置Druid连接池"></a>配置Druid连接池</h3><ul><li>使用new DruidDataSource()新建连接池对象</li><li>使用setXxx方法配置连接池</li><li>使用getConnection()<strong>获取</strong>连接，进行CRUD</li><li>使用close()回收连接</li></ul><hr><h5 id="使用硬编码方式创建Druid连接池"><a href="#使用硬编码方式创建Druid连接池" class="headerlink" title="使用硬编码方式创建Druid连接池"></a>使用硬编码方式创建Druid连接池</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testHardCodeDruid</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>    <span class="hljs-comment">//创建Druid连接池对象</span><br>    <span class="hljs-type">DruidDataSource</span> <span class="hljs-variable">druidDataSource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DruidDataSource</span>();<br><br>    <span class="hljs-comment">//连接池的配置信息，设置JDBC连接四大件（必要设置）</span><br>    druidDataSource.setDriverClassName(<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);<br>    druidDataSource.setUrl(<span class="hljs-string">&quot;jdbc:mysql://192.168.2.2:3306/xiaobai&quot;</span>);<br>    druidDataSource.setUsername(<span class="hljs-string">&quot;root&quot;</span>);<br>    druidDataSource.setPassword(<span class="hljs-string">&quot;Zhuwenxue2002&quot;</span>);<br><br>    <span class="hljs-comment">//连接池的配置信息，配置连接池参数（非必要设置）</span><br>    druidDataSource.setInitialSize(<span class="hljs-number">5</span>);<span class="hljs-comment">//初始连接池的连接数量（最小数量）</span><br>    druidDataSource.setMaxActive(<span class="hljs-number">20</span>);<span class="hljs-comment">//连接池中连接的最大数量</span><br><br>    <span class="hljs-comment">//通过连接池获取连接对象</span><br>    <span class="hljs-type">DruidPooledConnection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> druidDataSource.getConnection();<br><br>    <span class="hljs-comment">//基于connection进行CRUD</span><br><br>    <span class="hljs-comment">//回收连接</span><br>    connection.close();<br>&#125;<br></code></pre></td></tr></table></figure><p><em>注：这里的close不再是释放资源，而是把这个数据库连接回收到连接池中</em></p><hr><h5 id="使用Properties配置创建Druid（软编码方式）"><a href="#使用Properties配置创建Druid（软编码方式）" class="headerlink" title="使用Properties配置创建Druid（软编码方式）"></a>使用Properties配置创建Druid（软编码方式）</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">driverClassName</span>=<span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br><span class="hljs-attr">url</span>=<span class="hljs-string">jdbc:mysql://192.168.2.2:3306/xiaobai</span><br><span class="hljs-attr">username</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">password</span>=<span class="hljs-string">Zhuwenxue2002</span><br><span class="hljs-attr">initialSize</span>=<span class="hljs-string">5</span><br><span class="hljs-attr">maxActive</span>=<span class="hljs-string">20</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSoftCodeDruid</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">//创建properties集合，用于存放外部配置信息</span><br>    <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>    <span class="hljs-type">InputStream</span> <span class="hljs-variable">resourceAsStream</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getClass().getClassLoader().getResourceAsStream(<span class="hljs-string">&quot;db.properties&quot;</span>);<br>    properties.load(resourceAsStream);<br><br>    <span class="hljs-comment">//基于Properties集合，构建DruidDateSource连接池</span><br>    <span class="hljs-type">DataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> DruidDataSourceFactory.createDataSource(properties);<br><br>    <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> dataSource.getConnection();<br><br>    connection.close();<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="配置Hikari连接池"><a href="#配置Hikari连接池" class="headerlink" title="配置Hikari连接池"></a>配置Hikari连接池</h3><p>总的来说，Hikari与Druid在使用上并没有什么本质的不同</p><p><em>需要注意的是：在setXXX配置文件时，有一些配置属性名时不同的，例如Url 与 JdbcUrl</em></p><h5 id="使用硬编码方式创建Hikari连接池"><a href="#使用硬编码方式创建Hikari连接池" class="headerlink" title="使用硬编码方式创建Hikari连接池"></a>使用硬编码方式创建Hikari连接池</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testHardCodeHikari</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>    <span class="hljs-type">HikariDataSource</span> <span class="hljs-variable">hikariDataSource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HikariDataSource</span>();<br>    <span class="hljs-comment">//连接池的配置信息，设置JDBC连接四大件（必要设置）</span><br>    hikariDataSource.setDriverClassName(<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);<br>    hikariDataSource.setJdbcUrl(<span class="hljs-string">&quot;jdbc:mysql://192.168.2.2:3306/xiaobai&quot;</span>);<br>    hikariDataSource.setUsername(<span class="hljs-string">&quot;root&quot;</span>);<br>    hikariDataSource.setPassword(<span class="hljs-string">&quot;Zhuwenxue2002&quot;</span>);<br><br>    <span class="hljs-comment">//连接池的配置信息，配置连接池参数（非必要设置）</span><br>    hikariDataSource.setMinimumIdle(<span class="hljs-number">10</span>);<span class="hljs-comment">//初始连接池的连接数量（最小数量）</span><br>    hikariDataSource.setMaximumPoolSize(<span class="hljs-number">10</span>);<span class="hljs-comment">//连接池中连接的最大数量</span><br><br>    <span class="hljs-comment">//通过连接池获取连接对象</span><br>    <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> hikariDataSource.getConnection();<br>    <span class="hljs-comment">//回收连接</span><br>    connection.close();<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="使用Properties配置创建Hikari（软编码方式）"><a href="#使用Properties配置创建Hikari（软编码方式）" class="headerlink" title="使用Properties配置创建Hikari（软编码方式）"></a>使用Properties配置创建Hikari（软编码方式）</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">driverClassName</span>=<span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br><span class="hljs-attr">jdbcUrl</span>=<span class="hljs-string">jdbc:mysql://192.168.2.2:3306/xiaobai</span><br><span class="hljs-attr">username</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">password</span>=<span class="hljs-string">Zhuwenxue2002</span><br><span class="hljs-attr">minimumIdle</span>=<span class="hljs-string">5</span><br><span class="hljs-attr">maximumPoolSize</span>=<span class="hljs-string">20</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSoftCodeHikari</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">//创建properties集合，用于存放外部配置信息</span><br>    <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>    <span class="hljs-type">InputStream</span> <span class="hljs-variable">resourceAsStream</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getClass().getClassLoader().getResourceAsStream(<span class="hljs-string">&quot;db.properties&quot;</span>);<br>    properties.load(resourceAsStream);<br><br>    <span class="hljs-comment">//创建HikariConfig对象</span><br>    <span class="hljs-type">HikariConfig</span> <span class="hljs-variable">hikariConfig</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HikariConfig</span>(properties);<br><br>    <span class="hljs-comment">//使用hikariConfig对象调用getDataSource()方法 或者 使用hikariConfig作为参数实例化hikariDataSource对象</span><br>    <span class="hljs-comment">//DataSource dataSource = hikariConfig.getDataSource();</span><br>    <span class="hljs-type">HikariDataSource</span> <span class="hljs-variable">hikariDataSource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HikariDataSource</span>(hikariConfig);<br>    <br>    <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> hikariDataSource.getConnection();<br>    connection.close();<br>&#125;<br></code></pre></td></tr></table></figure><p><em><strong>注：在读取properties集合的配置信息时，Hikari需要先实例化一个hikariConfig对象，这比Druid多了一个步骤</strong></em></p><hr>]]></content>
    
    
    <categories>
      
      <category>数据库相关</category>
      
      <category>JDBC</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JDBC-进阶</title>
    <link href="/2024/04/18/JDBC-%E8%BF%9B%E9%98%B6/"/>
    <url>/2024/04/18/JDBC-%E8%BF%9B%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="JDBC进阶"><a href="#JDBC进阶" class="headerlink" title="JDBC进阶"></a>JDBC进阶</h1><h3 id="实体类和ORM"><a href="#实体类和ORM" class="headerlink" title="实体类和ORM"></a>实体类和ORM</h3><h5 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h5><p>在使用JDBC操作数据库是，我们会发现数据都是零散的，明明在数据库中是一行完整的数据，到了Java中变成了一个一个变量，不利于维护和管理</p><p>所以我们把表的设计转换成一个类，每一行都是一个对象，每一列是对象的其中的一个方法</p><p>这个类就是实体类</p><hr><h3 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h3><p>ORM（Object Relational Mapping），对象到关系数据库的映射思想</p><p>目前的阶段我们称之为手动ORM，后续我们回学习一些ORM框架，比如MyBatis、JPA等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xiaobai.advanced;<br><br><span class="hljs-keyword">import</span> com.xiaobai.pojo.User;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">import</span> java.sql.*;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JDBCAdvanced</span> &#123;<br>    <span class="hljs-comment">//使用ORM思想封装单个对象</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testORM</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> DriverManager.getConnection(<span class="hljs-string">&quot;jdbc:mysql://192.168.2.2:3306/xiaobai&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;Zhuwenxue2002&quot;</span>);<br>        <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">preparedStatement</span> <span class="hljs-operator">=</span> connection.prepareStatement(<span class="hljs-string">&quot;select * from user where u_id=?&quot;</span>);<br>        preparedStatement.setInt(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<span class="hljs-comment">//给占位符赋值</span><br>        <span class="hljs-type">ResultSet</span> <span class="hljs-variable">resultSet</span> <span class="hljs-operator">=</span> preparedStatement.executeQuery();<br><br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (resultSet.next()) &#123;<br>            user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> resultSet.getInt(<span class="hljs-string">&quot;u_id&quot;</span>);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> resultSet.getString(<span class="hljs-string">&quot;u_name&quot;</span>);<br>            <span class="hljs-type">Double</span> <span class="hljs-variable">salary</span> <span class="hljs-operator">=</span> resultSet.getDouble(<span class="hljs-string">&quot;u_salary&quot;</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> resultSet.getInt(<span class="hljs-string">&quot;u_age&quot;</span>);<br><br>            user.setU_id(id);<br>            user.setU_name(name);<br>            user.setU_salary(salary);<br>            user.setU_age(age);<br><br>            resultSet.close();<br>            preparedStatement.close();<br>            connection.close();<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-comment">//使用ORM思想封装多个对象（集合）</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testORMList</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> DriverManager.getConnection(<span class="hljs-string">&quot;jdbc:mysql://192.168.2.2:3306/xiaobai&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;Zhuwenxue2002&quot;</span>);<br>        <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">preparedStatement</span> <span class="hljs-operator">=</span> connection.prepareStatement(<span class="hljs-string">&quot;select * from user&quot;</span>);<br>        <span class="hljs-type">ResultSet</span> <span class="hljs-variable">resultSet</span> <span class="hljs-operator">=</span> preparedStatement.executeQuery();<br><br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span>  <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        List&lt;User&gt; userList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        <span class="hljs-keyword">while</span> (resultSet.next()) &#123;<br>            user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> resultSet.getInt(<span class="hljs-string">&quot;u_id&quot;</span>);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> resultSet.getString(<span class="hljs-string">&quot;u_name&quot;</span>);<br>            <span class="hljs-type">Double</span> <span class="hljs-variable">salary</span> <span class="hljs-operator">=</span> resultSet.getDouble(<span class="hljs-string">&quot;u_salary&quot;</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> resultSet.getInt(<span class="hljs-string">&quot;u_age&quot;</span>);<br><br>            user.setU_id(id);<br>            user.setU_name(name);<br>            user.setU_salary(salary);<br>            user.setU_age(age);<br>            <span class="hljs-comment">//将每次循环封装的一行数据的对象加入到集合里</span><br>            userList.add(user);<br>        &#125;<br><br>        <span class="hljs-comment">//遍历集合</span><br>        <span class="hljs-keyword">for</span> (User user1 : userList) &#123;<br>            System.out.println(user1);<br>        &#125;<br><br>        resultSet.close();<br>        preparedStatement.close();<br>        connection.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="主键回显"><a href="#主键回显" class="headerlink" title="主键回显"></a>主键回显</h3><p>在预编译SQL语句时，告知客户端在插入一条数据时记得返回主键值</p><blockquote><p>PreparedStatement preparedStatement &#x3D; connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);</p></blockquote><p>使用预编译对象获取到主键</p><blockquote><p>ResultSet resultSet &#x3D; preparedStatement.getGeneratedKeys();</p></blockquote><p><em>注：此方法的返回值是个单行单列的result结果集，用索引的方式获取即可</em></p><p><em>结果集需要释放资源！！！</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xiaobai.advanced;<br><br><span class="hljs-keyword">import</span> com.xiaobai.pojo.User;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">import</span> java.sql.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JDBCReturnPK</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testReturnPK</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> DriverManager.getConnection(<span class="hljs-string">&quot;jdbc:mysql://192.168.2.2:3306/xiaobai&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;Zhuwenxue2002&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;INSERT INTO `user`(u_name,u_salary,u_age) VALUES(?,?,?)&quot;</span>;<br>        <span class="hljs-comment">//告知PreparedStatement  记得回填主键列</span><br>        <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">preparedStatement</span> <span class="hljs-operator">=</span> connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);<br><br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;xiaobai&quot;</span>, <span class="hljs-number">5000.00</span>, <span class="hljs-number">18</span>);<br><br>        preparedStatement.setString(<span class="hljs-number">1</span>, user.getU_name());<br>        preparedStatement.setDouble(<span class="hljs-number">2</span>, user.getU_salary());<br>        preparedStatement.setInt(<span class="hljs-number">3</span>, user.getU_age());<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> preparedStatement.executeUpdate();<br>        <span class="hljs-comment">//既然时结果集，那么就需要释放该资源，放在if中无法释放资源则在if外提前声明</span><br>        <span class="hljs-type">ResultSet</span> <span class="hljs-variable">resultSet</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;成功&quot;</span>);<br>            <span class="hljs-comment">//返回的主键值是一个单行单列的结果</span><br>            resultSet = preparedStatement.getGeneratedKeys();<br>            <span class="hljs-keyword">if</span> (resultSet.next()) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">anInt</span> <span class="hljs-operator">=</span> resultSet.getInt(<span class="hljs-number">1</span>);<br>                user.setU_id(anInt);<br>            &#125;<br>            System.out.println(user);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;失败&quot;</span>);<br>        &#125;<br>        <br>        <span class="hljs-comment">//判断结果集非空才释放资源，否则有可能报空指针异常</span><br>        <span class="hljs-keyword">if</span> (resultSet!=<span class="hljs-literal">null</span>)&#123;<br>            resultSet.close();<br>        &#125;<br>        preparedStatement.close();<br>        connection.close();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="批量操作"><a href="#批量操作" class="headerlink" title="批量操作"></a>批量操作</h3><blockquote><p> 在连接数据库时的链接后加入参数：?rewriteBatchedStatements&#x3D;true 即允许批量传数据给数据库</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> DriverManager.getConnection(<span class="hljs-string">&quot;jdbc:mysql://192.168.2.2:3306/xiaobai?rewriteBatchedStatements=true&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;Zhuwenxue2002&quot;</span>);<br></code></pre></td></tr></table></figure><p><em><strong>在使用批量操作时，预编译的SQL语句要以values语句操作，并且语句结束一定不能加；</strong></em></p><ul><li><p>调用addBatch()方法，将数据值批量添加到预编译语句中</p></li><li><p>调用executeBatch()方法，统一提交</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xiaobai.advanced;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">import</span> java.sql.Connection;<br><span class="hljs-keyword">import</span> java.sql.DriverManager;<br><span class="hljs-keyword">import</span> java.sql.PreparedStatement;<br><span class="hljs-keyword">import</span> java.sql.SQLException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JDBCMoreInsert</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testMoreInsert</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> DriverManager.getConnection(<span class="hljs-string">&quot;jdbc:mysql://192.168.2.2:3306/xiaobai?rewriteBatchedStatements=true&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;Zhuwenxue2002&quot;</span>);<br>        <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">preparedStatement</span> <span class="hljs-operator">=</span> connection.prepareStatement(<span class="hljs-string">&quot;INSERT INTO `user`(u_name,u_salary,u_age) VALUES(?,?,?)&quot;</span>);<br><br>        preparedStatement.setString(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;xiaoma&quot;</span>);<br>        preparedStatement.setDouble(<span class="hljs-number">2</span>,<span class="hljs-number">3124.23</span>);<br>        preparedStatement.setInt(<span class="hljs-number">3</span>,<span class="hljs-number">18</span>);<br>        preparedStatement.addBatch();<br>        preparedStatement.setString(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;xiaolong&quot;</span>);<br>        preparedStatement.setDouble(<span class="hljs-number">2</span>,<span class="hljs-number">4124.23</span>);<br>        preparedStatement.setInt(<span class="hljs-number">3</span>,<span class="hljs-number">28</span>);<br>        preparedStatement.addBatch();<br>        preparedStatement.setString(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;xiaozhu&quot;</span>);<br>        preparedStatement.setDouble(<span class="hljs-number">2</span>,<span class="hljs-number">5323.09</span>);<br>        preparedStatement.setInt(<span class="hljs-number">3</span>,<span class="hljs-number">16</span>);<br>        preparedStatement.executeBatch();<br><br>        preparedStatement.close();<br>        connection.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>数据库相关</category>
      
      <category>JDBC</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JDBC-常见问题</title>
    <link href="/2024/04/17/JDBC-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <url>/2024/04/17/JDBC-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="JDBC-常见问题"><a href="#JDBC-常见问题" class="headerlink" title="JDBC-常见问题"></a>JDBC-常见问题</h1><h3 id="资源的管理"><a href="#资源的管理" class="headerlink" title="资源的管理"></a>资源的管理</h3><p>在JDBC的相关资源使用完毕后，要及时释放资源，以防内存泄漏</p><hr><h3 id="SQL语句问题"><a href="#SQL语句问题" class="headerlink" title="SQL语句问题"></a>SQL语句问题</h3><p>Java.sql.SQLSyntaxErrorException：SQL语句异常</p><ul><li>SQL语句有误，请检查SQL语句！<strong>强烈建议在SQL工具中编写测试后再粘到Java程序中</strong></li><li>来连接数据库的URL中，数据库名称编写错误也会报此异常</li></ul><hr><h3 id="SQL语句未设置参数问题"><a href="#SQL语句未设置参数问题" class="headerlink" title="SQL语句未设置参数问题"></a>SQL语句未设置参数问题</h3><p>java.sql.SQLException：No value specified for parameter 1</p><p>在使用预编译SQL语句时，如果有?占位符，要为每一个占位符赋值，否则报该错误</p><hr><h3 id="用户名或密码错误问题"><a href="#用户名或密码错误问题" class="headerlink" title="用户名或密码错误问题"></a>用户名或密码错误问题</h3><p>java.sql.SQLException: Access denied for user ‘root‘@’ZOEY.lan’ (using password: YES)</p><hr><h3 id="通信异常"><a href="#通信异常" class="headerlink" title="通信异常"></a>通信异常</h3><p>com.mysql.cj.jdbc.exceptions.<strong>CommunicationsException:</strong> Communications link failure</p><p>如果连接时的IP地址和端口写错，则会报此异常</p><hr>]]></content>
    
    
    <categories>
      
      <category>数据库相关</category>
      
      <category>JDBC</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JDBC-CURD</title>
    <link href="/2024/04/17/JDBC-CURD/"/>
    <url>/2024/04/17/JDBC-CURD/</url>
    
    <content type="html"><![CDATA[<h1 id="JDBC-CURD"><a href="#JDBC-CURD" class="headerlink" title="JDBC-CURD"></a>JDBC-CURD</h1><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>在关系型数据库中，查询会返回三种结果</p><ul><li>单行单列</li><li>单行多列</li><li>多行多列</li></ul><hr><h5 id="查询单行单列"><a href="#查询单行单列" class="headerlink" title="查询单行单列"></a>查询单行单列</h5><p>确定表中有多少条数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testQuerySingleRowAndCol</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>    <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> DriverManager.getConnection(<span class="hljs-string">&quot;jdbc:mysql://192.168.2.2:3306/xiaobai&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;Zhuwenxue2002&quot;</span>);<br><br>    <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">preparedStatement</span> <span class="hljs-operator">=</span> connection.prepareStatement(<span class="hljs-string">&quot;SELECT COUNT(*) as count FROM `user`&quot;</span>);<span class="hljs-comment">//如果结果集的列名不是很明确，可以给列名定义别名</span><br>    <span class="hljs-type">ResultSet</span> <span class="hljs-variable">resultSet</span> <span class="hljs-operator">=</span> preparedStatement.executeQuery();<br><br>    <span class="hljs-comment">//遍历结果集</span><br><span class="hljs-comment">//        while (resultSet.next()) &#123;</span><br><span class="hljs-comment">//            System.out.println(resultSet.getInt(1));//使用下标获取，第一行第一个数据</span><br><span class="hljs-comment">//        &#125;</span><br><br>    <span class="hljs-comment">//如果确定只有一个结果，也要至少执行一次next的判断</span><br>    <span class="hljs-keyword">if</span> (resultSet.next()) &#123;<br>        System.out.println(resultSet.getInt(<span class="hljs-string">&quot;count&quot;</span>));<span class="hljs-comment">//使用列名的别名获取</span><br>    &#125;<br><br>    connection.close();<br>    preparedStatement.close();<br>    resultSet.close();<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="查询单行多列"><a href="#查询单行多列" class="headerlink" title="查询单行多列"></a>查询单行多列</h5><p>输入ID查询整条数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testQuerySingleRow</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>    <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> DriverManager.getConnection(<span class="hljs-string">&quot;jdbc:mysql://192.168.2.2:3306/xiaobai&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;Zhuwenxue2002&quot;</span>);<br><br>    <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">preparedStatement</span> <span class="hljs-operator">=</span> connection.prepareStatement(<span class="hljs-string">&quot;select * from user where u_id=?&quot;</span>);<span class="hljs-comment">//如果结果集的列名不是很明确，可以给列名定义别名</span><br>    preparedStatement.setInt(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<span class="hljs-comment">//给占位符赋值</span><br>    <span class="hljs-type">ResultSet</span> <span class="hljs-variable">resultSet</span> <span class="hljs-operator">=</span> preparedStatement.executeQuery();<br><br>    <span class="hljs-comment">//这里我们确定结果只有一行，所以仍然不用遍历（遍历的是行）</span><br>    <span class="hljs-keyword">if</span> (resultSet.next()) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> resultSet.getInt(<span class="hljs-string">&quot;u_id&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> resultSet.getString(<span class="hljs-string">&quot;u_name&quot;</span>);<br>        <span class="hljs-type">double</span> <span class="hljs-variable">salary</span> <span class="hljs-operator">=</span> resultSet.getDouble(<span class="hljs-string">&quot;u_salary&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> resultSet.getInt(<span class="hljs-string">&quot;u_age&quot;</span>);<br>        System.out.println(id + <span class="hljs-string">&quot;\t&quot;</span> + name + <span class="hljs-string">&quot;\t&quot;</span> + salary + <span class="hljs-string">&quot;\t&quot;</span> + age);<br>    &#125;<br><br>    connection.close();<br>    preparedStatement.close();<br>    resultSet.close();<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><h5 id="插入一条数据"><a href="#插入一条数据" class="headerlink" title="插入一条数据"></a>插入一条数据</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testInsert</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>    <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> DriverManager.getConnection(<span class="hljs-string">&quot;jdbc:mysql://192.168.2.2:3306/xiaobai&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;Zhuwenxue2002&quot;</span>);<br><br>    <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">preparedStatement</span> <span class="hljs-operator">=</span> connection.prepareStatement(<span class="hljs-string">&quot;INSERT INTO `user`(u_name,u_salary,u_age) VALUES(?,?,?)&quot;</span>);<br>    preparedStatement.setString(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;xiaoxue&quot;</span>);<br>    preparedStatement.setDouble(<span class="hljs-number">2</span>, <span class="hljs-number">4320.23</span>);<br>    preparedStatement.setInt(<span class="hljs-number">3</span>, <span class="hljs-number">24</span>);<br><br>    <span class="hljs-comment">//根据受影响行数做判断</span><br>    System.out.println(preparedStatement.executeUpdate());<br><br>    connection.close();<br>    preparedStatement.close();<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><h5 id="修改一条数据"><a href="#修改一条数据" class="headerlink" title="修改一条数据"></a>修改一条数据</h5><p>输入被修改的人的ID和要修改的工资数目</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testUpdate</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>    <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> DriverManager.getConnection(<span class="hljs-string">&quot;jdbc:mysql://192.168.2.2:3306/xiaobai&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;Zhuwenxue2002&quot;</span>);<br><br>    <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">preparedStatement</span> <span class="hljs-operator">=</span> connection.prepareStatement(<span class="hljs-string">&quot;UPDATE `user`SET u_salary = ? WHERE u_id = ?&quot;</span>);<br>    <span class="hljs-comment">//将id为5的人的工资改为5320.23</span><br>    preparedStatement.setDouble(<span class="hljs-number">1</span>, <span class="hljs-number">5320.23</span>);<br>    preparedStatement.setInt(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>);<br><br>    <span class="hljs-comment">//根据受影响行数做判断</span><br>    System.out.println(preparedStatement.executeUpdate());<br><br>    connection.close();<br>    preparedStatement.close();<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><h5 id="删除一条数据"><a href="#删除一条数据" class="headerlink" title="删除一条数据"></a>删除一条数据</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testDelete</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>    <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> DriverManager.getConnection(<span class="hljs-string">&quot;jdbc:mysql://192.168.2.2:3306/xiaobai&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;Zhuwenxue2002&quot;</span>);<br><br>    <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">preparedStatement</span> <span class="hljs-operator">=</span> connection.prepareStatement(<span class="hljs-string">&quot;DELETE FROM `user` WHERE u_id = ?&quot;</span>);<br>    <span class="hljs-comment">//删除ID为5的这条数据</span><br>    preparedStatement.setInt(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>);<br><br>    <span class="hljs-comment">//根据受影响行数做判断</span><br>    System.out.println(preparedStatement.executeUpdate());<br><br>    connection.close();<br>    preparedStatement.close();<br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>数据库相关</category>
      
      <category>JDBC</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JDBC</title>
    <link href="/2024/04/17/JDBC/"/>
    <url>/2024/04/17/JDBC/</url>
    
    <content type="html"><![CDATA[<h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><p>JDBC：Java Database Connectity，意为Java数据库连接</p><p>java提供了接口规范，由各个数据库厂商提供了接口的实现，厂商提供的实现类封装成jar文件</p><p>这充分的体现了面向接口编程的好处，程序员只关心标准和规范，而无需关注实现过程</p><hr><h3 id="JDBC的核心组成"><a href="#JDBC的核心组成" class="headerlink" title="JDBC的核心组成"></a>JDBC的核心组成</h3><p>接口储存在java.sql,javax.sql包下</p><p>厂商提供了这两个接口的实现类，并封装成jar包给程序员使用</p><hr><h3 id="JDBC搭建步骤"><a href="#JDBC搭建步骤" class="headerlink" title="JDBC搭建步骤"></a>JDBC搭建步骤</h3><p>JDBC下载链接：<a href="https://downloads.mysql.com/archives/c-j/">MySQL :: Download MySQL Connector&#x2F;J (Archived Versions)</a></p><p>选择对应MySQL版本后，选择Platform Independent（独立于平台）</p><h5 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xiaobai.base;<br><br><span class="hljs-keyword">import</span> java.sql.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JDBCQuick</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//1. 注册驱动（缺省）</span><br><span class="hljs-comment">//Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="hljs-comment">//DriverManager.registerDriver(new Driver());</span><br>        <br>        <span class="hljs-comment">//2. 获取连接对象</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jdbc:mysql://192.168.2.2:3306/xiaobai&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;root&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Zhuwenxue2002&quot;</span>;<br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> DriverManager.getConnection(url, user, password);<br>        <br>        <span class="hljs-comment">//3. 获取执行SQL语句的对象</span><br>        <span class="hljs-type">Statement</span> <span class="hljs-variable">statement</span> <span class="hljs-operator">=</span> connection.createStatement();<br>        <br>        <span class="hljs-comment">//4. 编写SQL语句并执行，接收返回的结果集</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from user&quot;</span>;<br>        <span class="hljs-type">ResultSet</span> <span class="hljs-variable">resultSet</span> <span class="hljs-operator">=</span> statement.executeQuery(sql);<br>        <br>        <span class="hljs-comment">//5. 处理结果，遍历结果集</span><br>        <span class="hljs-keyword">while</span> (resultSet.next()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> resultSet.getInt(<span class="hljs-string">&quot;u_id&quot;</span>);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> resultSet.getString(<span class="hljs-string">&quot;u_name&quot;</span>);<br>            <span class="hljs-type">double</span> <span class="hljs-variable">salary</span> <span class="hljs-operator">=</span> resultSet.getDouble(<span class="hljs-string">&quot;u_salary&quot;</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> resultSet.getInt(<span class="hljs-string">&quot;u_age&quot;</span>);<br>            System.out.println(id + <span class="hljs-string">&quot;\t&quot;</span> + name + <span class="hljs-string">&quot;\t&quot;</span> + salary + <span class="hljs-string">&quot;\t&quot;</span> + age);<br>        &#125;<br>        <br>        <span class="hljs-comment">//6. 释放资源（先开后关的原则）</span><br>        resultSet.close();<br>        statement.close();<br>        connection.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="JDBC核心API"><a href="#JDBC核心API" class="headerlink" title="JDBC核心API"></a>JDBC核心API</h3><h5 id="驱动的注册"><a href="#驱动的注册" class="headerlink" title="驱动的注册"></a>驱动的注册</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Class.forName(<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);<span class="hljs-comment">//通过加载类来注册驱动</span><br><br>DriverManager.registerDriver(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Driver</span>());<span class="hljs-comment">//手动注册驱动，这个类的包别导错了</span><br></code></pre></td></tr></table></figure><p><em><strong>在JDK6之后，java中会自动检索驱动是否存在，所以现在不用注册驱动了（白学）</strong></em>😓</p><hr><h5 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h5><p>创建与数据库的连接，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> DriverManager.getConnection(url, user, password);<br></code></pre></td></tr></table></figure><p>通过DriverManager调用静态方法getConnection即可获得数据库连接</p><p>当我们想在url后接参数时，使用以下格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jdbc:mysql://192.168.2.2:3306/xiaobai?key1=value1&amp;key2=value2&quot;</span>;<br></code></pre></td></tr></table></figure><p><em>jdbc:mysql:&#x2F;&#x2F;为固定格式，只要连接的是MySQL的数据库都要这么写</em></p><ul><li><p>connection还负责管理事务，提供了<strong>commit</strong>和<strong>rollback</strong>方法，用于提交事务和回滚事务</p></li><li><p>connection可以创建一个发送语句的对象statement，用于执行SQL语句并与数据库进行交互</p></li><li><p>在使用JDBC技术时，必须要先获取Connection对象，使用完毕后，要释放资源，避免资源占用浪费以及泄露</p></li></ul><hr><h5 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h5><p>由connection对象获得，可以向数据库发送SQL语句并获取执行结果</p><p><em>Statement英文释义：陈述</em></p><p>结果可以是一个或多个结果</p><ul><li>增删改：受影响行数的单个结果</li><li>查询：单行单列、多行多列、单行多列等结果</li></ul><p>动态查询</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in).nextLine();<br><span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from user where u_name=&#x27;&quot;</span> + s + <span class="hljs-string">&quot;&#x27;&quot;</span>;<br></code></pre></td></tr></table></figure><p>我们如果通过拼接字符串的方式来对SQL语句实现动态查询，就会产生<strong>SQL注入攻击问题</strong></p><p>比如，我们在以上代码输入 <strong>abc’ or ‘1’ &#x3D; ‘1</strong> 就会将SQL语句拼接为 <strong>select * from user where u_name&#x3D;’abc’ or ‘1’ &#x3D; ‘1’</strong></p><p>这样就会遍历整个数据表，<strong>这是十分危险的</strong></p><hr><h5 id="PreparedStatement"><a href="#PreparedStatement" class="headerlink" title="PreparedStatement"></a>PreparedStatement</h5><p>PreparedStatement是Statement的子接口，用于执行预编译的SQL查询</p><ul><li><p>防止SQL注入：PreparedStatement支持参数化查询，就是将参数作为参数传递到SQL语句中，采用?占位符的方式，将传入的参数用一对单引号包裹起来，<strong>无论传递什么都作为值</strong>，有效防止传入关键字导致SQL注入问题</p></li><li><p>性能提升：PreparedStatement时预编译SQL语句，可以代码复用，效率更高</p></li></ul><p><em><strong>后续的学习我们都是基于PreparedStatement进行实现</strong></em>🙃</p><ol><li><p>PreparedStatement是通过connection调用prepareStatement方法获得，<em>这个方法不支持无参构造</em></p></li><li><p>通过setString()方法传入参数，<em>注：这里的索引不再是从零开始，1即为第一个参数</em></p></li><li><p>调用executeQuery()，传入SQL语句到数据库，获得结果集</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in).nextLine();<br><span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">preparedStatement</span> <span class="hljs-operator">=</span> connection.prepareStatement(<span class="hljs-string">&quot;select * from user where u_name=?&quot;</span>);<br>preparedStatement.setString(<span class="hljs-number">1</span>, s);<br><span class="hljs-type">ResultSet</span> <span class="hljs-variable">resultSet</span> <span class="hljs-operator">=</span> preparedStatement.executeQuery();<br></code></pre></td></tr></table></figure><p><em>executeQuery中文释义：执行查询</em></p><hr><h5 id="ResultSet"><a href="#ResultSet" class="headerlink" title="ResultSet"></a>ResultSet</h5><p>ResultSet用于从数据库中执行查找语句接收结果集，它提供了用于遍历和访问查询结果的方式</p><ul><li>遍历结果：ResultSet可以使用next()方法将游标移动到结果集的下一行，逐行遍历数据库查询的结果，返回值为boolean类型true代表有下一行结果，false则代表没有</li><li>获取单列结果：可以通过getXxx的方法获取单列的数据，该方法为重载方法，支持索引和列名进行获取</li></ul><hr>]]></content>
    
    
    <categories>
      
      <category>数据库相关</category>
      
      <category>JDBC</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MVC架构模式</title>
    <link href="/2024/04/17/MVC%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/"/>
    <url>/2024/04/17/MVC%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="MVC架构模式"><a href="#MVC架构模式" class="headerlink" title="MVC架构模式"></a>MVC架构模式</h1><p>MVC 模式代表 Model-View-Controller（模型-视图-控制器） 模式。这种模式用于应用程序的分层开发</p><p><em><strong>使用 &#x2F;** 的方式可为类和方法编写文档，写文档对于一个程序员来说是很重要的事</strong></em></p><ul><li>高内聚，低耦合</li><li>开闭原则（对于新的需求，我们更多的时采用增加，而不是修改原有）</li></ul><hr><h3 id="M层"><a href="#M层" class="headerlink" title="M层"></a>M层</h3><h5 id="POJO-beans-entitiies-层"><a href="#POJO-beans-entitiies-层" class="headerlink" title="POJO&#x2F;beans&#x2F;entitiies 层"></a>POJO&#x2F;beans&#x2F;entitiies 层</h5><ul><li><p>包括一些实体类</p></li><li><p>vo（valueObject）对象</p></li></ul><hr><h5 id="service服务层"><a href="#service服务层" class="headerlink" title="service服务层"></a>service服务层</h5><ul><li>封装通用的业务逻辑和操作</li><li>由控制层调用</li><li>调用DAO层的方法对数据进行操作</li></ul><hr><h5 id="DAO层"><a href="#DAO层" class="headerlink" title="DAO层"></a>DAO层</h5><ul><li>封装一些对表格数据进行CRUD的方法</li></ul><hr><h3 id="C层"><a href="#C层" class="headerlink" title="C层"></a>C层</h3><h5 id="Controller控制层（例如Servlet）"><a href="#Controller控制层（例如Servlet）" class="headerlink" title="Controller控制层（例如Servlet）"></a>Controller控制层（例如Servlet）</h5><ul><li>接受用户请求，获得请求中的参数</li><li>调用服务层处理业务逻辑，接受结果</li><li>将结果响应给客户端（控制页面跳转）</li></ul><p><em>在前后端分离项目中，控制层不再负责页面跳转</em></p><hr><h3 id="V层"><a href="#V层" class="headerlink" title="V层"></a>V层</h3><p>html css js </p><p><em>在前后端分离的项目中，V层被分离出来变成单独的项目</em></p><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>java-web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>路径问题</title>
    <link href="/2024/04/16/%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/"/>
    <url>/2024/04/16/%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="路径问题"><a href="#路径问题" class="headerlink" title="路径问题"></a>路径问题</h1><h3 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径"></a>相对路径</h3><ul><li>不以&#x2F; 开头</li><li>.&#x2F; 表示当前资源的路经</li><li>..&#x2F; 表示当前资源的上一层路经</li></ul><p><em>缺点：目标资源路径受到当前资源路径的影响，不同的位置，相对路径的写法不同</em></p><hr><h5 id="目标资源的请求全过程"><a href="#目标资源的请求全过程" class="headerlink" title="目标资源的请求全过程"></a>目标资源的请求全过程</h5><p>当前资源请求路径：<a href="http://localhost:8080/demo/index.html">http://localhost:8080/demo/index.html</a></p><p>当前资源是：index.html</p><p>当前资源的所在路径：<a href="http://localhost:8080/demo">http://localhost:8080/demo</a></p><p>目标资源的相对路径：static&#x2F;img&#x2F;logo.png</p><p>当页面加载到有相对路径的目标资源时，会将当前资源所在路经与目标资源的相对路径拼接，然后发送请求找目标资源</p><p>目标资源的完整路径：<a href="http://localhost:8080/demo/static/img/logo.png">http://localhost:8080/demo/static/img/logo.png</a></p><hr><h5 id="请求转发的问题"><a href="#请求转发的问题" class="headerlink" title="请求转发的问题"></a>请求转发的问题</h5><p>在进行请求转发时，浏览器中URL不变</p><p>在获取相对路径的资源时，还是会把原URL的路经作i为当前资源路经与相对进行路经拼接</p><p><em><strong>因此，资源文件的加载，是针对客户端而言，针对URL而言的，单纯的看服务端的目录结构来写相对路径是不对的</strong></em>😮</p><hr><h3 id="绝对路经"><a href="#绝对路经" class="headerlink" title="绝对路经"></a>绝对路经</h3><ul><li><p>以&#x2F; 开头</p></li><li><p>不同的项目中，固定的路径出发点可能不一样，<em>可以先测试一下</em></p></li></ul><p><em>以Tomcat10为例，绝对路径的出发点是<a href="http://localhost:8080/%EF%BC%8C**%E4%B8%8D%E5%8C%85%E5%90%AB%E4%B8%8A%E4%B8%8B%E6%96%87%E8%B7%AF%E5%BE%84">http://localhost:8080/，**不包含上下文路径</a>**</em></p><p>如果要写绝对路径，应该写成：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/demo05/static/img/logo.png&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p><em>优点：目标资源路径的写法不会受到当前资源路径的影响，不同的位置，绝对路径的写法一致</em></p><p><em><strong>缺点：绝对路径要补充项目的上下文，而上下文是经常改变的</strong></em></p><hr><h5 id="base标签的妙用（不完美）"><a href="#base标签的妙用（不完美）" class="headerlink" title="base标签的妙用（不完美）"></a>base标签的妙用（不完美）</h5><p>通过 head&gt;base&gt;href属性，定义相对路径公共前缀，通过公共前缀把一个相对路径转换为绝对路径</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">base</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/demo/&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在定义此标签后，所有<strong>没有前缀</strong>的相对路径前都会加上此<strong>上下文路径</strong>(&#x2F;demo&#x2F;)</p><p>这样就能把一个相对路径转换为一个带有上下文的绝对路径访问</p><p><em>当上下文路径发生变化时，可以将base标签的href属性更改即可</em>😊</p><hr><h3 id="后端资源的路径问题"><a href="#后端资源的路径问题" class="headerlink" title="后端资源的路径问题"></a>后端资源的路径问题</h3><h5 id="相对路径-1"><a href="#相对路径-1" class="headerlink" title="相对路径"></a>相对路径</h5><p>在进行请求转发或响应重定向时，也会出现路径问题，并且与资源获取的路径问题大致相同</p><h5 id="响应重定向的路经"><a href="#响应重定向的路经" class="headerlink" title="响应重定向的路经"></a>响应重定向的路经</h5><p>在响应重定向使用绝对路经时，和前端一样，需要加拼接上下文路经（访问路经）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">resp.sendRedirect(<span class="hljs-string">&quot;/demo/ServletB&quot;</span>);<br></code></pre></td></tr></table></figure><p>但是，这样也会出先与前端相同的问题：当我们修改上下文路经时，后端代码需要同步修改</p><p>为了解决这个问题，<strong>我们应该动态获取上下文路径，再与重定向路经进行拼接</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">contextPath</span> <span class="hljs-operator">=</span> req.getContextPath();<br>resp.sendRedirect(contextPath + <span class="hljs-string">&quot;/ServletB&quot;</span>);<br></code></pre></td></tr></table></figure><hr><h5 id="请求转发的路经"><a href="#请求转发的路经" class="headerlink" title="请求转发的路经"></a>请求转发的路经</h5><p><em><strong>与响应重定向不同，请求转发的路经时不需要拼接上下文路经的！！！</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">req.getRequestDispatcher(<span class="hljs-string">&quot;/ServletB&quot;</span>).forward(req, resp);<br></code></pre></td></tr></table></figure><p>在请求转发时，资源路径的地址是：<a href="http://localhost:8080/demo/">http://localhost:8080/demo/</a></p><p>与前面的绝对路经都不相同，所以我们在请求转发到绝对路径时，是不需要拼接上下文路径的</p><hr><h1 id="路经问题的最终解决方法"><a href="#路经问题的最终解决方法" class="headerlink" title="路经问题的最终解决方法*"></a>路经问题的最终解决方法*</h1><p>为了解决前端后端的所有路径问题，我们最终采用的方案就是——不设置上下文路经！！！😝</p><p><em>是的你没听错，前面的全部白学！！！</em></p><p><img src="/upload/%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98-%E5%90%8E%E7%AB%AF%E8%B5%84%E6%BA%90%E7%9A%84%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98.png" alt="路径问题-后端资源的路径问题.png"></p><p>当上下文路经设置为&#x2F; 时，我们所有资源的访问路经都可以设置为绝对路径的方式，并且忽略上下文路经，这也是实战开发中所采取的方式</p><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>java-web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>WEB乱码问题汇总</title>
    <link href="/2024/04/16/WEB%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <url>/2024/04/16/WEB%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="WEB乱码问题汇总"><a href="#WEB乱码问题汇总" class="headerlink" title="WEB乱码问题汇总"></a>WEB乱码问题汇总</h1><p>产生的根本原因：</p><ul><li>数据的编码和解码使用的不是同一个字符集</li><li>使用了不支持某个语言文字的字符集</li></ul><p><em>如果是自己编写的项目，就把所有能看到的编码全都设置成UTF-8！</em>🙂</p><hr><h3 id="HTMl乱码问题"><a href="#HTMl乱码问题" class="headerlink" title="HTMl乱码问题"></a>HTMl乱码问题</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--告诉浏览器以UTF-8的解码方式打开--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h3 id="Tomcat控制台乱码"><a href="#Tomcat控制台乱码" class="headerlink" title="Tomcat控制台乱码"></a>Tomcat控制台乱码</h3><blockquote><p>具体参考笔记中Tomcat -&gt; Idea关联Tomcat -&gt; Tomcat运行时部署</p></blockquote><hr><h3 id="sout乱码问题，设置JVM加载-class文件时（编译）的解码模式"><a href="#sout乱码问题，设置JVM加载-class文件时（编译）的解码模式" class="headerlink" title="sout乱码问题，设置JVM加载.class文件时（编译）的解码模式"></a>sout乱码问题，设置JVM加载.class文件时（编译）的解码模式</h3><blockquote><p>在Tomcat的虚拟机选项中添加参数 -Dfile.encoding&#x3D;UTF-8</p></blockquote><hr><h3 id="get方法提交乱码问题（请求行URI编码问题）"><a href="#get方法提交乱码问题（请求行URI编码问题）" class="headerlink" title="get方法提交乱码问题（请求行URI编码问题）"></a>get方法提交乱码问题（请求行URI编码问题）</h3><p>个别的Tomcat版本中，servlet获取参数时会存在乱码现象</p><p>可以通过更改配置文件Tomcat解码，使得和编码一致</p><blockquote><p>Tomcat配置文件 -&gt; server.xml中</p></blockquote><p><em>默认的情况是没有的URIEncoding这条属性（默认的编码URI编码使用UTF-8）</em></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;8080&quot;</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">&quot;HTTP/1.1&quot;</span></span><br><span class="hljs-tag">           <span class="hljs-attr">connectionTimeout</span>=<span class="hljs-string">&quot;20000&quot;</span></span><br><span class="hljs-tag">           <span class="hljs-attr">redirectPort</span>=<span class="hljs-string">&quot;8443&quot;</span></span><br><span class="hljs-tag">           <span class="hljs-attr">maxParameterCount</span>=<span class="hljs-string">&quot;1000&quot;</span></span><br><span class="hljs-tag">           <span class="hljs-attr">URIEncoding</span>=<span class="hljs-string">&quot;GBK&quot;</span></span><br><span class="hljs-tag">           /&gt;</span><br></code></pre></td></tr></table></figure><hr><h3 id="post方法提交乱码问题（请求体中编码问题）"><a href="#post方法提交乱码问题（请求体中编码问题）" class="headerlink" title="post方法提交乱码问题（请求体中编码问题）"></a>post方法提交乱码问题（请求体中编码问题）</h3><p>个别的Tomcat版本中，servlet获取参数时会存在乱码现象</p><p>可以在Servlet-service中，设置请求体的解码字符集</p><blockquote><p>req.setCharacterEncoding(“GBK”);</p></blockquote><hr><h3 id="响应的乱码问题"><a href="#响应的乱码问题" class="headerlink" title="响应的乱码问题"></a>响应的乱码问题</h3><p>在Tomcat10中，响应体的默认编码字符集使用的UTF-8</p><p>windows的Edge客户端的解码方式是GBK模式</p><h5 id="更改后端编码（不推荐）"><a href="#更改后端编码（不推荐）" class="headerlink" title="更改后端编码（不推荐）"></a>更改后端编码（不推荐）</h5><p>可以设置后端编码模式为GBK模式，就可以解决此问题</p><blockquote><p>resp.setCharacterEncoding(“UTF-8”);</p></blockquote><p><em>但我们及其不推荐使用这种方式去解决乱码问题，因为你并不能确定前端的解码方式是什么，不能以“后端适应前端”</em> 🙃</p><h5 id="设置响应头的参数：ContentType（推荐）"><a href="#设置响应头的参数：ContentType（推荐）" class="headerlink" title="设置响应头的参数：ContentType（推荐）"></a>设置响应头的参数：ContentType（推荐）</h5><p>我们也可以通过响应头中ContentType的参数，来告诉前端以此方式进行解码</p><blockquote><p>resp.setContentType(“text&#x2F;html;charset-UTF-8”);</p></blockquote><h5 id="Tomcat版本问题"><a href="#Tomcat版本问题" class="headerlink" title="Tomcat版本问题"></a>Tomcat版本问题</h5><p>因为不同版本的Tomcat的后端编码模式也不尽相同，所以我们可以把编码和解码都设置一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">resp.setCharacterEncoding(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>resp.setContentType(<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span>);<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>java-web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Servlet-请求转发和响应重定向</title>
    <link href="/2024/04/15/Servlet-%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E5%92%8C%E5%93%8D%E5%BA%94%E9%87%8D%E5%AE%9A%E5%90%91/"/>
    <url>/2024/04/15/Servlet-%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E5%92%8C%E5%93%8D%E5%BA%94%E9%87%8D%E5%AE%9A%E5%90%91/</url>
    
    <content type="html"><![CDATA[<h1 id="Servlet-请求转发和响应重定向"><a href="#Servlet-请求转发和响应重定向" class="headerlink" title="Servlet-请求转发和响应重定向"></a>Servlet-请求转发和响应重定向</h1><p>请求转发和响应重定向是web应用中间接访问项目资源的两种手段，也是Servlet控制页面跳转的两种手段</p><p>请求转发通过HttpServletRequest实现，响应重定向通过HttpServletResponse实现</p><hr><h3 id="请求转发"><a href="#请求转发" class="headerlink" title="请求转发*"></a>请求转发*</h3><ul><li>请求转发通过<strong>HttpServletRequest对象获取请求转发器</strong>实现</li><li>请求转发是服务器内部的行为，对客户端是屏蔽的</li><li>客户端只发送了一次请求，<strong>客户端地址栏不变</strong></li><li>服务端只产生了一对请求和响应对象，这一对请求和响应对象会继续传递给下一资源</li><li>因为全程只有一个HttpServletRequest对象，所以请求参数可以传递，<strong>请求域中的数据也可以传递</strong></li><li>请求转发可以转发给其他Servlet动态资源，也可也转发给一些<strong>静态资源</strong>以实现页面跳转，<strong>但不可以是外部资源</strong></li><li>请求转发可以转发给<strong>WEB-INF下受保护的资源</strong> <em>在转发路径中写(WEB-INF&#x2F;路经)</em>，也是访问WEB-INF下资源的唯一方式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">getRequestDispatcher()(String var1)<span class="hljs-comment">//获取转发器（参数是转发路经）</span><br>getRequestDispatcher()(String var1).forward(req, resp)<span class="hljs-comment">//获取转发器后请求转发器做出转发动作</span><br></code></pre></td></tr></table></figure><p><em>Dispatcher中文释义：调度</em></p><hr><h3 id="响应重定向"><a href="#响应重定向" class="headerlink" title="响应重定向*"></a>响应重定向*</h3><ul><li><p>响应重定向<strong>通过HttpServletResponse对象的sendRedirect方法</strong>实现</p></li><li><p>响应重定向是服务端通过<strong>302响应码和路经</strong>，告诉客户端自己去找其他资源，<strong>是在服务端提示下的，客户端的行为</strong></p></li><li><p>客户端发送多次请求，<strong>客户端地址栏是要变化的</strong></p></li><li><p>服务端产生了多对请求和响应对象，且请求和响应对象不会传给下一个资源</p></li><li><p>因为全程产生多个HttpServletRequest对象，所以请求参数不可以传递，<strong>请求域中的数据也不可以传递</strong></p></li><li><p>重定向可以是其他Servlet动态资源，也可以是一些静态资源以实现页面跳转，<strong>也可以跳转到外部资源</strong></p></li><li><p>重定向<strong>不可以到WEB-INF下受保护的资源</strong></p></li><li><pre><code class="language-java">void sendRedirect(String var1) throws IOException//1. 设置响应状态码 2.设置响应头location的值（本地路经）</code></pre><p><em>Redirect中文释义：重定向</em></p></li></ul><hr><p><em><strong>重点：同样能够实现页面跳转，优先使用响应重定向</strong></em></p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>java-web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Servlet-HttpServletResponse</title>
    <link href="/2024/04/15/Servlet-HttpServletResponse/"/>
    <url>/2024/04/15/Servlet-HttpServletResponse/</url>
    
    <content type="html"><![CDATA[<h1 id="Servlet-HttpServletResponse"><a href="#Servlet-HttpServletResponse" class="headerlink" title="Servlet-HttpServletResponse"></a>Servlet-HttpServletResponse</h1><p>HttpServletResponse是一个接口，其父接口是ServletResponse</p><p>他是由Tomcat将请求报文转换封装而来的对象，在Tomcat调用service时传入</p><p>他代表着对客户端的响应，该对象会被转换成响应报文发送给客户端，通过该对象我们可以设置响应信息</p><hr><h3 id="设置响应行相关"><a href="#设置响应行相关" class="headerlink" title="设置响应行相关"></a>设置响应行相关</h3><table><thead><tr><th>API</th><th>说明</th></tr></thead><tbody><tr><td>void setStatus(int code)</td><td>设置响应状态</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(&quot;/HttpServletResponseTest&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpServletResponseTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        resp.setStatus(<span class="hljs-number">404</span>);<span class="hljs-comment">//故意响应404</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="设置响应头相关"><a href="#设置响应头相关" class="headerlink" title="设置响应头相关"></a>设置响应头相关</h3><table><thead><tr><th>API</th><th>说明</th></tr></thead><tbody><tr><td>void setHeader(String headerName,String headerValue)</td><td>设置&#x2F;修改响应头键值对</td></tr><tr><td>void setContentType(String contentType)</td><td>设置content-type响应头及相应字符集（设置MIME类型）</td></tr><tr><td>void setContentLength(int length)</td><td>设置content-length响应头（设置响应体的字节长度）</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(&quot;/HttpServletResponseTest&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpServletResponseTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-comment">//这两种方法是一样的，是因为Content参数过于重要，所以单独出现了API</span><br>        resp.setHeader(<span class="hljs-string">&quot;Content-Type&quot;</span>,<span class="hljs-string">&quot;text/html;charset=utf-8&quot;</span>);<br>        resp.setContentType(<span class="hljs-string">&quot;text/html;charset=utf-8&quot;</span>);<br>        resp.setHeader(<span class="hljs-string">&quot;Content-Length&quot;</span>,<span class="hljs-string">&quot;1234&quot;</span>);<br>        resp.setContentLength(<span class="hljs-number">1234</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="设置响应体相关"><a href="#设置响应体相关" class="headerlink" title="设置响应体相关"></a>设置响应体相关</h3><table><thead><tr><th>API</th><th>说明</th></tr></thead><tbody><tr><td>PrintWriter getWriter() throws IOException</td><td>获得向响应体放入信息的字符输出流</td></tr><tr><td>ServletOutputStream getOutputStream() throws IOException</td><td>获得向响应体放入信息的字节输出流</td></tr></tbody></table><h5 id="getWriter"><a href="#getWriter" class="headerlink" title="getWriter()"></a>getWriter()</h5><p><em>当包含中文的字符串转成字节数组时，应传参UTF-8作为字符集编码 getBytes(“UTF-8”)</em>😦</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(&quot;/HttpServletResponseTest&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpServletResponseTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">info</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&lt;h1&gt;hello&lt;/h1&gt;&quot;</span>;<br>        <span class="hljs-comment">//先转成字符串转字节数组，再获取长度，作为content-length的参数，这里的字符串如果有中文，要写成getBytes(&quot;UTF-8&quot;)</span><br>        resp.setContentLength(info.getBytes().length);<br>        <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">writer</span> <span class="hljs-operator">=</span> resp.getWriter();<br>        writer.write(info);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="getOutputStream"><a href="#getOutputStream" class="headerlink" title="getOutputStream()"></a>getOutputStream()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ServletOutputStream</span> <span class="hljs-variable">outputStream</span> <span class="hljs-operator">=</span> resp.getOutputStream();<span class="hljs-comment">//获取字节输出流，将文件通过此流写入响应体中</span><br></code></pre></td></tr></table></figure><hr><h3 id="其他API"><a href="#其他API" class="headerlink" title="其他API"></a>其他API</h3><table><thead><tr><th>API</th><th>说明</th></tr></thead><tbody><tr><td>void sendError(int code,String message) throws IOException</td><td>向客户端相应错误信息的方法，需要制定响应码和响应信息</td></tr><tr><td>void addCookie(Cookie cookie)</td><td>向响应体中增加cookie</td></tr><tr><td>void setCharacterEncoding(String encoding)</td><td>设置响应体字符集</td></tr></tbody></table><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>java-web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Servlet-HttpServletRequest</title>
    <link href="/2024/04/15/Servlet-HttpServletRequest/"/>
    <url>/2024/04/15/Servlet-HttpServletRequest/</url>
    
    <content type="html"><![CDATA[<h1 id="Servlet-HttpServletRequest"><a href="#Servlet-HttpServletRequest" class="headerlink" title="Servlet-HttpServletRequest"></a>Servlet-HttpServletRequest</h1><p>HttpServletResquest是一个接口，其父接口是ServletRequest</p><p>他是由Tomcat将请求报文转换封装而来的对象，在Tomcat调用service时传入</p><p>他代表着客户端发来的请求，所有请求中的信息都可以通过该对象获得</p><hr><h3 id="获取请求行信息相关（方式，请求的url，协议及版本）"><a href="#获取请求行信息相关（方式，请求的url，协议及版本）" class="headerlink" title="获取请求行信息相关（方式，请求的url，协议及版本）"></a>获取请求行信息相关（方式，请求的url，协议及版本）</h3><table><thead><tr><th>API</th><th>说明</th></tr></thead><tbody><tr><td>StringBuffer getRequestURL()</td><td>获取客户端请求的URL</td></tr><tr><td>String getRequestURL()</td><td>获取客户端请求项目中的具体资源</td></tr><tr><td>String getRequestURI()</td><td>获取客户端请求的URI</td></tr><tr><td>int getServerPort()</td><td>获取客户端发送请求时的端口</td></tr><tr><td>int getLocalPort()</td><td>获取本应用所在容器的端口</td></tr><tr><td>int getRemotePort()</td><td>获取客户端程序的端口</td></tr><tr><td>String getScheme()</td><td>获取请求协议</td></tr><tr><td>String getProtocol()</td><td>获取请求协议以及版本号</td></tr><tr><td>String getMethod()</td><td>获取请求方式</td></tr></tbody></table><h5 id="URI与URL"><a href="#URI与URL" class="headerlink" title="URI与URL"></a>URI与URL</h5><p><strong>URI</strong>：统一资源标识符</p><p>interface URI{}</p><p>资源定位的要求和规范</p><p><strong>URL</strong>：统一资源定位符</p><p>class URL implements URI{}</p><p>一个具体的资源路径</p><hr><h3 id="获取请求头信息相关"><a href="#获取请求头信息相关" class="headerlink" title="获取请求头信息相关"></a>获取请求头信息相关</h3><table><thead><tr><th>API</th><th>说明</th></tr></thead><tbody><tr><td>String getHeader(String headerName)</td><td>根据头名称获取请求头</td></tr><tr><td>Emumeration&lt;String&gt; getHeaderNames()</td><td>获取所有请求头名字</td></tr><tr><td>String ContentType()</td><td>获取content-type请求头</td></tr></tbody></table><hr><h3 id="获取请求参数相关"><a href="#获取请求参数相关" class="headerlink" title="获取请求参数相关"></a>获取请求参数相关</h3><table><thead><tr><th>API</th><th>说明</th></tr></thead><tbody><tr><td>String getParameter(String ParameterName)</td><td>根据请求参数名获取请求单个参数值</td></tr><tr><td>String[] getParameterValues(String paramaterName)</td><td>根据请求参数名获取请求多个参数值数组</td></tr><tr><td>Emumeration&lt;String&gt; getParameterNames()</td><td>获取所有请求参数名</td></tr><tr><td>Map&lt;String,String[]&gt; getParameterMap()</td><td>获取所有请求参数的键值对集合</td></tr><tr><td>BufferedReader getReader() throws IOException</td><td>获取读取请求体的字符输入流</td></tr><tr><td>ServletInputStrem getInputStream() throws IOException</td><td>获取读取请求体的字节输入流</td></tr><tr><td>int getContentLength()</td><td>获得请求体长度的字节数</td></tr></tbody></table><h5 id="表单例子"><a href="#表单例子" class="headerlink" title="表单例子"></a>表单例子</h5><p>使用API获取键值对参数时，无论这些参数在url后还是在请求体中</p><p><em>并不是说get就没有请求体，或者无法将参数放到请求体中，post也不是只能将参数放到请求体中，不能放到URI中</em>😶</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;HttpServletRequestTest&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;get&quot;</span>&gt;</span><br>    账号：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    密码：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    篮球<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hobby&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;篮球&quot;</span>&gt;</span><br>    足球<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hobby&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;足球&quot;</span>&gt;</span><br>    羽毛球<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hobby&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;羽毛球&quot;</span>&gt;</span><br>    乒乓球<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hobby&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;乒乓球&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;提交&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="获取参数值（包括多个参数）"><a href="#获取参数值（包括多个参数）" class="headerlink" title="获取参数值（包括多个参数）"></a>获取参数值（包括多个参数）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(&quot;/HttpServletRequestTest&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpServletRequestTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-comment">//根据key获取value</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> req.getParameter(<span class="hljs-string">&quot;username&quot;</span>);<br>        System.out.println(username);<br>        <span class="hljs-comment">//根据key获取多个value（比如多选框）</span><br>        String[] hobbies = req.getParameterValues(<span class="hljs-string">&quot;hobby&quot;</span>);<br>        System.out.println(Arrays.toString(hobbies));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="获取所有参数名和参数值（使用getParameterNames）"><a href="#获取所有参数名和参数值（使用getParameterNames）" class="headerlink" title="获取所有参数名和参数值（使用getParameterNames）"></a>获取所有参数名和参数值（使用getParameterNames）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(&quot;/HttpServletRequestTest&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpServletRequestTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        Enumeration&lt;String&gt; parameterNames = req.getParameterNames();<br>        <span class="hljs-keyword">while</span> (parameterNames.hasMoreElements()) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">parameterName</span> <span class="hljs-operator">=</span> parameterNames.nextElement();<br>            String[] parameter = req.getParameterValues(parameterName);<br>            <span class="hljs-keyword">if</span> (parameter.length &gt; <span class="hljs-number">1</span>) &#123;<br>                System.out.println(parameterName + <span class="hljs-string">&quot;:&quot;</span> + Arrays.toString(parameter));<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                System.out.println(parameterName + <span class="hljs-string">&quot;:&quot;</span> + parameter[<span class="hljs-number">0</span>]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="获取所有参数名和参数值（使用getParameterMap）"><a href="#获取所有参数名和参数值（使用getParameterMap）" class="headerlink" title="获取所有参数名和参数值（使用getParameterMap）"></a>获取所有参数名和参数值（使用getParameterMap）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(&quot;/HttpServletRequestTest&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpServletRequestTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        Map&lt;String, String[]&gt; parameterMap = req.getParameterMap();<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;String, String[]&gt; stringEntry : parameterMap.entrySet()) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> stringEntry.getKey();<br>            String[] value = stringEntry.getValue();<br>            <span class="hljs-keyword">if</span> (value.length &gt; <span class="hljs-number">1</span>) &#123;<br>                System.out.println(key + <span class="hljs-string">&quot;:&quot;</span> + Arrays.toString(value));<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                System.out.println(key + <span class="hljs-string">&quot;:&quot;</span> + value[<span class="hljs-number">0</span>]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="获取请求体中非键值对的内容"><a href="#获取请求体中非键值对的内容" class="headerlink" title="获取请求体中非键值对的内容"></a>获取请求体中非键值对的内容</h5><p>请求体中还会存放一些其他内容，比如json串和文件等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BufferedReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> req.getReader();<span class="hljs-comment">//从请求体获得一个字符输入流来读取json串</span><br><span class="hljs-type">ServletInputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> req.getInputStream();<span class="hljs-comment">//从请求体中获得一个字节输入流来读取文件</span><br></code></pre></td></tr></table></figure><p><em>请求体中存json串和文件一般用于文件上传，使用异步请求时可以测试这两个API</em>🙂</p><hr><h3 id="其他API"><a href="#其他API" class="headerlink" title="其他API"></a>其他API</h3><table><thead><tr><th>API</th><th>说明</th></tr></thead><tbody><tr><td>String getServletPath()</td><td>获取请求的Servlet的映射路径</td></tr><tr><td>ServletContext getServletContext()</td><td>获取ServletContext对象</td></tr><tr><td>Cookie[] getCookies()</td><td>获取请求中的所有cookie</td></tr><tr><td>HttpSession getSession()</td><td>获取Session对象</td></tr><tr><td>void setCharacterEncoding(String encoding)</td><td>设置请求体字符集</td></tr></tbody></table><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>java-web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Servlet-域对象</title>
    <link href="/2024/04/14/Servlet-%E5%9F%9F%E5%AF%B9%E8%B1%A1/"/>
    <url>/2024/04/14/Servlet-%E5%9F%9F%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="Servlet-域对象"><a href="#Servlet-域对象" class="headerlink" title="Servlet-域对象"></a>Servlet-域对象</h1><p>域对象时一些用于存储数据和传递数据的对象，传递数据不同的范围，我们称之为不同的域</p><p>不同的域对象代表不同的域，共享数据的范围也不同</p><p>webapp中的三大域对象，分别是应用域，会话域，请求域</p><ul><li><p>请求域（HttpServletRequest）传递数据的范围是一次请求之内及多次请求转发</p></li><li><p>会话域（HttpSession）传递数据的范围是一次会话之内，可以跨多个请求</p></li><li><p>应用域（ServletContext）传递数据的范围是本应用内，可以跨多个会话</p></li></ul><hr><h3 id="域对象的共有API"><a href="#域对象的共有API" class="headerlink" title="域对象的共有API"></a>域对象的共有API</h3><table><thead><tr><th>API</th><th>说明</th></tr></thead><tbody><tr><td>void setAttribut(String key,Object value)</td><td>向域中增加&#x2F;修改数据</td></tr><tr><td>Object getAttribute(String key)</td><td>获得域中数据</td></tr><tr><td>void removeAttribute(String key)</td><td>删除域中数据</td></tr></tbody></table><hr><h5 id="Context对象操作数据"><a href="#Context对象操作数据" class="headerlink" title="Context对象操作数据"></a>Context对象操作数据</h5><p>ServletContext代表应用，所以ServletContext域也叫做应用域，时webapp中最大的域，可以在本应用内实现数据的共享和传递</p><p><em><strong>因为Context对象的作用域是整个webapp，所以经常使用application作为Context的对象命名</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(&quot;/servlet1&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Servlet1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-type">ServletContext</span> <span class="hljs-variable">application</span> <span class="hljs-operator">=</span> getServletContext();<br>        application.setAttribute(<span class="hljs-string">&quot;ka&quot;</span>,<span class="hljs-string">&quot;va&quot;</span>);<br>        application.setAttribute(<span class="hljs-string">&quot;ka&quot;</span>,<span class="hljs-string">&quot;vaa&quot;</span>);<br>        System.out.println(application.getAttribute(<span class="hljs-string">&quot;ka&quot;</span>));<span class="hljs-comment">//vaa</span><br>        application.removeAttribute(<span class="hljs-string">&quot;ka&quot;</span>);<br>        System.out.println(application.getAttribute(<span class="hljs-string">&quot;ka&quot;</span>));<span class="hljs-comment">//null</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>因为Context是webapp中最大的域，所以在不同的servlet中都可以得到这个数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(&quot;/servlet2&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Servlet2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-type">ServletContext</span> <span class="hljs-variable">application</span> <span class="hljs-operator">=</span> getServletContext();<br>        System.out.println(application.getAttribute(<span class="hljs-string">&quot;ka&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p><strong>请求转发中，请求域可以传递数据</strong></p><p>请求域中一般存放本次请求业务有关的数据，如：查询的所有部门信息</p><p><strong>同一个绘画内，不用请求转发，会话域可以传递数据</strong></p><p>会话域内一般存放本次会话客户端有关的数据，如：当前客户端登陆的用户</p><p><strong>同一个APP内，不同的客户端，应用域可以传递数据</strong></p><p>应用域内一般存放程序应用有关的数据，如：Spring框架的IOC容器</p><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>java-web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Servlet-ServletContext</title>
    <link href="/2024/04/14/Servlet-ServletContext/"/>
    <url>/2024/04/14/Servlet-ServletContext/</url>
    
    <content type="html"><![CDATA[<h1 id="Servlet-ServletContext"><a href="#Servlet-ServletContext" class="headerlink" title="Servlet-ServletContext"></a>Servlet-ServletContext</h1><ul><li>ServletContext对象又称呼为上下文对象，或者叫做应用域对象</li><li>容器会为每一个app创建一个独立的唯一的ServletContext对象</li><li>ServletContext对象为所有的Servlet所共享</li><li>ServletContext可以为所有的Servlet提供初始配置参数</li></ul><p><em>ServletContext是单例模式</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericServlet</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Servlet</span>, ServletConfig, Serializable &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> ServletConfig config;<br><br>    <span class="hljs-keyword">public</span> ServletContext <span class="hljs-title function_">getServletContext</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.getServletConfig().getServletContext();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="配置初始参数"><a href="#配置初始参数" class="headerlink" title="配置初始参数"></a>配置初始参数</h3><p>与ServletConfig不同，ServletContext的标签不写在Servlet中，而是写在根标签下</p><p>这些<strong>初始参数</strong>由<strong>Tomcat</strong>读取并创建一个<strong>Context</strong>对象，这个对象作用于<strong>每一个Servlet</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;https://jakarta.ee/xml/ns/jakartaee&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_6_0.xsd&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;6.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>encoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>username<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>xiaobai<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>ServletConfig<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.xiaobai.servlet.ServletConfigTest<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>ServletConfig<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/ServletConfig<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h3 id="获取初始参数"><a href="#获取初始参数" class="headerlink" title="获取初始参数"></a>获取初始参数</h3><p>Context对象可由Config对象调用getServletContext()方法得到</p><p>也可由req对象调用getServletContext()方法得到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServletContextTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-type">ServletContext</span> <span class="hljs-variable">servletContext</span> <span class="hljs-operator">=</span> getServletContext();<br>        <span class="hljs-type">ServletContext</span> <span class="hljs-variable">servletContext1</span> <span class="hljs-operator">=</span> getServletConfig().getServletContext();<br>        <span class="hljs-type">ServletContext</span> <span class="hljs-variable">servletContext2</span> <span class="hljs-operator">=</span> req.getServletContext();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>虽然在这里我们创建了三个servletContext对象，但其实都指向了一个内存地址</em></p><hr><p>ServletContext的方法</p><ul><li>getInitParameter(“keyA”)：根据key获取value</li><li>getInitParameterNames()：返回Enumeration&lt;&gt;类型的对象，此对象中有所有的初始参数的key</li></ul><p>Enumeration&lt;&gt;的方法</p><ul><li>hasMoreElements()：判断有没有下一个参数，如果有返回true，没有则返回false、</li><li>nextElement()：取出当前元素，向下移动游标</li></ul><p><em>不难看出，Context的使用方法和Config一样。但不同的是，无论哪一个servlet来获取Context的初始参数都是一样的</em></p><hr><h3 id="获取磁盘路经"><a href="#获取磁盘路经" class="headerlink" title="获取磁盘路经*"></a>获取磁盘路经*</h3><p>操作初始参数只是Context的用法之一</p><p>ServletContext的方法</p><ul><li>getRealPath()：获取一个指向项目部署位置下的某个文件&#x2F;目录的磁盘真实路径</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServletContextTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-type">ServletContext</span> <span class="hljs-variable">servletContext</span> <span class="hljs-operator">=</span> getServletContext();<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> servletContext.getRealPath(<span class="hljs-string">&quot;upload&quot;</span>);<br>        System.out.println(path);<span class="hljs-comment">//C:\Users\ZOEY\IdeaProjects\web-all\out\artifacts\demo02_servlet_war_exploded\upload</span><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="获得上下文路径"><a href="#获得上下文路径" class="headerlink" title="获得上下文路径*"></a>获得上下文路径*</h3><p>后续学习在项目中使用相对和绝对路经寻找目标资源</p><p>在使用绝对路经寻找目标资源时，就需要动态获取上下文路径</p><p>ServletContext的方法：</p><ul><li>getContextPath()：获取当前项目上下文路径（访问路径）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServletContextTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-type">ServletContext</span> <span class="hljs-variable">servletContext</span> <span class="hljs-operator">=</span> getServletContext();<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">contextPath</span> <span class="hljs-operator">=</span> servletContext.getContextPath();<br>        System.out.println(contextPath);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>java-web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Servlet-ServletConfig</title>
    <link href="/2024/04/14/Servlet-ServletConfig/"/>
    <url>/2024/04/14/Servlet-ServletConfig/</url>
    
    <content type="html"><![CDATA[<h1 id="Servlet-ServletConfig"><a href="#Servlet-ServletConfig" class="headerlink" title="Servlet-ServletConfig"></a>Servlet-ServletConfig</h1><ul><li>为Servlet提供初始配置参数的一种对象，每个Servlet都有自己<strong>独立唯一</strong>的ServletConfig对象</li><li>容器会为每个Servlet实例化一个ServletConfig对象，并通过init方法传入给Servlet作为属性</li></ul><p>Tomcat在初始化Servlet时，将ServletConfig也转换成其对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericServlet</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Servlet</span>, ServletConfig, Serializable &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> ServletConfig config;<br>    <span class="hljs-comment">//此方法将Servlet配置文件赋值给了类型ServletConfig的对象，以便在Servlet类中获取配置文件里的内容</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(ServletConfig config)</span> <span class="hljs-keyword">throws</span> ServletException &#123;<br>        <span class="hljs-built_in">this</span>.config = config;<br>        <span class="hljs-built_in">this</span>.init();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="配置初始参数"><a href="#配置初始参数" class="headerlink" title="配置初始参数"></a>配置初始参数</h3><p>在web.xml文件中可使用init-param标签配置一些<strong>初始参数</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;https://jakarta.ee/xml/ns/jakartaee&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance  &quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_6_0.xsd&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;6.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>ServletConfig<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.xiaobai.servlet.ServletConfig<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>keyA<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>valueA<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>·2<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>keyB<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>valueB<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>ServletConfig<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/ServletConfig<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h3 id="配置初始参数-注解配置"><a href="#配置初始参数-注解配置" class="headerlink" title="配置初始参数-注解配置"></a>配置初始参数-注解配置</h3><p>同样的，我们也可以使用注解的方式来配置初始参数，但这里我们使用了一种类似与注解嵌套的方式来配置多个键值对</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> WebServlet &#123;<br>    WebInitParam[] initParams() <span class="hljs-keyword">default</span> &#123;&#125;;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> WebInitParam &#123;<br>    String <span class="hljs-title function_">name</span><span class="hljs-params">()</span>;<br><br>    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span>;<br><br>    String <span class="hljs-title function_">description</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(</span><br><span class="hljs-meta">        value = &quot;/ServletConfig&quot;,</span><br><span class="hljs-meta">        initParams = &#123;</span><br><span class="hljs-meta">                @WebInitParam(name=&quot;keyA&quot;,value = &quot;ValueA&quot;),</span><br><span class="hljs-meta">                @WebInitParam(name=&quot;keyB&quot;,value = &quot;ValueB&quot;)</span><br><span class="hljs-meta">        &#125;</span><br><span class="hljs-meta">)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServletConfigTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br><span class="hljs-comment">//…………</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="获取初始参数"><a href="#获取初始参数" class="headerlink" title="获取初始参数"></a>获取初始参数</h3><p>ServletConfig的方法</p><ul><li>getInitParameter(“keyA”)：根据key获取value</li><li>getInitParameterNames()：返回Enumeration&lt;&gt;类型的对象，此对象中有所有的初始参数的key</li></ul><p>Enumeration&lt;&gt;的方法</p><ul><li>hasMoreElements()：判断有没有下一个参数，如果有返回true，没有则返回false、</li><li>nextElement()：取出当前元素，向下移动游标</li></ul><p>所以，我们可以在Servlet中获取<strong>初始参数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServletConfigTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-type">ServletConfig</span> <span class="hljs-variable">servletconfig</span> <span class="hljs-operator">=</span> getServletConfig();<br>        <span class="hljs-comment">//根据参数名获取参数值（单个获取）</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">keyA</span> <span class="hljs-operator">=</span> servletconfig.getInitParameter(<span class="hljs-string">&quot;keyA&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;KeyA: &quot;</span> + keyA);<br><br>        <span class="hljs-comment">//获取所有初始参数</span><br>        <span class="hljs-comment">//hasMoreElements方法判断有没有下一个参数，如果有返回true，没有则返回false</span><br>        <span class="hljs-comment">//nextElement方法取出下一个元素，向下移动游标</span><br>        Enumeration&lt;String&gt; initParameterNames = servletconfig.getInitParameterNames();<br>        <span class="hljs-keyword">while</span> (initParameterNames.hasMoreElements()) &#123;<br>            System.out.println(initParameterNames.nextElement() + <span class="hljs-string">&quot; :&quot;</span> + servletconfig.getInitParameter(initParameterNames.nextElement()));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>java-web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Servlet-继承结构</title>
    <link href="/2024/04/14/Servlet-%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84/"/>
    <url>/2024/04/14/Servlet-%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="Servlet-继承结构"><a href="#Servlet-继承结构" class="headerlink" title="Servlet-继承结构"></a>Servlet-继承结构</h1><ul><li>Servlet接口</li><li>GenericServlet抽象类：实现了Servlet接口</li><li>HttpServlet抽象类：继承了GenericServlet抽象类</li></ul><hr><h3 id="Servlet接口"><a href="#Servlet接口" class="headerlink" title="Servlet接口"></a>Servlet接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> jakarta.servlet;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Servlet</span> &#123;<br>    <span class="hljs-comment">//实例化对象后对对象进行初始化</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(ServletConfig var1)</span> <span class="hljs-keyword">throws</span> ServletException;<br><span class="hljs-comment">//获取Servlet配置文件，返回一个ServletConfig对象</span><br>    ServletConfig <span class="hljs-title function_">getServletConfig</span><span class="hljs-params">()</span>;<br><span class="hljs-comment">//处理用户请求的方法</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(ServletRequest var1, ServletResponse var2)</span> <span class="hljs-keyword">throws</span> ServletException, IOException;<br><br>    String <span class="hljs-title function_">getServletInfo</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><h3 id="GenericServlet抽象类"><a href="#GenericServlet抽象类" class="headerlink" title="GenericServlet抽象类"></a>GenericServlet抽象类</h3><p>在GenericServlet抽象类中，着重实现的是除service方法外的其他方法的基础配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericServlet</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Servlet</span>, ServletConfig, Serializable &#123;<br>   <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> ServletConfig config;<br>    <br>    <span class="hljs-comment">//初始化方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(ServletConfig config)</span> <span class="hljs-keyword">throws</span> ServletException &#123;<br>   <span class="hljs-built_in">this</span>.config = config;<br>    <span class="hljs-built_in">this</span>.init();<br>&#125;<br>    <br>    <span class="hljs-comment">//初始化方法的重载</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ServletException &#123;<br>&#125;<br>    <br>    <span class="hljs-comment">//这里的service仍为抽象方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(ServletRequest var1, ServletResponse var2)</span> <span class="hljs-keyword">throws</span> ServletException, IOException;<br>    <br>    <span class="hljs-comment">//返回ServletConfig配置文件对象</span><br>    <span class="hljs-keyword">public</span> ServletConfig <span class="hljs-title function_">getServletConfig</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.config;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="HttpServlet抽象类"><a href="#HttpServlet抽象类" class="headerlink" title="HttpServlet抽象类"></a>HttpServlet抽象类</h3><p>在GenericServlet抽象类中，着重实现的是service方法</p><p><em>在这里，一部分程序员喜欢重写service方法，另一部分习惯于重写do…方法</em></p><p><em><strong>但这并不重要，因为在springMVC中，无需自己配置业务方法</strong></em>😓</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">GenericServlet</span> &#123;<br>    <span class="hljs-comment">//这个service方法将ServletRequest、ServletResponse两个对象转为其子类对象HttpServletRequest、HttpServletResponse（父转子）</span><br>    <span class="hljs-comment">//并调用其重载的service方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(ServletRequest req, ServletResponse res)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        HttpServletRequest request;<br>        HttpServletResponse response;<br>        <span class="hljs-keyword">try</span> &#123;<br>            request = (HttpServletRequest)req;<br>            response = (HttpServletResponse)res;<br>        &#125; <span class="hljs-keyword">catch</span> (ClassCastException var6) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletException</span>(lStrings.getString(<span class="hljs-string">&quot;http.non_http&quot;</span>));<br>        &#125;<br><br>        <span class="hljs-built_in">this</span>.service(request, response);<br>    &#125;<br>   <span class="hljs-comment">//重载的service方法，对请求的方式进行区分，在分别调用其处理业务的方法</span><br>     <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> req.getMethod();<br>        <span class="hljs-keyword">if</span> (method.equals(<span class="hljs-string">&quot;GET&quot;</span>)) &#123;<br>        <span class="hljs-built_in">this</span>.doGet(req, resp);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method.equals(<span class="hljs-string">&quot;HEAD&quot;</span>)) &#123;<br>            <span class="hljs-built_in">this</span>.doHead(req, resp);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method.equals(<span class="hljs-string">&quot;POST&quot;</span>)) &#123;<br>            <span class="hljs-built_in">this</span>.doPost(req, resp);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method.equals(<span class="hljs-string">&quot;PUT&quot;</span>)) &#123;<br>            <span class="hljs-built_in">this</span>.doPut(req, resp);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method.equals(<span class="hljs-string">&quot;DELETE&quot;</span>)) &#123;<br>            <span class="hljs-built_in">this</span>.doDelete(req, resp);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method.equals(<span class="hljs-string">&quot;OPTIONS&quot;</span>)) &#123;<br>            <span class="hljs-built_in">this</span>.doOptions(req, resp);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method.equals(<span class="hljs-string">&quot;TRACE&quot;</span>)) &#123;<br>            <span class="hljs-built_in">this</span>.doTrace(req, resp);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            resp.sendError(<span class="hljs-number">501</span>, errMsg);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//默认情况下，所有service调用的do…方法都是返回“此方法不被支持”</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> lStrings.getString(<span class="hljs-string">&quot;http.method_get_not_supported&quot;</span>);<br>        <span class="hljs-built_in">this</span>.sendMethodNotAllowed(req, resp, msg);<br>    &#125;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> lStrings.getString(<span class="hljs-string">&quot;http.method_post_not_supported&quot;</span>);<br>        <span class="hljs-built_in">this</span>.sendMethodNotAllowed(req, resp, msg);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>java-web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Servlet-生命周期</title>
    <link href="/2024/04/12/Servlet-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <url>/2024/04/12/Servlet-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="Servlet-生命周期"><a href="#Servlet-生命周期" class="headerlink" title="Servlet-生命周期"></a>Servlet-生命周期</h1><table><thead><tr><th>步骤</th><th>使用方法</th><th>执行时间</th></tr></thead><tbody><tr><td>实例化</td><td>构造器</td><td>第一次请求&#x2F;随服务器启动</td></tr><tr><td>初始化</td><td>init</td><td>构造完毕</td></tr><tr><td>接受请求，处理请求，服务</td><td>service</td><td>每次请求</td></tr><tr><td>销毁</td><td>destory</td><td>关闭服务</td></tr></tbody></table><blockquote><p> 在Servlet被访问时，经历了 实例化对象 -&gt; init初始化对象 -&gt; 执行service方法</p><p> 一直到服务器关闭，则会销毁此Servlet对象</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(&quot;/servletLifeCycle&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServletLifeCycle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ServletLifeCycle</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;构造器&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(ServletConfig config)</span> <span class="hljs-keyword">throws</span> ServletException &#123;<br>        System.out.println(<span class="hljs-string">&quot;初始化&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        System.out.println(<span class="hljs-string">&quot;service方法&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;销毁&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>由此次实验，我们可以知道以下结论</p><ul><li>Servlet在Tomcat中是单例的：<em><strong>既一个Servlet只会实例化一个对象</strong></em></li><li>Servlet不会只被一个客户端访问，每一个客户端都是一个线程，而Servlet的成员变量在多个线程栈之中时共享的，<em><strong>所以强烈建议不要在service方法中修改成员变量</strong></em>，避免线程安全问题</li></ul><h5 id="Servlet的对象"><a href="#Servlet的对象" class="headerlink" title="Servlet的对象"></a>Servlet的对象</h5><p>Servlet的对象是在其第一次被访问时实例化和初始化</p><p>我们可以通过调整web.xml的load-on-startup标签，让其与Tomcat启动时就实例化和初始化对象</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;https://jakarta.ee/xml/ns/jakartaee&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_6_0.xsd&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;6.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>servletLifeCycle<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.xiaobai.servlet.ServletLifeCycle<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br><span class="hljs-comment">&lt;!--        默认值是-1，含义是 tomcat启动时不会实例化该servlet</span><br><span class="hljs-comment">        其他正整数，含义是在tomcat在启动时，同时也是实例化该servlet的顺序</span><br><span class="hljs-comment">如果序号冲突，则tomcat会自动协调启动顺序--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>6<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>servletLifeCycle<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/servletLifeCycle<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span><br></code></pre></td></tr></table></figure><p><em>注：Tomcat的配置文件中web.xml里已经占用了很多启动的序号，这里推荐用户自定义的序号是从6开始</em></p><p>那么我们也可以调整注解的参数</p><blockquote><p>int loadOnStartup() default -1;</p><p>@WebServlet(value &#x3D; “&#x2F;servletLifeCycle”,loadOnStartup &#x3D; 6)</p></blockquote><hr><h3 id="default-servlet"><a href="#default-servlet" class="headerlink" title="default-servlet"></a>default-servlet</h3><p>在Tomcat的web.xml中，配置了这样的一个Sevlet映射</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>default<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.apache.catalina.servlets.DefaultServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>debug<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>0<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>listings<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>default<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><p>当客户端访问静态资源时，Tomcat仍然会将请求按照Servlet的寻找方式来寻找</p><p>当客户端没查到<strong>精确匹配</strong>的Servlet时，就会将请求交给DefaultServlet来处理</p><p>这个DefaultServlet配置了<strong>模糊匹配全部</strong>（除了.jsp文件外）</p><p>DefaultServlet会寻找其对应的具体文件，再使用IO流读取此文件，并将此文件放到response对象的响应体中</p><p>并根据文件的拓展名选择合适的MIME（媒体类型），使用response设置Content-Type响应头</p><p>再读取文件大小，使用response设置Content-Length响应头</p><p>最后将response对象转换成响应报文发送回客户端</p><h5 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h5><p>在SpringMVC中，会默认使default-servlet失效，如果不单独进行额外的配置，会导致无法访问其网站内的所有静态资源</p><p>我们可以通过在其中重新配置default-servlet映射来解决这个问题</p><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>java-web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Servlet-访问</title>
    <link href="/2024/04/11/Servlet-%E8%AE%BF%E9%97%AE/"/>
    <url>/2024/04/11/Servlet-%E8%AE%BF%E9%97%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="Servlet的访问"><a href="#Servlet的访问" class="headerlink" title="Servlet的访问"></a>Servlet的访问</h1><h3 id="XML配置文件"><a href="#XML配置文件" class="headerlink" title="XML配置文件"></a>XML配置文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>servlet1<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.xiaobai.servlet.Servlet1<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>servlet1<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/s1<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/s2<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>servlet1<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/a<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/b<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><p>一个servlet-name(别名)可以对应多个url-pattern(上下文路径,访问路经)</p><p>这代表着多个访问路径访问相同的servlet页面</p><p><em>同时,一个servlet可以对应多个servlet-mapping(但是这么写没必要)</em></p><h5 id="url-pattern"><a href="#url-pattern" class="headerlink" title="url-pattern"></a>url-pattern</h5><ul><li>精确匹配<ul><li>&#x2F;s1</li></ul></li><li><strong>模糊匹配</strong><ul><li>&#x2F;：匹配全部（不包括.jsp文件）</li><li>&#x2F;*：匹配全部</li><li>&#x2F;a&#x2F;*：匹前缀，后缀模糊</li><li>*.action：匹配后缀，前缀是模糊的</li></ul></li></ul><p>*<em>作为通配符，他在哪里，哪里就是模糊的</em></p><hr><h3 id="Servlet注解方式的配置"><a href="#Servlet注解方式的配置" class="headerlink" title="Servlet注解方式的配置"></a>Servlet注解方式的配置</h3><p>直接在Servlet中配置**@WebServlet(“&#x2F;s1”)**</p><p>同时缺省web.xml配置方式</p><p>即可配置成功</p><hr><h5 id="注解的源码"><a href="#注解的源码" class="headerlink" title="注解的源码"></a>注解的源码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">String <span class="hljs-title function_">name</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>String[] value() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br>String[] urlPatterns() <span class="hljs-keyword">default</span> &#123;&#125;;<br></code></pre></td></tr></table></figure><p>其中，name的值等同于web.xml中servlet-name标签内容，也就是<strong>别名</strong></p><p>而value和urlPatterns互为彼此的 别名，这样做的好处是，当给value赋值时，是不需要在注解里写value&#x3D;””这样的内容，可直接写”&#x2F;s1”这样引号加上下文路经（访问路径）的方式来给注解赋值</p><p>所以，以下的注解时等价的</p><blockquote><p>@WebServlet(“&#x2F;s1”)</p><p>@WebServlet(value&#x3D;”&#x2F;s1”)</p><p>@WebServlet(urlPatterns&#x3D;”&#x2F;s1”)</p></blockquote><p>他们的内容相当于web.xml中url-pattern标签内容，也就是<strong>路经</strong></p><p>因为上下文路经可以有多个的缘故，注解也可以写成：</p><blockquote><p>@WebServlet(urlPatterns &#x3D; {“&#x2F;s1”, “&#x2F;s2”, “&#x2F;s3”})</p></blockquote><p><em>但是没人这么写</em> 😓</p><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>java-web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Servlet-开发流程</title>
    <link href="/2024/04/11/Servlet-%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/"/>
    <url>/2024/04/11/Servlet-%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Servlet-开发流程"><a href="#Servlet-开发流程" class="headerlink" title="Servlet-开发流程"></a>Servlet-开发流程</h1><ul><li>创建一个JavaWeb项目，并将tomcat添加到当前项目的依赖</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-comment">&lt;!--这里使用get和post方法均可，但action的访问路经先不要加斜线--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;userServlet&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>    用户名：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;校验&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><ul><li><p>重写service方法，<em>注：其方法形参应该是（HttpServletRequest req, HttpServletResponse resp）</em></p></li><li><p>在service方法中，定义业务处理代码</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> jakarta.servlet.ServletException;<br><span class="hljs-keyword">import</span> jakarta.servlet.http.HttpServlet;<br><span class="hljs-keyword">import</span> jakarta.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> jakarta.servlet.http.HttpServletResponse;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.PrintWriter;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-comment">//从request对象中获取请求中的任何信息(username)</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> req.getParameter(<span class="hljs-string">&quot;username&quot;</span>);<br><br>        <span class="hljs-comment">//处理业务</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">info</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Yes&quot;</span>;<br>        <span class="hljs-keyword">if</span> (username.equals(<span class="hljs-string">&quot;xiaobai&quot;</span>))&#123;<br>            info = <span class="hljs-string">&quot;NO&quot;</span>;<br>        &#125;<br>        <span class="hljs-comment">//将要响应的数据放入response</span><br>        <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">writer</span> <span class="hljs-operator">=</span> resp.getWriter();<span class="hljs-comment">//该方法返回的是一个向响应体中打印字符的 打印流</span><br>        writer.write(info);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><ul><li>在Web.xml中，配置servlet 对应的请求映射路经</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;https://jakarta.ee/xml/ns/jakartaee&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_6_0.xsd&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;6.0&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!--    配置servlet类，并起一个别名</span><br><span class="hljs-comment">        servlet-class：告诉Tomcat对应的要实例化的Servlet类</span><br><span class="hljs-comment">        servlet-name：用于关联请求的应用瑞金</span><br><span class="hljs-comment">--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>userServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.xiaobai.servlet.UserServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>userServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/userServlet<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h3 id="Content-Type响应头"><a href="#Content-Type响应头" class="headerlink" title="Content-Type响应头"></a>Content-Type响应头</h3><p>MIME基类型响应头，又称为媒体类型、文件类型、响应的数据类型</p><p>MIME类型用于告诉客户端响应的数据是什么类型的数据，客户端以此类型决定用什么方式解析响应体</p><blockquote><p>在Tomcat 的配置文件 -&gt; web.xml中，几乎记录了所有的文件类型对应的MIME类型，例如：</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mime-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">extension</span>&gt;</span>html<span class="hljs-tag">&lt;/<span class="hljs-name">extension</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mime-type</span>&gt;</span>text/html<span class="hljs-tag">&lt;/<span class="hljs-name">mime-type</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mime-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>扩展名为html的文件在响应时，Tomcat会根据web.xml的配置查找到对应Content-Type的属性值并将其赋值</strong></p><hr><h5 id="动态页面的访问"><a href="#动态页面的访问" class="headerlink" title="动态页面的访问"></a>动态页面的访问</h5><p>当请求的是一个servlet页面时，响应头中没有Content-Type的键值对，默认的时html格式</p><p>我们需要调用resp对象的setContentType方法手动为其属性赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">resp.setContentType(<span class="hljs-string">&quot;text/html&quot;</span>);<br>resp.setHeader(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;text/html&quot;</span>);<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>java-web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Servlet</title>
    <link href="/2024/04/11/Servlet/"/>
    <url>/2024/04/11/Servlet/</url>
    
    <content type="html"><![CDATA[<h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><h3 id="静态资源与动态资源"><a href="#静态资源与动态资源" class="headerlink" title="静态资源与动态资源"></a>静态资源与动态资源</h3><ul><li>静态资源：无需在程序运行时通过代码运行生成的资源，在程序运行之前就写好的资源，例如：html css js img，音视频文件等</li><li>动态资源：需要在程序运行时通过代码生成的资源，在程序运行之前无法确定的数据，运行时动态生成，例如Servlet，Thymeleaf……</li></ul><p><em>动态资源指的不是视图上的动画效果或者是简单的人机交互效果</em></p><hr><h3 id="Servlet简介"><a href="#Servlet简介" class="headerlink" title="Servlet简介"></a>Servlet简介</h3><p>Servlet（server applet）是运行在服务器（tomcat）的java小程序，是sun公司提供一套定义动态资源规范</p><p> 从代码层面上来讲，Servlet就是一个接口</p><ul><li>不是所有的java类都能用于处理客户端请求，能处理客户端请求并做出响应的一套技术标准就是Servlet</li><li>Servlet是运行在服务端的，所以Servlet必须在WEB项目中开发且在Tomcat这样的服务容器中运行</li></ul><hr><h3 id="网页的请求响应流程"><a href="#网页的请求响应流程" class="headerlink" title="网页的请求响应流程"></a>网页的请求响应流程</h3><p>浏览器只会发请求报文和接收响应报文，不管服务器端是什么运行方式，或者是什么类型代码</p><ol><li>Tomcat接收到请求之后，会将请求报文的信息转换成一个HttpServletRequest对象，该对象中包含了请求中的所有信息（请求行、请求头、请求体）</li><li>Tomcat同时创建了HttpServletResponse对象，该对象用于承装要响应给客户端的信息，该对象会被转换成相应的报文（响应行、响应头、响应体）</li><li>Tomcat根据请求中的资源路径找到对应的servlet，将servlet实例化，调用service方法，同时将HttpServletRequest和HttpServletResponse对象传入</li></ol><hr><h5 id="service方法"><a href="#service方法" class="headerlink" title="service方法"></a>service方法</h5><ul><li>从request对象中获取请求中的所有信息（参数）</li><li>根据参数生成要响应给客户端的数据</li><li>将要响应的数据放到response对象中</li></ul>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>java-web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>HTTP</title>
    <link href="/2024/04/10/HTTP/"/>
    <url>/2024/04/10/HTTP/</url>
    
    <content type="html"><![CDATA[<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><p><code>HTTP</code>协议(超文本传输协议HyperText Transfer Protocol)，它是基于TCP协议的应用层传输协议，简单来说就是客户端和服务端进行数据传输的一种规则。</p><blockquote><p>ctrl + shift +delete 可清除浏览器缓存</p></blockquote><hr><h3 id="请求与响应"><a href="#请求与响应" class="headerlink" title="请求与响应"></a>请求与响应</h3><p>HTTP的交互方式：</p><ul><li>请求：永远都是客户向服务端发送</li><li>响应：永远都是服务端向客户端返回</li></ul><p>数据的格式：</p><ul><li><p>请求时发送的数据称之为请求报文</p></li><li><p>响应时返回的数据称之为响应报文</p></li></ul><hr><h3 id="http长连接和短链接的问题"><a href="#http长连接和短链接的问题" class="headerlink" title="http长连接和短链接的问题"></a>http长连接和短链接的问题</h3><ul><li><p>http是应用层协议</p></li><li><p>tcp是传输层协议：面向连接的特点</p></li><li><p>ip是网络层协议</p></li></ul><p>http在使用时，会经常的发送请求，而如果用tcp进行连接，就会进行多次的连接（三次握手，四次挥手）</p><p>为了解决这种问题，http1.1版本选择了tcp长连接（等待所有资源请求加载完再关闭连接）</p><hr><h3 id="请求和响应报文"><a href="#请求和响应报文" class="headerlink" title="请求和响应报文"></a>请求和响应报文</h3><p>报文有规定的格式</p><ul><li>行：请求行，响应行</li><li>头：请求头，响应头</li><li>报文主体：请求报文主体，响应报文主体</li></ul><h5 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h5><ul><li><p>请求行</p><ul><li>GET&#x2F;POST  </li><li>资源路径?参数</li><li>HTTP&#x2F;1.1</li></ul></li><li><p>请求头</p><ul><li>键值对</li></ul></li><li><p>请求体</p><ul><li>当请求方式为post方式时，请求体中就会存有参数的键值对</li></ul></li></ul><h5 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h5><ul><li><p>响应行</p><ul><li>HTTP&#x2F;1.1</li><li>响应状态码</li><li>响应状态描述（Tomcat10会被缺省）</li></ul></li><li><p>响应头</p><ul><li>键值对<ul><li>Content-Length：这个属性的值是响应体的长度</li><li>Content-Type：这个属性的值是响应体的具体类型</li></ul></li></ul></li><li><p>响应体</p></li><li><p><em>有了响应体的长度之后，我们就能对本地的响应体进行校验，是否完成数据的传输</em></p></li></ul><p><em>因为服务器返回的是0，1的编码，需要由服务器告诉客户端用什么类型来解析这个响应体</em></p><hr><h3 id="响应状态码"><a href="#响应状态码" class="headerlink" title="响应状态码"></a>响应状态码</h3><h5 id="常见的响应状态码"><a href="#常见的响应状态码" class="headerlink" title="常见的响应状态码"></a>常见的响应状态码</h5><ul><li>200：请求成功，浏览器会把响应体内容（通常是html）显示到浏览器中</li><li>302：重定向，当响应码为302时，表示服务器要求浏览器重新再发一个请求，服务器会发送一个响应头Location指定新请求的URL地址</li><li>304：使用了本地缓存</li><li>404：请求的资源没有找到，说明客户端错误的请求了不存在的资源</li><li>405：请求的方式不允许，例如网站本身的请求方法是get，但是用post请求</li><li>500：请求资源找到了，但服务器内部出现了错误，比如<strong>后台的代码有异常</strong></li></ul><hr><h5 id="更多的响应状态码"><a href="#更多的响应状态码" class="headerlink" title="更多的响应状态码"></a>更多的响应状态码</h5><p><a href="https://www.runoob.com/http/http-status-codes.html">HTTP 状态码 | 菜鸟教程 (runoob.com)</a></p><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>java-web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Tomcat</title>
    <link href="/2024/04/08/Tomcat/"/>
    <url>/2024/04/08/Tomcat/</url>
    
    <content type="html"><![CDATA[<h1 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h1><p>  常见的JavaWeb服务器：</p><ul><li>Tomcat（Apache）：当前应用最广的JavaWeb服务器</li><li>Jetty：更轻量级、更灵活的servlet容器</li><li>JBoss（Redhat红帽）：支持JavaEE，应用比较广 EJB容器 -&gt; SSH轻量级的框架代替</li><li>GlassFish（Orcale）：Oracle开发的JavaWeb服务器，应用不是很广</li><li>Resin（Caucho）：支持JavaEE，应用的越来越广</li><li>Weblogic（Orcale）：要钱的！支持JavaEE，适合大型项目</li><li>Websphere（IBM）：要钱的！支持JavaEE，适合大型项目</li></ul><hr><h3 id="Tomcat目录结构"><a href="#Tomcat目录结构" class="headerlink" title="Tomcat目录结构"></a>Tomcat目录结构</h3><ul><li><strong>bin</strong>: bin为binary的简写，主要放置系统的必备执行文件</li><li>work：work目录用来存放tomcat在运行时的编译后文件，<em>例如JSP编译后的文件</em></li><li><strong>conf</strong>：存放一些tomcat的配置文件</li><li><strong>lib</strong>：存放tomcat的主要jar包</li><li>logs：日志文件存放目录</li><li>temp：运行时产生的临时目录</li><li><strong>webapps</strong>：存放tomcat的具体项目</li></ul><hr><h3 id="Tomcat项目结构"><a href="#Tomcat项目结构" class="headerlink" title="Tomcat项目结构*"></a>Tomcat项目结构*</h3><p>Tomcat项目存放在<strong>webapps</strong>文件夹下，文件树结构一般如下</p><ul><li>app项目应用根目录<ul><li>一些.html文件（也可以新建目录page用来存放）</li><li>static：非必要目录，一般在此处放静态资源（css js img）<ul><li>css：存放css文件</li><li>js：存放js文件</li><li>img：存放图片</li></ul></li><li><strong>WEB-INF</strong>：此目录下的资源是受保护的资源，不可以通过浏览器直接访问<ul><li>classes：字节码根路径，是java文件生成的字节码文件</li><li>lib：项目中第三方jar包存放库，<em>一般不会存放到tomcat的lib下，要做到项目隔离</em></li><li>web.xml：每个项目都有自己的web.xml配置文件</li></ul></li></ul></li></ul><hr><h3 id="Tomcat部署项目"><a href="#Tomcat部署项目" class="headerlink" title="Tomcat部署项目"></a>Tomcat部署项目</h3><p>除了将项目直接放在webapps文件夹下，还可以将项目放到其他位置，由tomcat中的配置文件指向app的实际磁盘路径</p><p>在配置文件中新建xml配置文件</p><blockquote><p>conf -&gt; Catalina -&gt; localhost -&gt; app.xml</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Context</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/app&quot;</span> <span class="hljs-attr">docBase</span>=<span class="hljs-string">&quot;D:\mywebapps\app&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这样配置就可以将D盘根目录下mywebapps中的app项目挂载到tomcat运行</p><hr><h3 id="Tomcat的管理项目"><a href="#Tomcat的管理项目" class="headerlink" title="Tomcat的管理项目"></a>Tomcat的管理项目</h3><p>Tomcat中的manager和host-manager项目需要账户和密码来登录</p><p>可以通过<strong>tomcat-users.xml</strong>配置文件来配置用户名和密码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">role</span> <span class="hljs-attr">rolename</span>=<span class="hljs-string">&quot;admin-gui&quot;</span>/&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">role</span> <span class="hljs-attr">rolename</span>=<span class="hljs-string">&quot;admin-script&quot;</span>/&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">role</span> <span class="hljs-attr">rolename</span>=<span class="hljs-string">&quot;manager-gui&quot;</span>/&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">role</span> <span class="hljs-attr">rolename</span>=<span class="hljs-string">&quot;manager-script&quot;</span>/&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">role</span> <span class="hljs-attr">rolename</span>=<span class="hljs-string">&quot;manager-jmx&quot;</span>/&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">role</span> <span class="hljs-attr">rolename</span>=<span class="hljs-string">&quot;manager-status&quot;</span>/&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">user</span> <span class="hljs-attr">username</span>=<span class="hljs-string">&quot;XIAOBAI&quot;</span> <span class="hljs-attr">password</span>=<span class="hljs-string">&quot;XIAOBAI&quot;</span> <span class="hljs-attr">roles</span>=<span class="hljs-string">&quot;admin-gui,admin-script,manager-gui,manager-script,manager-jmx,manager-status&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><hr><h3 id="IDEA关联Tomcat"><a href="#IDEA关联Tomcat" class="headerlink" title="IDEA关联Tomcat"></a>IDEA关联Tomcat</h3><ul><li>建立Tomcat和idea的关联</li><li>使用idea创建一个Java web工程，在web工程中开发代码</li><li>使用idea将工程构建成一个可以发布的app</li><li>使用idea将构建好的app部署到tomcat中，启动运行</li></ul><blockquote><p>在idea设置中，构建、执行、部署 -&gt; 应用程序服务器中添加Tomcat</p><p>新建项目后，项目结构 -&gt; 模块 -&gt; 依赖中添加Tomcat</p><p>双击shift -&gt; 添加框架支持 -&gt; 添加JavaWeb应用程序</p></blockquote><p><em>注：如果不依赖添加Tomcat直接添加JavaWeb应用程序时，会直接添加到低版本的JavaWeb</em></p><p><em><strong>注：使用idea引入js和css文件时，可尝试直接将文件拖入</strong></em></p><hr><h5 id="工程文件"><a href="#工程文件" class="headerlink" title="工程文件"></a>工程文件</h5><p>工程文件可以理解为项目在idea里面的样子，其内容大致为</p><ul><li>resources文件夹：用来放一些配置文件要将其标记为Resources根目录**</li><li>src文件夹：通常用来存放java代码</li><li>web文件夹：此文件夹是web项目的文件夹<ul><li>static文件夹：存放css，js，img等静态文件</li><li>WEB-INF文件夹：存放web.xml，lib文件夹<ul><li>lib文件夹：<strong>web项目中的运行依赖要放在这，而不是在其他文件夹</strong></li></ul></li></ul></li></ul><p><em><strong>注：在web工程导入jar包时，需要在WEB-INF路径下的lib文件夹内导入，并将lib文件夹添加为库（模块）</strong></em></p><hr><h5 id="应用文件"><a href="#应用文件" class="headerlink" title="应用文件"></a>应用文件</h5><blockquote><p>工程文件在idea中 构建 -&gt; 构建工件 后产生的out -&gt; artifacts文件夹中</p></blockquote><p><em>artifaces中文释义：工件</em></p><p><strong>src与resources会被编译进classes文件夹中</strong></p><p>由idea编译生成的应用文件会有自己的命名规则，但这并不重要，因为：</p><p><em><strong>上下文路径（访问路径）与文件路经可以不相同！！！！！！！！！！</strong></em></p><hr><h5 id="Tomcat运行时部署"><a href="#Tomcat运行时部署" class="headerlink" title="Tomcat运行时部署"></a>Tomcat运行时部署</h5><blockquote><p>添加tomcat本地为运行时部署 -&gt; 在部署中将应用文件作为工件添加 -&gt; 配置上下文路经</p></blockquote><p>idea在运行Tomcat时调用的时Tomcat Catalina 日志，这个日志的默认字符集编码时UTF-8</p><p>通过修改配置文件，在idea的控制台中显示中文</p><blockquote><p>tomcat的配置文件夹 -&gt; logging.properties文件 -&gt;修改Catalina的字符集为GBK</p></blockquote><hr><h3 id="IDea实现Tomcat的原理"><a href="#IDea实现Tomcat的原理" class="headerlink" title="IDea实现Tomcat的原理"></a>IDea实现Tomcat的原理</h3><p>为了保证Tomcat的纯净，idea不会将文件放在Tomcat中运行，而会创建一个Tomcat的副本</p><p>但这个副本并不是Tomcat的完全复制，而是存放和部署项目相关的配置文件，让tomcat本体按照副本的配置文件运行</p><p>配置文件中，通过xml文件的配置信息来配置具体的项目地址</p><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>java-web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>XML</title>
    <link href="/2024/04/07/XML/"/>
    <url>/2024/04/07/XML/</url>
    
    <content type="html"><![CDATA[<h1 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h1><p>XML(Extensible Markup Language)<strong>可扩展</strong>标记语言</p><ul><li>XML允许自定义格式</li><li>XML在基本语法规范的前提下，第三方程序和框架会通过XML约束的方式强制规定配置文件中可以写什么和怎么写</li></ul><hr><h3 id="常见配置文件类型"><a href="#常见配置文件类型" class="headerlink" title="常见配置文件类型"></a>常见配置文件类型</h3><ul><li>properties文件，例如druid连接池就是使用properties文件作为配置文件</li><li>XML文件，例如Tomcat就是使用XML文件作为配置文件</li><li>YAML文件，例如Spring Boot就是用YAML作为配置文件</li><li>json文件，通常作为文件传输，也可以用来作前端或移动端的配置文件</li></ul><hr><h3 id="XML的书写规范和约束"><a href="#XML的书写规范和约束" class="headerlink" title="XML的书写规范和约束"></a>XML的书写规范和约束</h3><ul><li>根标签只能有一个</li><li>第一行永远都是&lt;?xml version&#x3D;”1.0” encoding&#x3D;”UTF-8”?&gt; 前面没有别的东西</li><li>xml有约束，约束用于限定XML内部能编写的内容<ul><li>dtd 简单 上手快 约束没有schema细致</li><li>schema 复杂 上手慢 约束要比dtd细致</li></ul></li></ul><hr><h3 id="使用DOM4J进行XML解析"><a href="#使用DOM4J进行XML解析" class="headerlink" title="使用DOM4J进行XML解析"></a>使用DOM4J进行XML解析</h3><p>DOM4J是java用来解析XML文件的工具jar包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> standalone=<span class="hljs-string">&quot;no&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">jdbc</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dev</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">driverClassName</span>&gt;</span>com.mysql.cj.jdbc.Driver<span class="hljs-tag">&lt;/<span class="hljs-name">driverClassName</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>jdbc:mysql://192.168.2.2:3306/xiaobai<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">username</span>&gt;</span>root<span class="hljs-tag">&lt;/<span class="hljs-name">username</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span>Zhuwenxue2002<span class="hljs-tag">&lt;/<span class="hljs-name">password</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dev</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">test</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">driverClassName</span>&gt;</span>com.mysql.cj.jdbc.Driver<span class="hljs-tag">&lt;/<span class="hljs-name">driverClassName</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>jdbc:mysql:///xiaobai<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">username</span>&gt;</span>root<span class="hljs-tag">&lt;/<span class="hljs-name">username</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span>123456<span class="hljs-tag">&lt;/<span class="hljs-name">password</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">test</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">jdbc</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xiaobai.xml;<br><br><span class="hljs-keyword">import</span> org.dom4j.Document;<br><span class="hljs-keyword">import</span> org.dom4j.Element;<br><span class="hljs-keyword">import</span> org.dom4j.io.SAXReader;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">import</span> java.io.InputStream;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dom4jTest</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testDom4j</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">SAXReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SAXReader</span>();<br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">resourceAsStream</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getClass().getClassLoader().getResourceAsStream(<span class="hljs-string">&quot;jdbc.xml&quot;</span>);<br>        <span class="hljs-type">Document</span> <span class="hljs-variable">read</span> <span class="hljs-operator">=</span> reader.read(resourceAsStream);<br>        <span class="hljs-comment">//此read对象就是一颗Dom树，其访问节点，属性，文本的方法与DOM语法相同</span><br><br>        <span class="hljs-comment">//以下代码是遍历该Dom树</span><br>        <span class="hljs-type">Element</span> <span class="hljs-variable">rootElement</span> <span class="hljs-operator">=</span> read.getRootElement();<span class="hljs-comment">//获取根节点</span><br>        System.out.println(rootElement.getName());<br>        List&lt;Element&gt; elements = rootElement.elements();<span class="hljs-comment">//获取根节点下所有子节点</span><br>        <span class="hljs-keyword">for</span> (Element element : elements) &#123;<br>            System.out.println(<span class="hljs-string">&quot;\t&quot;</span> + element.getName());<span class="hljs-comment">//遍历子节点</span><br>            List&lt;Element&gt; elements1 = element.elements();<br>            <span class="hljs-keyword">for</span> (Element element1 : elements1) &#123;<br>                System.out.printf(<span class="hljs-string">&quot;\t\t&quot;</span> + element1.getName() + <span class="hljs-string">&quot;:&quot;</span> + element1.getText());<span class="hljs-comment">//遍历子节点的子节点</span><br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;\n&quot;</span>);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/upload/XML.PNG" alt="XML.PNG"></p><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>java-web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JS-正则表达式</title>
    <link href="/2024/04/02/JS-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2024/04/02/JS-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p>正则表达式是描述字符模式的对象。正则表达式用于对字符串模式匹配及检索替换，是对字符串执行模式匹配的强大工具</p><hr><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>正则表达式的对象去调用test方法，将字符串作为参数，返回一个布尔类型</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-comment">//定义一个正则表达式</span></span><br><span class="language-javascript">      <span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/o/</span>;</span><br><span class="language-javascript">      <span class="hljs-comment">//自定义一个字符串</span></span><br><span class="language-javascript">      <span class="hljs-keyword">var</span> str = <span class="hljs-string">&quot;hello world&quot;</span>;</span><br><span class="language-javascript">      <span class="hljs-comment">//校验是否符合正则规则(字符串中是否包含字母o)</span></span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg.<span class="hljs-title function_">test</span>(str));</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure><hr><h3 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h3><p>使用字符串去调用match方法，将正则作为参数，返回的是一个result对象</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-comment">//定义一个正则表达式</span></span><br><span class="language-javascript">      <span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/o/g</span>;</span><br><span class="language-javascript">      <span class="hljs-comment">//自定义一个字符串</span></span><br><span class="language-javascript">      <span class="hljs-keyword">var</span> str = <span class="hljs-string">&quot;hello world&quot;</span>;</span><br><span class="language-javascript">      </span><br><span class="language-javascript">      <span class="hljs-keyword">var</span> result = str.<span class="hljs-title function_">match</span>(reg);</span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><em>注：正则表达式默认只匹配第一个值，如果需要全部值，则需要在正则后加参数 g</em></p><hr><h3 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h3><p>使用字符串去调用replace方法，将正则和新字符作为参数，返回的是一个字符串对象</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-comment">//定义一个正则表达式</span></span><br><span class="language-javascript">      <span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/o/gi</span>;</span><br><span class="language-javascript">      <span class="hljs-comment">//自定义一个字符串</span></span><br><span class="language-javascript">      <span class="hljs-keyword">var</span> str = <span class="hljs-string">&quot;hello world&quot;</span>;</span><br><span class="language-javascript">      <span class="hljs-comment">//将所有符合正则的字符替换成@</span></span><br><span class="language-javascript">      <span class="hljs-keyword">var</span> newStr = str.<span class="hljs-title function_">replace</span>(reg, <span class="hljs-string">&quot;@&quot;</span>);</span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newStr);</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><em>注：正则默认替换是区分大小写，加入参数i则忽略大小写</em></p><hr><h3 id="正则表达式验证"><a href="#正则表达式验证" class="headerlink" title="正则表达式验证"></a>正则表达式验证</h3><ul><li>&#x2F;java$&#x2F;：是否以java作为结尾</li><li>&#x2F;^java&#x2F;：是否以java作为开头</li><li>&#x2F;^java$&#x2F;：是否以java作为开头和结尾（常常用来控制长度）</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-comment">//定义一个正则表达式</span></span><br><span class="language-javascript">      <span class="hljs-keyword">var</span> reg1 = <span class="hljs-regexp">/java$/</span>;<span class="hljs-comment">//是否以java作为结尾</span></span><br><span class="language-javascript">      <span class="hljs-keyword">var</span> reg2 = <span class="hljs-regexp">/^java/</span>;<span class="hljs-comment">//是否以java作为开头</span></span><br><span class="language-javascript">      <span class="hljs-keyword">var</span> reg2 = <span class="hljs-regexp">/^java$/</span>;<span class="hljs-comment">//是否以java作为开头和结尾</span></span><br><span class="language-javascript">      <span class="hljs-comment">//自定义两个字符串</span></span><br><span class="language-javascript">      <span class="hljs-keyword">var</span> str1 = <span class="hljs-string">&quot;i love java&quot;</span>;</span><br><span class="language-javascript">      <span class="hljs-keyword">var</span> str2 = <span class="hljs-string">&quot;java love me&quot;</span>;</span><br><span class="language-javascript">      <span class="hljs-comment">//验证</span></span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg1.<span class="hljs-title function_">test</span>(str1));<span class="hljs-comment">//true</span></span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg1.<span class="hljs-title function_">test</span>(str2));<span class="hljs-comment">//false</span></span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg2.<span class="hljs-title function_">test</span>(str1));<span class="hljs-comment">//false</span></span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg2.<span class="hljs-title function_">test</span>(str2));<span class="hljs-comment">//true</span></span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h5 id="匹配字符"><a href="#匹配字符" class="headerlink" title="匹配字符"></a>匹配字符</h5><ol><li>用户名以字母开头</li><li>组成必须是字母数字下划线</li><li>长度在6-10位</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//定义一个正则表达式</span><br><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/^[a-zA-Z]$/</span>;<span class="hljs-comment">//字符串只有1位，且必须是字母</span><br><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/^[a-zA-Z][a-zA-Z0-9_]$/</span>;<span class="hljs-comment">//字符串只能有2位，第一位是字母，第2位是字母数组下划线</span><br><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/^[a-zA-Z][a-zA-Z0-9_]&#123;6&#125;$/</span>;<span class="hljs-comment">//字符串只能有7位，第一位是字母，必须有6位字符满足字母数组下划线</span><br><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/^[a-zA-Z][a-zA-Z0-9_]&#123;5,9&#125;$/</span>;<span class="hljs-comment">//字符串可以有6-10位，第一位是字母，可以有5-10字符满足字母数组下划线</span><br><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/^[a-zA-Z][a-zA-Z0-9_]&#123;1,&#125;$/</span>;<span class="hljs-comment">//字符串不限制长度，第一位是字母，至少有1位字符满足字母数组下划线（可以有不限制多个）</span><br><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/^[a-zA-Z][a-zA-Z0-9_]+$/</span>;<span class="hljs-comment">//字符串不限制长度，第一位是字母，至少有1位字符满足字母数组下划线（可以有不限制多个）</span><br><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/^[a-zA-Z][a-zA-Z0-9_]*$/</span>;<span class="hljs-comment">//字符串不限制长度，第一位是字母，至少有0位字符满足字母数组下划线（可以有不限制多个）</span><br><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/^[a-zA-Z][a-zA-Z0-9_]?$/</span>;<span class="hljs-comment">//字符串最多有两位，第一位是字母，有0位或1位字符满足字母数组下划线（限制一个）</span><br></code></pre></td></tr></table></figure><hr><h5 id="正则表达式的元字符"><a href="#正则表达式的元字符" class="headerlink" title="正则表达式的元字符"></a>正则表达式的元字符</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/^[a-zA-Z]\w$/</span>;<span class="hljs-comment">//\w查找字母、数字及下划线</span><br><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/^[a-zA-Z]\w&#123;5,9&#125;$/</span>;<span class="hljs-comment">//字符串可以有6-10位，第一位是字母，可以有5-10字符满足字母数组下划线</span><br><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/^[a-zA-Z]\W$/</span>;<span class="hljs-comment">//\W查找非字母、数字及下划线</span><br><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/^[a-zA-Z]\d$/</span>;<span class="hljs-comment">//\d查找数字</span><br><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/^[a-zA-Z]\D$/</span>;<span class="hljs-comment">//\D查找非数字</span><br></code></pre></td></tr></table></figure><p><a href="https://www.runoob.com/regexp/regexp-metachar.html">正则表达式 – 元字符 | 菜鸟教程 (runoob.com)</a></p><hr><h5 id="常用的正则表达式"><a href="#常用的正则表达式" class="headerlink" title="常用的正则表达式"></a>常用的正则表达式</h5><table><thead><tr><th>需求</th><th>正则表达式</th></tr></thead><tbody><tr><td>用户名</td><td>&#x2F;^[a-zA-Z][a-zA-Z-0-9]{5-9}$&#x2F;</td></tr><tr><td>密码</td><td>&#x2F;^[a-zA-Z0-9_-@#&amp;*]{6-12}$&#x2F;</td></tr><tr><td>前后空格</td><td>&#x2F;^\s+|\s+$&#x2F;g</td></tr><tr><td>电子邮箱</td><td>&#x2F;^[a-zA-Z0-9_.-]+@([a-zA-Z0-9]+[.]{1})+[a-zA-Z]+$&#x2F;</td></tr></tbody></table><hr><p><em>正则表达式在开发的过程中只需要读懂，在网上寻找现有的正则模板使用即可</em></p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>java-web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JS-DOM编程</title>
    <link href="/2024/03/31/JS-DOM%E7%BC%96%E7%A8%8B/"/>
    <url>/2024/03/31/JS-DOM%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="DOM编程"><a href="#DOM编程" class="headerlink" title="DOM编程"></a>DOM编程</h1><p>DOM（Document Object Model）编程就是使用document对象的API完成对网页HTMl文档进行动态修改，以实现网页数据和样式动态变化效果的编程</p><p><em>document准确来说是window对象的属性对象之一</em></p><p>document是一个树形结构，以元素（属性和文本）作为树的结点</p><hr><h3 id="Document直接获取指定元素"><a href="#Document直接获取指定元素" class="headerlink" title="Document直接获取指定元素"></a>Document直接获取指定元素</h3><ul><li><strong>document.getElementById()：根据id获取当前页面唯一元素</strong></li><li>document.getElementsByTagName()：根据标签获取当前页面多个元素</li><li>document.getElementsByName()：根据name属性值获取当前页面多个元素</li><li>document.getElementsByClassName()：根据class属性值获取当前页面多个元素</li></ul><p>多个元素的获取会返回一个htmlCollection对象，用for循环遍历即可获得每个元素</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-keyword">function</span> <span class="hljs-title function_">fun1</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">var</span> els = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByClassName</span>(<span class="hljs-string">&quot;div1&quot;</span>);</span><br><span class="language-javascript">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; els.<span class="hljs-property">length</span>; i++) &#123;</span><br><span class="language-javascript">          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(els[i]);</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">      &#125; </span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;div1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;div1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;div1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;div1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;div1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;div1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;fun1()&quot;</span>&gt;</span>循环<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><p>使用foreach循环遍历不仅会获得元素，还会获得对象中的其他方法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-keyword">function</span> <span class="hljs-title function_">fun1</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">var</span> els = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByClassName</span>(<span class="hljs-string">&quot;div1&quot;</span>);</span><br><span class="language-javascript">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> els) &#123;</span><br><span class="language-javascript">          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(els[i]);</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;div1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;div1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;div1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;div1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;div1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;div1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;fun1()&quot;</span>&gt;</span>循环<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h3 id="通过方法间接访问元素"><a href="#通过方法间接访问元素" class="headerlink" title="通过方法间接访问元素"></a>通过方法间接访问元素</h3><ul><li><em>父元素.children</em> 通过父元素获取子元素</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">      onload = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">var</span> div1 = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;div1&quot;</span>);</span><br><span class="language-javascript">        <span class="hljs-comment">//根据父元素获取其所有子元素</span></span><br><span class="language-javascript">        <span class="hljs-keyword">var</span> cs = div1.<span class="hljs-property">children</span>;</span><br><span class="language-javascript">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; cs.<span class="hljs-property">length</span>; i++) &#123;</span><br><span class="language-javascript">          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cs[i]);</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">        <span class="hljs-comment">//根据父元素获取第一个子元素</span></span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(div1.<span class="hljs-property">firstElementChild</span>)</span><br><span class="language-javascript">        <span class="hljs-comment">//根据父元素获取最后一个子元素</span></span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(div1.<span class="hljs-property">lastElementChild</span>)</span><br><span class="language-javascript">      &#125;;</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;div1&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><ul><li>子元素.parentElement获取父元素</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">      onload = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">var</span> div1 = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;div1&quot;</span>);</span><br><span class="language-javascript">        <span class="hljs-comment">//根据子元素获取父元素</span></span><br><span class="language-javascript">        <span class="hljs-keyword">var</span> pr = div1.<span class="hljs-property">parentElement</span>;</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pr);</span><br><span class="language-javascript">      &#125;;</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;div1&quot;</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><ul><li>通过.previousElementSibling和.nextElementSibling获取当前元素的兄弟元素</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">      onload = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">var</span> div1 = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;div1&quot;</span>);</span><br><span class="language-javascript">        <span class="hljs-comment">//根据当前元素获取兄弟元素</span></span><br><span class="language-javascript">        <span class="hljs-comment">//获取当前元素的前一个元素</span></span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(div1.<span class="hljs-property">previousElementSibling</span>);</span><br><span class="language-javascript">        <span class="hljs-comment">//获取当前元素的后一个元素</span></span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(div1.<span class="hljs-property">nextElementSibling</span>);</span><br><span class="language-javascript">      &#125;;</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;div1&quot;</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h3 id="对元素进行操作"><a href="#对元素进行操作" class="headerlink" title="对元素进行操作"></a>对元素进行操作</h3><ul><li><p>操作元素的属性：元素名.属性名&#x3D;””</p></li><li><p>操作元素的样式：元素名.style.样式名&#x3D;””</p><ul><li>当遇到带有中横线的样式名，要采用驼峰命名，例如”background-color”要写成”backgroundColor”</li></ul></li><li><p>操作元素的文本：元素名.innerText&#x3D;””  元素名.htmlText&#x3D;””</p><ul><li>innerText不会识别html中的标签结构，而htmlText能识别html标签</li></ul></li><li><p>增加元素</p><ul><li><p>document.createElement(“元素名”)：创建一个新元素</p></li><li><p>父元素.appendChild(新元素)：在父元素中追加一个新元素</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 在列表最后添加元素&quot;长沙&quot; --&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-keyword">function</span> <span class="hljs-title function_">addCs</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-comment">//新建元素li</span></span><br><span class="language-javascript">        <span class="hljs-keyword">var</span> csli = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;li&quot;</span>);</span><br><span class="language-javascript">        <span class="hljs-comment">//给元素添加属性值和文本</span></span><br><span class="language-javascript">        csli.<span class="hljs-property">id</span> = <span class="hljs-string">&quot;cs&quot;</span>;</span><br><span class="language-javascript">        csli.<span class="hljs-property">innerText</span> = <span class="hljs-string">&quot;长沙&quot;</span>;</span><br><span class="language-javascript">        <span class="hljs-comment">//找到父元素city</span></span><br><span class="language-javascript">        <span class="hljs-keyword">var</span> city = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;city&quot;</span>);</span><br><span class="language-javascript">        <span class="hljs-comment">//在父元素city中增加子元素csli</span></span><br><span class="language-javascript">        city.<span class="hljs-title function_">appendChild</span>(csli);</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;city&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;bj&quot;</span>&gt;</span>北京<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sh&quot;</span>&gt;</span>上海<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;gz&quot;</span>&gt;</span>广州<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sz&quot;</span>&gt;</span>深圳<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;addCs()&quot;</span>&gt;</span>增加一个<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>父元素.insertBefore(新元素,参照元素)：在指定元素前添加新元素</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 在指定的元素前添加元素&quot;长沙&quot; --&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-keyword">function</span> <span class="hljs-title function_">addCs</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-comment">//新建元素li</span></span><br><span class="language-javascript">        <span class="hljs-keyword">var</span> csli = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;li&quot;</span>);</span><br><span class="language-javascript">        <span class="hljs-comment">//给元素添加属性值和文本</span></span><br><span class="language-javascript">        csli.<span class="hljs-property">id</span> = <span class="hljs-string">&quot;cs&quot;</span>;</span><br><span class="language-javascript">        csli.<span class="hljs-property">innerText</span> = <span class="hljs-string">&quot;长沙&quot;</span>;</span><br><span class="language-javascript">        <span class="hljs-comment">//找到父元素city</span></span><br><span class="language-javascript">        <span class="hljs-keyword">var</span> city = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;city&quot;</span>);</span><br><span class="language-javascript">        <span class="hljs-comment">//找到参照元素&quot;深圳&quot;</span></span><br><span class="language-javascript">        <span class="hljs-keyword">var</span> sz = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;sz&quot;</span>);</span><br><span class="language-javascript">        <span class="hljs-comment">//在父元素city中，在深圳前增加子元素csli</span></span><br><span class="language-javascript">        city.<span class="hljs-title function_">insertBefore</span>(csli, sz);</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;city&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;bj&quot;</span>&gt;</span>北京<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sh&quot;</span>&gt;</span>上海<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;gz&quot;</span>&gt;</span>广州<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sz&quot;</span>&gt;</span>深圳<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;addCs()&quot;</span>&gt;</span>增加一个<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>父元素.replaceChild(新元素,被替换元素)：用新元素替换某个子元素</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 把原有元素&quot;深圳&quot;替换成新元素&quot;长沙&quot; --&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-keyword">function</span> <span class="hljs-title function_">replaceSz</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-comment">//新建元素li</span></span><br><span class="language-javascript">        <span class="hljs-keyword">var</span> csli = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;li&quot;</span>);</span><br><span class="language-javascript">        <span class="hljs-comment">//给元素添加属性值和文本</span></span><br><span class="language-javascript">        csli.<span class="hljs-property">id</span> = <span class="hljs-string">&quot;cs&quot;</span>;</span><br><span class="language-javascript">        csli.<span class="hljs-property">innerText</span> = <span class="hljs-string">&quot;长沙&quot;</span>;</span><br><span class="language-javascript">        <span class="hljs-comment">//找到父元素city</span></span><br><span class="language-javascript">        <span class="hljs-keyword">var</span> city = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;city&quot;</span>);</span><br><span class="language-javascript">        <span class="hljs-comment">//找到参照元素&quot;深圳&quot;</span></span><br><span class="language-javascript">        <span class="hljs-keyword">var</span> sz = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;sz&quot;</span>);</span><br><span class="language-javascript">        <span class="hljs-comment">//在父元素city中，把深圳替换成新元素&quot;长沙&quot;</span></span><br><span class="language-javascript">        city.<span class="hljs-title function_">replaceChild</span>(csli, sz);</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;city&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;bj&quot;</span>&gt;</span>北京<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sh&quot;</span>&gt;</span>上海<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;gz&quot;</span>&gt;</span>广州<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sz&quot;</span>&gt;</span>深圳<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;replaceSz()&quot;</span>&gt;</span>替换一个<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><hr></li></ul></li><li><p>删除元素</p><ul><li>元素.remove()：哪一个元素调用remove()方法，此元素在Dom树中被删除</li><li>父元素.innerHTMl&#x3D;””：即可清空父元素内所有子元素，但<strong>保留父元素</strong></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>java-web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JS-BOM编程</title>
    <link href="/2024/03/31/JS-BOM%E7%BC%96%E7%A8%8B/"/>
    <url>/2024/03/31/JS-BOM%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="BOM编程"><a href="#BOM编程" class="headerlink" title="BOM编程"></a>BOM编程</h1><p>BOM是Browser Object Model的缩写，即浏览器对象模型</p><p>BOM是由一系列的对象组成，是访问、控制、修改浏览器的属性和方法（通过window对象及属性的一系列方法控制浏览器行为的一种编程）</p><hr><h3 id="window对象"><a href="#window对象" class="headerlink" title="window对象"></a>window对象</h3><p>window对象是浏览器提供给我们使用的，无需自己创建</p><ul><li><p>window顶级对象：代表整个浏览器窗口</p><ul><li><p>history对象：代表浏览器的访问历史</p></li><li><p>location对象：代表浏览器的地址栏</p></li><li><p>screen对象：代表屏幕</p></li><li><p>navigator对象：代表浏览器软件本身</p></li><li><p>document对象：代表浏览器窗口目前解析的html文档</p></li><li><p>console对象：代表浏览器开发者工具的控制台</p></li><li><p>localStorage对象：代表浏览器本地数据持久化储存</p></li><li><p>sessionStorage对象：代表浏览器本地数据会话级储存</p></li></ul></li><li><p>window对象的API</p><ul><li><a href="https://www.w3school.com.cn/js/js_window.asp">JavaScript Window - 浏览器对象模型 (w3school.com.cn)</a></li></ul></li><li><p>history属性的API</p><ul><li>forward()：向后翻页</li><li>back()：向前翻页</li><li>go()；向前翻几页</li><li><a href="https://www.w3school.com.cn/js/js_window_history.asp">JavaScript Window History (w3school.com.cn)</a></li></ul></li><li><p>location属性的API</p><ul><li>href：当前浏览器地址栏的网址（可通过此属性实现页面的跳转）</li><li><a href="https://www.w3school.com.cn/js/js_window_location.asp">JavaScript Window Location (w3school.com.cn)</a></li></ul></li><li><p>console属性的API</p><ul><li>log()：使用控制台打印日志</li></ul></li></ul><hr><h3 id="三种弹窗方式"><a href="#三种弹窗方式" class="headerlink" title="三种弹窗方式"></a>三种弹窗方式</h3><p>我们在前文已经学习到了三种弹窗方式，这三个API都是window对象本身的API</p><p>*<em>在使用API时，我们的</em>window.<em>可省略不写</em>*</p><hr><h3 id="Storage-API"><a href="#Storage-API" class="headerlink" title="Storage API"></a>Storage API</h3><ul><li>sessionStorage属性的API<ul><li>setItem()：存储数据</li><li>getItem()：读取数据</li><li>removeItem()：删除数据</li></ul></li><li>localStorage属性的API<ul><li>setItem()：存储数据</li><li>getItem()：读取数据</li><li>removeItem()：删除数据</li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-keyword">function</span> <span class="hljs-title function_">fun1</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-comment">//使用key,value的键值对方式对storage进行存放数据</span></span><br><span class="language-javascript">        <span class="hljs-variable language_">sessionStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&quot;keya&quot;</span>, <span class="hljs-string">&quot;valueA&quot;</span>);</span><br><span class="language-javascript">        <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&quot;keyb&quot;</span>, <span class="hljs-string">&quot;valueB&quot;</span>);</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">      <span class="hljs-keyword">function</span> <span class="hljs-title function_">fun2</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-comment">//使用key对storage进行读取数据</span></span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">sessionStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&quot;keya&quot;</span>));</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&quot;keyb&quot;</span>));</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">      <span class="hljs-keyword">function</span> <span class="hljs-title function_">fun3</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-comment">//使用key对storage进行删除数据</span></span><br><span class="language-javascript">        <span class="hljs-variable language_">sessionStorage</span>.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">&quot;keya&quot;</span>);</span><br><span class="language-javascript">        <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">&quot;keyb&quot;</span>);</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;btn1&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;fun1()&quot;</span>&gt;</span>存数据<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;btn2&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;fun2()&quot;</span>&gt;</span>读数据<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;btn3&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;fun3()&quot;</span>&gt;</span>删数据<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>java-web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JS-事件</title>
    <link href="/2024/03/30/JS-%E4%BA%8B%E4%BB%B6/"/>
    <url>/2024/03/30/JS-%E4%BA%8B%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><p>HTMl事件可以是浏览器行为，也可以是用户行为。当这一些行为发生时，可以自动触发对应的JS函数的运行，我们称之为事件发生，JS的事件驱动指的就是行为触发代码运行的这种特点</p><p><em>在html中使用事件调用函数时，一定不要忘了()</em></p><h3 id="三种弹窗方式"><a href="#三种弹窗方式" class="headerlink" title="三种弹窗方式"></a>三种弹窗方式</h3><ul><li>alert()信息提示框</li><li>prompt()信息输入框</li><li>confirm()信息确认框<ul><li>这个函数的返回值为布尔类型，可以利用此返回值选择是否提交表单</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//利用onsubmit事件调用这个方法，当点击取消时，不提交表单</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">testSubmit</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> flag = <span class="hljs-title function_">confirm</span>(<span class="hljs-string">&quot;确定要提交表单吗&quot;</span>);<br>    <span class="hljs-keyword">if</span>(!flag)&#123;<br>        event.<span class="hljs-title function_">preventDefault</span>();<span class="hljs-comment">//阻止表单提交的方法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//当onsubmit=&quot;return testSubmit()&quot;时，当点击取消时，不提交表单</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">testSubmit</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> flag = <span class="hljs-title function_">confirm</span>(<span class="hljs-string">&quot;确定要提交表单吗&quot;</span>);<br>    <span class="hljs-keyword">if</span>(!flag)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么就可以简写成</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//当onsubmit=&quot;return testSubmit()&quot;时，当点击取消时，不提交表单</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">testOnsubmit</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-title function_">confirm</span>(<span class="hljs-string">&quot;确定要提交表单吗？&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="绑定方式"><a href="#绑定方式" class="headerlink" title="绑定方式"></a>绑定方式</h3><ul><li>通过元素的属性绑定</li><li>通过DOM编程动态绑定</li></ul><p><em>一个事件可以绑定多个函数</em></p><p><em>一个元素可以绑定多个事件</em></p><hr><h3 id="常见事件"><a href="#常见事件" class="headerlink" title="常见事件"></a>常见事件</h3><h5 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h5><ul><li>onclick：当用户点击某个对象时调用的事件句柄</li><li>ondbclick：当用户双击某个对象时调用的事件句柄</li><li>onmouseover：当鼠标悬停时调用的事件句柄</li><li>onmousemove：当鼠标移动时调用的事件句柄</li><li>onmouseleave：当鼠标离开时调用的事件句柄</li></ul><h5 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h5><ul><li>onkeydown：当按键按下时调用的事件句柄</li><li>onkeyup：当按键抬起时调用的事件句柄</li></ul><h5 id="表单事件"><a href="#表单事件" class="headerlink" title="表单事件*"></a>表单事件*</h5><ul><li><p>onfocus：当表单获得焦点时调用的事件句柄</p></li><li><p>onblur：当表单失去焦点时调用的事件句柄</p></li><li><p>onchange：当内容发生改变时调用的事件句柄（内容改变，失去焦点）</p><ul><li><p>onchange之后的事件方法传参为this.value，即可获取到改变的内容</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;input type=<span class="hljs-string">&quot;text&quot;</span> onchange=<span class="hljs-string">&quot;testOnchange(this.value)&quot;</span>&gt;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>onsubmit：当表单提交时调用的事件句柄</p><ul><li>此事件要绑定在form标签中，而不是input标签中</li></ul></li><li><p>onreset：当表单重置时调用的事件句柄</p><ul><li>此事件要绑定在form标签中，而不是input标签中</li></ul></li></ul><h5 id="页面加载事件"><a href="#页面加载事件" class="headerlink" title="页面加载事件"></a>页面加载事件</h5><ul><li>onload：当页面加载完成时调用的事件句柄<ul><li>此事件要绑定在body标签中</li><li>也可以通过在js代码中window.onload&#x3D;function(){}完成对页面加载完成时的事件触发</li></ul></li></ul><hr><h3 id="通过DOM编程动态处理事件"><a href="#通过DOM编程动态处理事件" class="headerlink" title="通过DOM编程动态处理事件"></a>通过DOM编程动态处理事件</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-comment">//使用dom编程绑定页面加载事件</span></span><br><span class="language-javascript">      <span class="hljs-variable language_">window</span>.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-comment">//使用dom编程获取div为对象</span></span><br><span class="language-javascript">        <span class="hljs-keyword">var</span> div1 = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;div1&quot;</span>);</span><br><span class="language-javascript">        div1.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">          div1.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundColor</span> = <span class="hljs-string">&quot;red&quot;</span>;</span><br><span class="language-javascript">        &#125;;</span><br><span class="language-javascript">        <span class="hljs-keyword">var</span> btn1 = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;btn1&quot;</span>);</span><br><span class="language-javascript">        btn1.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">          <span class="hljs-comment">//使用dom编程触发事件</span></span><br><span class="language-javascript">          div1.<span class="hljs-title function_">onclick</span>();</span><br><span class="language-javascript">        &#125;;</span><br><span class="language-javascript">      &#125;;</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">      <span class="hljs-selector-id">#div1</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: yellow;</span><br><span class="language-css">      &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;div1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;btn1&quot;</span>&gt;</span>按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>java-web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JS-基本对象</title>
    <link href="/2024/03/30/JS-%E5%9F%BA%E6%9C%AC%E5%AF%B9%E8%B1%A1/"/>
    <url>/2024/03/30/JS-%E5%9F%BA%E6%9C%AC%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h3 id="JS常见对象"><a href="#JS常见对象" class="headerlink" title="JS常见对象"></a>JS常见对象</h3><p><em>类比java的基础类库</em> </p><ul><li><p>数组：<a href="https://www.runoob.com/js/js-obj-array.html">JavaScript Array（数组）对象 | 菜鸟教程 (runoob.com)</a></p></li><li><p>Boolean对象：<a href="https://www.runoob.com/js/js-obj-boolean.html">JavaScript Boolean（布尔）对象 | 菜鸟教程 (runoob.com)</a></p></li><li><p>Date对象：<a href="https://www.runoob.com/js/js-obj-date.html">JavaScript Date（日期）对象 | 菜鸟教程 (runoob.com)</a></p></li><li><p>Math：<a href="https://www.runoob.com/js/js-obj-math.html">JavaScript Math（算数）对象 | 菜鸟教程 (runoob.com)</a></p></li><li><p>Number：<a href="https://www.runoob.com/js/js-obj-number.html">JavaScript Number 对象 | 菜鸟教程 (runoob.com)</a></p></li><li><p>String：<a href="https://www.runoob.com/js/js-obj-string.html">JavaScript 字符串（String）对象 | 菜鸟教程 (runoob.com)</a></p></li></ul><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>java-web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JS-json</title>
    <link href="/2024/03/28/JS-json/"/>
    <url>/2024/03/28/JS-json/</url>
    
    <content type="html"><![CDATA[<h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><p>JSON(JavaScript Object Notation,js对象简谱)</p><p>一个特定的字符串语法结构</p><p>JSON格式的字符串，在前后端都可以很方便的和对象之间进行转换</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script&gt;<br>  <span class="hljs-comment">// json中,属性值和属性名都需要用双引号包好,数字可以不做处理</span><br>  <span class="hljs-comment">// 属性值可以是数组,对象,对象数组</span><br>  <span class="hljs-comment">// var personStr =&#x27;&#123;&quot;属性名&quot;:&quot;属性值&quot;,&quot;属性名&quot;:&quot;属性值&quot;&#125;&#x27;</span><br>  <span class="hljs-comment">// 在json中主要使用属性传递数据,不讨论方法的传递</span><br><br>  <span class="hljs-comment">//创建一个json格式的字符串</span><br>  <span class="hljs-keyword">var</span> personStr =<br>    <span class="hljs-string">&#x27;&#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:10,&quot;dog&quot;:&#123;&quot;dname&quot;:&quot;小花&quot;&#125;,&quot;loveSingers&quot; :[&quot;张晓明&quot;,&quot;王晓东&quot;,&quot;李小黑&quot;],&quot;friends&quot;:[&#123;&quot;fname&quot;:&quot;赵四儿&quot;&#125;,&#123;&quot;fname&quot;:&quot;玉田&quot;&#125;,&#123;&quot;fname&quot;:&quot;王小蒙&quot;&#125;] &#125;&#x27;</span>;<br>  <span class="hljs-keyword">var</span> person = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(personStr);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(personStr);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person);<br>  <span class="hljs-comment">//可以通过逐层打点的方式,访问每一个属性</span><br><br>  <span class="hljs-comment">//也可以将对象转换为json串</span><br>  <span class="hljs-keyword">var</span> personstr1 = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(person);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(personstr1);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><hr><p>在后端，同样可使用jackson工具对json串进行转换操作</p><p><strong>我们需要使用到Jackson来对json串进行转换</strong></p><p><a href="https://repo1.maven.org/maven2/com/fasterxml/jackson/core/">Central Repository: com&#x2F;fasterxml&#x2F;jackson&#x2F;core (maven.org)</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">objectMapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">personStr</span> <span class="hljs-operator">=</span> objectMapper.writeValueAsString(person);<span class="hljs-comment">//将 person对象转成json串</span><br><br>    <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">objectMapper1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> objectMapper1.readValue(PersonStr, Person.class);<span class="hljs-comment">//将personStr字符串转成Person类的对象person</span><br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="Map，List，数组的JSON串"><a href="#Map，List，数组的JSON串" class="headerlink" title="Map，List，数组的JSON串"></a>Map，List，数组的JSON串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> JsonProcessingException &#123;<br>    <span class="hljs-comment">//map集合转为JSON串</span><br>    <span class="hljs-type">Map</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>    map.put(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;valuea&quot;</span>);<br>    map.put(<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;valueb&quot;</span>);<br>    map.put(<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;valuec&quot;</span>);<br><br>    <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">objectMapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br>    System.out.println(objectMapper.writeValueAsString(map));<span class="hljs-comment">//&#123;&quot;a&quot;:&quot;valuea&quot;,&quot;b&quot;:&quot;valueb&quot;,&quot;c&quot;:&quot;valuec&quot;&#125;</span><br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> JsonProcessingException &#123;<br>    <span class="hljs-comment">//List集合转为JSON串</span><br>    <span class="hljs-type">List</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>    list.add(<span class="hljs-string">&quot;a&quot;</span>);<br>    list.add(<span class="hljs-string">&quot;b&quot;</span>);<br>    list.add(<span class="hljs-string">&quot;c&quot;</span>);<br>    <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">objectMapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br>    System.out.println(objectMapper.writeValueAsString(list));<span class="hljs-comment">//[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span><br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test3</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> JsonProcessingException &#123;<br>    String[] data = &#123;<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>&#125;;<br>    <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">objectMapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br>    System.out.println(objectMapper.writeValueAsString(data));<span class="hljs-comment">//[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span><br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>java-web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JS</title>
    <link href="/2024/03/27/JS/"/>
    <url>/2024/03/27/JS/</url>
    
    <content type="html"><![CDATA[<h1 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h1><h3 id="js的引入"><a href="#js的引入" class="headerlink" title="js的引入"></a>js的引入</h3><ul><li>内嵌式：在head中通过一对script标签定义脚本代码</li><li>引入外部脚本文件：在head中通过script标签引入外部脚本文件<ul><li>一个html中可以有多个script标签</li><li>script标签如果用于引入外部js文件，中间不要有任何字符，甚至空格和换行</li></ul></li></ul><hr><h3 id="js的简单方法："><a href="#js的简单方法：" class="headerlink" title="js的简单方法："></a>js的简单方法：</h3><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>console.log()</td><td>可在控制台输出</td></tr><tr><td>typeof()</td><td>可判断数据类型</td></tr><tr><td>prompt()</td><td>弹窗以供用户输入，<strong>返回一个string类型</strong></td></tr><tr><td>alter()</td><td>弹窗显示</td></tr><tr><td>Number.parseInt(String)</td><td>将字符串转换成整数</td></tr><tr><td>document.write()</td><td>向文档写入文本内容，<strong>可以是 HTML 代码</strong></td></tr><tr><td>JSON.parse()</td><td>此方法可将json串转换为js对象</td></tr><tr><td>JSON.stringify()</td><td>将一个js对象转换为json字符串</td></tr></tbody></table><hr><h3 id="js的函数声明"><a href="#js的函数声明" class="headerlink" title="js的函数声明"></a>js的函数声明</h3><ul><li>function <em>函数名</em> (){}</li><li>var <em>函数名</em> &#x3D; function(){}</li></ul><p>和java相比，js的函数有如下特点</p><ul><li>没有访问修饰符</li><li>没有返回值类型，如果有值要返回直接return即可</li><li>没有异常列表</li><li>调用方法时，形参和实参可以在数量上不一致</li><li>函数可以作为参数传递给另一个参数</li></ul><hr><h3 id="js的数据类型"><a href="#js的数据类型" class="headerlink" title="js的数据类型"></a>js的数据类型</h3><p>js是弱类型语言，但不是没有类型。是变量在声明时不指定数据类型，赋值时才确定类型。<strong>用var来赋值所有变量</strong></p><ul><li>数值类型number ：包括整数、小数</li><li>字符串类型string </li><li>布尔类型boolean</li><li>引用类型Object</li><li>function类型（函数类型）</li></ul><hr><h3 id="js的运算符"><a href="#js的运算符" class="headerlink" title="js的运算符"></a>js的运算符</h3><ul><li>算术运算符： + - * &#x2F; %<ul><li><em>当除(除等)0时会报错：Infinity</em></li><li><em>当模(模等)0时会报错：NaN（not a number）</em></li></ul></li><li>复合运算符： ++ – +&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; %&#x3D;</li><li>关系运算符：&gt; &lt; &gt;&#x3D; &lt;&#x3D; !&#x3D; &#x3D;&#x3D; &#x3D;&#x3D;&#x3D;<ul><li><em>&#x3D;&#x3D;：如果两端的数据类型不一致，会尝试将两端的数据都转换为number再对比</em></li><li><em>&#x3D;&#x3D;&#x3D;：如果两端的数据类型不一致，直接返回false，相同则继续对比</em></li></ul></li><li>逻辑运算符：|| &amp;&amp;</li><li>条件运算符：三目运算</li><li>按位运算符：| &amp; ^ &lt;&lt; &gt;&gt; &gt;&gt;&gt;</li></ul><hr><h3 id="js分支结构"><a href="#js分支结构" class="headerlink" title="js分支结构"></a>js分支结构</h3><ul><li>if后的非空字符串会判断为true</li><li>非空对象也会判断为true</li></ul><hr><h3 id="js循环结构"><a href="#js循环结构" class="headerlink" title="js循环结构"></a>js循环结构</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript">   <span class="hljs-comment">//   var arr = [&quot;北京&quot;, &quot;上海&quot;, &quot;广州&quot;];</span><br>   <span class="hljs-comment">//   document.write(&quot;&lt;ul&gt;&quot;);</span><br>   <span class="hljs-comment">//   for (var index = 0; index &lt; arr.length; index++) &#123;</span><br>   <span class="hljs-comment">//     document.write(&quot;&lt;li&gt;&quot; + arr[index] + &quot;&lt;/li&gt;&quot;);</span><br>   <span class="hljs-comment">//   &#125;</span><br>   <span class="hljs-comment">//   document.write(&quot;&lt;/ul&gt;&quot;);</span><br><span class="hljs-comment">//使用foreach改写普通for循环</span><br>     <span class="hljs-keyword">var</span> arr = [<span class="hljs-string">&quot;北京&quot;</span>, <span class="hljs-string">&quot;上海&quot;</span>, <span class="hljs-string">&quot;广州&quot;</span>];<br>     <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">&quot;&lt;ul&gt;&quot;</span>);<br>     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> index <span class="hljs-keyword">in</span> arr) &#123;<br>       <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">&quot;&lt;li&gt;&quot;</span> + arr[index] + <span class="hljs-string">&quot;&lt;/li&gt;&quot;</span>);<br>     &#125;<br>     <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">&quot;&lt;/ul&gt;&quot;</span>);<br></code></pre></td></tr></table></figure><hr><h3 id="js的对象"><a href="#js的对象" class="headerlink" title="js的对象"></a>js的对象</h3><ul><li>new Object()</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script&gt;<br>  <span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>  <span class="hljs-comment">//直接给person对象的name属性创建并赋值为张三</span><br>  person.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;张三&quot;</span>;<br>  person.<span class="hljs-property">age</span> = <span class="hljs-number">18</span>;<br>  <span class="hljs-comment">//直接给person对象的eat方法创建并创建方法体</span><br>  person.<span class="hljs-property">eat</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">food</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> + <span class="hljs-string">&quot;岁&quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&quot;正在吃&quot;</span> + food);<br>  &#125;;<br>  person.<span class="hljs-title function_">eat</span>(<span class="hljs-string">&quot;火锅&quot;</span>);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><hr><ul><li>{属性名:属性值，……，函数名:function(){}}</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script&gt;<br>  <span class="hljs-keyword">var</span> person = &#123;<br>    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;张三&quot;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">10</span>,<br>    <span class="hljs-attr">eat</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">food</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> + <span class="hljs-string">&quot;岁&quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&quot;正在吃&quot;</span> + food);<br>    &#125;,<br>  &#125;;<br>  person.<span class="hljs-title function_">eat</span>(<span class="hljs-string">&quot;火锅&quot;</span>);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><em>注意，要用逗号将属性值隔开，属性名可用双引号引起，推荐引起</em></p><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>java-web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>学习用软件的网站地址</title>
    <link href="/2024/03/24/%E5%AD%A6%E4%B9%A0%E7%94%A8%E8%BD%AF%E4%BB%B6%E7%9A%84%E7%BD%91%E7%AB%99%E5%9C%B0%E5%9D%80/"/>
    <url>/2024/03/24/%E5%AD%A6%E4%B9%A0%E7%94%A8%E8%BD%AF%E4%BB%B6%E7%9A%84%E7%BD%91%E7%AB%99%E5%9C%B0%E5%9D%80/</url>
    
    <content type="html"><![CDATA[<h1 id="Navicat"><a href="#Navicat" class="headerlink" title="Navicat"></a>Navicat</h1><p>Navicat激活方法：<a href="https://gitlab.com/ajiajishu/navicat-keygen-16V">https://gitlab.com/ajiajishu/navicat-keygen-16V</a><br>官方网站：<a href="https://www.navicat.com/">https://www.navicat.com/</a></p><hr><h1 id="VScode"><a href="#VScode" class="headerlink" title="VScode"></a>VScode</h1><p>VScode：<a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a><br>插件列表</p><ul><li><p>Auto Rename Tag 自动修改标签对插件</p></li><li><p>Chinese Language Pack汉化包</p></li><li><p>HTML CSS Support HTML CSS支持</p></li><li><p>Intellij IDEA Keybindings IDEA快捷键支持</p></li><li><p>Live Server实时加载功能的小型服务器</p></li><li><p>open in browser 通过浏览器打开当前文件的插件</p></li><li><p>Prettier iCode formatter 代码美化格式化插件</p></li><li><p>Vetur VScode中的Vue工具插件</p></li><li><p>vscode-icons 文件显示图标插件</p></li><li><p>vue3 snipptes 生成VUE模板插件</p></li><li><p>Vue language Features Vue3 语言特征插件</p></li></ul><hr><h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><p>docker：<a href="https://www.docker.com/">https://www.docker.com/</a><br>docker-compose：<a href="https://github.com/docker/compose/releases/">https://github.com/docker/compose/releases/</a></p><h1 id="VMware"><a href="#VMware" class="headerlink" title="VMware"></a>VMware</h1><p><a href="https://www.vmware.com/products/workstation-pro/workstation-pro-evaluation.html.html">https://www.vmware.com/products/workstation-pro/workstation-pro-evaluation.html.html</a></p><p>17激活码：JU090-6039P-08409-8J0QH-2YR7F</p><h1 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h1><p><a href="https://nodejs.org/en">Node.js — Run JavaScript Everywhere (nodejs.org)</a></p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
      <category>note</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Docker-compose的一些常用文档</title>
    <link href="/2024/03/24/Docker-compose%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E6%96%87%E6%A1%A3/"/>
    <url>/2024/03/24/Docker-compose%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E6%96%87%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker-compose的一些常用文档"><a href="#Docker-compose的一些常用文档" class="headerlink" title="Docker-compose的一些常用文档"></a>Docker-compose的一些常用文档</h1><p>在使用volumes做卷映射时，有两种映射方式：</p><ul><li>相对路径：相对于 docker-compose.yml 文件所在目录的路径。</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">volumes:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">./relative/path/to/data:/var/lib/postgresql/data</span><br></code></pre></td></tr></table></figure><ul><li>绝对路径：主机上的绝对路径。</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">volumes:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">/absolute/path/to/data:/var/lib/postgresql/data</span><br></code></pre></td></tr></table></figure><h3 id="Jellyfin"><a href="#Jellyfin" class="headerlink" title="Jellyfin"></a>Jellyfin</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&quot;3&quot;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">jellyfin:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">jellyfin/jellyfin</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">jellyfin</span><br>    <span class="hljs-attr">stdin_open:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">tty:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">8096</span><span class="hljs-string">:8096</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/mnt/config:/config</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/mnt/nas:/nas</span><br>    <span class="hljs-attr">privileged:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><hr><h3 id="Portainer"><a href="#Portainer" class="headerlink" title="Portainer"></a>Portainer</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3&#x27;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">portainer:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">&quot;portainer/portainer-ce:latest&quot;</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;9000:9000&quot;</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/var/run/docker.sock:/var/run/docker.sock</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/home/docker/Portainer/data:/data</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/home/docker/Portainer/public:/public</span><br></code></pre></td></tr></table></figure><p><em><a href="https://imnks.com/3406.html">Docker管理面板Portainer中文汉化 新增CE、EE企业版汉化 - 我不是矿神 (imnks.com)</a>下载汉化文件后将public文件夹替换</em></p><hr><h3 id="Webdav"><a href="#Webdav" class="headerlink" title="Webdav"></a>Webdav</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3&#x27;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">webdav:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">&quot;bytemark/webdav:latest&quot;</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;8060:80&quot;</span><br>    <span class="hljs-attr">enviroment:</span><br>      <span class="hljs-string">AUTH_TYPE=Basic</span><br>      <span class="hljs-string">USERNAME=XIAOBAI</span><br>      <span class="hljs-string">PASSWORD=XIAOBAI</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/home/docker/webdav/dav:/var/lib/dav</span><br></code></pre></td></tr></table></figure><hr><h3 id="halo"><a href="#halo" class="headerlink" title="halo"></a>halo</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&quot;3&quot;</span><br><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">halo:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">halohub/halo:2.13</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">on-failure:3</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">home/docker/halo2:/root/.halo2</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;8090:8090&quot;</span><br>    <span class="hljs-attr">healthcheck:</span><br>      <span class="hljs-attr">test:</span> [<span class="hljs-string">&quot;CMD&quot;</span>, <span class="hljs-string">&quot;curl&quot;</span>, <span class="hljs-string">&quot;-f&quot;</span>, <span class="hljs-string">&quot;http://localhost:8090/actuator/health/readiness&quot;</span>]<br>      <span class="hljs-attr">interval:</span> <span class="hljs-string">30s</span><br>      <span class="hljs-attr">timeout:</span> <span class="hljs-string">5s</span><br>      <span class="hljs-attr">retries:</span> <span class="hljs-number">5</span><br>      <span class="hljs-attr">start_period:</span> <span class="hljs-string">30s</span><br>    <span class="hljs-attr">command:</span><br>      <span class="hljs-comment"># 外部访问地址，请根据实际需要修改</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">--halo.external-url=http://localhost:8090/</span><br></code></pre></td></tr></table></figure><hr><h3 id="Zfile-云盘"><a href="#Zfile-云盘" class="headerlink" title="Zfile(云盘)"></a>Zfile(云盘)</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3&#x27;</span><br><span class="hljs-attr">services:</span><br>    <span class="hljs-attr">zfile:</span><br>        <span class="hljs-attr">container_name:</span> <span class="hljs-string">zfile</span><br>        <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>        <span class="hljs-attr">ports:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;8100:8080&#x27;</span><br>        <span class="hljs-attr">volumes:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;/mnt/zfile/db:/root/.zfile-v4/db&#x27;</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;/mnt/zfile/logs:/root/.zfile-v4/logs&#x27;</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;/mnt/zfile/file:/data/file&#x27;</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">zhaojun1998/zfile</span><br></code></pre></td></tr></table></figure><hr><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><blockquote><p>官方文档：<a href="https://dev.mysql.com/doc/refman/9.0/en/docker-mysql-getting-started.html#docker-starting-mysql-server">https://dev.mysql.com/doc/refman/9.0/en/docker-mysql-getting-started.html#docker-starting-mysql-server</a></p></blockquote><h5 id="注册token"><a href="#注册token" class="headerlink" title="注册token"></a>注册token</h5><ul><li><p>点击网址：<a href="https://container-registry.oracle.com/">https://container-registry.oracle.com/</a></p></li><li><p>登录网站：点击右上角的Sign in按钮并登录</p></li><li><p>生成密钥：点击账号下拉框中的Auth Token按钮，然后点击Generate Secret Key按钮并保存</p></li></ul><h5 id="注册仓库"><a href="#注册仓库" class="headerlink" title="注册仓库"></a>注册仓库</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker login container-registry.oracle.com<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir -p /home/mysql/&#123;conf,data,logs&#125;<br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3.0&#x27;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">mysql:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">container-registry.oracle.com/mysql/community-server:9.0</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">mysql</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;3306:3306&quot;</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/home/mysql/conf/my.cnf:/etc/my.cnf</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/home/mysql/logs:/var/logs</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/home/mysql/data:/var/lib/mysql</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">unless-stopped</span><br>    <span class="hljs-attr">privileged:</span> <span class="hljs-string">tru</span><br></code></pre></td></tr></table></figure><hr><p>&#x2F;home&#x2F;docker&#x2F;mysql&#x2F;conf&#x2F;my.cnf</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml">[<span class="hljs-string">mysqld</span>]<br><span class="hljs-string">user=mysql</span><br></code></pre></td></tr></table></figure><hr><h5 id="开通远程主机连接权限"><a href="#开通远程主机连接权限" class="headerlink" title="开通远程主机连接权限"></a>开通远程主机连接权限</h5><p>首先，使用docker logs mysql获取到初始密码</p><p>登录后，使用ALTER USER ‘root‘@’localhost’ IDENTIFIED BY ‘Zhuwenxue2002’修改密码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">在本机登入mysql后，更改 “mysql” 数据库里的 “user” 表里的 “host” 项，从”localhost”改称’%’。</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">mysql&gt;</span><span class="language-bash">use mysql;</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查询出数据库的用户名</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">mysql&gt;</span><span class="language-bash"><span class="hljs-keyword">select</span> host,user,password from user;</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">把用户表里面的host项改为“%”</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">mysql&gt;</span><span class="language-bash">update user <span class="hljs-built_in">set</span> host = ‘%’ <span class="hljs-built_in">where</span> user =’root’;</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">mysql&gt;</span><span class="language-bash">flush privileges;    <span class="hljs-comment">#刷新用户权限表</span></span><br><br></code></pre></td></tr></table></figure><h3 id="MinIO"><a href="#MinIO" class="headerlink" title="MinIO"></a>MinIO</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3&#x27;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">minio:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">minio/minio</span><br>    <span class="hljs-attr">hostname:</span> <span class="hljs-string">&quot;minio&quot;</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">9000</span><span class="hljs-string">:9000</span> <span class="hljs-comment"># api 端口</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">9001</span><span class="hljs-string">:9001</span> <span class="hljs-comment"># 控制台端口</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">MINIO_ACCESS_KEY:</span> <span class="hljs-string">xiaobai</span>    <span class="hljs-comment">#管理后台用户名</span><br>      <span class="hljs-attr">MINIO_SECRET_KEY:</span> <span class="hljs-string">Zhuwenxue2002</span> <span class="hljs-comment">#管理后台密码，最小8个字符</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./data:/data</span>               <span class="hljs-comment">#映射当前目录下的data目录至容器内/data目录</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./config:/root/.minio/</span>     <span class="hljs-comment">#映射配置目录</span><br>    <span class="hljs-attr">command:</span> <span class="hljs-string">server</span> <span class="hljs-string">--console-address</span> <span class="hljs-string">&#x27;:9001&#x27;</span> <span class="hljs-string">/data</span>  <span class="hljs-comment">#指定容器中的目录 /data</span><br>    <span class="hljs-attr">privileged:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br></code></pre></td></tr></table></figure><h3 id="PgSQL"><a href="#PgSQL" class="headerlink" title="PgSQL"></a>PgSQL</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3.1&#x27;</span><br><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">db:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">postgres:latest</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">POSTGRES_PASSWORD:</span> <span class="hljs-string">Zhuwenxue2002</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;5432:5432&quot;</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./data:/var/lib/postgresql/data</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./log:/var/log/postgresql</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
      <category>server</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Stream API</title>
    <link href="/2024/03/23/Stream%20API/"/>
    <url>/2024/03/23/Stream%20API/</url>
    
    <content type="html"><![CDATA[<h1 id="Stream-API"><a href="#Stream-API" class="headerlink" title="Stream API"></a>Stream API</h1><p>StreamAPI（java.util.stream）把真正的函数式编程风格引入到Java中，这是目前为止对Java类库最好的补充</p><p><em>StreamAPI实现将数据在后端去操作</em></p><hr><h3 id="StreamAPI和集合框架的区别"><a href="#StreamAPI和集合框架的区别" class="headerlink" title="StreamAPI和集合框架的区别"></a>StreamAPI和集合框架的区别</h3><ul><li>Stream API关注的是数据的计算（排序、查找、过滤、映射、遍历），面向CPU</li><li>集合关注的是数据的存储，面向内存的</li><li>Stream API之于集合，类似于SQL之余数据表的查询</li></ul><hr><h3 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h3><ul><li>Stream自己不会存储元素</li><li>Stream不会改变源对象，相反，他们会返回一个持有结果的新Stream</li><li>Stream操作时延迟进行的，这意味着它们会等到需要结果的时候才执。一旦中途执行中止操作，就执行中间操作链，并产生结果</li><li>Stream一旦执行了终止操作，就不能再调用其他中间操作或终止操作了</li></ul><hr><h3 id="Stream执行流程"><a href="#Stream执行流程" class="headerlink" title="Stream执行流程"></a>Stream执行流程</h3><ul><li><p>Steam的实例化</p></li><li><p>一系列的中间操作</p></li><li><p>执行中止操作</p></li></ul><hr><h3 id="创建Stream"><a href="#创建Stream" class="headerlink" title="创建Stream"></a>创建Stream</h3><h5 id="创建Stream方式一：通过集合"><a href="#创建Stream方式一：通过集合" class="headerlink" title="创建Stream方式一：通过集合"></a>创建Stream方式一：通过集合</h5><p>结构Collection中提供了一个stream方法，可通过集合获取顺序流和并行流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">//创建Stream方式一：通过集合</span><br>    <span class="hljs-comment">//结构Collection中提供了一个stream方法，可通过集合获取顺序流和并行流</span><br>    <span class="hljs-type">List</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>    <span class="hljs-comment">//获取一个顺序流</span><br>    list.stream();<br>    <span class="hljs-comment">//获取一个并行流</span><br>    list.parallelStream();<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="创建Stream方式二：通过数组"><a href="#创建Stream方式二：通过数组" class="headerlink" title="创建Stream方式二：通过数组"></a>创建Stream方式二：通过数组</h5><p>调用Arrays类的static &lt;T&gt; Stream &lt;T&gt; stream(T[] array)：返回一个流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span>&#123;<br>    Integer[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>    Stream&lt;Integer&gt; stream = Arrays.stream(arr);<br>    <span class="hljs-comment">//基本数据类型不能当作泛型使用，所以有专门的基本数据类型Stream</span><br>    <span class="hljs-type">int</span>[] ints = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-type">IntStream</span> <span class="hljs-variable">stream1</span> <span class="hljs-operator">=</span> Arrays.stream(ints);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="创建Stream方式三：通过Stream的of"><a href="#创建Stream方式三：通过Stream的of" class="headerlink" title="创建Stream方式三：通过Stream的of()"></a>创建Stream方式三：通过Stream的of()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test3</span><span class="hljs-params">()</span> &#123;<br>    Stream&lt;String&gt; stream = Stream.of(<span class="hljs-string">&quot;AA&quot;</span>, <span class="hljs-string">&quot;BB&quot;</span>, <span class="hljs-string">&quot;CC&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="Stream的中间操作（方法）"><a href="#Stream的中间操作（方法）" class="headerlink" title="Stream的中间操作（方法）"></a>Stream的中间操作（方法）</h3><p>在此我们建立一个实体类Employee</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> salary;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Employee</span><span class="hljs-params">(<span class="hljs-type">int</span> id, String name, <span class="hljs-type">int</span> age, <span class="hljs-type">double</span> salary)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>        <span class="hljs-built_in">this</span>.salary = salary;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setId</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getSalary</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> salary;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSalary</span><span class="hljs-params">(<span class="hljs-type">double</span> salary)</span> &#123;<br>        <span class="hljs-built_in">this</span>.salary = salary;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Employee&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;id=&quot;</span> + id +<br>                <span class="hljs-string">&quot;, name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>                <span class="hljs-string">&quot;, salary=&quot;</span> + salary +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在此我们建立一个数据集合类EmployeeDate，此类中有get方法返回一个Employee类型的List集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EmployeeDate</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Employee&gt; <span class="hljs-title function_">getEmployees</span><span class="hljs-params">()</span>&#123;<br>        List&lt;Employee&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-number">1001</span>,<span class="hljs-string">&quot;马化腾&quot;</span>,<span class="hljs-number">34</span>,<span class="hljs-number">6000.38</span>));<br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-number">1002</span>,<span class="hljs-string">&quot;马云&quot;</span>,<span class="hljs-number">2</span>,<span class="hljs-number">9876.12</span>));<br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-number">1003</span>,<span class="hljs-string">&quot;刘强东&quot;</span>,<span class="hljs-number">33</span>,<span class="hljs-number">3000.82</span>));<br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-number">1004</span>,<span class="hljs-string">&quot;雷军&quot;</span>,<span class="hljs-number">26</span>,<span class="hljs-number">7657.37</span>));<br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-number">1005</span>,<span class="hljs-string">&quot;李彦宏&quot;</span>,<span class="hljs-number">65</span>,<span class="hljs-number">5555.32</span>));<br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-number">1005</span>,<span class="hljs-string">&quot;比尔盖茨&quot;</span>,<span class="hljs-number">42</span>,<span class="hljs-number">9500.43</span>));<br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-number">1006</span>,<span class="hljs-string">&quot;任正非&quot;</span>,<span class="hljs-number">26</span>,<span class="hljs-number">4333.32</span>));<br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-number">1007</span>,<span class="hljs-string">&quot;扎克伯格&quot;</span>,<span class="hljs-number">35</span>,<span class="hljs-number">2500.32</span>));<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="筛选与切片"><a href="#筛选与切片" class="headerlink" title="筛选与切片"></a>筛选与切片</h5><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>filter()</td><td>过滤</td></tr><tr><td>limit()</td><td>截取</td></tr><tr><td>skip()</td><td>跳过</td></tr><tr><td>distinct()</td><td>筛选（去重）</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//练习：查询员工表中薪资大于7000的员工信息</span><br>    List&lt;Employee&gt; list = EmployeeDate.getEmployees();<br>    Stream&lt;Employee&gt; stream = list.stream();<br><br>    <span class="hljs-comment">//使用流过滤工资（salary）大于七千的，并终止操作（输出到控制台）</span><br>    stream.filter(employee -&gt; employee.getSalary() &gt; <span class="hljs-number">7000</span>).forEach(System.out::println);<br>    <br>    System.out.println();<br>    <span class="hljs-comment">//终止操作之后，此Stream将无法再进行任何中间操作</span><br>    <br>    <span class="hljs-comment">//单独的流执行截取前四段，并终止操作（输出到控制台）</span><br>    list.stream().limit(<span class="hljs-number">4</span>).forEach(System.out::println);<br>    <br>    <span class="hljs-comment">//相同的，如果没有进行终止操作，可以进行多步中间操作（方法链）</span><br>    list.stream().filter(employee -&gt; employee.getSalary() &gt; <span class="hljs-number">7000</span>).limit(<span class="hljs-number">2</span>).forEach(System.out::println);<br>    <br>    <span class="hljs-comment">//跳过前五个</span><br>    list.stream().skip(<span class="hljs-number">5</span>).forEach(System.out::println);<br>    <br>    <span class="hljs-comment">//筛选（去重）</span><br>    list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-number">1009</span>, <span class="hljs-string">&quot;马斯克&quot;</span>, <span class="hljs-number">40</span>, <span class="hljs-number">12500.32</span>));<br>    list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-number">1009</span>, <span class="hljs-string">&quot;马斯克&quot;</span>, <span class="hljs-number">40</span>, <span class="hljs-number">12500.32</span>));<br>    list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-number">1009</span>, <span class="hljs-string">&quot;马斯克&quot;</span>, <span class="hljs-number">40</span>, <span class="hljs-number">12500.32</span>));<br>    list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-number">1009</span>, <span class="hljs-string">&quot;马斯克&quot;</span>, <span class="hljs-number">40</span>, <span class="hljs-number">12500.32</span>));<br>    list.stream().distinct().forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h5><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>map(Function f)</td><td>接受一个函数作为参数，将元素转换为其他形式或提取信息</td></tr></tbody></table><p><em>该方法会被应用到每一个元素上</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//练习：转大写</span><br>    List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-string">&quot;bb&quot;</span>, <span class="hljs-string">&quot;cc&quot;</span>, <span class="hljs-string">&quot;dd&quot;</span>);<br>    list.stream().map(String::toUpperCase).forEach(System.out::println);<br>    System.out.println();<br>    <span class="hljs-comment">//练习：获取员工姓名大于3的员工的姓名</span><br>    List&lt;Employee&gt; list1 = EmployeeDate.getEmployees();<br>    <span class="hljs-comment">//方式1：先过滤出名字大于3的再提取名字</span><br>    list1.stream().filter(employee -&gt; employee.getName().length() &gt; <span class="hljs-number">3</span>).map(employee -&gt; employee.getName()).forEach(System.out::println);<br>    <span class="hljs-comment">//方式2：先提取所有名字，再去找长度大于三的</span><br>    list1.stream().map(employee -&gt; employee.getName()).filter(name -&gt; name.length() &gt; <span class="hljs-number">3</span>).forEach(System.out::println);<br>    <span class="hljs-comment">//方式3：使用方法引用</span><br>    list1.stream().filter(employee -&gt; employee.getName().length() &gt; <span class="hljs-number">3</span>).map(Employee::getName).forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>sorted()</td><td>自然排序（默认升序）</td></tr><tr><td>sorted(Comparator com)</td><td>定制排序（默认升序）</td></tr><tr><td>sorted((s1,s2)-&gt;-s1.compareTo(s2))</td><td>降序排列</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span>&#123;<br>        Integer[] integers = &#123;<span class="hljs-number">345</span>, <span class="hljs-number">3</span>, <span class="hljs-number">64</span>, <span class="hljs-number">3</span>, <span class="hljs-number">45</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">34</span>, <span class="hljs-number">65</span>, <span class="hljs-number">68</span>&#125;;<br>        <span class="hljs-comment">//使用方式2构建stream流</span><br>        Arrays.stream(integers).sorted().forEach(System.out::println);<br><br>        <span class="hljs-comment">//字符数组也可以实现自然排序</span><br>        String[] strings = &#123;<span class="hljs-string">&quot;GG&quot;</span>, <span class="hljs-string">&quot;MM&quot;</span>, <span class="hljs-string">&quot;SS&quot;</span>, <span class="hljs-string">&quot;JJ&quot;</span>, <span class="hljs-string">&quot;DD&quot;</span>&#125;;<br>        Arrays.stream(strings).sorted().forEach(System.out::println);<br>        <span class="hljs-comment">//降序排列</span><br>        Arrays.stream(strings).sorted(String::compareTo).forEach(System.out::println);<br><br>        <span class="hljs-comment">//实体类对象不能实现自然排序，因为没有实现自然排序接口</span><br><span class="hljs-comment">//        List&lt;Employee&gt; list = EmployeeDate.getEmployees();</span><br><span class="hljs-comment">//        list.stream().sorted().forEach(System.out::println);</span><br><br>        <span class="hljs-comment">//定制排序：sorted(Comparator com)</span><br>        List&lt;Employee&gt; list = EmployeeDate.getEmployees();<br>        list.stream().sorted((e1,e2)-&gt;e1.getAge() - e2.getAge()).forEach(System.out::println);<br>    &#125;<br></code></pre></td></tr></table></figure><hr><h3 id="Stream的终止操作"><a href="#Stream的终止操作" class="headerlink" title="Stream的终止操作"></a>Stream的终止操作</h3><h5 id="匹配与查找"><a href="#匹配与查找" class="headerlink" title="匹配与查找"></a>匹配与查找</h5><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>allMatch()</td><td>全部元素匹配条件才为true</td></tr><tr><td>anyMatch()</td><td>有一个元素匹配条件就为true</td></tr><tr><td>findFirst()</td><td>返回第一个元素</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test4</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">//查询集合里的员工是否全都大于18岁</span><br>    List&lt;Employee&gt; list = EmployeeDate.getEmployees();<br>    System.out.println(list.stream().allMatch(employee -&gt; employee.getAge() &gt; <span class="hljs-number">18</span>));<br>    <span class="hljs-comment">//查询集合里的员工是否存在大于18岁</span><br>    System.out.println(list.stream().anyMatch(employee -&gt; employee.getAge() &gt; <span class="hljs-number">18</span>));<br>    <span class="hljs-comment">//返回第一个元素</span><br>    System.out.println(list.stream().findFirst());<br>&#125;<br></code></pre></td></tr></table></figure><hr><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>count()</td><td>返回流中元素的个数</td></tr><tr><td>max(Comparator c)</td><td>返回最高的</td></tr><tr><td>min(Comparator c)</td><td>返回最低的</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test5</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">//返回流中元素个数</span><br>    List&lt;Employee&gt; list = EmployeeDate.getEmployees();<br>    System.out.println(list.stream().count());<br>    <span class="hljs-comment">//返回最高的工资的员工</span><br>    System.out.println(list.stream().max((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary())));<br>    <span class="hljs-comment">//返回最高工资</span><br>    <span class="hljs-comment">//方式一</span><br>    System.out.println(list.stream().max((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary())).get().getSalary());<br>    <span class="hljs-comment">//方式二</span><br>    System.out.println(list.stream().map(employee -&gt; employee.getSalary()).max(Double::compare).get());<br>&#125;<br></code></pre></td></tr></table></figure><p><em>返回最低工资同理</em></p><hr><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>forEach(Consumer c)</td><td>内部迭代</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>    List&lt;Employee&gt; list = EmployeeDate.getEmployees();<br>    <span class="hljs-comment">//内部迭代</span><br>    list.stream().forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><hr><p><em><strong>list集合的遍历方式</strong></em></p><ul><li>使用Iterator</li><li>增强for</li><li>一般for</li><li>forEach**（新增）**</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//针对于集合，jdk8中增加了一个遍历的方法</span><br>list.forEach(System.out::println);<br></code></pre></td></tr></table></figure><hr><h5 id="归约"><a href="#归约" class="headerlink" title="归约"></a>归约</h5><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>reduce(T identity, BinaryOperator)</td><td>可以将流中元素反复结合起来，得到一个值，返回T</td></tr><tr><td>reduce(BinaryOperator)</td><td>可以将流中元素反复结合起来，得到一个值，返回Optional&lt;T&gt;</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//练习1：计算1-10的自然数的和</span><br>    List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>);<br>    System.out.println(list.stream().reduce(<span class="hljs-number">0</span>, (x1, x2) -&gt; x1 + x2));<br>    System.out.println(list.stream().reduce(<span class="hljs-number">0</span>, Integer::sum));<span class="hljs-comment">//方法引用</span><br><br>    <span class="hljs-comment">//求所有员工的工资和</span><br>    List&lt;Employee&gt; list1 = EmployeeDate.getEmployees();<br>    System.out.println(list1.stream().map(employee -&gt; employee.getSalary()).reduce((salary1, salary2) -&gt; Double.sum(salary1, salary2)));<br>    System.out.println(list1.stream().map(employee -&gt; employee.getSalary()).reduce(Double::sum));<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="收集"><a href="#收集" class="headerlink" title="收集"></a>收集</h5><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>collect(Collector c)</td><td>将流转换为其他形式，接受一个collector接口的实现。用于给Stream中的元素做汇总的方法</td></tr></tbody></table><p><em>另外Collector类给提供了很多静态方法，可供作为collect方法的参数使用</em></p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>JAVASE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Lambda表达式-方法引用</title>
    <link href="/2024/03/23/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/"/>
    <url>/2024/03/23/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Comparator&lt;Integer&gt; com3 = Integer :: compare;<span class="hljs-comment">//方法引用</span><br>System.out.println(com3.compare(<span class="hljs-number">23</span>,<span class="hljs-number">21</span>));<br></code></pre></td></tr></table></figure><p>方法引用可以看作是基于Lambda表达式的进一步刻画</p><p><strong>当满足一定条件的情况下，我们还可以使用方法应用或构造器引用替换Lambda表达式</strong></p><h3 id="方法引用的格式"><a href="#方法引用的格式" class="headerlink" title="方法引用的格式"></a>方法引用的格式</h3><p>类（或对象）::  方法名</p><ul><li>情况1：对象 :: 实例方法</li></ul><p>函数式接口的抽象方法（重写）a与其内部实现时调用对象的某个方法b的形参列表和返回值类型都相同</p><p>可以考虑使用方法b实现对方法a的覆盖。此替换即为方法引用</p><ul><li>情况2：类 :: 静态方法</li></ul><p>函数式接口的抽象方法（重写）a与其内部实现时调用类的某个静态方法方法b的形参列表和返回值类型都相同</p><p>可以考虑使用方法b实现对方法a的覆盖。此替换即为方法引用</p><ul><li>情况3：类 :: 实例方法</li></ul><p>函数式接口的抽象方法（重写）a与其内部实现时调用对象的某个方法b的返回值类型相同</p><p><strong>同时</strong>，抽象方法a中有n个参数，方法b中有n-1个参数，且抽象方法a的第一个参数作为方法b的调用者，后n-1个参数与方法b的n-1个参数相同。可以考虑使用方法b实现对方法a的覆盖。此替换即为方法引用</p><p><em>注：此方法b是非静态方法，本质上还是使用对象调用。但形式上我们写对象a所在的类</em></p><hr><h3 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h3><blockquote><p>类名 :: new</p></blockquote><h5 id="应用案例"><a href="#应用案例" class="headerlink" title="应用案例"></a>应用案例</h5><p>Person类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-comment">//有参构造器（只有一个参数）</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>    &#125;<br>    <span class="hljs-comment">//有参构造器</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(<span class="hljs-type">int</span> id, String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-comment">//空参构造器</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>案例要求：实例化一个Person类的对象，使用构造器引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">import</span> java.util.function.BiFunction;<br><span class="hljs-keyword">import</span> java.util.function.Function;<br><span class="hljs-keyword">import</span> java.util.function.Supplier;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConstructorTest</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//使用供给型接口，有返回值无参数</span><br>        Supplier&lt;Person&gt; supplier = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Supplier</span>&lt;Person&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Person <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>            &#125;<br>        &#125;;<br>        <span class="hljs-comment">//方法引用写法</span><br>        Supplier&lt;Person&gt; supplier1 = Person::<span class="hljs-keyword">new</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//使用函数式结构，有返回值有参数</span><br>        Function&lt;Integer, Person&gt; function = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>&lt;Integer, Person&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Person <span class="hljs-title function_">apply</span><span class="hljs-params">(Integer integer)</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(integer);<br>            &#125;<br>        &#125;;<br>        <span class="hljs-comment">//方法引用写法</span><br>        Function&lt;Integer, Person&gt; function1 = Person::<span class="hljs-keyword">new</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test3</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//使用BiFunction接口，有返回值有两个参数</span><br>        BiFunction&lt;Integer, String, Person&gt; function = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BiFunction</span>&lt;Integer, String, Person&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Person <span class="hljs-title function_">apply</span><span class="hljs-params">(Integer integer, String s)</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(integer, s);<br>            &#125;<br>        &#125;;<br>        <span class="hljs-comment">//方法引用写法</span><br>        BiFunction&lt;Integer, String, Person&gt; biFunction = Person::<span class="hljs-keyword">new</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>**总结：**无论使用何种构造器，最后的格式不变，因类型推断的缘故，构造器参数看的是泛型类型</p><hr><h3 id="数组引用"><a href="#数组引用" class="headerlink" title="数组引用"></a>数组引用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test4</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//使用函数式结构，有返回值有参数</span><br>    Function&lt;Integer, Person[]&gt; function = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>&lt;Integer, Person[]&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Person[] apply(Integer integer) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>[integer];<br>        &#125;<br>    &#125;;<br>    <span class="hljs-comment">//方法引用写法</span><br>    Function&lt;Integer, Person[]&gt; function1 = Person[]::<span class="hljs-keyword">new</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>JAVASE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Lambda表达式</title>
    <link href="/2024/03/23/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2024/03/23/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><p>作为JDK8的新特性，Lambda表达式提供了更方便的写法（匿名内部类）</p><p>Lambda表达式的本质，是一个<strong>对象</strong>，也是一个匿名函数</p><hr><h3 id="Lambda表达式的使用举例"><a href="#Lambda表达式的使用举例" class="headerlink" title="Lambda表达式的使用举例"></a>Lambda表达式的使用举例</h3><blockquote><p>(o1, o2) -&gt; Integer.compare(o1,o2);</p></blockquote><hr><h3 id="Lambda表达式的格式说明"><a href="#Lambda表达式的格式说明" class="headerlink" title="Lambda表达式的格式说明"></a>Lambda表达式的格式说明</h3><blockquote><p> -&gt; ：Lambda操作符或箭头操作符</p><p> -&gt;的左边：Lambda形参列表，对应着重写方法的形参列表</p><p> -&gt;的右边：Lambda体，对应着重写方法的方法体</p></blockquote><hr><h3 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断*"></a>类型推断*</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">//类型推断</span><br>    <span class="hljs-type">int</span>[] arr1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br>    <span class="hljs-type">int</span>[] arr2 = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<br>    <span class="hljs-comment">//类型推断</span><br>    HashMap&lt;String, Integer&gt; stringIntegerHashMap1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String,Integer&gt;();<br>    HashMap&lt;String, Integer&gt; stringIntegerHashMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>&#125;<br></code></pre></td></tr></table></figure><p><em>类型推断的功能导致了-&gt;左边的形参可以省略声明类型</em></p><hr><h3 id="Lambda实例"><a href="#Lambda实例" class="headerlink" title="Lambda实例"></a>Lambda实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//使用匿名内部类重写compare方法完成对两个数的对比</span><br>    Comparator&lt;Integer&gt; com1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Integer&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> &#123;<br>            <span class="hljs-keyword">return</span> Integer.compare(o1, o2);<br>        &#125;<br>    &#125;;<br>    System.out.println(com1.compare(<span class="hljs-number">23</span>, <span class="hljs-number">21</span>));<br>    <br>    <span class="hljs-comment">//Lambda表达式的写法</span><br>    Comparator&lt;Integer&gt; com2 = (o1, o2) -&gt; Integer.compare(o1,o2); <span class="hljs-comment">//类型推断，形参没有写明数据类型</span><br>    System.out.println(com2.compare(<span class="hljs-number">23</span>, <span class="hljs-number">21</span>));<br>    <span class="hljs-comment">//方法引用</span><br>    Comparator&lt;Integer&gt; com3 = Integer :: compare;<br>    System.out.println(com3.compare(<span class="hljs-number">23</span>,<span class="hljs-number">21</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p><em>当-&gt;左边的形参列表只有<strong>一个</strong>参数时，甚至可以省掉形参列表中的小括号</em></p><p><em>当-&gt;右边的执行体只有一条语句时，大括号可以省略，<strong>如有return语句，return关键字必须省略</strong></em></p><hr><h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><p>如果接口中只有一个抽象方法，则此接口就成为函数式接口**@FunctionalInterface**</p><p>函数式接口所在的包：声明在java.util.function包下</p><h4 id="四个基本的函数式接口"><a href="#四个基本的函数式接口" class="headerlink" title="四个基本的函数式接口"></a>四个基本的函数式接口</h4><table><thead><tr><th>函数式接口</th><th>称谓</th><th>参数类型</th><th>用途</th></tr></thead><tbody><tr><td>Consumer &lt;T&gt;</td><td>消费型接口</td><td>T</td><td>包含方法：void accept(T t) <em>有参无返回值</em></td></tr><tr><td>Supplier&lt;T&gt;</td><td>供给型接口</td><td>无</td><td>包含方法：T get() <em>有返回值无参数</em></td></tr><tr><td>Function&lt;T,R&gt;</td><td>函数式接口</td><td>T</td><td>包含方法：R apply(T t) <em>有形参有返回值</em></td></tr><tr><td>Predicate&lt;T&gt;</td><td>判断型接口</td><td>T</td><td>包含方法：boolean test(T t) <em>有形参有布尔类型返回值</em></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>JAVASE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>反射-反射的应用案例</title>
    <link href="/2024/03/21/%E5%8F%8D%E5%B0%84-%E5%8F%8D%E5%B0%84%E7%9A%84%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B/"/>
    <url>/2024/03/21/%E5%8F%8D%E5%B0%84-%E5%8F%8D%E5%B0%84%E7%9A%84%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<p>​                                </p><h1 id="反射的应用实例"><a href="#反射的应用实例" class="headerlink" title="反射的应用实例"></a>反射的应用实例</h1><p>接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Fruit</span> &#123;<br>    <span class="hljs-comment">//榨汁儿的方法</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">squeeze</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>水果实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Apple</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Fruit</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">squeeze</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;榨一杯苹果汁&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Banana</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Fruit</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">squeeze</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;榨一杯香蕉汁&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Orange</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Fruit</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">squeeze</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;榨一杯橘子汁&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>榨汁类，榨汁方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Juicer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(Fruit f)</span><br>    &#123;<br>        <span class="hljs-comment">//传进来一个Fruit的对象，使用这个对象调用其类中方法</span><br>        f.squeeze();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">import</span> java.io.File;<br><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><span class="hljs-keyword">import</span> java.util.Properties;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FruitTest</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//读取配置文件中的信息，获取全类名</span><br>        <span class="hljs-type">Properties</span> <span class="hljs-variable">pros</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;src/config.properties&quot;</span>);<br>        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(file);<br>        pros.load(fis);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">fn</span> <span class="hljs-operator">=</span> pros.getProperty(<span class="hljs-string">&quot;fruitName&quot;</span>);<br>        <span class="hljs-comment">//通过反射，指定全类对应类的实例</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Class.forName(fn);<br>        <span class="hljs-type">Constructor</span> <span class="hljs-variable">co</span> <span class="hljs-operator">=</span> clazz.getDeclaredConstructor();<br>        co.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-comment">//通过对象调用run()</span><br>        <span class="hljs-type">Fruit</span> <span class="hljs-variable">fruit</span> <span class="hljs-operator">=</span> (Fruit) co.newInstance();<br>        <span class="hljs-type">Juicer</span> <span class="hljs-variable">juicer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Juicer</span>();<br>        juicer.run(fruit);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>此案例体现了反射动态的特性，在此案例中，实体类的对象是未定义的，通过配置文件config.properties来通过反射获取具体是哪一个类的对象来调用方法</p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>JAVASE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>反射-反射的应用</title>
    <link href="/2024/03/18/%E5%8F%8D%E5%B0%84-%E5%8F%8D%E5%B0%84%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <url>/2024/03/18/%E5%8F%8D%E5%B0%84-%E5%8F%8D%E5%B0%84%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="反射的应用"><a href="#反射的应用" class="headerlink" title="反射的应用"></a>反射的应用</h1><p><em><strong>注：clazz是Class的实例，per才是Person的对象！！！</strong></em></p><h3 id="创建运行时类的对象"><a href="#创建运行时类的对象" class="headerlink" title="创建运行时类的对象"></a>创建运行时类的对象</h3><h5 id="通过Class实例调用newInstance-方法"><a href="#通过Class实例调用newInstance-方法" class="headerlink" title="通过Class实例调用newInstance()方法"></a>通过Class实例调用newInstance()方法</h5><ul><li><p>条件1：要求运行时类中必须提供一个空参的构造器</p></li><li><p>条件2：要求提供的空参的构造器的权限要足够</p></li></ul><p><em>在JDK9后此方法被标记为过时，替换为：Constructor调用newInstance()</em></p><hr><h5 id="获取运行时类的内部结构：所有属性、所有方法、所有构造器"><a href="#获取运行时类的内部结构：所有属性、所有方法、所有构造器" class="headerlink" title="获取运行时类的内部结构：所有属性、所有方法、所有构造器"></a>获取运行时类的内部结构：所有属性、所有方法、所有构造器</h5><ul><li><p>getFields()：获取到<strong>运行时类本身及其所有父类</strong>中声明为public权限的属性</p></li><li><p>getDeclaredFields()：获取当前<strong>运行时类</strong>中声明的所有属性</p></li><li><p>getMethods()：获取到<strong>运行时类本身及其所有父类</strong>中声明为public权限的方法</p></li><li><p>getDeclaredMethods()：获取当前<strong>运行时类</strong>中声明的所有方法</p></li></ul><hr><h5 id="获取运行时类的内部结构：父类、接口们、包、带泛型的父类、父类的泛型等"><a href="#获取运行时类的内部结构：父类、接口们、包、带泛型的父类、父类的泛型等" class="headerlink" title="获取运行时类的内部结构：父类、接口们、包、带泛型的父类、父类的泛型等"></a>获取运行时类的内部结构：父类、接口们、包、带泛型的父类、父类的泛型等</h5><ul><li>getSuperclass()：获取运行时类的父类</li><li>getInterfaces()：获取运行时类的接口，<em>因接口数量不唯一，需用数组接收，循环遍历</em></li><li>getPackage()：获取运行时类的包</li><li>getGennericSuperclass()：获取运行时类的带泛型的父类</li><li>获取运行时类的父类的泛型：<em><strong>此代码为工具代码，用时粘贴就行</strong></em></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取当前运行时类clazz</span><br>Class&lt;?&gt; clazz = Class.forName(<span class="hljs-string">&quot;Person&quot;</span>);<br><span class="hljs-comment">//获取运行时类的带泛型的父类</span><br><span class="hljs-type">Type</span> <span class="hljs-variable">genericSuperclass</span> <span class="hljs-operator">=</span> clazz.getGenericSuperclass();<br><span class="hljs-comment">//Class实现的接口Type可强转为ParameterizedType</span><br><span class="hljs-type">ParameterizedType</span> <span class="hljs-variable">parameterizedType</span> <span class="hljs-operator">=</span> (ParameterizedType) genericSuperclass;<br><span class="hljs-comment">//使用getActualTypeArguments()返回一个数组，返回所有泛型操作的名称</span><br>Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();<br><span class="hljs-keyword">for</span> (Type actualTypeArgument : actualTypeArguments) &#123;<br>    System.out.println(actualTypeArgument);<span class="hljs-comment">//遍历输出所有泛型父类的名称</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="调用指定的属性"><a href="#调用指定的属性" class="headerlink" title="调用指定的属性*"></a>调用指定的属性*</h5><p>先指定一个Person类，类中要有一个空参public构造器，方便newInstance()方法生成Person的对象per&#96;&#96;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<span class="hljs-comment">//私有属性name</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> age;<span class="hljs-comment">//私有属性age</span><br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>    <span class="hljs-comment">//空参构造器</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;person()&quot;</span>);<br>    &#125;<br><span class="hljs-comment">//私有方法show</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">(<span class="hljs-type">int</span> age, String name)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;这是show方法&quot;</span>);<br>        System.out.println(age + name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>关于属性的调用：get&#x2F;set方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">reflectTest</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        Class&lt;Person&gt; clazz = Person.class;<span class="hljs-comment">//构建Class实例Clazz</span><br>        <span class="hljs-type">Person</span> <span class="hljs-variable">per</span> <span class="hljs-operator">=</span> clazz.newInstance();<span class="hljs-comment">//通过Clazz对象调用方法构建Person对象per</span><br>        <span class="hljs-comment">//以下代码是获取公有属性</span><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> clazz.getField(<span class="hljs-string">&quot;age&quot;</span>);<span class="hljs-comment">//通过getField方法获取到public属性</span><br>        field.setInt(per,<span class="hljs-number">18</span>);<span class="hljs-comment">//设置对象per的属性age为18</span><br>        System.out.println(field.get(per));<br>        <span class="hljs-comment">//以下代码是获取私有属性</span><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">field1</span> <span class="hljs-operator">=</span> clazz.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);<span class="hljs-comment">//通过getDeclaredFiled方法获取到private属性</span><br>        field1.setAccessible(<span class="hljs-literal">true</span>);<span class="hljs-comment">//设置私有属性可访问为true</span><br>        field1.set(per,<span class="hljs-string">&quot;XIAOBAI&quot;</span>);<span class="hljs-comment">//给per对象的name属性设置为XIOABAI</span><br>        System.out.println(field1.get(per));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>关于方法的调用：invoke方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    Class&lt;Person&gt; clazz = Person.class;<span class="hljs-comment">//构建Class实例Clazz</span><br>    <span class="hljs-type">Person</span> <span class="hljs-variable">per</span> <span class="hljs-operator">=</span> clazz.newInstance();<span class="hljs-comment">//通过Clazz对象调用方法构建Person对象per</span><br>    <span class="hljs-comment">//以下代码是获取私有方法</span><br>    <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> clazz.getDeclaredMethod(<span class="hljs-string">&quot;show&quot;</span>, <span class="hljs-type">int</span>.class, String.class);<span class="hljs-comment">//通过clazz对象调用方法获取show方法，在这里要写实参类型.class</span><br>    method.setAccessible(<span class="hljs-literal">true</span>);<span class="hljs-comment">//设置私有方法可访问为true</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">invoke</span> <span class="hljs-operator">=</span> method.invoke(per, <span class="hljs-number">22</span>,<span class="hljs-string">&quot;Xiaobai&quot;</span>);<span class="hljs-comment">//用per对象来调用方法，写入实参</span><br>&#125;<br></code></pre></td></tr></table></figure><p><em>注：invoke方法的返回值即为调用方法的返回值，如果是void方法则会返回null</em></p><hr><p>调用静态属性的时候，不需要对象per去调用，使用Clazz实例clazz或Person.class（指代此类）去调用即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//设name属性为私有静态属性</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    Class&lt;Person&gt; clazz = Person.class;<span class="hljs-comment">//构建Class实例Clazz</span><br>    <span class="hljs-comment">//以下代码是获取静态私有属性</span><br>    <span class="hljs-type">Field</span> <span class="hljs-variable">field1</span> <span class="hljs-operator">=</span> clazz.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);<span class="hljs-comment">//通过getDeclaredFiled方法获取到private属性</span><br>    field1.setAccessible(<span class="hljs-literal">true</span>);<span class="hljs-comment">//设置私有属性可访问为true</span><br>    field1.set(Person.class,<span class="hljs-string">&quot;XIAOBAI&quot;</span>);<span class="hljs-comment">//给Person.class静态对象的name属性设置为XIAOBAI</span><br>    System.out.println(field1.get(Person.class));<br></code></pre></td></tr></table></figure><hr><p>调用静态属性的时候，不需要对象per去调用，使用Clazz实例clazz或Person.class（指代此类）或<strong>null</strong>去调用即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//设show方法为私有静态方法</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    Class&lt;Person&gt; clazz = Person.class;<span class="hljs-comment">//构建Class实例Clazz</span><br>    <span class="hljs-type">Person</span> <span class="hljs-variable">per</span> <span class="hljs-operator">=</span> clazz.newInstance();<span class="hljs-comment">//通过Clazz对象调用方法构建Person对象per</span><br>    <span class="hljs-comment">//以下代码是获取私有方法</span><br>    <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> clazz.getDeclaredMethod(<span class="hljs-string">&quot;show&quot;</span>, <span class="hljs-type">int</span>.class, String.class);<span class="hljs-comment">//通过clazz对象调用方法获取show方法，在这里要写实参类型.class</span><br>    method.setAccessible(<span class="hljs-literal">true</span>);<span class="hljs-comment">//设置私有方法可访问为true</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">invoke</span> <span class="hljs-operator">=</span> method.invoke(<span class="hljs-literal">null</span>, <span class="hljs-number">22</span>,<span class="hljs-string">&quot;Xiaobai&quot;</span>);<span class="hljs-comment">//null或clazz来调用方法，写入实参</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><p>调用构造器，和调用方法的区别是不需要写入方法名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    Class&lt;Person&gt; clazz = Person.class;<br>    <span class="hljs-comment">//通过getDeclaredConstructor方法返回一个构造器，写入形参 </span><br>    Constructor&lt;Person&gt; constructor = clazz.getDeclaredConstructor(String.class, <span class="hljs-type">int</span>.class);<br>    constructor.setAccessible(<span class="hljs-literal">true</span>);<br>    <span class="hljs-comment">//使用newInstance方法生成一个对象，并写入构造器实参</span><br>    <span class="hljs-type">Person</span> <span class="hljs-variable">per</span> <span class="hljs-operator">=</span> constructor.newInstance(<span class="hljs-string">&quot;XIAOBAI&quot;</span>, <span class="hljs-number">18</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><em>对比通过Class实例调用newInstance()方法，使用Constructor调用newInstance()创建实例的方法，因为constructor.setAccessible(true);语句的原因，所以不要求构造器public，因为后面也可以写入形参，所以不要求构造器空参</em></p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>JAVASE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>注解</title>
    <link href="/2024/03/18/%E6%B3%A8%E8%A7%A3/"/>
    <url>/2024/03/18/%E6%B3%A8%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><p>Annotation以 <em>@注解名</em>的方式在代码中存在</p><p>Annotation可以像修饰符一样使用，可用于修饰包、类、构造器、方法、成员变量、参数、局部变量的声明</p><p>还可以添加一些参数值，这些信息被保存在Annotation的”name &#x3D; value”键值对中</p><hr><h3 id="注解和注释"><a href="#注解和注释" class="headerlink" title="注解和注释"></a>注解和注释</h3><p>注解和注释是截然不同的</p><p>注释是给人看的，不参与java文件的编译</p><p>注解是给计算机看的，程序根据注解的不同，做出的响应的处理</p><hr><h3 id="Java基础阶段常用注解"><a href="#Java基础阶段常用注解" class="headerlink" title="Java基础阶段常用注解"></a>Java基础阶段常用注解</h3><table><thead><tr><th>注解名</th><th>说明</th></tr></thead><tbody><tr><td>@Override</td><td>限定重写父类方法，该注释只能用于方法</td></tr><tr><td>@Deprecated</td><td>用于表示所修饰的元素已过时，通常是因为其结构危险或者有更好的选择</td></tr><tr><td>@SuppressWarnings</td><td>抑制编译器警告</td></tr></tbody></table><hr><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>元注解就是用来修饰注解的注解，它们被用来提供对其他annotation类型作说明</p><ul><li><strong>@Target：用于描述注解的使用范围</strong><ul><li>是一个枚举类型，表明该注解可修饰哪些结构</li></ul></li><li><strong>@Retention：用于描述注解的生命周期</strong><ul><li>是一个枚举类型，表明该注解是在源码中，加载类时，还是运行时被销毁</li></ul></li><li>@Documented：表明这个注解应该被javadoc工具记录</li><li>@Inherited：允许子类继承父类的注解</li></ul><hr><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><ul><li>单元测试类必须是public的，非抽象的，<strong>包含唯一的无参构造器</strong></li><li>@Test标记的方法本事必须是public，非抽象的，非静态的，void无返回值，没有形参的</li></ul><p><em>注：在单元测试中使用scanner对象输入时，需要将vm虚拟机加入以下参数</em></p><blockquote><p>-Deditable.java.test.console&#x3D;true</p></blockquote><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>JAVASE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>枚举类</title>
    <link href="/2024/03/17/%E6%9E%9A%E4%B8%BE%E7%B1%BB/"/>
    <url>/2024/03/17/%E6%9E%9A%E4%B8%BE%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h1><p>枚举类本质上是一个类，只不过这个类的对象是有限个的，不能让用户随便创建</p><p>枚举类的例子很多，比如说星期、月份、性别、订单状态、支付方式、线程状态等</p><blockquote><p>开发中，如果针对于某个类，其实例是确定个数的，则推荐将此类声明为枚举类</p></blockquote><p><em>如果枚举类的实例只有一个，则可以看作是单例的实现方式</em></p><hr><h5 id="枚举类方法"><a href="#枚举类方法" class="headerlink" title="枚举类方法"></a>枚举类方法</h5><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>toString()</td><td>在重写前，返回被调用的对象。可通过重写显示想要的内容</td></tr><tr><td>name()</td><td>和没重写的toString()功能相同，返回当前对象的内容</td></tr><tr><td>values()</td><td>返回枚举类型所有对象，通常用来遍历枚举类型用</td></tr><tr><td>valueOf(String objName)</td><td>根据对象名找到该对象</td></tr><tr><td>ordinal()</td><td><em>此方法非静态，用来查询此对象在枚举类生成次序</em></td></tr></tbody></table><hr><p><em><strong>在实际开发中，枚举类型其实只需要这样写，代表着一个只有四个类型的构造类型</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Status</span> &#123;<br>    <span class="hljs-comment">//在职,空闲,假期,离职;</span><br>    BUSY,FREE,VOCATION,DIMISSION;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="枚举类实例"><a href="#枚举类实例" class="headerlink" title="枚举类实例"></a>枚举类实例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SeasonTest1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(Season1.SPRING.name());<span class="hljs-comment">//SPRING</span><br>        System.out.println(Season1.SUMMER);<span class="hljs-comment">//Season1&#123;seasonName=&#x27;夏天&#x27;, SeasonDesc=&#x27;夏日炎炎&#x27;&#125;</span><br>        Season1[] values = Season1.values();<br>        <span class="hljs-keyword">for</span> (Season1 value : values) &#123;<br>            System.out.println(value);<br>        &#125;<br>        <span class="hljs-comment">/*Season1&#123;seasonName=&#x27;春天&#x27;, SeasonDesc=&#x27;春暖花开&#x27;&#125;</span><br><span class="hljs-comment">            Season1&#123;seasonName=&#x27;夏天&#x27;, SeasonDesc=&#x27;夏日炎炎&#x27;&#125;</span><br><span class="hljs-comment">            Season1&#123;seasonName=&#x27;秋天&#x27;, SeasonDesc=&#x27;秋高气爽&#x27;&#125;</span><br><span class="hljs-comment">            Season1&#123;seasonName=&#x27;冬天&#x27;, SeasonDesc=&#x27;白雪皑皑&#x27;&#125;*/</span><br>        System.out.println(Season1.valueOf(<span class="hljs-string">&quot;AUTUMN&quot;</span>));<span class="hljs-comment">//Season1&#123;seasonName=&#x27;秋天&#x27;, SeasonDesc=&#x27;秋高气爽&#x27;&#125;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Season1</span> &#123;<br>    <span class="hljs-comment">//本质上是public static final Season SPRING = new Season(&quot;春天&quot;, &quot;春暖花开&quot;);</span><br>    <span class="hljs-comment">//枚举类的声明的实例应该是静态常量，但在枚举类型类中，必须省略 public static final</span><br>    SPRING(<span class="hljs-string">&quot;春天&quot;</span>, <span class="hljs-string">&quot;春暖花开&quot;</span>),<br>    SUMMER(<span class="hljs-string">&quot;夏天&quot;</span>, <span class="hljs-string">&quot;夏日炎炎&quot;</span>),<br>    AUTUMN(<span class="hljs-string">&quot;秋天&quot;</span>, <span class="hljs-string">&quot;秋高气爽&quot;</span>),<br>    WINTER(<span class="hljs-string">&quot;冬天&quot;</span>, <span class="hljs-string">&quot;白雪皑皑&quot;</span>);<br>    <span class="hljs-comment">//类中属性是不需要静态的，毕竟是多个在类中声明的对象 </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String seasonName;<span class="hljs-comment">//季节的名称</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String SeasonDesc;<span class="hljs-comment">//季节的描述</span><br>    <span class="hljs-comment">//将构造方法私有化</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Season1</span><span class="hljs-params">(String seasonName, String seasonDesc)</span> &#123;<br>        <span class="hljs-built_in">this</span>.seasonName = seasonName;<br>        SeasonDesc = seasonDesc;<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getSeasonName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> seasonName;<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getSeasonDesc</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> SeasonDesc;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Season1&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;seasonName=&#x27;&quot;</span> + seasonName + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, SeasonDesc=&#x27;&quot;</span> + SeasonDesc + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="枚举类实现接口操作"><a href="#枚举类实现接口操作" class="headerlink" title="枚举类实现接口操作"></a>枚举类实现接口操作</h5><ul><li>枚举类实现接口，直接在枚举类中重写接口的抽象方法，使用不同的枚举类对象调用此方法时，执行的同一个方法</li><li>枚举类实现接口，在枚举类的每一个实例中重写接口的抽象方法，使得不同的实例在调用该方法时执行不同的方法</li></ul><h5 id="枚举类实现接口实例"><a href="#枚举类实现接口实例" class="headerlink" title="枚举类实现接口实例"></a>枚举类实现接口实例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.sun.xml.internal.ws.api.model.wsdl.WSDLOutput;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SeasonTest3</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Season1.SPRING.show();<span class="hljs-comment">//春天在哪里</span><br>        Season1.SUMMER.show();<span class="hljs-comment">//宁静的夏天</span><br>        Season1.AUTUMN.show();<span class="hljs-comment">//秋意浓</span><br>        Season1.WINTER.show();<span class="hljs-comment">//大约在冬季</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Show</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Season1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Show</span>&#123;<br>    <span class="hljs-comment">//本质上是public static final Season SPRING = new Season(&quot;春天&quot;, &quot;春暖花开&quot;);</span><br>    <span class="hljs-comment">//枚举类的声明的实例应该是静态常量，但在枚举类型类中，必须省略 public static final</span><br>    SPRING(<span class="hljs-string">&quot;春天&quot;</span>, <span class="hljs-string">&quot;春暖花开&quot;</span>)&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;春天在哪里&quot;</span>);<br>        &#125;<br>    &#125;,<br>    SUMMER(<span class="hljs-string">&quot;夏天&quot;</span>, <span class="hljs-string">&quot;夏日炎炎&quot;</span>)&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;宁静的夏天&quot;</span>);<br>        &#125;<br>    &#125;,<br>    AUTUMN(<span class="hljs-string">&quot;秋天&quot;</span>, <span class="hljs-string">&quot;秋高气爽&quot;</span>)&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;秋意浓&quot;</span>);<br>        &#125;<br>    &#125;,<br>    WINTER(<span class="hljs-string">&quot;冬天&quot;</span>, <span class="hljs-string">&quot;白雪皑皑&quot;</span>)&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;大约在冬季&quot;</span>);<br>        &#125;<br>    &#125;;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String seasonName;<span class="hljs-comment">//季节的名称</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String SeasonDesc;<span class="hljs-comment">//季节的描述</span><br>    <span class="hljs-comment">//将构造方法私有化（在enum中，构造方法一定是私有化的，不需要额外添加private参数）</span><br>    Season1(String seasonName, String seasonDesc) &#123;<br>        <span class="hljs-built_in">this</span>.seasonName = seasonName;<br>        SeasonDesc = seasonDesc;<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getSeasonName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> seasonName;<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getSeasonDesc</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> SeasonDesc;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;meijulei.Season1&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;seasonName=&#x27;&quot;</span> + seasonName + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, SeasonDesc=&#x27;&quot;</span> + SeasonDesc + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p><em><strong>在对象中可以直接重写类中方法</strong></em></p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>JAVASE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>反射-类的加载</title>
    <link href="/2024/03/17/%E5%8F%8D%E5%B0%84-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/"/>
    <url>/2024/03/17/%E5%8F%8D%E5%B0%84-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<h1 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h1><h3 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h3><ul><li>类的装载（loading）</li></ul><p>将类的.class文件读入内存，并位置创建一个java.lang.Class对象。此过程由类加载器完成</p><ul><li><p>链接（linking）</p><ul><li>验证（Verify）：确认读取的文件是合规的文件</li><li>准备（Prepare）：为类变量（static）分配内存和赋初值</li><li>解析（Res olve）：将常量池内的符号引用（常量名）替换为直接引用（地址）的过程</li></ul></li><li><p>初始化（initialization）</p></li></ul><p>执行类构造器&lt;clinit&gt;()的过程，此方法是由编译器自动收集所有类变量的赋值动作和静态代码块中的语句合并产生的</p><hr><h3 id="类加载器的分类"><a href="#类加载器的分类" class="headerlink" title="类加载器的分类"></a>类加载器的分类</h3><ul><li>启动类装载器（Bootstrap ClassLoader）：加载核心库，使用C&#x2F;C++语言编写</li><li>继承于ClassLoader<ul><li>扩展类装载器（Exension ClassLoader）：加载jre&#x2F;lib库中的除核心库外的扩展库</li><li>应用程序类装载器（ApplicationClassLoader）&#x2F;系统类加载器（SystemClassLoader）：我们自定义的类，默认能使用的类加载器</li><li>用户自定义类装载器</li></ul></li></ul><h3 id="使用自定义加载器加载IO流"><a href="#使用自定义加载器加载IO流" class="headerlink" title="使用自定义加载器加载IO流*"></a>使用自定义加载器加载IO流*</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.InputStream;<br><span class="hljs-keyword">import</span> java.util.Properties;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">//新建properties集合</span><br>        <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>        <span class="hljs-comment">//使用自定义加载器从文件中加载IO流</span><br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> ClassLoader.getSystemClassLoader().getResourceAsStream(<span class="hljs-string">&quot;info.properties&quot;</span>);<br>        properties.load(is);<br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><hr><p><em>注：使用类加载器读取文件时，相对路经是在module文件夹下的src文件夹下</em></p><p><em>而使用File流读取文件的相对目录则是在module根目录下</em></p><hr><h3 id="类加载器加载文件的使用方式"><a href="#类加载器加载文件的使用方式" class="headerlink" title="类加载器加载文件的使用方式"></a>类加载器加载文件的使用方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-built_in">this</span>.getClass()  <span class="hljs-comment">// getClass() 返回:表示此对象的运行时类的Class对象。</span><br>    .getClassLoader()   <span class="hljs-comment">// 返回:装入此对象表示的类或接口的类装入器。</span><br>    .getResourceAsStream(<span class="hljs-string">&quot;process/process.zip&quot;</span>);<br><br><br><span class="hljs-built_in">this</span>.getClass()  <span class="hljs-comment">// getClass() 返回:表示此对象的运行时类的Class对象</span><br>    .getResourceAsStream(<span class="hljs-string">&quot;process/process.zip&quot;</span>);  <br><br><span class="hljs-comment">//使用ClassLoader静态类中的静态方法获取当前类加载器</span><br>ClassLoader.getSystemClassLoader().getResourceAsStream(<span class="hljs-string">&quot;process/process.zip&quot;</span>);<br></code></pre></td></tr></table></figure><ul><li><p>this.getClass().getClassLoader().getResourceAsStream(“process&#x2F;process.zip”)： 这种方式使用类加载器（ClassLoader）来加载资源文件。类加载器是用于加载类的机制，并且每个类加载器都有自己的类加载路径。getResourceAsStream方法的路径是相对于类加载器的根路径。因此，”process&#x2F;process.zip” 这个路径将相对于类加载器的根路径来定位资源文件。</p><ul><li>在一些情况下，特别是当使用不同的类加载器（例如自定义类加载器）加载类时，this.getClass().getClassLoader().getResourceAsStream(“process&#x2F;process.zip”) 可能更可靠，因为它直接使用类加载器的路径，不受当前类的位置的影响。</li></ul></li><li><p>this.getClass().getResourceAsStream(“process&#x2F;process.zip”)： 这种方式使用当前类的类加载器来加载资源文件。getResourceAsStream方法的路径是相对于当前类所在的包路径（package path）。换句话说，它会在当前类的包路径下寻找资源文件。</p><ul><li>这种方式适用于当前类和资源文件在同一个包路径下的情况。如果资源文件与当前类在不同的包路径下，或者资源文件位于类加载器的根路径（Classpath根目录）下，这种方式可能会失败，因为它是相对于当前类所在的包路径来定位资源文件。</li></ul></li><li><p>ClassLoader.getSystemClassLoader().getResourceAsStream(“process&#x2F;process.zip”);：这种方式和第二种方式相同，区别是使用了静态类和静态方法，路径也是包路径</p></li></ul><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>JAVASE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>反射</title>
    <link href="/2024/03/17/%E5%8F%8D%E5%B0%84/"/>
    <url>/2024/03/17/%E5%8F%8D%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>Java程序中，所有的对象都有两种类型：编译时类型和运行时类型，很多对象的编译时类型和运行时类型不一致。</p><p><em>多态： Object obj &#x3D; new String(“hello”);</em></p><p>当程序完全知道编译时和运行时的完成信息，这种情况下不需要使用反射</p><p>当程序需要靠运行时信息来调用对象和类的真实信息时，必须要用到反射</p><h3 id="反射的定义"><a href="#反射的定义" class="headerlink" title="反射的定义"></a>反射的定义</h3><p>Reflection 是被视为动态语言的关键，反射机制允许程序在运行期间借助于Reflection API取得任何类的内部信息，并能直接操作任意对象内部的属性和方法。</p><p><em>利用反射，我们可以直接对运行时类中私有的方法和属性进行操作（暴力反射）</em></p><blockquote><p>从我们作为开发者角度来讲，我们开发中主要是完成业务代码，对于相关对象和方法的调用都是确定的，所以我们基本不会用到反射</p></blockquote><blockquote><p>因为反射的特性是动态性（可以在运行时动态获取对象所属的类，动态的调用相关的方法），所以在设计框架时会使用大量的反射</p></blockquote><p><em>框架 &#x3D; 注解 + 反射 + 设计模式</em></p><h3 id="反射的问题"><a href="#反射的问题" class="headerlink" title="反射的问题"></a>反射的问题</h3><p>通过反射，可以调用类中私有的结构，这与对象的封装性有冲突</p><p>封装性体现的是是否建议我们调用内部api的问题</p><p>而类被加载到内存中，我们当然是有能力去调用</p><hr><h3 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h3><p>Class类的本质其实是.java文件经过编译后的.class文件加载（类的加载器）到内存中（存放在方法区），对应的结构即为Class的一个实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Person.class;<span class="hljs-comment">//运行时类</span><br></code></pre></td></tr></table></figure><p><em>注：此时不使用class作为对象名，是因为class为关键字不能作为对象名</em></p><p><em>Class是反射的源头</em></p><hr><h3 id="获取Class的三种方法"><a href="#获取Class的三种方法" class="headerlink" title="获取Class的三种方法"></a>获取Class的三种方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//通过Person类获取Class</span><br><span class="hljs-type">Class</span> <span class="hljs-variable">clazz1</span> <span class="hljs-operator">=</span> Person.class;<br><span class="hljs-comment">//通过对象.getClass()返回其类的Class</span><br><span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br><span class="hljs-type">Class</span> <span class="hljs-variable">class2</span> <span class="hljs-operator">=</span> user.getClass();<br><span class="hljs-comment">//通过Class的静态方法forName(String className)返回一个Class</span><br><span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;com.xiaobai.test.User&quot;</span>; <span class="hljs-comment">//这里的参数应为全类名</span><br><span class="hljs-type">Class</span> <span class="hljs-variable">class3</span> <span class="hljs-operator">=</span> Class.forName(className);<br></code></pre></td></tr></table></figure><p><em>注：同一个类只有一个Class类的对象，也就是说，运行时类在内存中缓存起来，在整个执行期间，只会加载一次</em></p><hr><h3 id="反射相关的API"><a href="#反射相关的API" class="headerlink" title="反射相关的API"></a>反射相关的API</h3><blockquote><p>java.lang.Class ：代表一个类  </p><p>java.lang.reflectMethod：代表类的方法</p><p>java.lang.Field：代表类的成员变量</p><p>java.lang.reflect.Constructor：代表类的构造器</p></blockquote><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>JAVASE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>单例模式</title>
    <link href="/2024/03/17/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2024/03/17/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>单例设计模式，就是采用一定方法保证在整个软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法</p><h3 id="饿汉式方法实现单例模式"><a href="#饿汉式方法实现单例模式" class="headerlink" title="饿汉式方法实现单例模式"></a>饿汉式方法实现单例模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bank</span>&#123;<br>    <span class="hljs-comment">//私有化构造方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Bank</span><span class="hljs-params">()</span>&#123;<br><br>    &#125;<br>    <span class="hljs-comment">//直接声明对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Bank</span> <span class="hljs-variable">bank</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bank</span>();<br>    <span class="hljs-comment">//通过静态方法返回该对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Bank <span class="hljs-title function_">getBank</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> bank;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="懒汉式方法实现单例模式"><a href="#懒汉式方法实现单例模式" class="headerlink" title="懒汉式方法实现单例模式"></a>懒汉式方法实现单例模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bank</span>&#123;<br>    <span class="hljs-comment">//私有化构造方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Bank</span><span class="hljs-params">()</span>&#123;<br><br>    &#125;<br>    <span class="hljs-comment">//声明对象为空</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Bank</span> <span class="hljs-variable">bank</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">//在调用get方法是实例化对象，再通过静态方法返回该对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Bank <span class="hljs-title function_">getBank</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//如果bank为空，则实例化bank</span><br>        <span class="hljs-keyword">if</span> (bank == <span class="hljs-literal">null</span>)&#123;<br>            bank = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bank</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> bank;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="对比两种方式的区别"><a href="#对比两种方式的区别" class="headerlink" title="对比两种方式的区别"></a>对比两种方式的区别</h3><blockquote><p>饿汉式立即加载（随着类的加载而加载），懒汉式延迟加载（在需要使用时创建）</p><p>饿汉式写法简单，由于内存中较早加载，使用更方便更快。但在内存中占用时间长。<strong>线程安全</strong></p><p>懒汉式在需要的时候创建，节省内存空间，<strong>线程不安全</strong></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>JAVASE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>网络编程</title>
    <link href="/2024/03/10/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <url>/2024/03/10/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h3 id="InetAddress的使用"><a href="#InetAddress的使用" class="headerlink" title="InetAddress的使用"></a>InetAddress的使用</h3><p>实例化方法：</p><ul><li>InetAddressget ByName(String host) 使用IP地址或域名作为形参，生成一个IP地址的对象</li><li>InetAddressget LocalHost() 获取本机IP地址生成一个IP地址的对象</li></ul><p>此类使用两个静态实例化方法，其对象就是一个IP地址，</p><p>常用方法：</p><ul><li>getAddress() 返回IP地址</li><li>getHostAddress 返回域名</li></ul><hr><h3 id="TCP和UDP"><a href="#TCP和UDP" class="headerlink" title="TCP和UDP"></a>TCP和UDP</h3><h5 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h5><ul><li>TCP的进程：客户端、服务端</li><li>先建立链接才能使用</li><li>三次握手，点对点通信，是可靠的</li><li>连接时有大量数据传输</li><li>传输完毕，需释放已经建立的链接，效率低</li></ul><h5 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h5><ul><li>UDP的进程：发送端、接收端</li><li>将数据封装成包，不需要建立链接</li><li>不保证数据的完整性，是不可靠的</li><li>一个数据包的大小限制到64K内</li><li>发送数据结束时，无需释放资源，开销小，通信效率高</li></ul><hr><h5 id="TCP案例"><a href="#TCP案例" class="headerlink" title="TCP案例"></a>TCP案例</h5><p>客户端发送数据，服务端保存数据</p><table><thead><tr><th>客户端</th><th>服务端</th></tr></thead><tbody><tr><td>1.创建Socket <em>指明对方的服务器端的IP地址和端口号</em></td><td>1.创建Server Socket</td></tr><tr><td>2.创建File的实例、FileInputStream的实例</td><td>2.接收来自于客户端的socket:accept() <em>二次握手</em></td></tr></tbody></table><ol start="3"><li>通过Socket，获取输出流 <em>读写数据</em>|3.通过socket获取一个输入流<br>4.关闭相关流|4.创建File类的实例、FileOutStream的实例<br>|5.关闭相关流</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.net.InetAddress;<br><span class="hljs-keyword">import</span> java.net.ServerSocket;<br><span class="hljs-keyword">import</span> java.net.Socket;<br><span class="hljs-keyword">import</span> java.nio.charset.StandardCharsets;<br><span class="hljs-comment">//注意：因为涉及到相关资源的关闭，所以需要使用try、catch、finally处理异常</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TCPTest2</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">client</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">//1.创建Socket</span><br>        <span class="hljs-comment">//指明对方的服务器端的IP地址和端口号</span><br>        <span class="hljs-type">InetAddress</span> <span class="hljs-variable">inetAddress</span> <span class="hljs-operator">=</span> InetAddress.getByName(<span class="hljs-string">&quot;127.0.0.1&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">port</span> <span class="hljs-operator">=</span> <span class="hljs-number">9091</span>;<br>        <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(inetAddress, port);<br>        <span class="hljs-comment">//2.创建File的实例、FileInputStream的实例</span><br>        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;pic.jpg&quot;</span>));<br>        <span class="hljs-comment">//3. 通过Socket，获取输出流</span><br>        <span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> socket.getOutputStream();<br>        <span class="hljs-comment">// 读写数据</span><br>        <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-type">int</span> len;<br>        <span class="hljs-keyword">while</span> ((len = fis.read(bytes)) != -<span class="hljs-number">1</span>) &#123;<br>            os.write(bytes, <span class="hljs-number">0</span>, len);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;数据发送完毕&quot;</span>);<br><br>        <span class="hljs-comment">//客户端表明不再继续发送数据，如果不表明，服务端将不知道发没法完，只有shutdown和close才能表明发送完成</span><br>        socket.shutdownOutput();<br><br>        <span class="hljs-comment">//接收来自于服务器端的数据</span><br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> socket.getInputStream();<br>        <span class="hljs-type">byte</span>[] bytes1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-type">int</span> len1;<br>        <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">baos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>        <span class="hljs-keyword">while</span> ((len1 = is.read(bytes1)) != -<span class="hljs-number">1</span>) &#123;<br>            baos.write(bytes1,<span class="hljs-number">0</span>,len1);<br>        &#125;<br>        System.out.println(baos);<br>        <span class="hljs-comment">//4.关闭Socket相关的流</span><br>        is.close();<br>        baos.close();<br>        os.close();<br>        fis.close();<br>        socket.close();<br>    &#125;<br><br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">server</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">//1.创建Server Socket</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">port</span> <span class="hljs-operator">=</span> <span class="hljs-number">9091</span>;<br>        <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(port);<br>        <span class="hljs-comment">//2.接收来自于客户端的socket:accept() 二次握手</span><br>        <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> serverSocket.accept();<br>        <span class="hljs-comment">//3.通过socket获取一个输入流</span><br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> socket.getInputStream();<br>        <span class="hljs-comment">//4.创建File类的实例、FileOutStream的实例</span><br>        <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;pic_copy.jpg&quot;</span>));<br>        <span class="hljs-comment">//读写过程</span><br>        <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-type">int</span> len;<br>        <span class="hljs-keyword">while</span> ((len = is.read(bytes)) != -<span class="hljs-number">1</span>) &#123;<br>            fos.write(bytes, <span class="hljs-number">0</span>, len);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;数据接收完毕&quot;</span>);<br><br>        <span class="hljs-comment">//发送数据回客户端，表示文件收到</span><br>        <span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> socket.getOutputStream();<br>        os.write(<span class="hljs-string">&quot;你的图片很漂亮，我接受到了&quot;</span>.getBytes(StandardCharsets.UTF_8));<br>        <span class="hljs-comment">//5.关闭相关流</span><br>        fos.close();<br>        is.close();<br>        socket.close();<br>        serverSocket.close();<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><hr><p><em>注：在多次反复传输数据时，客户端需使用shutdown和close表明不再继续发送数据，如果不表明，服务端将一直等待客户端发送，形成死锁</em></p><hr><h5 id="UDP案例"><a href="#UDP案例" class="headerlink" title="UDP案例"></a>UDP案例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.junit.Test;<br><br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.net.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UDPTest</span> &#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sender</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//创建DatagramSocket实例（此Socket为UDP传输对象）</span><br>        <span class="hljs-type">DatagramSocket</span> <span class="hljs-variable">ds</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramSocket</span>();<br>        <span class="hljs-comment">//编辑一个包，作为socket发送的参数</span><br>        <span class="hljs-type">InetAddress</span> <span class="hljs-variable">byName</span> <span class="hljs-operator">=</span> InetAddress.getByName(<span class="hljs-string">&quot;127.0.0.1&quot;</span>);<span class="hljs-comment">//ip</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">port</span> <span class="hljs-operator">=</span> <span class="hljs-number">9090</span>;<span class="hljs-comment">//端口号</span><br>        <span class="hljs-type">byte</span>[] bytes = <span class="hljs-string">&quot;我是发送端&quot;</span>.getBytes(<span class="hljs-string">&quot;utf-8&quot;</span>);<span class="hljs-comment">//发送的内容（字符数组）</span><br>        <span class="hljs-type">DatagramPacket</span> <span class="hljs-variable">dp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>(bytes, <span class="hljs-number">0</span>, bytes.length, byName, port);<br>        <span class="hljs-comment">//发送数据</span><br>        ds.send(dp);<br>        ds.close();<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receiver</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">port</span> <span class="hljs-operator">=</span> <span class="hljs-number">9090</span>;<br>        <span class="hljs-comment">//创建DatagramSocket实例</span><br>        <span class="hljs-type">DatagramSocket</span> <span class="hljs-variable">ds</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramSocket</span>(port);<br>        <span class="hljs-comment">//创建数据包对象，用来接收包</span><br>        <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">64</span>];<br>        <span class="hljs-type">DatagramPacket</span> <span class="hljs-variable">dp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>(bytes, <span class="hljs-number">0</span>, bytes.length);<br>        <span class="hljs-comment">//接收数据</span><br>        ds.receive(dp);<br>        <span class="hljs-comment">//读取数据并打印到控制台上</span><br>        java.lang.<span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.lang.String(dp.getData(), <span class="hljs-number">0</span>, dp.getLength());<br>        System.out.println(str);<br>        ds.close();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><h3 id="URL编程"><a href="#URL编程" class="headerlink" title="URL编程"></a>URL编程</h3><p><em>URL(Uniform Resource Locator): 统一资源定位符</em></p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public String getProtocol()</td><td>获取该URL的协议名</td></tr><tr><td>public String getHost()</td><td>获取该URL的主机名</td></tr><tr><td>public String getPort()</td><td>获取该URL的端口号</td></tr><tr><td>public String getPath()</td><td>获取该URL的文件路径</td></tr><tr><td>public String getQuery()</td><td>获取该URL的查询名</td></tr></tbody></table><h5 id="URL编程案例"><a href="#URL编程案例" class="headerlink" title="URL编程案例"></a>URL编程案例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">import</span> java.io.File;<br><span class="hljs-keyword">import</span> java.io.FileOutputStream;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.InputStream;<br><span class="hljs-keyword">import</span> java.net.HttpURLConnection;<br><span class="hljs-keyword">import</span> java.net.URL;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">URLTest1</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">HttpURLConnection</span> <span class="hljs-variable">urlConnection</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//1. 获取URL实例</span><br>            <span class="hljs-type">URL</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(<span class="hljs-string">&quot;https://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png&quot;</span>);<br>            <span class="hljs-comment">//2. 建立http协议url链接</span><br>            urlConnection = (HttpURLConnection) url.openConnection();<br>            <span class="hljs-comment">//3. 从连接中获取输入流读数据</span><br>            is = urlConnection.getInputStream();<br>            <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;dest.jpg&quot;</span>);<br>            <span class="hljs-comment">//4. 将读到的数据写入本地</span><br>            fos = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(file);<br><br>            <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>            <span class="hljs-type">int</span> len;<br>            <span class="hljs-keyword">while</span> ((len = is.read(bytes)) != -<span class="hljs-number">1</span>) &#123;<br>                fos.write(bytes, <span class="hljs-number">0</span>, len);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">//5. 关闭资源</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                fos.close();<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-keyword">try</span> &#123;<br>                is.close();<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            urlConnection.disconnect();<span class="hljs-comment">//关闭url</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>JAVASE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>多线程-创建线程的扩展方式</title>
    <link href="/2024/03/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%89%A9%E5%B1%95%E6%96%B9%E5%BC%8F/"/>
    <url>/2024/03/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%89%A9%E5%B1%95%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="创建线程的扩展方式"><a href="#创建线程的扩展方式" class="headerlink" title="创建线程的扩展方式"></a>创建线程的扩展方式</h1><h3 id="Callable接口"><a href="#Callable接口" class="headerlink" title="Callable接口"></a>Callable接口</h3><p>Callable接口,需重写call方法</p><h5 id="与Runnable方式对比"><a href="#与Runnable方式对比" class="headerlink" title="与Runnable方式对比"></a>与Runnable方式对比</h5><ul><li>call()可以有返回值,更灵活</li><li>call()可以使用throws的方式处理异常,更灵活</li><li>Callable使用了泛型参数,可以具体指明call()的返回值类型,更灵活</li></ul><hr><h3 id="使用线程池"><a href="#使用线程池" class="headerlink" title="使用线程池"></a>使用线程池</h3><p>使用并发的线程数量很多,并且每个线程都是执行一个时间很短的任务就结束了,这样频繁创建线程会大大降低系统效率,因为频繁创建线程和销毁线程需要时间.</p><p>所以我们提前创建好多个线程,放入线程池中,使用时直接获取,使用完放回池中.可以避免频繁创建销毁,实现重复利用.</p><h5 id="此方法的好处"><a href="#此方法的好处" class="headerlink" title="此方法的好处"></a>此方法的好处</h5><ul><li>提高了 程序执行效率(因为线程已经提前创建好了)</li><li>提高了资源的复用率(因为执行完的线程并未销毁,而是可以继续执行其他任务)</li><li>可以设置相关的参数,对线程池中的线程进行管理</li></ul>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>JAVASE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>多线程-综合练习</title>
    <link href="/2024/03/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0/"/>
    <url>/2024/03/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="消费者与生产者"><a href="#消费者与生产者" class="headerlink" title="消费者与生产者"></a>消费者与生产者</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xiaobai.shangguigu.Test;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Clerk</span> &#123;<span class="hljs-comment">//店员</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">productNum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//产品的数量</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addProductNum</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (productNum &gt; <span class="hljs-number">20</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                wait();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            productNum++;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;生产了第&quot;</span> + productNum + <span class="hljs-string">&quot;个产品&quot;</span>);<br>            notifyAll();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">minusProductNum</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (productNum &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                wait();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;消费了第&quot;</span> + productNum + <span class="hljs-string">&quot;个产品&quot;</span>);<br>            productNum--;<br>            notifyAll();<br>        &#125;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Producer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<span class="hljs-comment">//生产者</span><br>    <span class="hljs-keyword">private</span> Clerk clerk;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Producer</span><span class="hljs-params">(Clerk clerk)</span> &#123;<br>        <span class="hljs-built_in">this</span>.clerk = clerk;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;生产者开始生产&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">50</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>            clerk.addProductNum();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Consumer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<span class="hljs-comment">//消费者</span><br>    <span class="hljs-keyword">private</span> Clerk clerk;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Consumer</span><span class="hljs-params">(Clerk clerk)</span> &#123;<br>        <span class="hljs-built_in">this</span>.clerk = clerk;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;消费者正在消费&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">100</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>            clerk.minusProductNum();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//生产者和消费者实例</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProducerConsumerTest</span> &#123;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Clerk</span> <span class="hljs-variable">clerk</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Clerk</span>();<br>        <span class="hljs-type">Producer</span> <span class="hljs-variable">producer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Producer</span>(clerk);<br>        <span class="hljs-type">Consumer</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Consumer</span>(clerk);<br>        producer.setName(<span class="hljs-string">&quot;生产者1&quot;</span>);<br>        consumer.setName(<span class="hljs-string">&quot;消费者1&quot;</span>);<br>        producer.start();<br>        consumer.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>JAVASE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>多线程-线程的通信</title>
    <link href="/2024/03/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1/"/>
    <url>/2024/03/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="线程的通信"><a href="#线程的通信" class="headerlink" title="线程的通信"></a>线程的通信</h1><p>当我们需要多个线程来共同完成一个任务,并且我们希望他们有规律的执行,那么多线程之间需要一些通讯机制,可以协调他们的工作,以此实现多线程共同操作一份数据.</p><hr><h3 id="等待唤醒机制"><a href="#等待唤醒机制" class="headerlink" title="等待唤醒机制"></a>等待唤醒机制</h3><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>wait()</td><td>进入等待状态,<strong>会释放对同步监视器的调用</strong></td></tr><tr><td>notify()</td><td>唤醒被wait()的线程中优先级最高的一个线程(如果有多个并且优先级相同,则随机唤醒)</td></tr><tr><td>notifyAll()</td><td>唤醒所有被wait()的线程</td></tr></tbody></table><p><em>注:此三个方法的使用必须是在同步代码块或同步方法中</em></p><p><em>三个方法的调用者必须是同步监视器,且三个方法都在object类中</em></p><hr><h5 id="线程的交替通行"><a href="#线程的交替通行" class="headerlink" title="线程的交替通行"></a>线程的交替通行</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">package</span> com.xiaobai.shangguigu.Test;<br><br><span class="hljs-comment">//线程通信</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PrintNumber</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">PrintNumberTest</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintNumberTest</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(p1, <span class="hljs-string">&quot;线程1&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(p1, <span class="hljs-string">&quot;线程2&quot;</span>).start();<br><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PrintNumberTest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>                <span class="hljs-built_in">this</span>.notify();<span class="hljs-comment">//唤醒线程</span><br>                <span class="hljs-keyword">if</span> (number &lt;= <span class="hljs-number">100</span>) &#123;<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;:&quot;</span> + number);<br>                    number++;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-built_in">this</span>.wait();<span class="hljs-comment">//等待线程</span><br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="wait-和sleep-的区别"><a href="#wait-和sleep-的区别" class="headerlink" title="wait()和sleep()的区别"></a>wait()和sleep()的区别</h5><p>相同点:一旦执行,当前线程都会进入阻塞状态</p><p>不同点: </p><ul><li>声明的位置不通:wait()声明在Object类中,sleep()声明在Thread类中(静态方法)</li><li>使用场景不同:wait()只能使用在同步代码块(同步方法)中,sleep()可以在任何需要使用的场景</li><li>对”锁”的使用不同:sleep()不会释放同步监视器,而wait()会释放同步监视器</li><li>唤醒方式不同:wait()可以被notify唤醒,或时间结束唤醒,而sleep()只能等事件结束后唤醒</li></ul><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>JAVASE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Typora激活</title>
    <link href="/2024/03/01/Typora%E6%BF%80%E6%B4%BB/"/>
    <url>/2024/03/01/Typora%E6%BF%80%E6%B4%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="Typora激活"><a href="#Typora激活" class="headerlink" title="Typora激活"></a>Typora激活</h1><blockquote><p>下载链接:<a href="https://typoraio.cn/">https://typoraio.cn/</a></p></blockquote><h2 id="第一步-激活Typora"><a href="#第一步-激活Typora" class="headerlink" title="第一步 激活Typora"></a>第一步 激活Typora</h2><p>找到Typora安装目录，依次找到这个文件</p><p>resources\page-dist\static\js\LicenseIndex.**********.********.chunk.js </p><p>用记事本打开它，</p><p>查  找【<strong>e.hasActivated&#x3D;”true”&#x3D;&#x3D;e.hasActivated,</strong>】</p><p>替换为【<strong>e.hasActivated&#x3D;”true”&#x3D;&#x3D;”true”,</strong>】</p><p>保存文件失败的话，可以先保存到桌面，再去替换原来的文件</p><h2 id="第二步-去除软件左下角“未激活”提示"><a href="#第二步-去除软件左下角“未激活”提示" class="headerlink" title="第二步 去除软件左下角“未激活”提示"></a>第二步 去除软件左下角“未激活”提示</h2><p>在Typora安装目录依次找到这个文件</p><p>resources\locales\zh-Hans.lproj\<strong>Panel.json</strong> </p><p>查  找【<strong>“UNREGISTERED”:”未激活”,</strong>】</p><p>替换为【<strong>“UNREGISTERED”:” “,</strong>】</p><h2 id="第三步-会出现的问题"><a href="#第三步-会出现的问题" class="headerlink" title="第三步 会出现的问题"></a>第三步 会出现的问题</h2><p>最后激活成功, 缺点是每次打开软件时都会弹出激活成功的对话框,关掉即可</p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
      <category>note</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设置selinux</title>
    <link href="/2024/02/29/%E8%AE%BE%E7%BD%AEselinux/"/>
    <url>/2024/02/29/%E8%AE%BE%E7%BD%AEselinux/</url>
    
    <content type="html"><![CDATA[<h1 id="设置selinux"><a href="#设置selinux" class="headerlink" title="设置selinux"></a>设置selinux</h1><h3 id="设置SELinux为宽容模式或者临时关闭"><a href="#设置SELinux为宽容模式或者临时关闭" class="headerlink" title="设置SELinux为宽容模式或者临时关闭"></a>设置SELinux为宽容模式或者临时关闭</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#临时改成宽容模式</span><br>setenforce 0<br><span class="hljs-comment">#查看selinux</span><br>getenforce<br></code></pre></td></tr></table></figure><h3 id="永久设置selinux，修改配置文件"><a href="#永久设置selinux，修改配置文件" class="headerlink" title="永久设置selinux，修改配置文件"></a>永久设置selinux，修改配置文件</h3><blockquote><p>&#x2F;etc&#x2F;sysconfig&#x2F;selinux</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#查看，默认配置文件是开启的</span><br><span class="hljs-built_in">cat</span> /etc/sysconfig/selinux<br>SELINUX=enforcing<br><span class="hljs-comment">#禁用selinux</span><br>SELINUX=<span class="hljs-built_in">disable</span><br><span class="hljs-comment">#宽容模式</span><br>SELINUX=Permissive<br></code></pre></td></tr></table></figure><h1 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#关闭防火墙</span><br>systemctl stop firewalld<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
      <category>linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DHCP服务器的配置方法</title>
    <link href="/2024/02/29/DHCP%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95/"/>
    <url>/2024/02/29/DHCP%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="DHCP服务器的配置方法"><a href="#DHCP服务器的配置方法" class="headerlink" title="DHCP服务器的配置方法"></a>DHCP服务器的配置方法</h1><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum -y install dhcp<br></code></pre></td></tr></table></figure><h2 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h2><ul><li>DCHP配置文件位置<ul><li>vim &#x2F;etc&#x2F;dhcp&#x2F;dhcpd.conf<br><em>此时该文件只有几行注释，没有其他配置信息</em></li></ul></li><li>将 &#x2F;usr&#x2F;share&#x2F;doc&#x2F;dhcp*&#x2F;dhcpd.conf.example 拷贝到 &#x2F;etc&#x2F;dhcp&#x2F;dhcpd.conf 按y 确认覆盖<ul><li>cp &#x2F;usr&#x2F;share&#x2F;doc&#x2F;dhcp-4.2.5&#x2F;dhcpd.conf.example &#x2F;etc&#x2F;dhcp&#x2F;dhcpd.conf</li></ul></li><li>更改配置文件中的subnet的网段,子网掩码,分配IP范围,网关和默认DNS服务器</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">subnet 192.168.1.0 netmask 255.255.255.0 &#123;<br>  range 192.168.1.60 192.168.1.80; <span class="hljs-comment">#IP地址区间</span><br>  option routers 192.168.1.1; <span class="hljs-comment">#网关</span><br>  option domain-name-servers 114.114.114.114; <span class="hljs-comment">#DNS服务器地址</span><br>&#125;<br></code></pre></td></tr></table></figure><p><em>本文中配置192.168.1.0网段的ip</em></p><ul><li>开启dhcpd服务<ul><li>systemctl start dhcpd</li></ul></li><li>查看运行状态<ul><li>systemctl status dhcpd</li></ul></li><li>创建用户端测试是否可以被分配IP</li></ul><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>此实验中服务端网卡应尽量使用静态地址,且在DHCP网段中</li><li>此实验如果要在虚拟机中试验,则需要在下载好DHCP服务后将网卡模式调成仅主机连接模式</li><li>在VMware中,虚拟网络编辑器里,将<em>使用本地DHCP服务将IP地址分配给虚拟机</em>取消勾选,否则会使用VMware的DHCP服务器而不是自建的</li></ol>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
      <category>linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>FTP基础命令</title>
    <link href="/2024/02/29/FTP%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"/>
    <url>/2024/02/29/FTP%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="FTP基础命令"><a href="#FTP基础命令" class="headerlink" title="FTP基础命令"></a>FTP基础命令</h1><ul><li><code>ls</code>：列出当前目录中的文件和子目录。</li><li><code>cd &lt;directory&gt;</code>：切换到指定的目录。</li><li><code>get &lt;file&gt;</code>：从服务器下载文件到本地计算机。</li><li><code>put &lt;file&gt;</code>：将本地文件上传到服务器。</li><li><code>delete &lt;file&gt;</code>：删除服务器上的文件。</li><li><code>mkdir &lt;directory&gt;</code>：在服务器上创建新目录。</li><li><code>quit</code>：断开 FTP 连接并退出。</li></ul><p>**请注意: 默认掩码为022 put文件权限为644<br>如果相对其进行ftp的删除和get操作,则需要改变文件权限</p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
      <category>linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>VSFTPD关于虚拟用户的配置方法</title>
    <link href="/2024/02/29/VSFTPD%E5%85%B3%E4%BA%8E%E8%99%9A%E6%8B%9F%E7%94%A8%E6%88%B7%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95/"/>
    <url>/2024/02/29/VSFTPD%E5%85%B3%E4%BA%8E%E8%99%9A%E6%8B%9F%E7%94%A8%E6%88%B7%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="VSFTPD关于虚拟用户的配置方法"><a href="#VSFTPD关于虚拟用户的配置方法" class="headerlink" title="VSFTPD关于虚拟用户的配置方法"></a>VSFTPD关于虚拟用户的配置方法</h1><blockquote><p>在配置文件vim &#x2F;etc&#x2F;vsftpd&#x2F;vsftpd.conf 后添加如下参数</p></blockquote><ul><li>开启虚拟用户组参数</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># ---------开启虚拟用户组参数--------</span><br><span class="hljs-comment"># 开启虚拟用户</span><br>guest_enable=YES<br><span class="hljs-comment"># 主虚拟用户名,使用本机用户zoey</span><br>guest_username=zoey<br><span class="hljs-comment"># 虚拟用户配置（可以对每一个虚拟用户进行单独的权限配置）</span><br>user_config_dir=/etc/vsftpd/vconf<br></code></pre></td></tr></table></figure><ul><li>虚拟用户高级参数（请选择一组）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># ---------虚拟用户高级参数（请选择一组）--------</span><br><span class="hljs-comment"># 虚拟用户和本地用户有相同的权限</span><br>virtual_use_local_privs=YES<br><br><span class="hljs-comment"># 虚拟用户和匿名用户有相同的权限，默认是NO</span><br>virtual_use_local_privs=NO<br><br><span class="hljs-comment"># 虚拟用户具有写权限（上传、下载、删除、重命名）</span><br>virtual_use_local_privs=YES<br>write_enable=YES<br><br><span class="hljs-comment"># 虚拟用户不能浏览目录，只能上传文件，无其他权限</span><br>virtual_use_local_privs=NO<br>write_enable=YES<br>anon_world_readable_only=YES<br>anon_upload_enable=YES<br><br><span class="hljs-comment"># 虚拟用户只能下载文件，无其他权限</span><br>virtual_use_local_privs=NO<br>write_enable=YES<br>anon_world_readable_only=NO<br>anon_upload_enable=NO<br><br><span class="hljs-comment"># 虚拟用户只能上传和下载文件，无其他权限</span><br>virtual_use_local_privs=NO<br>write_enable=YES<br>anon_world_readable_only=NO<br>anon_upload_enable=YES<br><br><span class="hljs-comment"># 虚拟用户只能下载文件和创建文件夹，无其他权限</span><br>virtual_use_local_privs=NO<br>write_enable=YES<br>anon_world_readable_only=NO<br>anon_mkdir_write_enable=YES<br><br><span class="hljs-comment"># 虚拟用户只能下载、删除和重命名文件，无其他权限</span><br>virtual_use_local_privs=NO<br>write_enable=YES<br>anon_world_readable_only=NO<br>anon_other_write_enable=YES<br></code></pre></td></tr></table></figure><h2 id="本文中文件对应的功能"><a href="#本文中文件对应的功能" class="headerlink" title="本文中文件对应的功能"></a>本文中文件对应的功能</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#vsftpd服务总配置文件</span><br>vim /etc/vsftpd/vsftpd.conf<br><span class="hljs-comment">#chroot管理用户文件列表</span><br>vim /etc/vsftpd/chroot_list<br><span class="hljs-comment">#虚拟用户文件(包括账号密码)</span><br>vim /etc/vsftpd/virtusers<br><span class="hljs-comment">#虚拟用户配置文件目录</span><br><span class="hljs-built_in">cd</span> /etc/vsftpd/vconf<br><span class="hljs-comment">#虚拟用户文件目录</span><br><span class="hljs-built_in">cd</span> /home/vsftpd/test<br><span class="hljs-comment">#PAM验证文件</span><br>vim /etc/pam.d/vsftpd<br></code></pre></td></tr></table></figure><h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><ol><li>首先在主配置文件中加入chroot ,可以实现对用户的访问管理</li><li>添加虚拟用户列表(本文中创建了虚拟账户test)</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /etc/vsftpd/virtusers<br><br><span class="hljs-comment">#写入账户和密码</span><br><span class="hljs-built_in">test</span><br>123456<br></code></pre></td></tr></table></figure><ol start="3"><li>对虚拟用户列表生成数据库文件,并给权限</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">db_load -T -t <span class="hljs-built_in">hash</span> -f /etc/vsftpd/virtusers /etc/vsftpd/virtusers.db<br><span class="hljs-comment"># 给虚拟用户数据库文件权限(读写权限即可)</span><br><span class="hljs-built_in">chmod</span> 600 /etc/vsftpd/virtusers.db<br></code></pre></td></tr></table></figure><ol start="4"><li>在PAM中添加vsftpd的虚拟用户的验证</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">auth sufficient /lib64/security/pam_userdb.so db=/etc/vsftpd/virtusers<br>account sufficient /lib64/security/pam_userdb.so db=/etc/vsftpd/virtusers<br></code></pre></td></tr></table></figure><ol start="5"><li>建立虚拟用户配置目录及文件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#创建目录</span><br><span class="hljs-built_in">mkdir</span> -p /etc/vsftpd/vconf<br><span class="hljs-comment">#创建文件</span><br>vim /etc/vsftpd/vconf/test<br><br><span class="hljs-comment">#配置文件内容</span><br><span class="hljs-comment"># 用户 test 配置目录</span><br>local_root=/home/vsftpd/test<br><span class="hljs-comment"># 允许本地用户对FTP服务器文件具有写权限</span><br>write_enable=YES<br>anon_world_readable_only=NO<br><span class="hljs-comment"># 允许匿名用户上传文件(须将全局的write_enable=YES,默认YES)</span><br>anon_upload_enable=YES<br><span class="hljs-comment"># 允许匿名用户创建目录</span><br>anon_mkdir_write_enable=YES<br><span class="hljs-comment"># 允许匿名用户删除和重命名权限(自行添加)</span><br>anon_other_write_enable=YES<br></code></pre></td></tr></table></figure><ol start="6"><li>创建用户目录</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p /home/vsftpd/test<br></code></pre></td></tr></table></figure><ol start="7"><li>将虚拟用户test加入到被chroot控制的列表中,实现虚拟用户只能访问其自身目录</li><li>将虚拟用户文件夹的拥有者变为他自己</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chown</span> zoey.zoey /home/vsftpd/test<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
      <category>linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>vsftpd安装与配置</title>
    <link href="/2024/02/29/vsftpd%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
    <url>/2024/02/29/vsftpd%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="vsftpd安装与配置"><a href="#vsftpd安装与配置" class="headerlink" title="vsftpd安装与配置"></a>vsftpd安装与配置</h1><h2 id="用户类型"><a href="#用户类型" class="headerlink" title="用户类型"></a>用户类型</h2><p>本地用户（local）： 用户在FTP服务器拥有账号，且该账号为本地用户的账号，可以通过自己的账号和口令进行授权登录，登录目录为自己的home目录$HOME<br>虚拟用户（guest）： 用户在FTP服务器上拥有账号，但该账号只能用于文件传输服务。登录目录为某一特定的目录，通常可以上传和下载<br>匿名用户（anonymous）： 用户在FTP服务器上没有账号，登录目录为&#x2F;var&#x2F;ftp</p><blockquote><p>对于vsftpd默认配置是开启了本地用户和匿名用户，可以直接登录的。</p></blockquote><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">首先要查看你是否安装vsftpd</span><br>rpm -qa | grep vsftpd<br><span class="hljs-meta prompt_">#</span><span class="language-bash">安装httpd</span><br>yum install -y vsftpd<br></code></pre></td></tr></table></figure><h2 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h2><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><ul><li>systemctl start vsftpd.service</li></ul><h3 id="测试链接成功与否"><a href="#测试链接成功与否" class="headerlink" title="测试链接成功与否"></a>测试链接成功与否</h3><ul><li>切换回普通用户<ul><li>su <em>用户名</em></li><li>ftp <em>本机IP</em></li><li><em>注: linux中规定默认无法使用root用户登录ftp</em></li></ul></li><li><strong>匿名登陆</strong><ul><li>ftp <em>本机IP</em> </li><li>账户名使用<strong>anonymous</strong>登录(密码为空)</li></ul></li></ul><h3 id="配置vsftpd"><a href="#配置vsftpd" class="headerlink" title="配置vsftpd"></a>配置vsftpd</h3><p>配置文件地址</p><blockquote><p>vim &#x2F;etc&#x2F;vsftpd&#x2F;vsftpd.conf </p></blockquote><ul><li>基础配置文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 首先我们先看一下本身的vsftpd有什么属性吧</span><br><span class="hljs-built_in">cat</span> /etc/vsftpd/vsftpd.conf | grep -v <span class="hljs-string">&quot;#&quot;</span> | more<br><span class="hljs-comment"># 打开vsftpd配置文件</span><br>vim /etc/vsftpd/vsftpd.conf<br>// 基本配置<br><span class="hljs-comment"># 开启匿名登录</span><br>anonymous_enable=YES<br><span class="hljs-comment"># 允许使用本地帐户进行FTP用户登录验证</span><br>local_enable=YES<br><span class="hljs-comment"># 允许写</span><br>write_enable=YES<br><span class="hljs-comment"># 设置本地用户默认文件掩码022</span><br>local_umask=022<br><span class="hljs-comment"># 设置匿名用户的根</span><br>anon_root=/var/ftp/pub<br><span class="hljs-comment"># 允许匿名上传</span><br>anon_upload_enable=YES<br><span class="hljs-comment"># 允许匿名创建新目录</span><br>anon_mkdir_write_enable=YES<br><span class="hljs-comment"># 同时开放其它权限</span><br>anon_other_write_enable=YES<br><span class="hljs-comment"># 可以发送消息当访问某个目录时</span><br>dirmessage_enable=YES<br><span class="hljs-comment"># 开启上传下载记录</span><br>xferlog_enable=YES<br><span class="hljs-comment"># 数据链通过20端口建立</span><br>connect_from_port_20=YES<br><br><span class="hljs-comment"># 允许其它用户上传匿名文件</span><br><span class="hljs-comment">#chown_uploads=YES</span><br><span class="hljs-comment"># 所有用户</span><br><span class="hljs-comment">#chown_username=whoever</span><br><span class="hljs-comment"># 日志保存到</span><br><span class="hljs-comment">#xferlog_file=/var/log/xferlog</span><br><span class="hljs-comment"># 日志标准输出</span><br>xferlog_std_format=YES<br><span class="hljs-comment"># 空闲会话时间</span><br><span class="hljs-comment">#idle_session_timeout=600</span><br><span class="hljs-comment"># 数据连接超时时间</span><br><span class="hljs-comment">#data_connection_timeout=120</span><br><span class="hljs-comment"># 隔离的安全用户</span><br><span class="hljs-comment">#nopriv_user=ftpsecure</span><br><span class="hljs-comment"># 开启异步数据线程</span><br><span class="hljs-comment">#async_abor_enable=YES</span><br><span class="hljs-comment"># 开启ASCII协议上传</span><br>ascii_upload_enable=YES<br><span class="hljs-comment"># 开启ASCII协议下载</span><br>ascii_download_enable=YES<br><span class="hljs-comment"># 开启邮箱验证</span><br><span class="hljs-comment">#deny_email_enable=YES</span><br><span class="hljs-comment"># 拒绝的邮箱列表</span><br><span class="hljs-comment">#banned_email_file=/etc/vsftpd/banned_emails</span><br><br><span class="hljs-comment"># 是否允许直接获取子目录信息</span><br><span class="hljs-comment">#ls_recurse_enable=YES</span><br><span class="hljs-comment"># 监听IPv4</span><br>listen=NO<br><span class="hljs-comment"># 监听IPv6和监听IPv4</span><br>listen_ipv6=YES<br><br><span class="hljs-comment"># 虚拟用户启用pam认证</span><br>pam_service_name=vsftpd<br><span class="hljs-comment"># 用户组管理</span><br>userlist_enable=YES<br><span class="hljs-comment"># 访问控制</span><br>tcp_wrappers=YES<br><br><span class="hljs-comment"># 允使用被动模式</span><br>pasv_enable=YES<br><span class="hljs-comment"># 指定使用被动模式时打开端口的最小值</span><br>pasv_min_port=10060<br><span class="hljs-comment"># 指定使用被动模式时打开端口的最大值。</span><br>pasv_max_port=10090<br><span class="hljs-comment"># 用户宽带限制200kps</span><br><span class="hljs-comment">#local_max_rate=200000</span><br><span class="hljs-comment"># 登录后欢迎内容</span><br>ftpd_banner=Welcome to My FTP service.<br></code></pre></td></tr></table></figure><h2 id="使用chroot配置对用户的管理"><a href="#使用chroot配置对用户的管理" class="headerlink" title="使用chroot配置对用户的管理"></a>使用chroot配置对用户的管理</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 启用限定用户在其主目录下</span><br>chroot_local_user=YES<br><span class="hljs-comment"># 开启用户列表chroot管理</span><br>chroot_list_enable=YES<br><span class="hljs-comment"># chroot管理的用户列表（一行一用户,虚拟用户都要添加进去）</span><br><span class="hljs-comment"># 当设置用户只能在登录目录时，chroot管理的用户为不受限制，否则相反</span><br>chroot_list_file=/etc/vsftpd/chroot_list<br><span class="hljs-comment"># 允许chroot管理用户进行写操作</span><br>allow_writeable_chroot=YES<br></code></pre></td></tr></table></figure><p><em>注: 当chroot_local_user&#x3D;NO时，chroot_list里面配置的用户不可以跳出家目录，当chroot_local_user&#x3D;YES时，chroot_list里面配置的用户可以跳出家目录</em></p><h2 id="匿名用户"><a href="#匿名用户" class="headerlink" title="匿名用户"></a>匿名用户</h2><p>假如你开启了匿名用户，则需要重新修改权限<br>将匿名目录下的 pub 文件夹 赋予匿名用户管理权限：  </p><blockquote><p>chown ftp &#x2F;var&#x2F;ftp&#x2F;pub</p></blockquote><p>在主配置文件中选配参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 设置匿名用户的根</span><br>anon_root=/var/ftp/pub<br><span class="hljs-comment"># 允许匿名上传</span><br>anon_upload_enable=YES<br><span class="hljs-comment"># 允许匿名创建新目录</span><br>anon_mkdir_write_enable=YES<br><span class="hljs-comment"># 同时开放其它权限</span><br>anon_other_write_enable=YES<br></code></pre></td></tr></table></figure><p><em>注: 匿名用户在使用中默认进入&#x2F;var&#x2F;ftp文件夹中,此文件夹不能直接上传文件,可以进入pub文件夹,再进行上传操作</em></p><h2 id="如何实现root登录ftp"><a href="#如何实现root登录ftp" class="headerlink" title="如何实现root登录ftp"></a>如何实现root登录ftp</h2><blockquote><p>vim &#x2F;etc&#x2F;vsftpd&#x2F;ftpusers<br>vim &#x2F;etc&#x2F;vsftpd&#x2F;user_list</p></blockquote><p>分别在这两个文件中对root进行注释<br>将禁用用户登录中将root解禁<br>也可添加用户使其不可通过ftp访问</p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
      <category>linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux 关于 Apache 服务器的配置</title>
    <link href="/2024/02/29/Linux%20%E5%85%B3%E4%BA%8E%20Apache%20%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
    <url>/2024/02/29/Linux%20%E5%85%B3%E4%BA%8E%20Apache%20%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux-关于-Apache-服务器的配置"><a href="#Linux-关于-Apache-服务器的配置" class="headerlink" title="Linux 关于 Apache 服务器的配置"></a>Linux 关于 Apache 服务器的配置</h1><p>通过 Apache 搭建 web静态服务器</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">安装httpd</span><br>yum -y install httpd<br><span class="hljs-meta prompt_">#</span><span class="language-bash">安装字符界面下的浏览器客户端：elinks</span><br>yum install -y elinks<br></code></pre></td></tr></table></figure><h2 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h2><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><ul><li>在&#x2F;var&#x2F;www&#x2F;html <em>(默认主目录中)</em> 创建主页文件(index.html)</li><li>启动httpd服务<ul><li>systemlctl start httpd</li></ul></li><li>使用浏览器或者elinks方式访问本机ip<ul><li>elinks 127.0.0.1</li></ul></li><li>看到主页即说明配置成功</li></ul><h3 id="创建虚拟主机"><a href="#创建虚拟主机" class="headerlink" title="创建虚拟主机"></a>创建虚拟主机</h3><ul><li>在&#x2F;var&#x2F;www&#x2F;html <em>(默认主目录中)</em> 创建目录1 <em>(bai1)</em> 和目录2 <em>(bai2)</em></li><li>在目录1和2中分别创建主页文件创建主页文件(index.html)</li><li>给网卡绑定两个虚拟ip<ul><li><em>本文绑定的虚拟ip为(192.168.198.10、192.168.198.20)</em></li><li><em>虚拟机的网卡名字为ens33</em></li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Shell">ifconfig ens33:1 192.168.198.10<br>ifconfig ens33:2 192.168.198.20<br></code></pre></td></tr></table></figure><ul><li>更改httpd服务配置文件,在其中加入两个虚拟主机的配置文件<ul><li>vim &#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Shell">&lt;VirtualHost 192.168.198.10&gt;<br>DocumentRoot /var/www/html/bai1<br>&lt;Directory &quot;/var/www/html/bai1&quot;&gt;<br>AllowOverRide none<br>Require all granted<br>&lt;/Directory&gt;<br>&lt;/VirtualHost&gt;<br><br>&lt;VirtualHost 192.168.198.20&gt;<br>DocumentRoot /var/www/html/bai2<br>&lt;Directory &quot;var/www/html/bai2&quot;&gt;<br>AllowOverRide none<br>Require all granted<br>&lt;/Directory&gt;<br>&lt;/VirtualHost&gt;<br><br></code></pre></td></tr></table></figure><ul><li>重启httpd服务<ul><li>systemctl restart httpd</li></ul></li><li>使用浏览器或者elinks方式访问虚拟主机 <ul><li>elinks 192.168.198.10</li><li>elinks 192.168.198.20</li></ul></li><li>看到主页内容即配置成功</li></ul><h3 id="基于端口的虚拟主机配置"><a href="#基于端口的虚拟主机配置" class="headerlink" title="基于端口的虚拟主机配置"></a>基于端口的虚拟主机配置</h3><ul><li>临时关闭selinux防火墙 <ul><li>setenforce 0</li></ul></li><li>在&#x2F;var&#x2F;www&#x2F;html <em>(默认主目录中)</em> 创建目录1 <em>(bai88)</em> 和目录2 <em>(bai8081)</em></li><li>在目录1和2中分别创建主页文件创建主页文件(index.html)</li><li>给网卡绑定一个虚拟ip<ul><li><em>本文绑定的虚拟ip为(192.168.198.10、192.168.198.20)</em></li><li><em>虚拟机的网卡名字为ens33</em></li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell">ifconfig ens33:1 192.168.198.100<br></code></pre></td></tr></table></figure><ul><li>更改httpd服务配置文件,在其中加入两个虚拟主机的配置文件<ul><li>vim &#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Shell">&lt;VirtualHost 192.168.198.100:88&gt;<br>DocumentRoot /var/www/html/bai88<br>&lt;Directory &quot;/var/www/html/bai88&quot;&gt;<br>AllowOverRide none<br>Require all granted<br>&lt;/Directory&gt;<br>&lt;/VirtualHost&gt;<br><br>&lt;VirtualHost 192.168.198.100:8081&gt;<br>DocumentRoot /var/www/html/bai8081<br>&lt;Directory &quot;var/www/html/bai8081&quot;&gt;<br>AllowOverRide none<br>Require all granted<br>&lt;/Directory&gt;<br>&lt;/VirtualHost&gt;<br></code></pre></td></tr></table></figure><ul><li>额外监听端口<em>本文中使用88和8081</em></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Shell">Listen 88<br>Listen 8081<br></code></pre></td></tr></table></figure><ul><li>重启httpd服务<ul><li>systemctl restart httpd</li></ul></li><li>使用浏览器或者elinks方式访问虚拟主机 <ul><li>elinks 192.168.198.100:88</li><li>elinks 192.168.198.100:8081</li></ul></li><li>看到主页内容即配置成功</li></ul><h3 id="使用DNS服务器解析到域名"><a href="#使用DNS服务器解析到域名" class="headerlink" title="使用DNS服务器解析到域名"></a>使用DNS服务器解析到域名</h3><ul><li>在named配置文件中正向解析两个域名到web服务ip</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">TTL 1D</span><br>@IN SOAxiaobai.com. rname.invalid. (<br>0; serial<br>1D; refresh<br>1H; retry<br>1W; expire<br>3H ); minimum<br>NSdns.xiaobai.com.<br>dnsA192.168.198.129<br>wwwA192.168.198.128<br>bai1A192.168.198.10<br>bai2A192.168.198.20<br>baiA192.168.198.100<br></code></pre></td></tr></table></figure><p><em>192.168.198.129为本机ip</em><br><em>192.168.198.10为虚拟主机1ip</em><br><em>192.168.198.20为虚拟主机2ip</em><br><em>192.168.198.100为虚拟主机3ip 绑定端口88和端口8081</em></p><hr><h2 id="2023-10-26新增"><a href="#2023-10-26新增" class="headerlink" title="2023.10.26新增"></a>2023.10.26新增</h2><ul><li>ifconfig ens33:3 192.168.198.30  <em>挂载新的虚拟主机</em></li><li>在vim &#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf 中增加新的文件夹及其index.html网页<blockquote><p>在httpd服务配置文件中vim &#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf增加域名级虚拟主机</p></blockquote></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">&lt;VirtualHost 192.168.198.30&gt;<br>DocumentRoot /var/www/html/bainew1<br>ServerName new1.bai.com<br>&lt;/VirtualHost&gt;<br>&lt;VirtualHost 192.168.198.30&gt;<br>DocumentRoot /var/www/html/bainew2<br>ServerName new2.bai.com<br>&lt;/VirtualHost&gt;<br></code></pre></td></tr></table></figure><blockquote><p>在正向数据库解析文件vim &#x2F;var&#x2F;named&#x2F;named. localhost中配置两个域名访问一个ip</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">TTL 1D</span><br>@       IN SOA  xiaobai.com. rname.invalid. (<br><br>        NS      dns.xiaobai.com.<br>dns     A       192.168.113.129<br>www     A       192.168.113.128<br>new1    A       192.168.198.30<br>new2    A       192.168.198.30<br></code></pre></td></tr></table></figure><ul><li>重启服务<ul><li>systemctl restart named</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
      <category>linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux 关于 DNS 服务器的配置</title>
    <link href="/2024/02/29/Linux%20%E5%85%B3%E4%BA%8E%20DNS%20%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
    <url>/2024/02/29/Linux%20%E5%85%B3%E4%BA%8E%20DNS%20%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux-关于-DNS-服务器的配置"><a href="#Linux-关于-DNS-服务器的配置" class="headerlink" title="Linux 关于 DNS 服务器的配置"></a>Linux 关于 DNS 服务器的配置</h1><p>通过工具 bind 搭建 DNS 服务器 named</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">安装<span class="hljs-built_in">bind</span></span><br>yum install -y bind<br><span class="hljs-meta prompt_">#</span><span class="language-bash">安装工具包</span><br>yum install -y bind-utils<br></code></pre></td></tr></table></figure><h2 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h2><ul><li>记录本机 ip 地址<ul><li>ifconfig <em>实例 ip 为 192.168.113.129</em></li></ul></li><li>配置主文件<ul><li>vim &#x2F;etc&#x2F;named. conf</li></ul></li><li>配置正反向区域文件<ul><li>vim &#x2F;etc&#x2F;named. rfc1912.zones</li></ul></li><li>配置正向数据库文件<ul><li>vim &#x2F;var&#x2F;named&#x2F;named. localhost</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">TTL 1D</span><br>@       IN SOA  xiaobai.com. rname.invalid. (<br><br>        NS      dns.xiaobai.com.<br>dns     A       192.168.113.129<br>www     A       192.168.113.128<br></code></pre></td></tr></table></figure><ul><li>配置反向数据库文件<ul><li>vim &#x2F;var&#x2F;named&#x2F;named.loopback</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">TTL 1D</span><br>@       IN SOA  xiaobai.com. rname.invalid. (<br><br>        NS      dns.xiaobai.com.<br>129     PTR     dns.xiaobai.com.<br>128     PTR     www.xiaobai.com.<br></code></pre></td></tr></table></figure><ul><li>启动 named 服务<ul><li>systemctl start named <em>如果遇到异常问题, 可以通过可以通过 systemctl status named 检查运行状态</em></li></ul></li><li>使用 nslookup 测试 DNS 服务器配置是否成功</li></ul><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p><img src="/upload/DNS%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E6%88%90%E5%8A%9F.jpg" alt="DNS服务器配置成功.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
      <category>linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>基础命令</title>
    <link href="/2024/02/29/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"/>
    <url>/2024/02/29/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h1><ul><li>pwd 显示当前目录</li><li>whoami 显示当前用户</li><li>mkdir 创建目录<ul><li>mkdir -p a&#x2F;b&#x2F;c 创建多级目录</li></ul></li><li>cd 进入目录</li><li>touch 创建文件</li><li>cp 复制文 件<ul><li>cp &#x2F;etc&#x2F;*.conf abc 将&#x2F;etc&#x2F;目录下所有.conf结尾文件复制到目录abc下</li><li>cp -R 复制目录下全部文件到目标目录</li></ul></li><li>mv 移动文件 <ul><li><em>mv的两个参数如果都是文件的话，即为文件更名</em></li></ul></li><li>rmdir 删除目录</li><li>rm 删除文件<ul><li>rm -r 递归删除</li><li>rm -f 强制删除</li><li><em>注：可以通过rm -rf的命令删除非空目录</em></li></ul></li><li>cat 显示文件内容</li><li>more 分屏显示文件内容</li><li>head -n 从头显示n行（默认10行）</li><li>tail -n 从尾显示n行 （默认10行）</li><li>echo 打印字符串或者变量</li><li>find 查找文件<ul><li>find &#x2F;etc -name “*.conf” 查找etc目录下所有.conf文件</li><li>find -size 8 查找8字节文件</li><li>find -type d 查找所有目录文件</li><li>find . -mmin -5 查找当前目录下五分钟之内的文件 <em>.代表当前文件夹</em></li><li>find . -mtime -5 查找当前目录下五天内的文件</li><li>find &#x2F;etc -perm -755 查找etc目录下755权限的文件</li><li><em>可以用-a -o -not参数代表与（and）或（or）非（not）的查询条件</em></li><li>find .-size 0 -exec rm{} \; 查找当前目录下0字节文件并全部删除</li></ul></li><li>which 查看可执行文件的位置<ul><li><em>这个地址只能是PATH中的地址，且自建命令（例如cd）查不到地址</em></li></ul></li><li>whereis 查看文件的位置</li><li>grep 在指定文件中查找包括字符串的行<ul><li>grep “localhost” &#x2F;etc&#x2F;hosts 在文件hosts中查找包含字符串“localhost”所在的行</li><li>grep “localhost” &#x2F;etc&#x2F;*.conf 在所有etc文件夹内所有.conf文件中查找包括”localhost”的行</li><li>grep -v 查找不包含字符串的行</li></ul></li><li>wc 统计指定文件中的数据<ul><li>wc -c 统计字节数</li><li>wc -l 统计行数</li><li>wc -w 统计字数</li></ul></li><li>sort 将文件按行正序输出<ul><li>sort -r将文件按行倒序输出</li></ul></li><li>diff 显示两个文件内容用以比较</li><li>cut 文本提取，以行为单位<ul><li>cut -d: 以:作为分隔符分割文件</li><li>cut -d: -f1 以:作为分隔符分割文件并提取第一个字段</li><li>cut -c 提取文件的第几个字符</li></ul></li></ul><h3 id="管道和重定向"><a href="#管道和重定向" class="headerlink" title="管道和重定向"></a>管道和重定向</h3><p>管道|<br>输出重定向<br>重定向&gt;<br>将查询到的内容用&gt;输出重定向到新文件里<br>追加重定向&gt;&gt;<br>将查询到的内容用&gt;&gt;输出重定向（追加）到新文件里</p><h3 id="网卡信息"><a href="#网卡信息" class="headerlink" title="网卡信息"></a>网卡信息</h3><ul><li>ifconfig 查看网卡信息</li><li>ifconfig 更改网卡设置</li><li>ifconfig 网卡名称 up 激活网卡</li><li>ifconfig 网卡名称 down 停止网卡</li></ul><h3 id="用户相关操作"><a href="#用户相关操作" class="headerlink" title="用户相关操作"></a>用户相关操作</h3><ul><li>useradd 添加一个新的用户<ul><li>-u 指定uid</li><li>-g 指定主要组</li><li>-G 指定附加组</li><li>-d 指定用户的主目录</li></ul></li><li>passwd user 修改user的密码<ul><li>-l 给用户加锁</li><li>-u 给用户解锁</li></ul></li><li>userdel 删除用户<ul><li>-r 删除用户的同时删除主目录</li></ul></li><li>usermod 修改用户<ul><li>-u 修改uid</li><li>-g 修改所属组</li><li>-l 修改用户登录名称</li></ul></li><li>id 查找用户的uid和所属组</li><li>groupadd 添加组</li><li>chown 更改文件的所属用户<ul><li><em>change owner</em></li><li>chown user1 1.txt 将1.txt给改为用户user所有</li><li>-R 递归更改所属用户（用于文件夹）</li></ul></li><li>chgrp 更改用户所属组<ul><li>-R 递归更改</li></ul></li><li>chmod 更改文件的权限</li><li>umask 查询系统的创建掩码<ul><li>创建文件时，文件夹用777减去创建掩码，文件用666减，作为文件和文件夹的默认权限</li></ul></li></ul><h3 id="inode节点及相关命令"><a href="#inode节点及相关命令" class="headerlink" title="inode节点及相关命令"></a>inode节点及相关命令</h3><ul><li>ln 创建硬连接<ul><li>-s 创建软连接<br>硬连接就是两个文件指向同一个节点，软连接指向文件</li></ul></li></ul><h3 id="压缩与打包命令"><a href="#压缩与打包命令" class="headerlink" title="压缩与打包命令"></a>压缩与打包命令</h3><ul><li>tar 压缩与解压缩<ul><li>-x 解压缩文件</li><li>-c 压缩文件</li><li>-v 显示处理过程</li><li>-f 指定压缩包名字</li><li>-z 调用gzip压缩，扩展名是gz</li><li>-Z 调用compress，扩展名是Z</li><li>-j 是调用bzip2命令来压缩，扩展名为bz2</li></ul></li></ul><h3 id="软件包管理器rpm"><a href="#软件包管理器rpm" class="headerlink" title="软件包管理器rpm"></a>软件包管理器rpm</h3><ul><li>rpm <ul><li>-qa 查询软件包</li><li>-ql 查询软件包下的文件</li><li>-ivh 安装软件包</li><li>-i 安装</li><li>-v 显示处理过程</li><li>-h 显示处理进度</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
      <category>linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>基础知识</title>
    <link href="/2024/02/29/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2024/02/29/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux版本号"><a href="#Linux版本号" class="headerlink" title="Linux版本号"></a>Linux版本号</h1><p>编号形式：主版本号.次版本号.主版本补丁号.次版本补丁号</p><h1 id="Linux目录结构"><a href="#Linux目录结构" class="headerlink" title="Linux目录结构"></a>Linux目录结构</h1><ul><li>&#x2F;bin 用来储存用户命令<br>  <em>目录&#x2F;usr&#x2F;bin也被用来储存用户命令</em></li><li>&#x2F;sbin 许多系统命令（例如shutdown）的储存位置。<br>  <em>目录&#x2F;sbin中包括了许多系统命令</em></li><li>&#x2F;root 根用户（超级用户）的主目录<br>  <em>相当于超级用户的桌面</em></li><li>&#x2F;mnt 该目录中通常包括系统引导后被挂载的文件系统的挂载点<br>  <em>譬如，光盘的挂载点为&#x2F;mnt&#x2F;cdrom</em></li><li>&#x2F;boot 包括内核和其他系统启动期间使用的文件</li><li>&#x2F;lost+found 被fsck用来放置零散文件</li><li>&#x2F;lib 用来存放系统动态链接共享库</li><li>&#x2F;dev 储存设备文件</li><li>&#x2F;etc 存放了系统管理时要用到各种配置文件和子目录</li><li>&#x2F;var 用于储存variable（不断改变的文件）<br>  例如日志文件和打印机假脱机文件</li><li>&#x2F;usr 这是linux系统中占用硬盘空间最大的目录<br>  <em>用户很多应用程序和文件都放到这个目录下</em></li><li>&#x2F;proc 一个虚拟的系统目录<br>  <em>可以在这个目录下获取系统信息，存在内存中，由系统自己产生的</em></li><li>&#x2F;initrd 用于在计算机启动时挂载initrd.img映像文件的目录以及载入所需设备模块的目录</li><li>&#x2F;tmp 用户和程序的临时目录<br>  <em>存放不同程序指定时产生的临时文件</em></li><li>&#x2F;home 每一个用户都在&#x2F;home下拥有自己的文件夹，作为用户的主目录</li><li>&#x2F;opt 可选文件和程序的储存目录<br>  <em>该目录主要被第三方开发者用来简易的安装和卸载他们的软件包</em></li></ul><h1 id="命令和指令"><a href="#命令和指令" class="headerlink" title="命令和指令"></a>命令和指令</h1><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>init + 数字</td><td>设置当前计算机状态，0是关机，6是重启</td></tr><tr><td>systemctl reboot</td><td>重启</td></tr><tr><td>shutdown now</td><td>立即关机</td></tr><tr><td>systemctl poweroff</td><td>关闭系统，切断电源</td></tr><tr><td>systemctl suspend</td><td>挂机，暂停</td></tr><tr><td>clear</td><td>清屏</td></tr></tbody></table><h3 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h3><p>vim编辑器</p><ul><li>命令模式：控制光标移动，可对文本进行删除、复制、粘贴</li><li>输入模式：正常的文本录入<br>  <em>a、i、o等键可进入输入模式</em></li><li>末行模式：保存、退出与设置编辑环境<br>  <em>“:”可进入末行模式</em><br><em>Esc可从输入模式和末行模式回到命令模式</em></li></ul><p>末行模式命令：</p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>:w</td><td>保存</td></tr><tr><td>:q</td><td>退出</td></tr><tr><td>:q!</td><td>强制退出，放弃对文本修改的内容</td></tr><tr><td>:wq!</td><td>强制保存退出</td></tr><tr><td>:set nu</td><td>显示行号</td></tr><tr><td>:set nonu</td><td>不显示行号</td></tr></tbody></table><pre><code class="hljs">:整数|跳转到该行</code></pre><h1 id="文件相关命令"><a href="#文件相关命令" class="headerlink" title="文件相关命令"></a>文件相关命令</h1><h5 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h5><p>r：读权限<br>w：写权限<br>x：执行权限<br>属主权限|属组权限|其他用户权限</p><h5 id="文件类型："><a href="#文件类型：" class="headerlink" title="文件类型："></a>文件类型：</h5><ul><li>-：表示普通文件</li><li>d：表示目录文件</li></ul><h5 id="文件相关命令："><a href="#文件相关命令：" class="headerlink" title="文件相关命令："></a>文件相关命令：</h5><ul><li>ls 显示当前目录清单<br>  -a：显示隐藏文件<br>  -l：显示详细文件信息（长格式输出）<br>  -R：递归显示</li></ul>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
      <category>linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>指定变量类型</title>
    <link href="/2024/02/29/%E6%8C%87%E5%AE%9A%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/"/>
    <url>/2024/02/29/%E6%8C%87%E5%AE%9A%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="指定变量类型"><a href="#指定变量类型" class="headerlink" title="指定变量类型"></a>指定变量类型</h1><p>需要注意的是，Python中可以用int(),float(),str()构造函数对数据类型进行转换<br>与Java不同的是，int()和float()可以将字符串字面量转换为整型数字或浮点数，例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">x = <span class="hljs-built_in">int</span>(<span class="hljs-string">&quot;123&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(x))<span class="hljs-comment">#输出为整型变量</span><br>y = <span class="hljs-built_in">float</span>(<span class="hljs-string">&quot;123.1&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(y))<span class="hljs-comment">#输出为浮点型变量</span><br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
      <category>python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>元组</title>
    <link href="/2024/02/29/%E5%85%83%E7%BB%84/"/>
    <url>/2024/02/29/%E5%85%83%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h1><p>元组是<strong>有序</strong>且<strong>不可更改</strong>的集合</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#创建元组</span><br>thistuple = (<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;cherry&quot;</span>)<br><span class="hljs-comment">#遍历元组</span><br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> thistuple:<br><span class="hljs-built_in">print</span>(x)<br><span class="hljs-comment">#检查项目是否存在</span><br><span class="hljs-keyword">if</span> <span class="hljs-string">&quot;apple&quot;</span> <span class="hljs-keyword">in</span> thistuple:<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;yes&quot;</span>)<br><span class="hljs-comment">#确定元组长度</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(thistuple))<br></code></pre></td></tr></table></figure><h3 id="元组的创建"><a href="#元组的创建" class="headerlink" title="元组的创建"></a>元组的创建</h3><p>需要注意的是，在创建只有一个项目的元组时，需要在其后加 , 否则系统无法识别其是否为元组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">thistuple = (<span class="hljs-string">&quot;apple&quot;</span>) <span class="hljs-comment">#不是元组，而是字符串</span><br>thistuple = (<span class="hljs-string">&quot;apple&quot;</span>, ) <span class="hljs-comment">#是元组</span><br></code></pre></td></tr></table></figure><h3 id="元组的增、删、改"><a href="#元组的增、删、改" class="headerlink" title="元组的增、删、改"></a>元组的增、删、改</h3><p>元组一旦创建，就无法添加项目，元组是无法改变的<br>如果想要对其进行修改操作，可以强制转型为list，更改之后在强制转型回tuple。<br>元组无法实现删除操作，但可以删除整个元组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#修改</span><br>thistuple = (<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;cherry&quot;</span>)<br><span class="hljs-built_in">list</span>(thistuple)<br>thistuple[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;orange&quot;</span><br><span class="hljs-built_in">tuple</span>(thistuple)<br><span class="hljs-built_in">print</span> thistuple<br><span class="hljs-comment">#删除元组</span><br><span class="hljs-keyword">del</span> thistuple<br></code></pre></td></tr></table></figure><h3 id="元组的合并"><a href="#元组的合并" class="headerlink" title="元组的合并"></a>元组的合并</h3><p>如果想连接两个以上的元组，可以通过+运算符进行连接</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(tuple1 + tuple2)<br></code></pre></td></tr></table></figure><h3 id="元组方法"><a href="#元组方法" class="headerlink" title="元组方法"></a>元组方法</h3><p>Python提供两个元组上的内建方法</p><table><thead><tr><th>方法名</th><th>功能</th></tr></thead><tbody><tr><td>count()</td><td>返回元组中指定值出现的次数</td></tr><tr><td>index()</td><td>返回元组中指定值的索引号</td></tr></tbody></table><hr>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
      <category>python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>列表</title>
    <link href="/2024/02/29/%E5%88%97%E8%A1%A8/"/>
    <url>/2024/02/29/%E5%88%97%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><p>列表的使用与Java的数组无异，需要注意列表有很多使用方法</p><ul><li>len()方法可返回列表的长度（项目数）</li><li>append()方法可将项目添加到列表的末尾</li><li>insert()方法可将项目添加到指定索引位置</li><li>remove()方法可删除指定的项目</li><li>pop()方法可删除指定索引的项目</li><li>del关键字可删除指定索引的项目，也可以删除整个列表</li><li>clear()方法可以清空列表<br><em>注：pop方法为列表所带方法，而del为关键字，两者在使用方法上是有区别的，例：</em></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">thislist = [<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;cherry&quot;</span>]<br>thislist.pop(<span class="hljs-number">0</span>)<span class="hljs-comment">#删除索引0的项目</span><br><span class="hljs-keyword">del</span> thislist[<span class="hljs-number">1</span>]<span class="hljs-comment">#删除索引1的项目</span><br></code></pre></td></tr></table></figure><p>列表的构建方法是List()，可直接添加元素进行构建，例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">thislist = <span class="hljs-type">List</span>(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="复制列表"><a href="#复制列表" class="headerlink" title="复制列表"></a>复制列表</h3><p>可通过List内置方法copy()进行复制<br>或使用List()方法制作副本，例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">thislist = [<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;cherry&quot;</span>]<br>mylist = thislist.copy()<span class="hljs-comment">#使用thislist调用方法</span><br>mylist = <span class="hljs-type">List</span>(thislist)<span class="hljs-comment">#使用List将参数thislist制作副本</span><br></code></pre></td></tr></table></figure><p><em>通过list2 &#x3D; list1的方式只能是将两个引用指向同一个对象，在更改list1时list2也会随之更改</em></p><h3 id="合并列表"><a href="#合并列表" class="headerlink" title="合并列表"></a>合并列表</h3><ul><li>可通过‘+’直接合并列表</li><li>可通过遍历list2，再使用append()方法对每一个元素进行追加</li><li>使用extend()方法直接将list2追加到list1的末尾</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">list1 = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]<br>list2 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>list3 = list1 + list2<span class="hljs-comment">#方法1</span><br><br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> list2:<br>list1.append(x)<span class="hljs-comment">#方法2</span><br><br>list1.extend(list2)<span class="hljs-comment">#方法3</span><br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
      <category>python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>词典</title>
    <link href="/2024/02/29/%E8%AF%8D%E5%85%B8/"/>
    <url>/2024/02/29/%E8%AF%8D%E5%85%B8/</url>
    
    <content type="html"><![CDATA[<h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><p>字典是一个无序，可变，有索引的集合<br>在Python中，字典用花括号编写，键值对表示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">thisdict = &#123;<br><span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;xiaobai&quot;</span><br><span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">23</span><br><span class="hljs-string">&quot;sex&quot;</span>: <span class="hljs-string">&quot;male&quot;</span><br>&#125;<br><span class="hljs-built_in">print</span>(thisdict)<br></code></pre></td></tr></table></figure><h3 id="访问项目"><a href="#访问项目" class="headerlink" title="访问项目"></a>访问项目</h3><p>可以通过方括号的方式访问项目<br><em>其本质相当于将键当做索引来访问项目</em><br>还可以通过内建方法get()来获取键的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(thisdict[<span class="hljs-string">&quot;name&quot;</span>])<br><span class="hljs-built_in">print</span>(thisdict.get(<span class="hljs-string">&quot;name&quot;</span>))<br></code></pre></td></tr></table></figure><h3 id="遍历字典"><a href="#遍历字典" class="headerlink" title="遍历字典"></a>遍历字典</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#遍历字典中的键</span><br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> thisdict:<br><span class="hljs-built_in">print</span>(x)<br><span class="hljs-comment">#遍历字典中的值</span><br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> thisdict:<br><span class="hljs-built_in">print</span>(thisdict[x])<br><span class="hljs-comment">#使用values()函数返回字典中的值</span><br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> thisdict.values():<br><span class="hljs-built_in">print</span>(x)<br><span class="hljs-comment">#使用items()函数遍历键值对</span><br><span class="hljs-keyword">for</span> x,y <span class="hljs-keyword">in</span> thisdict.items():<br><span class="hljs-built_in">print</span>(x,y)<br></code></pre></td></tr></table></figure><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul><li>同样的，可以在字典中使用in来检查<strong>键</strong>是否存在与字典中</li><li>可以通过len()函数确定字典的长度（键值对）<em>作为参数</em></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> <span class="hljs-string">&quot;name&quot;</span> <span class="hljs-keyword">in</span> thisdict:<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;yes&quot;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(thisdict))<br></code></pre></td></tr></table></figure><h3 id="字典的增删改"><a href="#字典的增删改" class="headerlink" title="字典的增删改"></a>字典的增删改</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#通过方括号的方式对键的值进行更改</span><br>thisdict[<span class="hljs-string">&quot;name&quot;</span>] = <span class="hljs-string">&quot;White&quot;</span><br><span class="hljs-comment">#通过新的键和值来对字典项目进行新增</span><br>thisdict[<span class="hljs-string">&quot;No.&quot;</span>] = <span class="hljs-string">&quot;15948060069&quot;</span><br><span class="hljs-comment">#使用内建函数pop()删除指定键的项目</span><br>thisdict.pop(<span class="hljs-string">&quot;No.&quot;</span>)<br><span class="hljs-comment">#使用内建函数popitem()删除最后插入的项目（在3.7之前的版本中，删除随机项目）</span><br>thisdict.popitem()<br><span class="hljs-comment">#使用del关键字删除指定键的项目</span><br><span class="hljs-keyword">del</span> thisdict[<span class="hljs-string">&quot;name&quot;</span>]<br><span class="hljs-comment">#使用del完全删除字典</span><br><span class="hljs-keyword">del</span> thisdict<br><span class="hljs-comment">#使用clear()内建函数清空字典</span><br>thisdict.clear()<br></code></pre></td></tr></table></figure><h3 id="复制字典"><a href="#复制字典" class="headerlink" title="复制字典"></a>复制字典</h3><p>与[[列表#复制列表]]相同，字典也有内建方法copy()或构造方法dict()</p><h3 id="嵌套字典"><a href="#嵌套字典" class="headerlink" title="嵌套字典"></a>嵌套字典</h3><p>字典也可以包含许多字典，这被称为嵌套字典</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python">child1 = &#123;<br><span class="hljs-string">&quot;name&quot;</span> : <span class="hljs-string">&quot;zhao&quot;</span><br><span class="hljs-string">&quot;year&quot;</span> : <span class="hljs-number">2002</span><br>&#125;<br>child2 = &#123;<br><span class="hljs-string">&quot;name&quot;</span> : <span class="hljs-string">&quot;li&quot;</span><br><span class="hljs-string">&quot;year&quot;</span> : <span class="hljs-number">2001</span><br>&#125;<br>child3 = &#123;<br><span class="hljs-string">&quot;name&quot;</span> : <span class="hljs-string">&quot;wang&quot;</span><br><span class="hljs-string">&quot;year&quot;</span> : <span class="hljs-number">2003</span><br>&#125;<br>myfamily = &#123;<br><span class="hljs-string">&quot;child1&quot;</span> : child1<br><span class="hljs-string">&quot;child2&quot;</span> : child2<br><span class="hljs-string">&quot;child3&quot;</span> : child3<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="dict"><a href="#dict" class="headerlink" title="dict()"></a>dict()</h3><pre><code class="language-python">thisdict = dict(name=&quot;xiaobai&quot;, age=23, sex=&quot;male&quot;)#请注意，使用构造函数创建字典时，键不再是字符串格式，且不再使用冒号而是等号来赋值</code></pre>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
      <category>python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python字符串</title>
    <link href="/2024/02/29/Python%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2024/02/29/Python%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="Python字符串"><a href="#Python字符串" class="headerlink" title="Python字符串"></a>Python字符串</h1><p>在Python中，单引号和双引号同样表示为字符串定义<br>‘hello’等同于”hello”<br>同样的，可以将多行字符串赋值给变量，例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-string">&#x27;&#x27;&#x27;hello world</span><br><span class="hljs-string">hello python</span><br><span class="hljs-string">hello mylove&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p>与C语言一样，字符串的本质是一个字符数组<br>但不同的是，Python中没有字符型数据(char)的定义，一个字符就是长度为1的字符串<br>方括号可以用于访问字符串（字符数组）的元素，例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-string">&quot;hello world&quot;</span><br><span class="hljs-built_in">print</span>(a[<span class="hljs-number">1</span>])<span class="hljs-comment">#输出为e</span><br></code></pre></td></tr></table></figure><h3 id="裁切"><a href="#裁切" class="headerlink" title="裁切"></a>裁切</h3><p>Python中，可通过指定索引的方式返回字符串的一部分，例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">b = <span class="hljs-string">&quot;hello world&quot;</span><br><span class="hljs-built_in">print</span>(b[<span class="hljs-number">2</span>:<span class="hljs-number">5</span>])<span class="hljs-comment">#输出为llo</span><br></code></pre></td></tr></table></figure><p>也可以通过负的索引来实现从字符串末尾进行裁切，例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">b = <span class="hljs-string">&quot;hello world&quot;</span><br><span class="hljs-built_in">print</span>(b[-<span class="hljs-number">5</span>:-<span class="hljs-number">2</span>])<span class="hljs-comment">#输出为orl</span><br></code></pre></td></tr></table></figure><h3 id="长度"><a href="#长度" class="headerlink" title="长度"></a>长度</h3><p>和Java相同，可以使用len()函数返回字符串的长度</p><h3 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h3><p>Python中有一组可用于字符串的内置方法</p><table><thead><tr><th>方法名</th><th>功能</th></tr></thead><tbody><tr><td>strip()</td><td>删除字符串开头和结尾的空白字符</td></tr><tr><td>lower()</td><td>返回小写的字符串</td></tr><tr><td>upper()</td><td>返回大写的字符串</td></tr><tr><td>replace()</td><td>用另一段字符串来替换字符串</td></tr><tr><td>split()</td><td>字符串拆分（基于分隔符）返回一个列表</td></tr></tbody></table><h3 id="检查字符串"><a href="#检查字符串" class="headerlink" title="检查字符串"></a>检查字符串</h3><p>在Python中，可以通过in或者not in关键字检查字符串中是否存在特定短语或字符，例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">txt = <span class="hljs-string">&quot;China is NO.1&quot;</span><br>x = <span class="hljs-string">&quot;ina&quot;</span> <span class="hljs-keyword">in</span> txt<br><span class="hljs-built_in">print</span>(x)<span class="hljs-comment">#返回值为布尔类型 True</span><br></code></pre></td></tr></table></figure><h3 id="字符串格式"><a href="#字符串格式" class="headerlink" title="字符串格式"></a>字符串格式</h3><p>正如前文所说，字符串和字符串可以用‘+’直接拼串，但字符串和数字之间不能<br>我们可以使用format()方法实现组合字符串和数字<br>format()方法支持参数的传递，并格式化他们，使用｛｝占位符传参，例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">age = <span class="hljs-number">23</span><br>txt = <span class="hljs-string">&quot;I am &#123;&#125;&quot;</span><br><span class="hljs-built_in">print</span>(txt.<span class="hljs-built_in">format</span>(age))<span class="hljs-comment">#输出为 I am 23</span><br></code></pre></td></tr></table></figure><p><em>注：format()方法支持不限量的参数，甚至可以使用索引来确保参数被放在正确的占位符中</em></p><hr>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
      <category>python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python注释</title>
    <link href="/2024/02/29/Python%E6%B3%A8%E9%87%8A/"/>
    <url>/2024/02/29/Python%E6%B3%A8%E9%87%8A/</url>
    
    <content type="html"><![CDATA[<h1 id="Python注释"><a href="#Python注释" class="headerlink" title="Python注释"></a>Python注释</h1><p>在Python中，注释以#开头<br>实际上Python没有多行注释的语法<br>如果想要实现多行注释可以在代码中添加多行字符串，只要字符串没有分配给变量，Python就会读取代码，然后忽略他，例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">这是一个多行代码块</span><br><span class="hljs-string">可以通过这种方式实现多行注释的效果</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
      <category>python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python运算符</title>
    <link href="/2024/02/29/Python%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <url>/2024/02/29/Python%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="Python-运算符"><a href="#Python-运算符" class="headerlink" title="Python 运算符"></a>Python 运算符</h1><p>与Java不同的是，Python中有**（幂运算）和&#x2F;&#x2F;（整除）<br>逻辑运算符为 and（与）or（或）not（非）<br>还有身份运算符 is和not is<br><em>注：is并不是判断是否相等，而是判断是否为同一个对象</em><br>成员运算符 in和not in<br>而&amp; | ^ ~ &lt;&lt; &gt;&gt;为双目按位运算符，一般适用于二进制数字</p><hr>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
      <category>python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python循环</title>
    <link href="/2024/02/29/Python%E5%BE%AA%E7%8E%AF/"/>
    <url>/2024/02/29/Python%E5%BE%AA%E7%8E%AF/</url>
    
    <content type="html"><![CDATA[<p><em>与Java相同，Python的while循环使用方法大致一致<br>不同的是，for循环与Java不太相似</em></p><h1 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h1><p>for 循环用于迭代序列（即列表，元组，字典，集合或字符串）<br>通过使用 for循环，我们可以为列表、元组、集合中的每个项目等执行一组语句</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">fruits = [<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;cherry&quot;</span>]<br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> fruits:<br><span class="hljs-built_in">print</span>(X)<br></code></pre></td></tr></table></figure><p>甚至可以遍历字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;banana&quot;</span>:<br><span class="hljs-built_in">print</span>(x)<br></code></pre></td></tr></table></figure><p><em>注：JAVA中的break和continue在Python中仍然适用且使用方法一样</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">fruits = [<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;cherry&quot;</span>]<br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> fruits:<br><span class="hljs-keyword">if</span> x == <span class="hljs-string">&quot;banana&quot;</span>:<br><span class="hljs-keyword">continue</span><br><span class="hljs-built_in">print</span>(X)<br><span class="hljs-comment">#跳过输出banana</span><br></code></pre></td></tr></table></figure><h3 id="range-函数"><a href="#range-函数" class="headerlink" title="range()函数"></a>range()函数</h3><p>在Python中，想要循环一组数字，就要使用range()函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)<br><span class="hljs-built_in">print</span>(x)<br><span class="hljs-comment">#遍历输出0-9</span><br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>, <span class="hljs-number">10</span>)<br><span class="hljs-built_in">print</span>(x)<br><span class="hljs-comment">#遍历输出3-9</span><br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>, <span class="hljs-number">3</span>)<br><span class="hljs-built_in">print</span>(x)<br><span class="hljs-comment">#遍历输出1-99，步长为3</span><br></code></pre></td></tr></table></figure><h3 id="for循环中的else"><a href="#for循环中的else" class="headerlink" title="for循环中的else"></a>for循环中的else</h3><p>在Python中，else的作用就像是switch中的default<br>在循环结束时执行这条语句</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)<br><span class="hljs-built_in">print</span>(x)<br><span class="hljs-keyword">else</span>:<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Finally finished!&quot;</span>)<br><span class="hljs-comment">#循环输出0-9后，在循环结束时打印这条消息</span><br></code></pre></td></tr></table></figure><h3 id="pass"><a href="#pass" class="headerlink" title="pass"></a>pass</h3><p>相同的，如果想在for循环中的循环体为空，可以在for里面写一个pass语句<br><em>注：Python中同样适用循环嵌套</em></p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
      <category>python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python选择</title>
    <link href="/2024/02/29/Python%E9%80%89%E6%8B%A9/"/>
    <url>/2024/02/29/Python%E9%80%89%E6%8B%A9/</url>
    
    <content type="html"><![CDATA[<h1 id="if"><a href="#if" class="headerlink" title="if"></a>if</h1><p>和Java不同的是，Python的else if被简写成elif<br>if语句可以被简写成一行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-number">100</span><br>b = <span class="hljs-number">200</span><br><span class="hljs-keyword">if</span> a &gt; b:<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;a&gt;b&quot;</span>)<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;a&lt;b&quot;</span>)<br><span class="hljs-comment">#可将以上语句简写成一行</span><br><span class="hljs-keyword">if</span> a &gt; b: <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;a&gt;b&quot;</span>)<br><span class="hljs-comment">#或将执行体放在if前</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;a&gt;b&quot;</span>) <span class="hljs-keyword">if</span>  a &gt; b <span class="hljs-keyword">else</span> <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;a&lt;b&quot;</span>)<br></code></pre></td></tr></table></figure><p>在Python中，与或的符号使用 and和or<br>if语句的执行体不能为空，如果出于某种原因写了无内容的if语句，请使用pass语句避免错误</p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
      <category>python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python数字</title>
    <link href="/2024/02/29/Python%E6%95%B0%E5%AD%97/"/>
    <url>/2024/02/29/Python%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h1 id="Python数字"><a href="#Python数字" class="headerlink" title="Python数字"></a>Python数字</h1><p>与Java不同的是，Python中具有三种数字类型：</p><ul><li>int</li><li>float</li><li>complex<br><em>complex中文释义：复杂的</em><br>complex表示复数，其中“j”为作为虚部编写，例：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">x = <span class="hljs-number">2</span> + <span class="hljs-number">3j</span><br>y = -<span class="hljs-number">7j</span><br>z = <span class="hljs-number">7j</span><br></code></pre></td></tr></table></figure><p>同样的，在数字类型中也可以相互进行数据类型转换，但需要注意的是<strong>复数类型（complex）无法转换为其他[[Python数据类型]]</strong></p><h3 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h3><p>Python中没有random()来创建随机数，但Python中有一个名为random的内置模块，可用于生成随机数，例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> random<br><span class="hljs-built_in">print</span>(random.randrange(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>)) <span class="hljs-comment">#打印1-9的随机数</span><br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
      <category>python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python数据类型</title>
    <link href="/2024/02/29/Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2024/02/29/Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Python数据类型"><a href="#Python数据类型" class="headerlink" title="Python数据类型"></a>Python数据类型</h1><p>Python默认拥有以下数据类型：</p><table><thead><tr><th>数据类型</th><th>对应类型</th></tr></thead><tbody><tr><td>文本类型</td><td>str</td></tr><tr><td>数据类型</td><td>int，float，complex</td></tr><tr><td>序列类型</td><td>list，tuple，range</td></tr><tr><td>映射类型</td><td>dict</td></tr><tr><td>集合类型</td><td>set，frozenset</td></tr><tr><td>布尔类型</td><td>bool</td></tr><tr><td>二进制类型</td><td>bytes，bytearray，memoryview</td></tr><tr><td><em>因为在定义变量时没有声明，所以在给变量进行赋值时会自动设置数据类型</em></td><td></td></tr><tr><td><strong>可以通过构造函数对变量的数据类型进行类型声明或者数据类型的转换</strong></td><td></td></tr></tbody></table><h3 id="获取数据类型"><a href="#获取数据类型" class="headerlink" title="获取数据类型"></a>获取数据类型</h3><p>可通过type()函数获取任何对象的数据类型,例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">x = <span class="hljs-number">10</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(x)) <span class="hljs-comment">#输出结果为int</span><br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
      <category>python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python集合（数组）</title>
    <link href="/2024/02/29/Python%E9%9B%86%E5%90%88%EF%BC%88%E6%95%B0%E7%BB%84%EF%BC%89/"/>
    <url>/2024/02/29/Python%E9%9B%86%E5%90%88%EF%BC%88%E6%95%B0%E7%BB%84%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="Python集合（数组）"><a href="#Python集合（数组）" class="headerlink" title="Python集合（数组）"></a>Python集合（数组）</h1><p>Python中有四种集合数据类型</p><ul><li>[[列表]]（list）是一种有序可更改集合，允许重复的成员</li><li>[[元组]]（tuple）是一种有序且不可更改的集合，允许有重复的成员</li><li>[[集合]]（set）是一个无序和无索引的集合，没有重复的集合</li><li>[[词典]]（dictionary）是一个无序，可变和有索引的集合，没有重复的成员</li></ul><hr>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
      <category>python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python函数</title>
    <link href="/2024/02/29/Python%E5%87%BD%E6%95%B0/"/>
    <url>/2024/02/29/Python%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>在Python中，使用def关键字来定义函数<br>与java相同，函数中仍可通过形参实现参数传递<br>不同的是，可通过形参直接设置参数的<strong>默认值</strong>，例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_fun</span>(<span class="hljs-params">country = <span class="hljs-string">&quot;China&quot;</span></span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;I am from &quot;</span> + country)<br>my_fun()<br><span class="hljs-comment">#在这里实参为空，形参默认值为China</span><br></code></pre></td></tr></table></figure><p>同样的，可以将任何参数作为参数传递，并且在函数内仍然被看作是相同的数据类型<br>例如，传参一个list到函数内，传到函数内仍然是list</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_fun</span>(<span class="hljs-params">food</span>):<br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> food:<br><span class="hljs-built_in">print</span>(x)<br><br>fruits = [<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;cherry&quot;</span>]<br>my_fun(fruits)<br></code></pre></td></tr></table></figure><p><strong>和Java相同，如果函数有返回值可使用return语句</strong></p><h3 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h3><p>在传参时，可以使用形参&#x3D;实参（key&#x3D;value）的方法来实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_fun</span>(<span class="hljs-params">a, b, c</span>):<br><span class="hljs-built_in">print</span>(a, b, c)<br><br>my_fun(c=<span class="hljs-number">1</span>, b=<span class="hljs-number">2</span>, a=<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><h3 id="任意参数"><a href="#任意参数" class="headerlink" title="任意参数"></a>任意参数</h3><p>如果参数的数量未知，可以在形参前加*<br>在传参时，会将多个参数变成一个元组，在函数中通过索引访问各项</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_fun</span>(<span class="hljs-params">*food</span>):<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;My favorite fruits is &quot;</span> + food[<span class="hljs-number">2</span>])<br><span class="hljs-comment">#打印为My favorite fruits is cherry</span><br>my_fun(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;cherry&quot;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
      <category>python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python变量</title>
    <link href="/2024/02/29/Python%E5%8F%98%E9%87%8F/"/>
    <url>/2024/02/29/Python%E5%8F%98%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="Python变量"><a href="#Python变量" class="headerlink" title="Python变量"></a>Python变量</h1><p>与Java不同的是，Python没有<strong>声明变量的命令</strong><br>但与Java命名规则大致一样：</p><ul><li>必须以字母或下划线开头</li><li>不能以数字开头</li><li>区分大小写</li><li>尽量达成见名知意，驼峰命名<br>与Java不同的是，Python中可以使用连等为变量赋值，或同时给多个变量赋值，例：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">x = y = z =<span class="hljs-string">&quot;Orange&quot;</span><br>x, y, z = <span class="hljs-string">&quot;Orange&quot;</span>, <span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-string">&quot;Cherry&quot;</span><br></code></pre></td></tr></table></figure><p><em>注：与Java不同，在Python中无法实现数字与字符串的拼串</em></p><h3 id="Python全局变量"><a href="#Python全局变量" class="headerlink" title="Python全局变量"></a>Python全局变量</h3><p>在Python中，函数之外定义的变量即为全局变量，函数里定义的变量为局部变量<br>在函数中可使用global关键字将局部变量声明为全局变量<br>同时，在函数内部想要更改全局变量的值时，需使用global在函数内重新声明，例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">x = <span class="hljs-number">1</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">myfunc</span>():<br><span class="hljs-keyword">global</span> x<br>x = <span class="hljs-number">2</span><br><span class="hljs-built_in">print</span>(x) <span class="hljs-comment">#x的值为2</span><br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
      <category>python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>静态路由、RIP和OSPF配置模板</title>
    <link href="/2023/11/06/%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1%E3%80%81RIP%E5%92%8COSPF%E9%85%8D%E7%BD%AE%E6%A8%A1%E6%9D%BF/"/>
    <url>/2023/11/06/%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1%E3%80%81RIP%E5%92%8COSPF%E9%85%8D%E7%BD%AE%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="RIP路由配置"><a href="#RIP路由配置" class="headerlink" title="RIP路由配置"></a>RIP路由配置</h1><h2 id="R1路由器配置示例"><a href="#R1路由器配置示例" class="headerlink" title="R1路由器配置示例"></a>R1路由器配置示例</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#进入用户视图</span><br>system-view <br><span class="hljs-comment">#更改设备名称(写自己名字)</span><br>sysname baishuyuan_R1<br><span class="hljs-comment">#进入g0/0/0接口</span><br>int g0/0/0<br><span class="hljs-comment">#配置ip地址(请根据题目实际填写)</span><br>ip address 172.16.10.2 255.255.255.0<br><span class="hljs-comment">#进入g0/0/1接口</span><br>int g0/0/1<br><span class="hljs-comment">#配置ip地址(请根据题目实际填写)</span><br>ip address 10.10.10.1 255.255.255.0<br><br><span class="hljs-comment">#配置RIP</span><br><span class="hljs-comment">#进入RIP视图</span><br>rip 1<br><span class="hljs-comment">#指定RIP版本为2</span><br>version 2<br><span class="hljs-comment">#关闭RIPv2自动路由聚合功能</span><br>undo summary<br><span class="hljs-comment">#在指定网段接口上使能RIP(version1特性)</span><br>network 172.16.0.0<br>network 10.0.0.0<br><span class="hljs-comment">#在指定网段接口上使能RIP(version2特性) 不要用这个!!!!!!</span><br>network 172.16.10.0 0.0.0.255<br>network 10.10.10.0 0.0.0.255<br><span class="hljs-comment">#保存更改!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span><br>save<br></code></pre></td></tr></table></figure><h1 id="静态路由配置示例"><a href="#静态路由配置示例" class="headerlink" title="静态路由配置示例"></a>静态路由配置示例</h1><h2 id="AR1示例-AR3同理"><a href="#AR1示例-AR3同理" class="headerlink" title="AR1示例(AR3同理)"></a>AR1示例(AR3同理)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#进入用户视图</span><br>system-view <br><span class="hljs-comment">#更改设备名称(写自己名字)</span><br>sysname baishuyuan_AR1<br><span class="hljs-comment">#进入g0/0/0接口</span><br>int g0/0/0<br><span class="hljs-comment">#配置ip地址(请根据题目实际填写)</span><br>ip address 192.168.1.254 255.255.255.0<br><span class="hljs-comment">#进入g0/0/1接口</span><br>int g0/0/1<br><span class="hljs-comment">#配置ip地址(请根据题目实际填写)</span><br>ip address 192.168.2.1 255.255.255.0<br><br><span class="hljs-comment">#配置缺省路由(查不到的网段发往默认路由)</span><br>ip route-static 0.0.0.0 0.0.0.0 192.168.2.2<br></code></pre></td></tr></table></figure><h2 id="AR2示例"><a href="#AR2示例" class="headerlink" title="AR2示例"></a>AR2示例</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#进入用户视图</span><br>system-view <br><span class="hljs-comment">#更改设备名称(写自己名字)</span><br>sysname baishuyuan_AR2<br><span class="hljs-comment">#进入g0/0/0接口</span><br>int g0/0/0<br><span class="hljs-comment">#配置ip地址(请根据题目实际填写)</span><br>ip address 192.168.2.2 255.255.255.0<br><span class="hljs-comment">#进入g0/0/1接口</span><br>int g0/0/1<br><span class="hljs-comment">#配置ip地址(请根据题目实际填写)</span><br>ip address 192.168.3.1 255.255.255.0<br><br><span class="hljs-comment">#配置静态路由(前往1.0网段的目标端口的网络地址是2.1)</span><br>ip route-static 192.168.1.0 255.255.255.0 192.168.2.1<br><span class="hljs-comment">#配置静态路由(前往4.0网段的目标端口的网络地址是3.2)</span><br>ip route-static 192.168.1.0 255.255.255.0 192.168.2.1<br></code></pre></td></tr></table></figure><h1 id="OSPF命令模板"><a href="#OSPF命令模板" class="headerlink" title="OSPF命令模板"></a>OSPF命令模板</h1><h2 id="AR1路由配置"><a href="#AR1路由配置" class="headerlink" title="AR1路由配置"></a>AR1路由配置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#进入用户视图</span><br>system-view <br><span class="hljs-comment">#更改设备名称(写自己名字)</span><br>sysname baishuyuan_AR1<br><span class="hljs-comment">#进入g0/0/0接口</span><br>int g0/0/0<br><span class="hljs-comment">#配置ip地址(请根据题目实际填写)</span><br>ip add 192.168.1.254 24<br><span class="hljs-comment">#进入g0/0/1接口</span><br>int g0/0/1<br><span class="hljs-comment">#配置ip地址(请根据题目实际填写)</span><br>ip add 10.10.1.1 24<br><span class="hljs-comment">#进入回环接口</span><br>int lo 0<br><span class="hljs-comment">#配置ip地址(回环接口的ip)</span><br>ip add 1.1.1.1 32<br><span class="hljs-comment">#退出此视图</span><br>quit<br>router <span class="hljs-built_in">id</span> 1.1.1.1<br>ospf 10<br>area 0<br>net 10.10.1.1 0.0.0.255<br>net 192.168.1.254 0.0.0.255<br>net 1.1.1.1 0.0.0.0<br>q<br>q<br>q<br>save<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
      <category>ccut</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MVC模板</title>
    <link href="/2023/06/14/MVC%E6%A8%A1%E6%9D%BF/"/>
    <url>/2023/06/14/MVC%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="MVC模板"><a href="#MVC模板" class="headerlink" title="MVC模板"></a>MVC模板</h1><p><img src="/upload/MVC.png" alt="MVC"></p><h1 id="mybatis-config"><a href="#mybatis-config" class="headerlink" title="mybatis-config"></a>mybatis-config</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">configuration</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span> <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">settting</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;LOG4J&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;logImpl&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">settting</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;mysql&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;mysql&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;UNPOOLED&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/demo&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123456&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;my.mapper.UserMapper&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="InitSession类"><a href="#InitSession类" class="headerlink" title="InitSession类"></a>InitSession类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> my.tool;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.InputStream;<br><br><span class="hljs-keyword">import</span> org.apache.ibatis.io.Resources;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSession;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InitSession</span> &#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SqlSessionFactory factory;<br><span class="hljs-keyword">static</span> &#123;<br>InputStream in;<br><span class="hljs-keyword">try</span> &#123;<br>in = Resources.getResourceAsStream(<span class="hljs-string">&quot;mybatis-config.xml&quot;</span>);<br>factory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(in);<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br><span class="hljs-comment">// TODO Auto-generated catch block</span><br>e.printStackTrace();<br>&#125;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SqlSession <span class="hljs-title function_">getSession</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> factory.openSession();<br>&#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="生成mapper对象的方法"><a href="#生成mapper对象的方法" class="headerlink" title="生成mapper对象的方法"></a>生成mapper对象的方法</h1><p>业务类功能需要对数据库进行操作，需要用到mapper接口链接数据库</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//定义SqlSession对象</span><br><span class="hljs-type">SqlSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> InitSession.getSession();<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//定义Mapper对象</span><br><span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> session.getMapper(UserMapper.class);<br></code></pre></td></tr></table></figure><p><em>注：这两条可以使用全局变量</em></p><h1 id="JSP实现连接数据库（利用JSTL）"><a href="#JSP实现连接数据库（利用JSTL）" class="headerlink" title="JSP实现连接数据库（利用JSTL）"></a>JSP实现连接数据库（利用JSTL）</h1><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;sql:setDataSource driver=<span class="hljs-string">&quot;com.mysql.jdbc.Driver &quot;</span><br>                   url=<span class="hljs-string">&quot;jdbc:mysql://43.143.152.156:3060/usermanager&quot;</span><br>                   user=<span class="hljs-string">&quot;root&quot;</span><br>                   password=<span class="hljs-string">&quot;Zhuwenxue2002&quot;</span><br>                   <span class="hljs-keyword">var</span>=<span class="hljs-string">&quot;snapshot&quot;</span><br>/&gt;<br>&lt;sql:query <span class="hljs-keyword">var</span>=<span class="hljs-string">&quot;result&quot;</span><br>           sql=<span class="hljs-string">&quot;SELECT password from user WHERE $&#123;username&#125;;&quot;</span><br>           dataSource=<span class="hljs-string">&quot;$&#123;snapshot&#125;&quot;</span><br>/&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
      <category>ccut</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库系统概论</title>
    <link href="/2023/05/26/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/"/>
    <url>/2023/05/26/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><h3 id="数据库的基本概念"><a href="#数据库的基本概念" class="headerlink" title="数据库的基本概念"></a>数据库的基本概念</h3><ol><li><p>数据（data）</p><p>描述事物的符号记录为数据</p><p>数据的含义称为数据的语义，数据及其语义是密不可分的</p></li><li><p>数据库（DB）</p><p>数据库具有永久存储、有组织和可共享三个特点</p></li><li><p>数据库管理系统（DBMS）</p><p>是计算机的基础软件</p><p>可以定义数据之间的联系</p><p>具有DDL和DML，可操作库和数据</p></li><li><p>数据库系统（DBS）</p><p>数据库系统是由数据库，数据库管理系统，应用程序和数据库管理员组成的储存、管理、处理和维护数据的系统</p></li></ol><hr><h3 id="数据模型的组成要素"><a href="#数据模型的组成要素" class="headerlink" title="数据模型的组成要素"></a>数据模型的组成要素</h3><p>数据模型通常由数据结构、数据操作和数据的完整性约束条件三部分组成</p><ol><li><p>数据结构</p><p>数据结构描述数据库的组成对象以及对象之间的联系</p></li><li><p>数据操作</p><p>数据操作是指数据库中各种对象的实例允许执行的操作的集合，包括操作有关的操作规则</p></li><li><p>数据的完整性约束条件</p><p>数据的完整性约束条件是一条完整性规则</p></li></ol><hr><h3 id="数据系统的三级模式结构"><a href="#数据系统的三级模式结构" class="headerlink" title="数据系统的三级模式结构"></a>数据系统的三级模式结构</h3><p>数据库系统的三级模式结构是指数据库系统是由外模式、模式和内模式三级构成</p><ol><li><p>模式</p><p>模式也称逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图</p></li><li><p>外模式</p><p>外模式也称子模式或用户模式，他是数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述，是数据用户的数据视图，是与某一应用有关的数据的逻辑表示</p></li><li><p>内模式</p><p>内模式又称存储模式，一个数据库只有一个内模式。他是数据物理结构和存储方式的描述，是数据在数据库内部的组织方式</p></li></ol><p><em>注：个人理解，模式就是数据库的逻辑结构，内模式就是数据库的物理结构</em></p><hr><h3 id="数据库的二级映像功能与数据独立性"><a href="#数据库的二级映像功能与数据独立性" class="headerlink" title="数据库的二级映像功能与数据独立性"></a>数据库的二级映像功能与数据独立性</h3><ol><li><p>外模式&#x2F;模式映像</p><p>当模式改变时，由数据库管理员对各个外模式&#x2F;模式的映像作相应改变，可以使外模式保持不变。应用程序是依据数据的外模式编写的，从而应用程序不必修改，保证了数据与程序的逻辑独立性，简称数据的逻辑独立性</p></li><li><p>模式&#x2F;内模式映像</p><p>当数据库的存储结构发生改变时，由数据库管理员对模式&#x2F;内模式映像作相应改变，可以使模式保持不变，从而应用程序也不必改变。保证了数据与程序的物理独立性，简称数据的物理独立性</p></li><li><p>数据独立性</p><p>数据与程序之间的独立性使得数据的定义和描述可以从应用程序中分离出去。由于数据的存取由数据库管理系统管理，从而简化了应用程序的编制，大大减少了应用程序的维护和修改</p></li></ol><hr><h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1><h3 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h3><h5 id="传统的集合运算"><a href="#传统的集合运算" class="headerlink" title="传统的集合运算"></a>传统的集合运算</h5><p>传统的集合运算是二目运算，包括并、交、差和笛卡尔积4种运算</p><h5 id="专门的关系运算"><a href="#专门的关系运算" class="headerlink" title="专门的关系运算"></a>专门的关系运算</h5><p>专门的关系运算包括选择、投影、链接、除运算等</p><ol><li><p>选择（σ）</p><p>σ字段条件（表名）</p></li><li><p>投影（Π）</p><p>Π想要显示的列（表名）</p></li><li><p>连接（⨝）</p><p>自然连接：关系1⨝关系2</p></li></ol><p><em>注：关系代数中，选择相当于sql语句中的where，投影相当于sql语句中的select</em></p><p><strong>一般流程为：将表自然连接后，用选择筛出符合条件的表，再用投影筛出自己想要的列</strong></p><hr><h1 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h1><p>SQL大致分为：QL（查询语言）DML（数据操纵语言）DDL（数据定义语言）DCL（数据控制语言）TC（事务控制）</p><hr><h3 id="QL"><a href="#QL" class="headerlink" title="QL"></a>QL</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br><span class="hljs-keyword">DISTINCT</span> 列名<span class="hljs-operator">|</span><span class="hljs-operator">*</span><span class="hljs-operator">|</span>表达式 别名<br><span class="hljs-keyword">FROM</span><br>表名<span class="hljs-operator">|</span>试图名<span class="hljs-operator">|</span>子查询 别名<br><span class="hljs-keyword">WHERE</span><br>条件表达式  <span class="hljs-operator">&gt;</span>   <span class="hljs-operator">&lt;</span>   <span class="hljs-operator">&gt;=</span>   <span class="hljs-operator">&lt;=</span>   <span class="hljs-operator">&lt;&gt;</span>（不等于<span class="hljs-operator">!=</span>仍可用）<br><span class="hljs-keyword">in</span>    <span class="hljs-keyword">between</span>……<span class="hljs-keyword">and</span>……    <span class="hljs-keyword">like</span>     <span class="hljs-keyword">or</span>     <span class="hljs-keyword">not</span>     <span class="hljs-keyword">is</span> <span class="hljs-keyword">null</span><br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span><br>列名<span class="hljs-operator">|</span>表达式<br><span class="hljs-built_in">sum</span>()   <span class="hljs-built_in">avg</span>()    <span class="hljs-built_in">count</span>()   <span class="hljs-built_in">max</span>()   <span class="hljs-built_in">min</span>()<br><span class="hljs-keyword">HAVING</span><br>限制组的条件表达式<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <br>列名<span class="hljs-operator">|</span>别名<span class="hljs-operator">|</span>列序号 <span class="hljs-keyword">desc</span>倒序 <br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">CASE</span> expr <span class="hljs-keyword">WHEN</span> 值<span class="hljs-number">1</span> <span class="hljs-keyword">THEN</span> 返回值<span class="hljs-number">1</span><br>                <span class="hljs-keyword">WHEN</span> 值<span class="hljs-number">2</span> <span class="hljs-keyword">THEN</span> 返回值<span class="hljs-number">2</span><br>                ……<br>                <span class="hljs-keyword">ELSE</span> 返回值<br><span class="hljs-keyword">END</span><br><br><span class="hljs-keyword">CASE</span> <span class="hljs-keyword">WHEN</span> 条件<span class="hljs-number">1</span> <span class="hljs-keyword">THEN</span> 返回值<span class="hljs-number">1</span><br>          <span class="hljs-keyword">WHEN</span> 条件<span class="hljs-number">2</span> <span class="hljs-keyword">THEN</span> 返回值<span class="hljs-number">2</span><br>          ……<br>          <span class="hljs-keyword">ELSE</span> 返回值<br><span class="hljs-keyword">END</span><br></code></pre></td></tr></table></figure><p>连接标准写法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">from</span> a <span class="hljs-keyword">left</span>  <span class="hljs-keyword">join</span> b<br><span class="hljs-keyword">on</span> a.col <span class="hljs-operator">=</span> b.col<br></code></pre></td></tr></table></figure><p>自链接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> q.ename,l.ename<br><span class="hljs-keyword">from</span> emp w,emp l<br><span class="hljs-keyword">where</span> w.领导号<span class="hljs-operator">=</span>l. 员工号<br></code></pre></td></tr></table></figure><p>子查询（嵌套查询）<br>单行子查询<br>&lt; &gt;  &gt;&#x3D; &lt;&#x3D; &#x3D; &lt;&gt;<br>多行子查询<br>in any all<br>相关子查询<br>查询工资比其所在部门平均工资还高的员工</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> ename,salary,dept_id<br><span class="hljs-keyword">from</span> emp e<br><span class="hljs-keyword">where</span> salary<span class="hljs-operator">&gt;</span>(<span class="hljs-keyword">select</span> <span class="hljs-built_in">avg</span>(salary)<br>                    <span class="hljs-keyword">from</span> emp<br>                    <span class="hljs-keyword">where</span> dept_id<span class="hljs-operator">=</span>e.dept_id)<br></code></pre></td></tr></table></figure><p>思路就是 ，查询第一个人的部门为参数，计算这个部门的平均工资，在对比。以此循环<br>相关子查询的改写</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> ename,salary,dept_id<br><span class="hljs-keyword">from</span> emp e,(<span class="hljs-keyword">select</span> dept_id ,<span class="hljs-built_in">avg</span>(salary) avgsal<br>                 <span class="hljs-keyword">from</span> emp<br>                 <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> dept_id) a                                                     <br><span class="hljs-keyword">where</span> e.dept_id<span class="hljs-operator">=</span>a.dept_id<br><span class="hljs-keyword">and</span> e.salary<span class="hljs-operator">&gt;</span>a.avgsal<br></code></pre></td></tr></table></figure><p>改写的思路是，分组部门获取每一个部门平均工资作为新表，把新旧表链接，在对比</p><p>集合运算<br>并 交 差<br>union&#x2F;union all(不去重，不排序)<br>intersect<br>minus</p><p>交 与 差 两种集合运算符在MySql无效，需通过相关子查询实现 </p><p>select ……<br>union<br>select ……</p><hr><h3 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h3><p>create</p><p>alter</p><p>drop</p><p>tuncate table 表名</p><hr><h3 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h3><p>增</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert into</span> 表名<br><span class="hljs-keyword">values</span> (值<span class="hljs-number">1</span>,值<span class="hljs-number">2</span>,值<span class="hljs-number">3</span>……)<br></code></pre></td></tr></table></figure><p>删</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">delete</span> 表名<br><span class="hljs-keyword">where</span> 条件<br></code></pre></td></tr></table></figure><p>改</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> 表名<br><span class="hljs-keyword">set</span> 列<span class="hljs-operator">=</span>值,列<span class="hljs-operator">=</span>值，……<br><span class="hljs-keyword">where</span> 条件<br></code></pre></td></tr></table></figure><hr><h3 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">grant</span> 权限<br><span class="hljs-keyword">on</span> 对象<br><span class="hljs-keyword">to</span> 用户<span class="hljs-operator">|</span>角色<br><br><span class="hljs-keyword">revoke</span> 权限<br><span class="hljs-keyword">on</span> 对象<br><span class="hljs-keyword">from</span> 用户<span class="hljs-operator">|</span>角色<br></code></pre></td></tr></table></figure><hr><h1 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h1><h3 id="完整性约束"><a href="#完整性约束" class="headerlink" title="完整性约束"></a>完整性约束</h3><ol><li><p>实体完整性</p><p>实体完整性约束就是对事物进行区分的唯一属性，在数据库中通常通过非空主键（primary key）来体现</p></li><li><p>参照完整性</p><p>参照完整性指的是关系与关系之间的联系，即表与表之间的联系，通常对应表中的外键约束或外键引用（Foreign Key）</p></li><li><p>用户自定义完整性</p><p>用户定义的完整性，针对的是某一个具体使用的数据库中的约束条件。反映的是具体应用、具体业务或场景，涉及的数据必须满足的要求。</p><p>这类约束的实现，可以放在应用层完成检查校验；也可以由关系数据库管理系统，提供对这类完整性定义、实现和检验的机制，由数据库系统层统一管理和处理，减少应用程序的负担</p><p><em>例如电话号码，身份证的有效性检验</em></p></li></ol><hr><h1 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h1><h3 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h3><p>关系数据库中的关系是要满足一定要求的，满足不同程度要求的为不同范式</p><p>一个低一级范式的关系模式通过模式分解可以转换为若干个高一级范式的关系模式的集合，这种过程就叫<strong>规范化</strong></p><p><em>个人理解：范式的存在就是为了消除数据冗余</em></p><ol><li><p>第一范式：无重复的列</p></li><li><p>第二范式：属性完全依赖于主键</p><p><em>注：如果出现了联合主键（例如：学号和学生姓名，课程号和课程名）同时出现一张表中，存在部份依赖，不符合第二范式</em></p></li><li><p>第三范式：要求一个数据库表中不包含已在其它表中已包含的非主关键字信息</p></li><li><p>BC范式：</p><p>与2NF,3NF的定义不同，BCNF的定义直接建立在1NF的基础上。但实质上BCNF是3NF的改进形式。3NF仅考虑了非主属性对键的依赖情况，BCNF把主属性对键的依赖情况也包括进去。BCNF要求满足的条件比3NF所要求的更高。如果关系模式R是BCNF的，那么R必定是3NF，反之，则不一定成立。</p></li></ol><hr><h3 id="模式的分解"><a href="#模式的分解" class="headerlink" title="模式的分解"></a>模式的分解</h3><p>模式分解的三个定义：</p><ol><li>分解具有无损连接性</li><li>分解要保持函数依赖</li><li>分解既要保证无损连接性，也要保持函数依赖</li></ol><p>这三个定义是实行分解的三条不同的准则。按照不同的分解准则，模式所能达到的分离程度各不相同，各种范式就是对分离程度的测度</p><hr><h1 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h1><p>数据库的设计中分为以下五个步骤</p><ol><li>需求分析</li><li>概念结构设计</li><li>逻辑结构设计</li><li>物理结构设计</li><li>数据库的实施与维护</li></ol><hr><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><h5 id="需求分析的任务"><a href="#需求分析的任务" class="headerlink" title="需求分析的任务"></a>需求分析的任务</h5><p>调查的重点是“数据”和“处理”，通过调查、收集与分析，获得用户对数据库的如下要求</p><ol><li>信息要求</li><li>处理要求</li><li>安全性与完整性要求</li></ol><h5 id="需求分析的方法"><a href="#需求分析的方法" class="headerlink" title="需求分析的方法"></a>需求分析的方法</h5><p>调查步骤</p><ol><li>调查组织机构情况</li><li>调查各部门的业务活动情况</li><li>在熟悉业务活动的基础上，协助用户明确对新系统的各种要求</li><li>确定新系统的边界</li></ol><p>调查方法</p><ol><li>跟班作业</li><li>开调查会</li><li>请专人介绍</li><li>询问</li><li>设计调查表请用户填写</li><li>查阅记录</li></ol><h5 id="数据字典"><a href="#数据字典" class="headerlink" title="数据字典"></a>数据字典</h5><p>关于数据库中数据的描述，即元数据，而不是数据本身。数据字典是在需求分析阶段建立，在数据库设计过程中不断修改、充实、完善的。它在数据库设计中占有很重要的地位</p><ol><li>数据项</li><li>数据结构</li><li>数据流</li><li>数据存储</li><li>处理过程</li></ol><hr><h3 id="概念结构设计"><a href="#概念结构设计" class="headerlink" title="概念结构设计"></a>概念结构设计</h3><h5 id="ER模型"><a href="#ER模型" class="headerlink" title="ER模型"></a>ER模型</h5><p>实体之间的联系：</p><ol><li>一对一联系</li><li>一对多联系</li><li>多对多联系</li></ol><h5 id="ER图"><a href="#ER图" class="headerlink" title="ER图"></a>ER图</h5><p>E-R 图提供了表示实体型、属性和联系的方法</p><ol><li>实体型用矩形表示，矩形框内写明实体名</li><li>属性用椭圆形表示，并用无向边将其与相应的实体型连接起来</li><li>联系用菱形表示，菱形框内写明联系名，并用无向边分别与有关实体型连接起来在无向边旁标上联系的类型(1:1、1:n或m:n)</li></ol><p>各子系统的 E-R图之间的冲突主要有三类:属性冲突、命名冲突和结构冲突</p><hr><h3 id="逻辑结构设计"><a href="#逻辑结构设计" class="headerlink" title="逻辑结构设计"></a>逻辑结构设计</h3><p>逻辑结构设计的任务就是把概念结构设计阶段设计好的基本 E-R 图转换为与选用数据库管理系统产品所支持的数据模型相符合的逻辑结构</p><p>设计步骤：</p><ol><li>一个实体型转换为一个关系模式</li><li>一个 1:1 联系可以转换为一个独立的关系模式，也可以与任意一端对应的关系模式合并</li><li>一个 1:n 联系可以转换为一个独立的关系模式，也可以与 n 端对应的关系模式合并</li><li>一个 m:n 联系转换为一个关系模式</li><li>三个或三个以上实体间的一个多元联系可以转换为一个关系模式</li><li>具有相同码的关系模式可合并</li></ol><p><em><strong>注：数据库逻辑设计的结果不是唯一的，且并不是规范化程度越高的关系就越优</strong></em></p><hr><h3 id="物理结构设计"><a href="#物理结构设计" class="headerlink" title="物理结构设计"></a>物理结构设计</h3><p>为一个给定的逻辑数据模型选取一个最适合应用要求的物理结构的过程，就是数据库的物理设计</p><p>设计步骤：</p><ol><li>确定数据库的物理结构</li><li>对物理结构进行评价</li></ol><hr><h3 id="数据库的实施与维护"><a href="#数据库的实施与维护" class="headerlink" title="数据库的实施与维护"></a>数据库的实施与维护</h3><p><strong>数据库应用程序的设计应该与数据库设计同时进行</strong></p><p>要注意两点：</p><ol><li>在数据库试运营时，先输入小批量数据做调试用，待试运行基本合格后再大批量输入数据，逐步增加数据量，逐步完成运行评价</li><li>要做好数据库的转储和恢复工作</li></ol><hr><h1 id="第十章"><a href="#第十章" class="headerlink" title="第十章"></a>第十章</h1><h3 id="故障的种类"><a href="#故障的种类" class="headerlink" title="故障的种类"></a>故障的种类</h3><ol><li><p>事务内部的故障</p><p>一小部分由事务程序发生的故障是可以由程序本身发现的，会直接让事物回滚（ROLLBACK）</p><p>绝大多数的事务内部故障是非预期的，是不能由应用程序处理的（一般都指的是此类故障）</p><p>事物撤销（UNDO）</p></li><li><p>系统故障</p><p>系统故障是指造成系统停止运转的任何事件，使得系统要重新启动</p><p>重做（REDO）</p></li></ol><p>各类故障对数据库的影响有两种可能性：</p><ol><li>数据库本身被破坏</li><li>数据库没有被破坏，但数据可能不正确</li></ol><p><strong>恢复的基本原理就是利用冗余</strong></p><hr><h3 id="恢复的实现技术"><a href="#恢复的实现技术" class="headerlink" title="恢复的实现技术"></a>恢复的实现技术</h3><p>建立冗余数据最常用的技术是数据转储和登记日志文件 (logging）</p><h5 id="数据转储"><a href="#数据转储" class="headerlink" title="数据转储"></a>数据转储</h5><p>数据转储有两种方式，分别可以在两种状态下进行，因此数据转储方法可以分为4类:动态海量转储、动态增量转储、静态海量转储和静态增量转储</p><p><em>个人理解：数据转储就是整盘备份，可以恢复到备份时间点后在运行所有更新事务</em></p><h5 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h5><p>日志文件是用来记录事务对数据库的更新操作的文件</p><p>日志文件中需要登记的内容包括:</p><ul><li>各个事务的开始(BEGINTRANSACTION)标记</li><li>各个事务的结束(COMMIT或ROLLBACK)标记</li><li>各个事务的所有更新操作</li></ul><p>为保证数据库是可恢复的，登记日志文件时必须遵循两条原则:</p><ul><li>登记的次序严格按并发事务执行的时间次序</li><li>必须先写日志文件，后写数据库</li></ul><hr><h1 id="第十一章"><a href="#第十一章" class="headerlink" title="第十一章"></a>第十一章</h1><h3 id="并发控制概述"><a href="#并发控制概述" class="headerlink" title="并发控制概述"></a>并发控制概述</h3><p>事务是并发控制的基本单位</p><p>并发控制机制就是要用正确的方式调度并发操作，使一个用户事务的执行不受其他事务的干扰，从而避免造成数据的不一致性</p><p>发控制的主要技术有封锁(locking)、时间戳(timestamp)、乐观控制法(optimisticscheduler)和多版本并发控制(multi-version concurrency control，MVCC)等</p><hr><h3 id="封锁"><a href="#封锁" class="headerlink" title="封锁"></a>封锁</h3><p>排他锁又称为写锁</p><p>共享锁又称为读锁</p><p><em>个人理解：写锁只能有一把，但是读锁可以由多把</em></p><hr><h3 id="活锁与死锁"><a href="#活锁与死锁" class="headerlink" title="活锁与死锁"></a>活锁与死锁</h3><h5 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h5><p>活锁最简单的解决方法就是使用队列</p><h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><p>出现T1在等待 T2，而T2又在等待T1的局面，T1和T2，两个事务永远不能结束，形成死锁</p><p>数据库系统中诊断死锁有两种方法</p><ol><li><p>超时法</p></li><li><p>事务图等待法</p><p>如果事务图形成回路，则发生死锁</p></li></ol><p>死锁的情况可以多种多样，死锁解决的方法就是<strong>选择一个处理死锁代价最小的事务，将其撤销，释放此事务持有的所有的锁，使其他事务得以继续运行下去</strong></p><hr><h3 id="两端锁协议"><a href="#两端锁协议" class="headerlink" title="两端锁协议"></a>两端锁协议</h3><p>两段锁 (TwoPhase Locking，简称2PL)</p><p>第一阶段是获得封锁，也称为扩展阶段</p><p>第二阶段是释放封锁，也称为收缩阶段</p><p>事务遵守两段锁协议是可串行化调度的充分条件，而不是必要条件</p><hr><h3 id="封锁的粒度"><a href="#封锁的粒度" class="headerlink" title="封锁的粒度"></a>封锁的粒度</h3><p>封锁对象的大小称为封锁粒度(granularity)</p><p>封锁对象可以是逻辑单元，也可以是物理单元</p><p>封锁粒度与系统的并发度和并发控制的开销密切相关</p><hr>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
      <category>ccut</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>多线程-线程同步</title>
    <link href="/2023/05/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
    <url>/2023/05/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h1><h3 id="数据安全问题"><a href="#数据安全问题" class="headerlink" title="数据安全问题"></a>数据安全问题</h3><p>出现问题的原因</p><ul><li>多线程环境</li><li>共享数据</li><li>多条语句同时操作共享数据</li></ul><h5 id="数据安全问题的解决"><a href="#数据安全问题的解决" class="headerlink" title="数据安全问题的解决"></a>数据安全问题的解决</h5><p>思路：让程序没有安全问题的环境</p><hr><h3 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h3><p>可以用同步代码块将操作共享数据的多条语句锁起来</p><p><em>synchronized中文释义：同步</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//任意对象</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-keyword">synchronized</span> (obj) &#123;<br>    <span class="hljs-comment">//操作共享数据的语句</span><br>&#125;<br></code></pre></td></tr></table></figure><p>通过synchronized加锁后，被锁起来的语句不会同时被多个线程执行，这样就可以解决数据安全问题</p><p><em>注：不能用不同的obj作为‘锁’，那样就是用不同的‘锁’来控制代码块，会不起作用</em><br><em>使用实现Runnable的方式时,由于object与this都指代同一个对象,可直接使用,但使用继承Thread类方式时,不可直接使用object,实例化对象时需用静态对象</em></p><h5 id="同步代码块的优缺点"><a href="#同步代码块的优缺点" class="headerlink" title="同步代码块的优缺点"></a>同步代码块的优缺点</h5><ul><li>好处：解决了多线程的数据安全性问题</li><li>当线程很多时，每个线程都会去判断同步代码块上面的‘锁’，这是一件很耗费资源的事，无形中会降低程序的运行效率</li></ul><hr><h3 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h3><p>同步方法就是将synchronized关键字加到方法上</p><ul><li><p>格式：</p><p>修饰符 synchronized 返回值类型 方法名(方法参数){ }</p></li></ul><p><em>同步方法的任意对象（obj）为本类（this）</em></p><h5 id="同步静态方法"><a href="#同步静态方法" class="headerlink" title="同步静态方法"></a>同步静态方法</h5><p>synchronized同样也可以加在静态方法上</p><ul><li><p>格式：</p><p>修饰符 static synchronized 返回值类型 方法名(方法参数){ }</p></li></ul><p><em>和同步方法不同，同步静态方法的任意对象（obj）为当前类的字节码文件（.class）</em></p><p><em>可通过类名.class的方式访问类的字节码文件</em></p><hr><h3 id="线程安全的类"><a href="#线程安全的类" class="headerlink" title="线程安全的类"></a>线程安全的类</h3><p>StringBuffer</p><ul><li>线程安全，可变的字符序列</li><li>从JDK5开始，被StringBuilder替代，如果不需要线程安全，更推荐使用StringBuilder</li></ul><p>Vector</p><ul><li><p>线程安全，该类实现了List接口</p></li><li><p>从Java2平台v1.2开始该类改进了List接口，是集合体系中的一员。Vector被同步，如果不需要线程安全，更推荐使用ArrayList</p></li></ul><p>Hashtable</p><ul><li>线程安全，该类实现了哈希表（键值对）</li><li>从Java2平台v1.2开始该类改进了Map接口，是集合体系中的一员。Hashtable被同步，如果不需要线程安全，更推荐使用HashMap</li></ul><table><thead><tr><th>线程安全</th><th>非线程安全</th></tr></thead><tbody><tr><td>StringBuffer</td><td>StringBuilder</td></tr><tr><td>Vector</td><td>ArrayList</td></tr><tr><td>Hashtable</td><td>HashMap</td></tr></tbody></table><h5 id="Collections-synchronized"><a href="#Collections-synchronized" class="headerlink" title="Collections.synchronized"></a>Collections.synchronized</h5><p>除StringBuffer外，其他两个类我们并不常用到</p><p>在使用线程安全的集合时，我们通常使用Collections工具类的synchronized系列方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//将ArrayList集合变成线程安全的集合</span><br>        List&lt;Object&gt; objects = Collections.synchronizedList(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="Lock锁"><a href="#Lock锁" class="headerlink" title="Lock锁"></a>Lock锁</h3><p>为了更清晰的表达如何加锁和释放锁，JDK5以后提供了一个新的锁对象Lock</p><p>Lock实现提供比synchronized方法和语句更广泛的锁定操作</p><p>Lock接口提供了获得锁和释放锁的方法</p><ul><li>void lock()：获得锁</li><li>void unlock()：释放锁</li></ul><p>Lock是接口不能够实例化，可以用其实现类ReentrantLock实例化对象</p><ul><li>ReentrantLock()：无参构造方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">//考虑在声明lock的时候加入static和final关键字</span><br>        <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>        <span class="hljs-keyword">try</span>&#123;<br>            lock.lock();<br>            <span class="hljs-comment">//这里写被枷锁的代码块</span><br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>为了让unlock方法无论何时都被执行，这里使用try finally来实现</em></p><hr><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>线程同步机制带来的问题:死锁</p><p>死锁不能由程序解开,只能是人为解锁</p><p>所以我们在编写代码时应该避免死锁的出现</p><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>JAVASE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Screen</title>
    <link href="/2023/04/24/Screen/"/>
    <url>/2023/04/24/Screen/</url>
    
    <content type="html"><![CDATA[<h1 id="Screen的基本命令"><a href="#Screen的基本命令" class="headerlink" title="Screen的基本命令"></a>Screen的基本命令</h1><table><thead><tr><th>功能</th><th>命令</th></tr></thead><tbody><tr><td>创建会话</td><td>screen -S <name></td></tr><tr><td>列出当前所有会话</td><td>screen -ls</td></tr><tr><td>恢复指定会话</td><td>screen -r &lt;name&#x2F;id&gt;</td></tr><tr><td>删除指定会话</td><td>screen -S &lt;name&#x2F;id&gt; -X quit</td></tr><tr><td>指定会话离线</td><td>screen -d <name></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
      <category>server</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Docker</title>
    <link href="/2023/04/24/Docker/"/>
    <url>/2023/04/24/Docker/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><h3 id="Docker概念"><a href="#Docker概念" class="headerlink" title="Docker概念"></a>Docker概念</h3><p>Docker是一个开源的应用容器引擎</p><p>诞生于2013年初，基于Go语言实现，dotCloud公司出品（后改名为Docker Lnc）</p><p>docker可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的linux容器上</p><p>容器使用沙箱机制，<strong>相互隔离</strong></p><p>容器的性能开箱极低</p><p>官方网站：<a href="http://www.docker.com/">www.docker.com</a></p><h3 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">1.yum包更新到最新版本</span><br>yum update <br><span class="hljs-meta prompt_"># </span><span class="language-bash">2.安装需要的软件包，yum-util提供yum-config-manager功能，其他两个是驱动依赖</span><br>yun install -y yum-utils device-mapper-persistent-data lvm2<br><span class="hljs-meta prompt_"># </span><span class="language-bash">3.设置yum源</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">4.安装docker</span><br>yum install -y docker-ce<br><span class="hljs-meta prompt_"># </span><span class="language-bash">5.查看docker版本</span><br>docker -v<br></code></pre></td></tr></table></figure><h3 id="Docker架构"><a href="#Docker架构" class="headerlink" title="Docker架构"></a>Docker架构</h3><p>daemon守护进程中，有容器和镜像</p><p><em>注：类比java，容器类似于对象，镜像类似于类</em></p><p>docker仓库专门存放镜像，分为<strong>官方仓库</strong>和<strong>私有仓库</strong></p><p><em>docker hub官方仓库下载docker镜像太慢，一般都会配置镜像加速器；例如：USTC 阿里云 腾讯云 网易云</em></p><h3 id="Docker命令"><a href="#Docker命令" class="headerlink" title="Docker命令"></a>Docker命令</h3><h4 id="Docker服务相关命令"><a href="#Docker服务相关命令" class="headerlink" title="Docker服务相关命令"></a>Docker服务相关命令</h4><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>systemctl start docker</td><td>启动docker</td></tr><tr><td>systemctl stop docker</td><td>停止docker</td></tr><tr><td>systemctl status docker</td><td>查看docker状态</td></tr><tr><td>systemctl restart docker</td><td>重启docker</td></tr><tr><td>systemctl enable docker</td><td>开机启动docker</td></tr></tbody></table><hr><h4 id="Docker镜像相关命令"><a href="#Docker镜像相关命令" class="headerlink" title="Docker镜像相关命令"></a>Docker镜像相关命令</h4><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>docker images</td><td>查看本地镜像内容</td></tr><tr><td>docker search &lt;镜像名&gt;</td><td>查看仓库是否有镜像文件</td></tr><tr><td>docker pull &lt;镜像名&gt;</td><td>拉取镜像（默认拉取最新版）</td></tr><tr><td>docker rmi &lt;镜像id&gt;</td><td>删除指定镜像</td></tr><tr><td>docker rim &#96;&#96;docker images -q</td><td>查看所有的镜像id作为参数被删除（删除所有镜像）</td></tr></tbody></table><p><em>注：拉取和删除镜像时可以用 :&lt;版本号&gt;来指定版本拉取&#x2F;删除镜像</em></p><p><em>如不知道版本号可以通过镜像官方网站hub.docker.com查找</em></p><hr><h4 id="docker容器相关命令"><a href="#docker容器相关命令" class="headerlink" title="docker容器相关命令"></a>docker容器相关命令</h4><p><strong>docker run 命令</strong>：启动容器</p><p>参数-i：容器保持运行</p><p>参数-t：给容器分配终端，可以接受命令</p><p>参数–name&#x3D;&lt;容器名字&gt;：给容器起名字</p><p>参数&#x2F;bin&#x2F;bash：打开容器终端*（加在最后）*</p><p>exit：退出容器</p><p><strong>docker ps命令</strong>：查看容器</p><p>参数-a：查看历史容器（包括已关闭的容器）</p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
      <category>server</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Webdav</title>
    <link href="/2023/04/24/Webdav/"/>
    <url>/2023/04/24/Webdav/</url>
    
    <content type="html"><![CDATA[<h1 id="如何使用docker搭建一个webdav服务器"><a href="#如何使用docker搭建一个webdav服务器" class="headerlink" title="如何使用docker搭建一个webdav服务器"></a>如何使用docker搭建一个webdav服务器</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run --restart always -v /srv/dav:/var/lib/dav  -e AUTH_TYPE=Basic -e USERNAME=&#x27;用户名&#x27; -e PASSWORD=&#x27;密码&#x27; --publish &#x27;端口&#x27;:80 -d bytemark/webdav<br></code></pre></td></tr></table></figure><p>替换用户名 密码以及端口创建容器成功</p><p>将&#x2F;srv&#x2F;dav作为共享文件夹挂载到docker</p><p>docker run –restart always -v &#x2F;srv&#x2F;dav:&#x2F;var&#x2F;lib&#x2F;dav  -e AUTH_TYPE&#x3D;Basic -e USERNAME&#x3D;XIAOBAI -e PASSWORD&#x3D;XIAOBAI –publish 8060:80 -d bytemark&#x2F;webdav</p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
      <category>server</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>adb/fastboot常用命令</title>
    <link href="/2023/04/24/adb-fastbootchang-yong-ming-ling/"/>
    <url>/2023/04/24/adb-fastbootchang-yong-ming-ling/</url>
    
    <content type="html"><![CDATA[<h1 id="adb-fastboot常用命令"><a href="#adb-fastboot常用命令" class="headerlink" title="adb&#x2F;fastboot常用命令"></a>adb&#x2F;fastboot常用命令</h1><h3 id="adb常用命令"><a href="#adb常用命令" class="headerlink" title="adb常用命令"></a>adb常用命令</h3><ul><li>adb devices</li></ul><p>查看adb链接设备</p><ul><li>adb reboot bootloader</li></ul><p>重启到fastboot模式</p><ul><li>adb reboot recovery</li></ul><p>重启到rec模式</p><ul><li>adb install &lt;appname&gt;.apk</li></ul><p>安装应用</p><h3 id="fastboot常用命令"><a href="#fastboot常用命令" class="headerlink" title="fastboot常用命令"></a>fastboot常用命令</h3><ul><li>fastboot devices</li></ul><p>查看fastboot链接设备</p><ul><li>fastboot flash boot &lt;bootname&gt;.img</li></ul><p>刷入boot</p><ul><li>fastboot flash recovery &lt;recoveryname&gt;.img</li></ul><p>刷入rec</p><ul><li>fastboot reboot</li></ul><p>重启</p><p><strong>注：在rec模式下adb连接手机后可以用adb sideload &lt;filename&gt;.zip 命令将卡刷包推送到手机自动刷机</strong></p><p>这种方法适用于：系统升级&#x2F;刷入谷歌套件</p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
      <category>note</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JSP</title>
    <link href="/2023/04/24/JSP/"/>
    <url>/2023/04/24/JSP/</url>
    
    <content type="html"><![CDATA[<h1 id="指令标记，动作标记和自定义标记"><a href="#指令标记，动作标记和自定义标记" class="headerlink" title="指令标记，动作标记和自定义标记"></a>指令标记，动作标记和自定义标记</h1><h3 id="指令标记"><a href="#指令标记" class="headerlink" title="指令标记"></a>指令标记</h3><h5 id="page标记"><a href="#page标记" class="headerlink" title="page标记"></a>page标记</h5><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%<span class="hljs-meta">@page</span> contentType=<span class="hljs-string">&quot;text/java;charset=UTF-8&quot;</span>%&gt;<br></code></pre></td></tr></table></figure><p>  contentType：设置MIME类型和字符编码</p><p>  import：导入类</p><p>  pageencoding：定义jsp的编码格式</p><h5 id="include标记"><a href="#include标记" class="headerlink" title="include标记"></a>include标记</h5><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%<span class="hljs-meta">@include</span> file=<span class="hljs-string">&quot;1.jsp&quot;</span>%&gt;<br></code></pre></td></tr></table></figure><p>  导入整个页面</p><h3 id="动作标记"><a href="#动作标记" class="headerlink" title="动作标记"></a>动作标记</h3><h5 id="include标记-1"><a href="#include标记-1" class="headerlink" title="include标记"></a>include标记</h5><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;jsp:include page=<span class="hljs-string">&quot;&quot;</span>&gt;<br>  &lt;jsp:param value=<span class="hljs-string">&quot;&quot;</span> name=<span class="hljs-string">&quot;&quot;</span>&gt;&lt;/jsp:param&gt;<br>&lt;/jsp:include&gt;<br></code></pre></td></tr></table></figure><p>  通过jsp:include可以导入页面（通过动态标签的方式）</p><p>  在标签对里面使用jsp:param可以在导入页面的时候传参</p><h5 id="forward标记"><a href="#forward标记" class="headerlink" title="forward标记"></a>forward标记</h5><p>  执行页面跳转——转发</p><p>  page属性指定转发的页面</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;jsp:forward page=<span class="hljs-string">&quot;&quot;</span>&gt;&lt;/jsp:forward&gt;<br></code></pre></td></tr></table></figure><p>   通过forward标签可以转发到指定页面</p><p>  <em>注：forword转发后导航栏网址不变，其目标是简化问题的解决</em></p><hr><h1 id="JSP内置对象"><a href="#JSP内置对象" class="headerlink" title="JSP内置对象"></a>JSP内置对象</h1><p>  概念：在JSP页面的java程序片和java表达式中可以直接使用的局部变量</p><ul><li>request</li></ul><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%<br>    request.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);<span class="hljs-comment">//设置编码格式</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> request.getParameter(<span class="hljs-string">&quot;&quot;</span>);<span class="hljs-comment">//接受单个参数值</span><br>    String[] ss = request.getParameterValues(<span class="hljs-string">&quot;&quot;</span>);<span class="hljs-comment">//接受多个参数值</span><br>    request.setAttribute(<span class="hljs-string">&quot;属性名&quot;</span>,<span class="hljs-string">&quot;属性值&quot;</span>);<br>    request.getRequestDispatcher(<span class="hljs-string">&quot;show.jsp&quot;</span>).forward(request,response);<span class="hljs-comment">//另一种转发方法</span><br>%&gt;<br></code></pre></td></tr></table></figure><ul><li>response</li></ul><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%<br>response.sendRedirect(url);<span class="hljs-comment">//重定向</span><br>response.setHeader(<span class="hljs-string">&quot;refresh&quot;</span>,<span class="hljs-string">&quot;1;url=&quot;</span>);<span class="hljs-comment">//刷新</span><br>%&gt;<br></code></pre></td></tr></table></figure><p>  <em>注：区别于转发和重定向，转发是服务端操作，浏览器地址不改变，重定向是浏览器操作，浏览器地址栏改变</em></p><ul><li>out</li></ul><p>  response.getWriter获取的对象</p><p>  out.print显示结果</p><ul><li>session <ul><li>public void setAttribute(String key,Object value)</li><li>public Object getAttribute(String Key)</li><li>public void removeAttribute(String key)</li></ul></li></ul><p>  从打开浏览器开始到关闭浏览器结束</p><p>  实质上是请求中的方法 request.getSession()                                                                                                                                                                                                                                      </p><p>  <em>session不同于请求和响应，不会随着请求响应的变化而关闭</em></p><ul><li>application</li></ul><p>  以服务器开始为开始，以服务器结束为结束</p><p>  <strong>application的方法和session基本相同</strong></p><ul><li>page、pageContext、config、exception</li></ul><p>  <em>page对象以页面为存活时间，无论是转发，重定向都会消失</em></p><p>  page对象是当前JSP页面转译生成的java文件所创建的对象</p><p>  pageContext对象可以获取当前页面的访问对象及相关页面信息</p><p>  setAttribute方法</p><p>  getAttribute方法</p><p>  findAttribute()方法</p><h1 id="javabean"><a href="#javabean" class="headerlink" title="javabean"></a>javabean</h1><p>  javaBean也分为三大类，分别是成员类、工具类、判别类</p><h2 id="三个基本动作标记"><a href="#三个基本动作标记" class="headerlink" title="三个基本动作标记"></a>三个基本动作标记</h2><ul><li>&lt;jsp:useBean&gt;</li><li>&lt;jsp:getProperty&gt;</li><li>&lt;jsp:setProperty&gt;</li></ul><h3 id="使用useBean标签寻找-创建对象"><a href="#使用useBean标签寻找-创建对象" class="headerlink" title="使用useBean标签寻找&#x2F;创建对象"></a>使用useBean标签寻找&#x2F;创建对象</h3><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;jsp:useBean id=<span class="hljs-string">&quot;对象名&quot;</span> class=<span class="hljs-string">&quot;类全名（包括包名）&quot;</span> scope=<span class="hljs-string">&quot;page/request/session/application&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p>  useBean的运行步骤</p><ol><li><p>最开始先从scope（内置对象）中寻找相应存在attribute中的id（对象名）</p><p><em>这一步用了getAttribute的方法</em></p></li><li><p>如果没有，就向外层寻找，比如scope写的是request，当request中没有时，向Session或application中寻找</p><p><em>这一步用了findAttribute方法</em></p></li><li><p>如果找到在1,2的步骤中找到，则标签返回此对象</p></li><li><p>如果都没找到，则在scope中的Attribute中根据class（类）实例化此对象</p></li></ol><hr><h3 id="使用访问器"><a href="#使用访问器" class="headerlink" title="使用访问器"></a>使用访问器</h3><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;jsp:getProperty name=<span class="hljs-string">&quot;对象名&quot;</span> property=<span class="hljs-string">&quot;成员变量名&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p>使用此访问器可直接访问对象中某一成员变量，返回值是该成员变量。</p><p><em>此访问器除直接访问变量之外，还可以访问以get&#x2F;is开头的方法，直接返回其方法的返回值</em></p><hr><h3 id="使用修改器"><a href="#使用修改器" class="headerlink" title="使用修改器"></a>使用修改器</h3><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;jsp:setProperty name=<span class="hljs-string">&quot;对象名&quot;</span> property=<span class="hljs-string">&quot;*&quot;</span>&gt; <br></code></pre></td></tr></table></figure><p>使用此修改器能直接修改对象中成员变量的属性</p><p>需注意，Property取值为*，必须保证传参时变量名称一致</p><p><em>由于表单中传过来的数据类型都是String 类型的，Jsp内在机制会把这些参数转化成Bean属性对应的类型。</em></p><hr><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;jsp:setProperty name=<span class="hljs-string">&quot;对象名&quot;</span> property=<span class="hljs-string">&quot;成员变量名&quot;</span> param=<span class="hljs-string">&quot;赋值来源参数名&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p>使用此修改器能直接修改对象中成员变量的属性</p><p><em>同方式一，也会把param传来的参数自动转化成成员变量的类型</em></p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;jsp:setProperty name=<span class="hljs-string">&quot;对象名&quot;</span> property=<span class="hljs-string">&quot;成员变量名&quot;</span> value=<span class="hljs-string">&quot;变量或表达式&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p>使用此修改器能直接修改对象中成员变量的属性</p><p><em>同方式一，也会把value中的值（表达式或字符串）自动转化成成员变量的类型</em></p><hr><h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><p>继承于HttpServlet类的一个子类</p><p><em>Jsp相当于把java程序片卸载网页中，Servlet相当于把网页写在；Java类中</em></p><hr><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p>public void init(ServletConfig config)</p><p>public void doGet&#x2F;doPost(HttpServletRequest request,HttpServletResponse response)</p><p>publie void destroy()</p><hr><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li><p>创建Servlet类</p></li><li><p>在web.xml文件中注册Servlet对象，格式：   </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span>&gt;</span><br>  ……<br>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>Servlet对象名<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>Servlet类全名<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>Servlet对象名<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/格式<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>或者在创建Servlet时利用@WebServlet完成配置Servlet：格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(&quot;/格式&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">XxxServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>亦或者多配置一些信息（对象名，多个格式，或者是带一些默认值）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(name=&quot;对象名字&quot;,</span><br><span class="hljs-meta">           urlPatterns=&#123;</span><br><span class="hljs-meta">              &quot;/格式1&quot;,</span><br><span class="hljs-meta">              &quot;/格式2&quot;</span><br><span class="hljs-meta">            &#125;</span><br><span class="hljs-meta">           initParams=&#123;</span><br><span class="hljs-meta">             @WebInitParam(name=&quot;param&quot;,value=&quot;123&quot;)，</span><br><span class="hljs-meta">               ……</span><br><span class="hljs-meta">           &#125;</span><br><span class="hljs-meta">           ……)</span><br></code></pre></td></tr></table></figure></li></ol><hr><h3 id="内置对象的一些特殊的定义方法"><a href="#内置对象的一些特殊的定义方法" class="headerlink" title="内置对象的一些特殊的定义方法"></a>内置对象的一些特殊的定义方法</h3><p><em>因为request和response是形参，可以直接使用。但是其他的内置对象需要单独定义</em></p><p>out:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">PrintWriter</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> resp.getWriter();<br></code></pre></td></tr></table></figure><p>session:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">HttpSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> req.getSession();<span class="hljs-comment">//非严格形式</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//严格形式</span><br><span class="hljs-type">HttpSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> req.getSession(<span class="hljs-literal">false</span>);<span class="hljs-comment">//使用已有的Session</span><br><span class="hljs-keyword">if</span>(session == <span class="hljs-literal">null</span>)&#123;<br>  session = req.getSession(<span class="hljs-literal">true</span>);<span class="hljs-comment">//当没有Session时，创建新的Session</span><br>&#125;<br></code></pre></td></tr></table></figure><p>application:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ServletContext</span> <span class="hljs-variable">application</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getServletContext();<br></code></pre></td></tr></table></figure><h1 id="EL"><a href="#EL" class="headerlink" title="EL"></a>EL</h1><p>Expression Language(表达式语言)</p><p>EL的底层操作就是调用内置对象方法</p><h3 id="表达式的构成"><a href="#表达式的构成" class="headerlink" title="表达式的构成"></a>表达式的构成</h3><ol><li><p>隐式对象</p><p>param、paramValues、initParam</p><table><thead><tr><th>jsp内置对象</th><th>EL隐式对象</th></tr></thead><tbody><tr><td>request.getParameter(“a”)</td><td>${param.a}</td></tr><tr><td>request.getAttribute(“a”)</td><td>${requestScope.a}</td></tr><tr><td>session.getAttribute(“a”)</td><td>${SessionScope.a}</td></tr><tr><td>pageConpage.findAttribute(“a”)</td><td>${a}</td></tr><tr><td>获取a中的属性value</td><td>${sessionScope.a.value}</td></tr></tbody></table></li></ol><p><em>scope中文释义：范围</em></p><ol start="2"><li>常量：boolean、整数、浮点数、字符串和null</li><li>运算符：算术运算符、关系运算符、逻辑运算符、空</li></ol><h1 id="JSTL"><a href="#JSTL" class="headerlink" title="JSTL"></a>JSTL</h1><p>JSP Standard Tap Liberary(JSP标准标记库)</p><h3 id="引入格式"><a href="#引入格式" class="headerlink" title="引入格式"></a>引入格式</h3><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%<span class="hljs-meta">@taglib</span>  uri=<span class="hljs-string">&quot;路径及其类型&quot;</span> prefix=<span class="hljs-string">&quot;前缀&quot;</span>%&gt;<br></code></pre></td></tr></table></figure><h3 id="标记库类型"><a href="#标记库类型" class="headerlink" title="标记库类型"></a>标记库类型</h3><ol><li>核心标记库（core）——c</li><li>数据库访问标记库（sql）——sql</li><li>XML标记库（xml）——x</li><li>国际化标记库（fmt）——fmt</li><li>函数标记库（functions）——fn</li></ol><hr><h3 id="核心标记库"><a href="#核心标记库" class="headerlink" title="核心标记库"></a>核心标记库</h3><h5 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h5><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;c:forEach iterms=<span class="hljs-string">&quot;遍历源&quot;</span> <span class="hljs-keyword">var</span>=<span class="hljs-string">&quot;元素&quot;</span> varStatus=<span class="hljs-string">&quot;指定遍历状态&quot;</span> begin=<span class="hljs-string">&quot;开始的索引值&quot;</span> end=<span class="hljs-string">&quot;结束的索引值&quot;</span> step=<span class="hljs-string">&quot;步长（默认值1）&quot;</span>&gt;<br>循环体<br>&lt;/c:forEach&gt;<br></code></pre></td></tr></table></figure><p><em>begin、end、step分别表示：起始序号，结束序号，跳跃步伐。</em></p><p>我们一般用&lt;c:forEach&gt; 来遍历需要的数据，为了方便使用，varStatus属性可以方便我们实现一些与行数相关的功能，如：奇数行、偶数行差异；最后一行特殊处理等等。</p><p>varStatus 是循环索引。先就varStatus属性常用参数总结下：</p><table><thead><tr><th>属性值</th><th>功能</th></tr></thead><tbody><tr><td>${status.index}</td><td>输出行号，从0开始。</td></tr><tr><td>${status.count}</td><td>输出行号，从1开始。</td></tr><tr><td>${status.current}</td><td>当前这次迭代的（集合中的）项</td></tr><tr><td>${status.first}</td><td>判断当前项是否为集合中的第一项，返回值为true或false</td></tr><tr><td>${status.last}</td><td>判断当前项是否为集合中的最后一项，返回值为true或false</td></tr></tbody></table><hr><h5 id="if"><a href="#if" class="headerlink" title="if"></a>if</h5><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;c:<span class="hljs-keyword">if</span> test=<span class="hljs-string">&quot;判断条件&quot;</span>&gt;<br>执行体<br>&lt;/c:<span class="hljs-keyword">if</span>&gt;<br></code></pre></td></tr></table></figure><p>if用于单分支判断</p><hr><h5 id="choose、when和otherwise"><a href="#choose、when和otherwise" class="headerlink" title="choose、when和otherwise"></a>choose、when和otherwise</h5><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;c:choose&gt;<br>&lt;c:<span class="hljs-keyword">when</span> test=<span class="hljs-string">&quot;判断条件&quot;</span>&gt;<br>    执行体<br>    &lt;/c:<span class="hljs-keyword">when</span>&gt;<br>    ……<br>    &lt;c:otherwise&gt;最后一种操作&lt;/c:otherwise&gt;<br>&lt;/c:choose&gt;<br></code></pre></td></tr></table></figure><p>choose、when和otherwise用于多分支判断</p><p>具体使用时可与if elseif else 与switch类比</p><hr><h5 id="set"><a href="#set" class="headerlink" title="set"></a>set</h5><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;c:<span class="hljs-type">set</span> <span class="hljs-variable">var</span> <span class="hljs-operator">=</span><span class="hljs-string">&quot;变量名&quot;</span> value=<span class="hljs-string">&quot;值&quot;</span> scope=<span class="hljs-string">&quot;变量储存的范围&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p>新建变量</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;c:set target=<span class="hljs-string">&quot;Bean对象名&quot;</span> property=<span class="hljs-string">&quot;成员变量名&quot;</span> value=<span class="hljs-string">&quot;值&quot;</span> scope=<span class="hljs-string">&quot;成员变量的储存位置&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p>为对象成员变量赋值</p><hr><h5 id="url"><a href="#url" class="headerlink" title="url"></a>url</h5><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;c:url <span class="hljs-keyword">var</span>=<span class="hljs-string">&quot;存储url地址对象名&quot;</span> value=<span class="hljs-string">&quot;被重写的url&quot;</span> context=<span class="hljs-string">&quot;站点名&quot;</span> scope=<span class="hljs-string">&quot;变量储存范围&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p>该标签用于生成一个 URL 路径的字符串，该符串可用于<a> 标记实现 URL 的链接，或者用于网页转发和重定向等</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;c:url <span class="hljs-keyword">var</span>=<span class="hljs-string">&quot;path&quot;</span> value=<span class="hljs-string">&quot;../login.jsp&quot;</span> scope=<span class="hljs-string">&quot;page&quot;</span>/&gt;<br>&lt;a href=<span class="hljs-string">&quot;$&#123;pageScope.path&#125;&quot;</span>&gt;登录页面&lt;/a&gt;<br></code></pre></td></tr></table></figure><hr><h5 id="redirect"><a href="#redirect" class="headerlink" title="redirect"></a>redirect</h5><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;c:redirect url=<span class="hljs-string">&quot;重定向地址&quot;</span> context=<span class="hljs-string">&quot;站点名&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p>重定向</p><p><em>注:例如url和redirect标记均可写成双标记形式，在中加入c:param标记传参</em></p><hr><h3 id="数据库访问标记库"><a href="#数据库访问标记库" class="headerlink" title="数据库访问标记库"></a>数据库访问标记库</h3><h5 id="setDataSource"><a href="#setDataSource" class="headerlink" title="setDataSource"></a>setDataSource</h5><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;sql:dataSource diver=<span class="hljs-string">&quot;驱动串&quot;</span><br>                url=<span class="hljs-string">&quot;连接串&quot;</span><br>                user=<span class="hljs-string">&quot;用户名&quot;</span><br>                password=<span class="hljs-string">&quot;密码&quot;</span><br>                <span class="hljs-keyword">var</span>=<span class="hljs-string">&quot;存储链接的变量&quot;</span><br>                scope=<span class="hljs-string">&quot;存储对象的作用范围&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p>建立与数据库的连接源</p><hr><h5 id="query"><a href="#query" class="headerlink" title="query"></a>query</h5><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;sql:query <span class="hljs-keyword">var</span>=<span class="hljs-string">&quot;存储查询结果的变量&quot;</span><br>           sql=<span class="hljs-string">&quot;sql语句&quot;</span><br>           dataSource=<span class="hljs-string">&quot;数据源&quot;</span><br>           startRow=<span class="hljs-string">&quot;起始行&quot;</span><br>           maxRows=<span class="hljs-string">&quot;显示的最大行数&quot;</span><br>           scope=<span class="hljs-string">&quot;存储对象的作用范围&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p><em>注:需使用查询结果变量的rows方法返回查询结果集</em></p><p><em>可使用c:foreach标签遍历结果集</em></p><hr>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
      <category>ccut</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>多线程</title>
    <link href="/2023/04/24/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <url>/2023/04/24/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h3 id="多线程的实现方式（继承Thread类）"><a href="#多线程的实现方式（继承Thread类）" class="headerlink" title="多线程的实现方式（继承Thread类）"></a>多线程的实现方式（继承Thread类）</h3><ol><li>创建一个类MyThread，继承Thread类</li><li>在MyThread类中重写run()方法</li><li>创建MyThread类的对象</li><li>启动线程</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>            System.out.println(i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThreadTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyThread</span> <span class="hljs-variable">myThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>        <span class="hljs-type">MyThread</span> <span class="hljs-variable">myThread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br><br>        myThread.start();<br>        myThread1.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>run()方法</p><p>重写run()，run()是用来封装被线程执行的代</p></li><li><p>run()方法和start()方法的区别</p><p>run方法是封装线程执行的代码，直接调用，相当于普通方法的调用</p><p>start方法是启动线程，然后由JVM调用此线程的run()方法</p></li></ul><hr><h3 id="设置和获取线程名称"><a href="#设置和获取线程名称" class="headerlink" title="设置和获取线程名称"></a>设置和获取线程名称</h3><p>Thread类中设置和获取线程名称的方法</p><ul><li><p>void setName(String name)：将此线程的名称更改为等于参数name</p></li><li><p>String getName()：返回此线程的名称</p></li><li><p>通过构造方法也可以设置线程名称</p></li></ul><p><em>注：如果想要使用构造方法设置线程名称，需要在Thread子类中重写参数为String name的构造方法</em></p><p>如何获取main()方法所在的线程名称？、</p><ul><li><p>public static Thread currentThread()：返回对当前正在执行的线程对象的引用</p><p>用此引用调用getName()方法即可获得主方法线程名称</p></li></ul><hr><h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><p>线程调度有两种模型</p><ul><li>分时调度模型：所有线程轮流使用CPU的使用权，平均分配每个线程占用CPU的时间片</li><li>抢占式调度模型：优先让优先级高的线程使用CPU，如果线程的优先级相同，那么会随机选择一个，优先级高的线程获取的CPU时间片相对多一些</li></ul><p><strong>Java使用的是抢占式调度模型</strong></p><p>Thread类中提供了两个方法设置和获取线程的优先级</p><ul><li>public final int getPriority()：返回此线程的优先级</li><li>public final void setPriority(int newPriority)：更改此线程的优先级</li></ul><p><em>priority英文释义：优先，优先权</em></p><p>线程的默认优先级是5；线程优先级的范围是：1-10</p><p>线程优先级高仅仅表示线程获取CPU时间片的几率高，并不能真正保证线程实行顺序的先后</p><hr><h3 id="线程控制"><a href="#线程控制" class="headerlink" title="线程控制"></a>线程控制</h3><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>static void sleep(long millis)</td><td>使当前正在执行的线程停留（暂停执行）指定的毫秒数</td></tr><tr><td>void join()</td><td>等待这个线程死亡</td></tr><tr><td>void setDaemon(boolean on)</td><td>将此线程标记为守护线程，当运行的线程都是守护线程时，Java虚拟机将退出</td></tr></tbody></table><hr><h3 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h3><p><img src="/upload/duoxiancheng1.jpg" alt="duoxiancheng1"></p><hr><h3 id="多线程的实现方式（实现Runnable接口）"><a href="#多线程的实现方式（实现Runnable接口）" class="headerlink" title="多线程的实现方式（实现Runnable接口）"></a>多线程的实现方式（实现Runnable接口）</h3><ol><li>定义一个类MyRunnable，实现Runnable接口</li><li>在MyRunnable类中重写run()方法</li><li>创建MyRunnable类的对象</li><li>创建Thread类的对象，把MyRunnable对象作为构造方法的参数（后可接自定义线程名）</li><li>启动线程</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">99</span>; i++) &#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;:&quot;</span> + i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnableTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyRunnable</span> <span class="hljs-variable">my</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(my, <span class="hljs-string">&quot;高铁&quot;</span>);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(my, <span class="hljs-string">&quot;飞机&quot;</span>);<br>        t1.start();<br>        t2.start();<br>    &#125;<br></code></pre></td></tr></table></figure><p><em>注，Runnable接口中并没有Thread类的方法，如果想用方法（例如getName()）就需要使用Thread.currentThread()方法获取当前线程引用</em></p><p>相比继承Thread类，实现Runnable接口的好处</p><ul><li>避免了Java单继承的局限性（实现Runnable接口后可以继承其他类，而Thread不可以）</li><li>适合多个相同程序的代码去处理同一个资源的情况，把线程和程序的代码、数据有效分离，体现了面向对象的设计思想</li></ul><p><em>runnable英文释义：可运行的</em></p><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>JAVASE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>IO-特殊操作流</title>
    <link href="/2023/04/24/IO-%E7%89%B9%E6%AE%8A%E6%93%8D%E4%BD%9C%E6%B5%81/"/>
    <url>/2023/04/24/IO-%E7%89%B9%E6%AE%8A%E6%93%8D%E4%BD%9C%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h1 id="特殊操作流"><a href="#特殊操作流" class="headerlink" title="特殊操作流"></a>特殊操作流</h1><h2 id="标准流"><a href="#标准流" class="headerlink" title="标准流"></a>标准流</h2><p>System类中有两个静态的成员变量</p><ul><li>public static final InputStream in：标准输入流</li><li>public static final OutputStream out：标准输出流</li></ul><hr><h3 id="标准输入流"><a href="#标准输入流" class="headerlink" title="标准输入流"></a>标准输入流</h3><p>自己实现键盘录入数据</p><ul><li>BufferedReader br &#x3D; new BufferedReader(new InputStreamReader(System.in));</li></ul><p>写起来太麻烦，涉及到数据类型之间的转换，字节字符之间的转换，所以Java提供了一个类来实现键盘录入</p><ul><li>Scanner scanner &#x3D; new Scanner(System.in);</li></ul><p><em>标准输入流的基类是InputSteam</em></p><hr><h3 id="标准输出流"><a href="#标准输出流" class="headerlink" title="标准输出流"></a>标准输出流</h3><p>输出语句的本质，是一个标准的输出流</p><ul><li><p>PrintStream ps &#x3D; System.out;</p></li><li><p>PrintStream类有的方法，System.out都可以使用</p></li></ul><p><em>标准输出流的基类是OutputStream</em></p><hr><h2 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h2><p>打印流分类：</p><ul><li>字节打印流：PrintStream</li><li>字符打印流：PrintWriter</li></ul><p>打印流的特点：</p><ul><li>只负责输出数据，不负责读取数据</li><li>有自己的特有方法</li></ul><hr><h3 id="字节打印流"><a href="#字节打印流" class="headerlink" title="字节打印流"></a>字节打印流</h3><ul><li><p>PrintStream(String fileName)：使用指定文件名创建新的打印流</p></li><li><p>使用继承父类的方法写数据，查看的时候会转码；使用自己特有的方法写数据，查看的数据原样输出</p></li></ul><p><em>字节打印流区别于字节文件输出流（FileOutputStream）。</em></p><ol><li>他们有这共同的基类（OutputStream）</li><li>在使用时，他们的构造方法实参都是File，或者File的String</li><li>字节打印流不止有继承来的方法（write），还有独有的方法（print）</li></ol><hr><h3 id="字符打印流"><a href="#字符打印流" class="headerlink" title="字符打印流"></a>字符打印流</h3><p>字符打印流PrintWriter的构造方法：</p><ul><li><p>PrintWriter(String fileName)|使用指定文件名创建一个新的PrintWriter，而不需要自动执行刷新</p></li><li><p>PrintWriter(Writer out,boolean autoFlush)|创造一个新的PrintWriter</p><ul><li><p>out：字符输出流</p></li><li><p>autoFlush：一个布尔值，如果为真，则println，printf，或format方法将刷新输出缓冲区</p></li></ul></li></ul><p><em>字符打印流同普通的字符流一样，每次写完数据需要调用Flush方法刷新。如果想实现自动刷新，在传参时使用第二中构造方法即可实现刷新功能</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">PrintWriter</span> <span class="hljs-variable">printWriter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;E:\\xiaobai\\bw.txt&quot;</span>),<span class="hljs-literal">true</span>);<span class="hljs-comment">//能够实现自动刷新</span><br><span class="hljs-type">PrintWriter</span> <span class="hljs-variable">pw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintWriter</span>(<span class="hljs-string">&quot;E:\\xiaobai\\bw.txt&quot;</span>);<span class="hljs-comment">//不能够实现自动刷新</span><br></code></pre></td></tr></table></figure><hr><h5 id="案例：利用字符打印流复制文件"><a href="#案例：利用字符打印流复制文件" class="headerlink" title="案例：利用字符打印流复制文件"></a>案例：利用字符打印流复制文件</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo05</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;E:\\xiaobai\\bw.txt&quot;</span>));<br>        <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">pw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;bw.txt&quot;</span>), <span class="hljs-literal">true</span>);<br>        String line;<br>        <span class="hljs-keyword">while</span> ((line = br.readLine()) != <span class="hljs-literal">null</span>)&#123;<br>            pw.println(line);<br>        &#125;<br>        br.close();<br>        pw.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="对象序列化流"><a href="#对象序列化流" class="headerlink" title="对象序列化流"></a>对象序列化流</h2><p>对象序列化：就是将对象保存在磁盘中，或者在网络中传输对象</p><p>这种机制就是将对象的类型、数据和属性等信息使用一个字节序列来存储，一个字节序列表示一个对象。存到文件之后，相当于文件持久保存了一个对象的信息</p><p>反之，该字节序列能从文件中读取，重构对象，对他进行<strong>反序列化</strong></p><ul><li>对象序列化流：ObjectOutputStream</li><li>对象反序列化流：ObjectInputStream</li></ul><hr><h3 id="对象序列化流-1"><a href="#对象序列化流-1" class="headerlink" title="对象序列化流"></a>对象序列化流</h3><p>构造方法：</p><ul><li>ObjectOutputStream(OutputStream out )：创建一个写入指定的OutputStream的ObjectOutputStream</li></ul><p><em>注：这里我们可以写一个FileOutputStream实现转存成文件</em></p><p>序列化对象的方法</p><ul><li>void writeObject(Object obj)：将指定的对象写入ObjectOutputStream</li></ul><p><strong>注：一个对象如果想要被序列化，该对象所属的类必须实现Serializable接口</strong></p><p><strong>Serializable是一个标记接口，实现这个接口不需要重写任何方法</strong></p><p><em>Serializable英文释义：可序列化的</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo06</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;oos.txt&quot;</span>));<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;林青霞&quot;</span>, <span class="hljs-number">30</span>);<br>        oos.writeObject(s);<br>        oos.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="对象反序列化流"><a href="#对象反序列化流" class="headerlink" title="对象反序列化流"></a>对象反序列化流</h3><p>构造方法：</p><ul><li>ObjectInputStream(InputStream out )：创建从指定的InputStream读取的ObjectInputStream</li></ul><p><em>注：这里我们可以写一个FileInputStream实现从文件中读取</em></p><p>反序列化对象的方法</p><ul><li>void readObject(Object obj)：从ObjectOutputStream读取一个对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo06</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;oos.txt&quot;</span>));<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> ois.readObject();<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> (Student) o;<br>        System.out.println(<span class="hljs-string">&quot;name=&quot;</span> + s1.getName() + <span class="hljs-string">&quot;age=&quot;</span> + s1.getAge());<br>        ois.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="序列化问题的出现"><a href="#序列化问题的出现" class="headerlink" title="序列化问题的出现"></a>序列化问题的出现</h3><p><em>当序列化的对象所属类文件被更改时，反序列化不成功</em></p><p>因为serialVersionUid不匹配</p><p>在没有额外声明时，序列化id是经过系统计算生成的，当所属类发生改变时，这个id会变化，所以反序列化不成功</p><p>解决方法：</p><p>在所属类进行serialVersionUid声明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUid</span> <span class="hljs-operator">=</span> <span class="hljs-number">42l</span>;<br></code></pre></td></tr></table></figure><p><em>serial英文释义：连续的</em></p><hr><p><em>当某一个成员变量不想被序列化，如何实现</em></p><p>需要用到关键字<strong>transient</strong></p><p><em>transient英文释义：临时的</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> age;<br></code></pre></td></tr></table></figure><p>该关键字标记的成员变量不参与序列化过程</p><hr><h2 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h2><p>Properties继承自Map集合的实现类Hashtable，他具有Map集合的用法，区别是他在声明时无法定义数据类型，默认是Object类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Properties</span> <span class="hljs-variable">prop</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br></code></pre></td></tr></table></figure><hr><h3 id="Properties作为集合的方法"><a href="#Properties作为集合的方法" class="headerlink" title="Properties作为集合的方法"></a>Properties作为集合的方法</h3><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>Object setProperty(String key,String value)</td><td>设置集合的键和值，都是String类型，底层调用Hashtable的put方法</td></tr><tr><td>String getProperty(String key)</td><td>使用此属性列表中指定的键搜索属性</td></tr><tr><td>Set<String> StringPropertyNames()</td><td>从该属性列表中返回一个不可修改的键集，其中键及其对应的值是字符串</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo07</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>        properties.setProperty(<span class="hljs-string">&quot;xiaobai1&quot;</span>, <span class="hljs-string">&quot;shuaige1&quot;</span>);<br>        properties.setProperty(<span class="hljs-string">&quot;xiaobai2&quot;</span>, <span class="hljs-string">&quot;shuaige2&quot;</span>);<br>        properties.setProperty(<span class="hljs-string">&quot;xiaobai3&quot;</span>, <span class="hljs-string">&quot;shuaige3&quot;</span>);<br>        System.out.println(properties.getProperty(<span class="hljs-string">&quot;xiaobai1&quot;</span>));<br>        System.out.println(properties);<br><br>        Set&lt;String&gt; names = properties.stringPropertyNames();<br>        <span class="hljs-keyword">for</span> (String name : names) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> properties.getProperty(name);<br>            System.out.println(name + <span class="hljs-string">&quot;,&quot;</span> + value);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="Properties和IO流结合的方法"><a href="#Properties和IO流结合的方法" class="headerlink" title="Properties和IO流结合的方法"></a>Properties和IO流结合的方法</h3><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>void load(InputStream inStream)</td><td>从字节流读取属性列表（键值对）</td></tr><tr><td>void load(Reader Reader)</td><td>从字符流读取属性列表（键值对）</td></tr><tr><td>void store(OutputStream out，String comments)</td><td>将此属性列表（键值对）写入此Properties表中，以适合于使用load(InputStream)方法的格式写入输出字节流</td></tr><tr><td>void Store(Write Writer,String comments)</td><td>将此属性列表（键值对）写入此Properties表中，以适合于使用load(Reader)方式的格式写入输出字符流</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo08</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span>  IOException&#123;<br>        mystore();<br>        myload();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">myload</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>        <span class="hljs-type">FileReader</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;oos&quot;</span>);<br>        properties.load(oos);<br>        oos.close();<br>        System.out.println(properties);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mystore</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>     properties.setProperty(<span class="hljs-string">&quot;xiaobai1&quot;</span>, <span class="hljs-string">&quot;shuaige1&quot;</span>);<br>     properties.setProperty(<span class="hljs-string">&quot;xiaobai2&quot;</span>, <span class="hljs-string">&quot;shuaige2&quot;</span>);<br>        properties.setProperty(<span class="hljs-string">&quot;xiaobai3&quot;</span>, <span class="hljs-string">&quot;shuaige3&quot;</span>);<br>        properties.setProperty(<span class="hljs-string">&quot;xiaobai4&quot;</span>, <span class="hljs-string">&quot;shuaige4&quot;</span>);<br>        <span class="hljs-type">FileWriter</span> <span class="hljs-variable">fileWriter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;oos&quot;</span>);<br>        properties.store(fileWriter,<span class="hljs-literal">null</span>);<br>        fileWriter.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>JAVASE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>IO-流</title>
    <link href="/2022/08/30/IO-%E6%B5%81/"/>
    <url>/2022/08/30/IO-%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h1 id="IO流概述和分类"><a href="#IO流概述和分类" class="headerlink" title="IO流概述和分类"></a>IO流概述和分类</h1><p>IO流分类：</p><ul><li>按照数据的流向<ul><li>输入流：读数据</li><li>输出流：写数据</li></ul></li><li>按照数据类型来分<ul><li>字节流：<ul><li>字节输入流；字节输出流</li></ul></li><li>字符流： <ul><li>字符输入流；字符输出流</li></ul></li></ul></li></ul><p>一般来说，我们的IO流分类是按照<strong>数据类型</strong>来分的</p><ul><li>如果数据通过windows自带的记事本打开，我们还可以读懂里面的内容，就是用字符流，否则使用字节流。如果你不知道该使用哪种类型的流，就用字节流</li></ul><p><img src="/upload/1679059439583.jpg"></p><h1 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h1><h3 id="字节流写数据"><a href="#字节流写数据" class="headerlink" title="字节流写数据"></a>字节流写数据</h3><p>字节流抽象基类</p><ul><li>InputStream：这个<strong>抽象类</strong>是表示字节输入流的所有类的超类</li><li>OutputStream：这个<strong>抽象类</strong>是表示字节输出流的所有类的超类</li><li>子类名特点：子类名称都是以其父类名作为子类名的后缀</li></ul><p><em>输入就是读，输出就是写</em></p><p>FileOutputStream：文件输出流 用于将数据写入File</p><ul><li>FileOutputStream(String name)：创建文件输出流以指定的名称写入文件</li></ul><p>使用字节流写数据的步骤：</p><ol><li><p>创建字节流输出对象</p></li><li><p>调用字节输出流对象的写数据方法</p></li><li><p>释放资源(关闭此文件输出流并释放与此流相关联的任何系统资源)</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;fos.txt&quot;</span>);<br>        fos.write(<span class="hljs-number">97</span>);<br>        fos.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="字节流写数据的三种方式"><a href="#字节流写数据的三种方式" class="headerlink" title="字节流写数据的三种方式"></a>字节流写数据的三种方式</h3><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>void write(int b)</td><td>将指定字节写入此文件输出流，一次写入一个字节数据</td></tr><tr><td>void write(byte[] b)</td><td>将b.length字节从指定的字节数组写入此文件输出流，一次写入一个字节数组数据</td></tr><tr><td>void write(byte[] b,int off,int len)</td><td>将len字节从指定的字节数组开始，从偏移量off开始写入此文件输出流，一次写一个字节数组的部分数据</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">byte</span>[] bys = <span class="hljs-string">&quot;abcde&quot;</span>.getBytes();<br>        <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;fos.txt&quot;</span>);<br>        <span class="hljs-comment">//fos.write(bys);//abcde</span><br>        fos.write(bys,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>);<span class="hljs-comment">//bcd</span><br>        fos.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="字节流写数据的小问题："><a href="#字节流写数据的小问题：" class="headerlink" title="字节流写数据的小问题："></a>字节流写数据的小问题：</h3><p>字节流写数据如何实现换行呢？</p><ul><li>写完数据后，加换行符<ul><li>windows: <strong>\r\n</strong></li><li>linux: <strong>\n</strong></li><li>mac: <strong>\r</strong></li></ul></li></ul><p>字节流写数据如何实现追加写入呢？</p><ul><li>public FileOutputStream(String name,boolean append)</li><li>创建文件输出流以指定的名称写入文件。如果第二个参数是true，则字节将写入文件的末尾而不是开头</li></ul><h3 id="字节流写数据加异常处理"><a href="#字节流写数据加异常处理" class="headerlink" title="字节流写数据加异常处理"></a>字节流写数据加异常处理</h3><p>finally：在异常处理时提供finally块来执行所有的清除操作。比如IO流中的释放资源</p><p>特点：被finally控制的语句一定会执行，除非JVM退出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>  &#123;<br>        <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">byte</span>[] bys = <span class="hljs-string">&quot;abcde&quot;</span>.getBytes();<br>        <span class="hljs-keyword">try</span> &#123;<br>            fos = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;fos.txt&quot;</span>);<br>            <span class="hljs-comment">//fos.write(bys);//abcde</span><br>            fos.write(bys,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>);<span class="hljs-comment">//bcd</span><br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (fos != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    fos.close();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="字节流读数据（一次读一个字节数据）"><a href="#字节流读数据（一次读一个字节数据）" class="headerlink" title="字节流读数据（一次读一个字节数据）"></a>字节流读数据（一次读一个字节数据）</h3><p>FileInputStream：从文件系统中的文件获取输入字节</p><ul><li>FileInputStream(String name)：通过打开与实际文件的链接来创建一个FileInputStream，该文件由系统中的路径名name命名</li></ul><p>使用字节输入流读数据的步骤：</p><ol><li>创建字节输入流对象</li><li>调用字节输入流对象的读数据方法</li><li>释放资源</li><li><em>注：如果read方法读取到文件末尾将会返回”-1”</em></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;fis.txt&quot;</span>);<br><span class="hljs-comment">//        System.out.println(fis.read());</span><br><span class="hljs-comment">//        System.out.println((char) fis.read());</span><br><span class="hljs-comment">//遍历文件中所有字节流</span><br>        <span class="hljs-type">int</span> by;<br>        <span class="hljs-keyword">while</span> ((by = fis.read()) != -<span class="hljs-number">1</span>) &#123;<br>            System.out.print((<span class="hljs-type">char</span>) by);<br>        &#125;<br>        fis.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="案例：复制文本文件"><a href="#案例：复制文本文件" class="headerlink" title="案例：复制文本文件"></a>案例：复制文本文件</h5><p>要求：复制字节流fis.txt到fos.txt中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;fos.txt&quot;</span>);<br>        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;fis.txt&quot;</span>);<br>        <span class="hljs-type">int</span> by;<br>        <span class="hljs-keyword">while</span> ((by = fis.read()) != -<span class="hljs-number">1</span>)<br>        &#123;<br>            fos.write(by);<br>        &#125;<br>        fos.close();<br>        fis.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="字节流读数据（一次读一个字节数组数据）"><a href="#字节流读数据（一次读一个字节数组数据）" class="headerlink" title="字节流读数据（一次读一个字节数组数据）"></a>字节流读数据（一次读一个字节数组数据）</h3><p>read()方法中，读取一个字节数据时，括号内为空，表达式的值为数据内容（int）</p><p> 读取一个字节数组内容时，read(b)方法中，括号里放字节数组，表达式的值为数据内容字节长度，读出数据放在字节数组里面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;fis.txt&quot;</span>);<br>        <span class="hljs-type">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-type">int</span> len;<br>        <span class="hljs-keyword">while</span> ((len = fis.read(b)) != -<span class="hljs-number">1</span>)<span class="hljs-comment">//实际读取长度不超过-1</span><br>        &#123;<br>            System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.lang.String(b,<span class="hljs-number">0</span>,len));<br>        &#125;<br>        fis.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="案例：复制图片"><a href="#案例：复制图片" class="headerlink" title="案例：复制图片"></a>案例：复制图片</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;1.jpg&quot;</span>);<br>        <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;2.jpg&quot;</span>);<br>        <span class="hljs-type">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-type">int</span> len;<br>        <span class="hljs-keyword">while</span> ((len = fis.read(b)) != -<span class="hljs-number">1</span>)&#123;<br>            fos.write(b,<span class="hljs-number">0</span>,len);<br>        &#125;<br>        fos.close();<br>        fis.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h3><p><em>buffer英文释义：缓冲器</em></p><ul><li><p>BufferedOutputStream：该类实现缓冲输出流。通过设置这样的输出流，应用程序可向底层输出流写入字节，而不必为写入每个字节调用系统底层</p></li><li><p>BufferedInputStream：将创建一个内部缓冲区数组。当从流中读取或跳过字节时，内部缓冲区将根据需要从所包含的输入流中充数据，一次很多字节</p></li></ul><p>构造方法：</p><ul><li>字节缓冲输出流：BufferedOutputStream(OutputStream out)</li><li>字节缓冲输出流：BufferedInputStream(InputStream in)</li></ul><p>为什么构造方法需要的是字节流，而不是具体的文件或者路径呢？</p><ul><li>字节缓冲流<strong>仅仅提供缓冲区</strong>，而真正的读写数据还得依靠基本的字节流对象进行操作</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">BufferedOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;bos.txt&quot;</span>));<br>        bos.write(<span class="hljs-string">&quot;hello\r\n&quot;</span>.getBytes());<br>        bos.close();<br>        <span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;bos.txt&quot;</span>));<br>        <span class="hljs-comment">//方法一：</span><br>        <span class="hljs-type">int</span> by;<br>        <span class="hljs-keyword">while</span> ((by = bis.read()) != -<span class="hljs-number">1</span>) &#123;<br>            System.out.print((<span class="hljs-type">char</span>) by);<br>        &#125;<br>        <span class="hljs-comment">//方法二：</span><br>        <span class="hljs-type">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-type">int</span> len;<br>        <span class="hljs-keyword">while</span> ((len= bis.read(b))!=-<span class="hljs-number">1</span>)&#123;<br>            System.out.print(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(b, <span class="hljs-number">0</span>, len));<br>        &#125;<br>        bis.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p><em>注：字节流读数据时，fos.read()方法中如果没有参数，则读取一个数据，返回值为该数据的int类型assic码。如果参数为字节数组，则把数据写入到字节数组中，返回值为int类型的长度len</em></p><hr><h1 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h1><h3 id="为什么会出现字符流"><a href="#为什么会出现字符流" class="headerlink" title="为什么会出现字符流"></a>为什么会出现字符流</h3><p>由于字节流操作中文不是特别的方便，所以JAVA提供字符流</p><ul><li>字符流 &#x3D; 字节流 + 编码表</li></ul><p><em>字符流的底层仍然是字节流</em></p><p>汉字在存储的时候，无论是哪种编码，第一个字节都是负数</p><hr><h3 id="编码表"><a href="#编码表" class="headerlink" title="编码表"></a>编码表</h3><p>按照某一种规则，将字符储存到计算机中，叫做编码</p><p>反之，讲计算机中的二进制数按照某种规则解析显示，叫做解码</p><p>按照A编码存储，必须按照A编码解析，这样才能正常显示，否则会出现乱码</p><p>一套字符集必然存在一套字符编码，常见的字符集有：</p><ul><li>ASCII字符集</li><li>GBXXX字符集<ul><li>GB2312：简体中文码表。包括7000个简体汉字</li><li><strong>GBK</strong>：最常见的中文码表。收录21003汉字，完全兼容GB2312标准。支持繁体中文和日韩汉字</li><li>GB18030：最新的中文码表。收录汉字70244个，采用多字节编码，支持中国国内少数民族的文字</li></ul></li><li>Unicode字符集<ul><li>UTF-8：万国码</li></ul></li></ul><p><strong>选用何种方法编码，必须选用何种方法解码</strong></p><hr><h3 id="字符串的编码与解码"><a href="#字符串的编码与解码" class="headerlink" title="字符串的编码与解码"></a>字符串的编码与解码</h3><p>编码：</p><ul><li>byte[] getBytes()：使用平台的默认字符集为String编码为一系列字节，将结果储存到新的字节数组中</li><li>byte[] getBytes(String charsetName)：使用指定的字符集将该String编码为一系列字节，将结果储存到新的字符数组中</li></ul><p>解码：</p><ul><li>String(byte[] bytes)：通过使用平台的默认字符集解码指定的字节数组来构造新的String</li><li>String(byte[] bytes,String charsetName)：通过指定的字符集解码指定的字节数组来构造新的String</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;中国&quot;</span>;<br>        <span class="hljs-type">byte</span>[] bys = s.getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>        System.out.println(Arrays.toString(bys));<span class="hljs-comment">//[-28, -72, -83, -27, -101, -67]</span><br>        <span class="hljs-type">byte</span>[] bys1 = s.getBytes(<span class="hljs-string">&quot;GBK&quot;</span>);<br>        System.out.println(Arrays.toString(bys1));<span class="hljs-comment">//[-42, -48, -71, -6]</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bys);<br>        System.out.println(s1);<span class="hljs-comment">//中国</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bys1,<span class="hljs-string">&quot;GBK&quot;</span>);<br>        System.out.println(s2);<span class="hljs-comment">//中国</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="字符流的编码与解码"><a href="#字符流的编码与解码" class="headerlink" title="字符流的编码与解码"></a>字符流的编码与解码</h3><p>字符流抽象基类</p><ul><li>Reader：字符输入流的抽象类</li><li>Writer：字符输出流的抽象类</li></ul><p>字符流中编码解码相关类</p><ul><li>InputStreamReader(InputStream out,charsetName)</li><li>OutputStreamWriter(OutputStream out,charsetName)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">//字符输出流以UTF-8的编码写入文件</span><br>        <span class="hljs-type">OutputStreamWriter</span> <span class="hljs-variable">osw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputStreamWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;osw.txt&quot;</span>),<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>        <span class="hljs-comment">//字符输出流以GBK的编码写入文件</span><br>        <span class="hljs-type">OutputStreamWriter</span> <span class="hljs-variable">osw1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputStreamWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;osw1.txt&quot;</span>),<span class="hljs-string">&quot;GBK&quot;</span>);<br>        osw.write(<span class="hljs-string">&quot;中国&quot;</span>);<span class="hljs-comment">//中国</span><br>        osw1.write(<span class="hljs-string">&quot;中国&quot;</span>);<span class="hljs-comment">//�й� 这里的乱码是因为idea平台的默认解码为UTF-8 使用GBK编码自然会乱码</span><br>        osw.close();<br>        osw1.close();<br>        <span class="hljs-comment">//字符输入流以默认（UTF-8）的方法解码读取文件</span><br>        <span class="hljs-type">InputStreamReader</span> <span class="hljs-variable">isr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;osw.txt&quot;</span>));<br>        <span class="hljs-type">int</span> ch;<br>        <span class="hljs-keyword">while</span>((ch=isr.read())!=-<span class="hljs-number">1</span>)&#123;<br>            System.out.print((<span class="hljs-type">char</span>)ch);<span class="hljs-comment">//中国</span><br>        &#125;<br>        isr.close();<br>        System.out.println();<br>         <span class="hljs-comment">//字符输入流以GBK的方法解码读取文件</span><br>        <span class="hljs-type">InputStreamReader</span> <span class="hljs-variable">isr1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;osw1.txt&quot;</span>), <span class="hljs-string">&quot;GBK&quot;</span>);<br>        <span class="hljs-type">int</span> ch1;<br>        <span class="hljs-keyword">while</span>((ch1=isr1.read())!=-<span class="hljs-number">1</span>)&#123;<br>            System.out.print((<span class="hljs-type">char</span>)ch1);<span class="hljs-comment">//中国</span><br>        &#125;<br>        isr1.close();<br>    &#125;<br></code></pre></td></tr></table></figure><hr><h3 id="字符流写数据的五种方式"><a href="#字符流写数据的五种方式" class="headerlink" title="字符流写数据的五种方式"></a>字符流写数据的五种方式</h3><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>void write(int c)</td><td>写入一个字符</td></tr><tr><td>void write(char[] cbuf)</td><td>写入一个字符数组</td></tr><tr><td>void write(char[] cbuf,int off,int len)</td><td>写入字符数组的一部分</td></tr><tr><td>void write(String str)</td><td>写入一个字符串</td></tr><tr><td>void write(String str,int off,int len)</td><td>写入字符串的一部分</td></tr><tr><td>void flush()</td><td>刷新流</td></tr><tr><td>void close()</td><td>关闭流（关闭前会刷新）</td></tr></tbody></table><p><em>注：字符流写数据之后，数据并不会直接写道文件中，需要用到flush()方法刷新。使用close()方法关闭流时会自动刷新一次</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">OutputStreamWriter</span> <span class="hljs-variable">osw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputStreamWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;osw.txt&quot;</span>));<br><span class="hljs-comment">//        osw.write(97);</span><br><span class="hljs-comment">//        osw.flush();</span><br><span class="hljs-comment">//        osw.write(98);</span><br><span class="hljs-comment">//        osw.close();</span><br><span class="hljs-comment">//        char[] chs = &#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;e&#x27;&#125;;</span><br><span class="hljs-comment">//        osw.write(chs);//abcde</span><br><span class="hljs-comment">//        char[] chs = &#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;e&#x27;&#125;;</span><br><span class="hljs-comment">//        osw.write(chs,2,3);//cde</span><br><span class="hljs-comment">//        osw.write(&quot;abcde&quot;);//abcde</span><br>        osw.write(<span class="hljs-string">&quot;abcde&quot;</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<span class="hljs-comment">//cde</span><br>        osw.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="字符流读数据的两种方式"><a href="#字符流读数据的两种方式" class="headerlink" title="字符流读数据的两种方式"></a>字符流读数据的两种方式</h3><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>int read()</td><td>一次都一个字符数据</td></tr><tr><td>int read(char[] cbuf)</td><td>一次读一个字符数组数据</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">//一次读一个数据</span><br>        <span class="hljs-type">InputStreamReader</span> <span class="hljs-variable">isr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;osw.tx t&quot;</span>));<br>        <span class="hljs-type">int</span> ch;<br>        <span class="hljs-keyword">while</span> ((ch = isr.read()) != -<span class="hljs-number">1</span>) &#123;<br>            System.out.print((<span class="hljs-type">char</span>) ch);<br>        &#125;<br>        isr.close();<br>        <span class="hljs-comment">//一次读一组数据</span><br>        <span class="hljs-type">InputStreamReader</span> <span class="hljs-variable">isr1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;osw.txt&quot;</span>));<br>        <span class="hljs-type">char</span>[] chs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-type">int</span> len;<br>        <span class="hljs-keyword">while</span> ((len=isr1.read(chs)) != -<span class="hljs-number">1</span>) &#123;<br>            System.out.print(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(chs,<span class="hljs-number">0</span>,len));<br>        &#125;<br>        isr.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="字符流读写的便捷类"><a href="#字符流读写的便捷类" class="headerlink" title="字符流读写的便捷类"></a>字符流读写的便捷类</h3><p>当不需要改变字符集编码解码（即用平台默认的字符集）时，我们转换流可以用便捷类实现</p><ul><li>FileReader()：继承自InputStreamReader()</li><li>FileWriter()：继承自OutputStreamReader()</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">FileReader</span> <span class="hljs-variable">fr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;osw.txt&quot;</span>);<br>        <span class="hljs-type">FileWriter</span> <span class="hljs-variable">fw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWrit</span> er(<span class="hljs-string">&quot;osw1.txt&quot;</span>);<br>        <span class="hljs-comment">//方法一</span><br>        <span class="hljs-type">int</span> ch;<br>        <span class="hljs-keyword">while</span> ((ch = br.read()) != -<span class="hljs-number">1</span>) &#123;<br>            bw.write(ch);<br>        &#125;<br>        <span class="hljs-comment">//方法二</span><br>        <span class="hljs-type">char</span>[] chr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-type">int</span> len;<br>        <span class="hljs-keyword">while</span> ((len = fr.read(chr)) != -<span class="hljs-number">1</span>)<br>        &#123;<br>            fw.write(chr,<span class="hljs-number">0</span>,len);<br>        &#125;<br>        fr.close();<br>        fw.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="字符缓冲流"><a href="#字符缓冲流" class="headerlink" title="字符缓冲流"></a>字符缓冲流</h3><p>构造方法：</p><ul><li>字节缓冲输出流：BufferedWriter out(Writer out)</li><li>字节缓冲输出流：BufferedReader(Reader in)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">bw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;osw1.txt&quot;</span>));<br>        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;osw.txt&quot;</span>));<br>        <span class="hljs-comment">//方法一</span><br>        <span class="hljs-type">int</span> ch;<br>        <span class="hljs-keyword">while</span> ((ch = br.read()) != -<span class="hljs-number">1</span>) &#123;<br>            bw.write(ch);<br>        &#125;<br>        <span class="hljs-comment">//方法二</span><br>        <span class="hljs-type">int</span> len;<br>        <span class="hljs-type">char</span>[] chs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-keyword">while</span> ((len = br.read(chs)) != -<span class="hljs-number">1</span>) &#123;<br>            bw.write(chs, <span class="hljs-number">0</span>, len);<br>        &#125;<br>        bw.close();<br>        br.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="字符缓冲流特有功能"><a href="#字符缓冲流特有功能" class="headerlink" title="字符缓冲流特有功能"></a>字符缓冲流特有功能</h3><p>BufferedWriter：</p><ul><li>void newLine()：写一行行分隔符，行分隔符字符串由系统属性定义</li></ul><p><em>可以解决不同系统下行分隔符不同的问题</em></p><p>BufferedReader：</p><ul><li>public String readLine()：读一行文字，结果包含行的内容的字符串</li></ul><p>readLine读取数据时，返回一行数据为字符串，当返回为空时数据读完</p><p><em>注：readLine读数据时不包含换行符，需要在输出时操作</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">bw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;osw1.txt&quot;</span>));<br>        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;osw1.txt&quot;</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            bw.write(<span class="hljs-string">&quot;hello&quot;</span> + i);<br>            bw.newLine();<br>            bw.flush();<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            System.out.println(br.readLine());<br>        &#125;<br>        System.out.println(br.readLine());<span class="hljs-comment">//NULL</span><br>        String line;<br>        <span class="hljs-keyword">while</span> ((line = br.readLine()) != <span class="hljs-literal">null</span>) &#123;<br>            System.out.println(line);<br>        &#125;<br>        bw.close();<br>        br.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="案例：复制文件"><a href="#案例：复制文件" class="headerlink" title="案例：复制文件"></a>案例：复制文件</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">bw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;osw.txt&quot;</span>));<br>        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;osw1.txt&quot;</span>));<br>        String str;<br>        <span class="hljs-keyword">while</span> ((str = br.readLine()) != <span class="hljs-literal">null</span>) &#123;<br>            bw.write(str);<br>            bw.newLine();<span class="hljs-comment">//readline不读取换行，需要额外写</span><br>            bw.flush();<span class="hljs-comment">//换行了就得刷新</span><br>        &#125;<br>        bw.close();<br>        br.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>JAVASE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>IO-File</title>
    <link href="/2022/08/29/IO-File/"/>
    <url>/2022/08/29/IO-File/</url>
    
    <content type="html"><![CDATA[<h1 id="File"><a href="#File" class="headerlink" title="File"></a>File</h1><p>File：他是文件和目录路径名的抽象表示</p><ul><li>文件和目录是可以通过File封装成对象的</li><li>对于File而言，其封装的并不是一个真正存在的文件，仅仅是一个路径名而已，它可以是存在的，也可以是不存在的。将来是要通过具体的操作把这个路径的内容转换为具体存在的</li></ul><h3 id="构造方法："><a href="#构造方法：" class="headerlink" title="构造方法："></a>构造方法：</h3><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>File(String pathname)</td><td>通过将给定的路径名子字符串转换为抽象路径名来创建新的File实例</td></tr><tr><td>File(String parent,String child)</td><td>从父路径名 字符串和子路径名 字符串创建新的File实例</td></tr><tr><td>File(File parent,String child)</td><td>从父路径名和子路径名 字符串创建新的File实例</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">f1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;G:\\JAVA学习\\IO\\java.txt&quot;</span>);<br>        System.out.println(f1);<br>        <span class="hljs-type">File</span> <span class="hljs-variable">f2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;G:\\JAVA学习\\IO&quot;</span>,<span class="hljs-string">&quot;java.txt&quot;</span>);<br>        System.out.println(f2);<br>        <span class="hljs-type">File</span> <span class="hljs-variable">f3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;G:\\JAVA学习\\IO&quot;</span>);<br>        <span class="hljs-type">File</span> <span class="hljs-variable">f4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(f3,<span class="hljs-string">&quot;java.txt&quot;</span>);<br>        System.out.println(f4);<br>        <span class="hljs-comment">//以上内容全部输出为G:\JAVA学习\IO\java.txt</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="File类创建功能"><a href="#File类创建功能" class="headerlink" title="File类创建功能"></a>File类创建功能</h3><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>boolean createNewFile()</td><td>当具有该名称的文件不存在时，创建一个由该抽象路径名命名的新空文件</td></tr><tr><td>boolean mkdir()</td><td>创建由此抽象路径名名命的目录</td></tr><tr><td>boolean mkdirs()</td><td>创建由此抽象路径名名命的目录，包括任何必须但不存在的父目录</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">f1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;G:\\JAVA学习\\java.txt&quot;</span>);<br>        <span class="hljs-comment">//如果文件不存在，就创建文件并返回true，如果文件存在就返回false</span><br>        System.out.println(f1.createNewFile());<br>        <span class="hljs-comment">//如果目录不存在，就创建目录并返回true，如果目录存在就返回false</span><br>        <span class="hljs-type">File</span> <span class="hljs-variable">f2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;G:\\JAVA学习\\Hellow world&quot;</span>);<br>        System.out.println(f2.mkdir());<br>        <span class="hljs-comment">//多级目录需要用mkdirs 不可以用mkdir</span><br>        <span class="hljs-type">File</span> <span class="hljs-variable">f3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;G:\\JAVA学习\\Java Web\\Html&quot;</span>);<br>        <span class="hljs-comment">//System.out.println(f3.mkdir());</span><br>        System.out.println(f3.mkdirs());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>注：用mkdir()创建java.txt仍能成功，只不过是建立了名为java.txt的目录</em></p><p><em>在有名为java.txt名字的目录时，创建java.txt名字的文件则会失败，哪怕一个是目录一个是文件也不能同名</em></p><p><em>创建文件时如果找不到指定上级目录也会存在异常</em></p><h3 id="File类的判断和获取功能"><a href="#File类的判断和获取功能" class="headerlink" title="File类的判断和获取功能"></a>File类的判断和获取功能</h3><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>boolean is Directory()</td><td>测试此抽象路径名表示的File是否为目录</td></tr><tr><td>boolean isFile()</td><td>测试此抽象路径名表示的File是否为文件</td></tr><tr><td>Boolean exists()</td><td>测试此抽象路径名表示的File是否存在</td></tr><tr><td>String getAbsolutePath()</td><td>返回此抽象路径名的绝对路径名 字符串</td></tr><tr><td>String getPath()</td><td>返回此抽象路径名的路径名 字符串</td></tr><tr><td>String getName()</td><td>返回此抽象路径名表示的文件或目录的名称</td></tr><tr><td>String[] list()</td><td>返回此抽象路径名表示的目录中的文件和目录的名称字符串数组</td></tr><tr><td>File[] listFiles()</td><td>返回此抽象路径名表示的目录中的文件和目录的File对象数组</td></tr></tbody></table><p><em>exists英文释义：存在，实际上有</em></p><p><em>absolute英文释义：绝对的，绝对</em></p><h3 id="File类删除功能"><a href="#File类删除功能" class="headerlink" title="File类删除功能"></a>File类删除功能</h3><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>boolean delet()</td><td>删除由此有抽象路径名表示的文件或目录</td></tr></tbody></table><p>绝对路径和相对路径的区别</p><ul><li>绝对路径：完整的目录名,不需要任何其他信息就可以定位她所表示的文件</li><li>相对路径：必须使用取自其他路径名的信息进行解释，例如模块名\\文件名</li></ul><p><em>注：如果一个目录中有内容（子目录或者文件），不能直接删除。应该先删除目录中的内容，最后才能删除目录</em></p><h3 id="File类递归遍历目录下所有文件"><a href="#File类递归遍历目录下所有文件" class="headerlink" title="File类递归遍历目录下所有文件"></a>File类递归遍历目录下所有文件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">srcFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;src&quot;</span>);<br>        getAllFilePath(srcFile);<span class="hljs-comment">//调用递归方法</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getAllFilePath</span><span class="hljs-params">(File srcFile)</span>&#123;<br>        File[] files = srcFile.listFiles();<span class="hljs-comment">//把File类对象转换成File类型的数组</span><br>        <span class="hljs-keyword">if</span> (files != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">for</span> (File file : files) &#123;<span class="hljs-comment">//遍历数组</span><br>                <span class="hljs-keyword">if</span> (file.isDirectory())<br>                &#123;<br>                    getAllFilePath(file);<span class="hljs-comment">//如果是目录，则递归调用方法</span><br>                &#125;<span class="hljs-keyword">else</span> &#123;<br>                    System.out.println(file.getAbsolutePath());<span class="hljs-comment">//如果是文件，则获取绝对路径并输出</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>JAVASE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>IO-进阶</title>
    <link href="/2022/08/29/IO-%E8%BF%9B%E9%98%B6/"/>
    <url>/2022/08/29/IO-%E8%BF%9B%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<p><img src="/upload/IO1.png"></p><h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><h3 id="案例：复制单极文件夹"><a href="#案例：复制单极文件夹" class="headerlink" title="案例：复制单极文件夹"></a>案例：复制单极文件夹</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo07</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">//创建数据源目录</span><br>        <span class="hljs-type">File</span> <span class="hljs-variable">srcFolder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;E:\\xiaobai&quot;</span>);<br>        <span class="hljs-comment">//取数据源目录名字，不包括文件名</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">srcFolderName</span> <span class="hljs-operator">=</span> srcFolder.getName();<br>        <span class="hljs-comment">//新建目标目录</span><br>        <span class="hljs-type">File</span> <span class="hljs-variable">destFoldername</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(srcFolderName);<br>        <span class="hljs-comment">//如果没有目标目录，则创建</span><br>        <span class="hljs-keyword">if</span> (!destFoldername.exists()) &#123;<br>            destFoldername.mkdir();<br>        &#125;<br>        <span class="hljs-comment">//列出源文件目录下所有目标文件，加入File集合</span><br>        File[] listFiles = srcFolder.listFiles();<br>        <span class="hljs-keyword">for</span> (File srcFile : listFiles) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">srcFileName</span> <span class="hljs-operator">=</span> srcFile.getName();<span class="hljs-comment">//获取目标文件名</span><br>            <span class="hljs-type">File</span> <span class="hljs-variable">destfile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(destFoldername, srcFileName);<span class="hljs-comment">//拼接目标目录名和目标文件名</span><br>            copyFile(srcFile, destfile);<span class="hljs-comment">//调用方法复制文件</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//复制文件方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">copyFile</span><span class="hljs-params">(File srcFile, File destfile)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(srcFile));<br>        <span class="hljs-type">BufferedOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(destfile));<br>        <span class="hljs-type">byte</span>[] by = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-type">int</span> len;<br>        <span class="hljs-keyword">while</span> ((len = bis.read(by)) != -<span class="hljs-number">1</span>) &#123;<br>            bos.write(by, <span class="hljs-number">0</span>, len);<br>        &#125;<br>        bis.close();<br>        bos.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="案例：复制多级文件夹"><a href="#案例：复制多级文件夹" class="headerlink" title="案例：复制多级文件夹"></a>案例：复制多级文件夹</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo08</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">srcFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;E:\\xiaobai&quot;</span>);<span class="hljs-comment">//源文件路径</span><br>        <span class="hljs-type">File</span> <span class="hljs-variable">destFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;F:\\&quot;</span>);<span class="hljs-comment">//目标文件路径</span><br>        copyFolder(srcFile, destFile);<span class="hljs-comment">//调用复制目录方法</span><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">copyFolder</span><span class="hljs-params">(File srcFile, File destFile)</span> <span class="hljs-keyword">throws</span> IOException&#123;<br>        <span class="hljs-keyword">if</span> (srcFile.isDirectory()) &#123; <span class="hljs-comment">//判断路径是否为目录，如果是，执行执行体内容</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">srcFileName</span> <span class="hljs-operator">=</span> srcFile.getName();<span class="hljs-comment">//获取源路径下目录名</span><br>            <span class="hljs-type">File</span> <span class="hljs-variable">newFolder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(destFile, srcFileName);<span class="hljs-comment">//拼接新的目录名</span><br>            <span class="hljs-comment">//如果该目录不存在，则创建目录</span><br>            <span class="hljs-keyword">if</span> (!newFolder.exists()) &#123;<br>                newFolder.mkdir(); <br>            &#125;<br>            File[] fileArray = srcFile.listFiles();<span class="hljs-comment">//获取源路径下所有目录/文件，创建File数组</span><br>            <span class="hljs-keyword">for</span> (File file : fileArray) &#123;<br>                copyFolder(file,newFolder);<span class="hljs-comment">//递归调用复制目录方法！！！！！！！</span><br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//如果当前路径非目录，则获取文件名，拼接后调用复制文件方法</span><br>            <span class="hljs-type">File</span> <span class="hljs-variable">newFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(destFile, srcFile.getName());<br>            copyFile(srcFile,newFile);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">copyFile</span><span class="hljs-params">(File srcFile, File file)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(srcFile));<br>        <span class="hljs-type">BufferedOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(file));<br>        <span class="hljs-type">byte</span>[] by = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-type">int</span> len;<br>        <span class="hljs-keyword">while</span> ((len = bis.read(by)) != -<span class="hljs-number">1</span>) &#123;<br>            bos.write(by, <span class="hljs-number">0</span>, len);<br>        &#125;<br>        bis.close();<br>        bos.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="复制文件的异常处理"><a href="#复制文件的异常处理" class="headerlink" title="复制文件的异常处理"></a>复制文件的异常处理</h1><h3 id="利用try-catch处理"><a href="#利用try-catch处理" class="headerlink" title="利用try catch处理"></a>利用try catch处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo09</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">bw</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            br = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;br.txt&quot;</span>));<br>            bw = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;br.txt&quot;</span>));<br>            String line;<br>            <span class="hljs-keyword">while</span> ((line = br.readLine()) != <span class="hljs-literal">null</span>) &#123;<br>                bw.write(line);<br>                bw.newLine();<br>                bw.flush();<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (br != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    br.close();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (bw != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    bw.close();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="JDK7改进方案"><a href="#JDK7改进方案" class="headerlink" title="JDK7改进方案"></a>JDK7改进方案</h3><p>在JDK7更新了try catch的新用法，格式为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>(定义流对象)&#123;<br>    可能出现异常的代码<br>&#125;<span class="hljs-keyword">catch</span>(异常类名 变量名)&#123;<br>    异常的处理代码<br>&#125;<br></code></pre></td></tr></table></figure><p>像是如上操作，不需要使用finally释放资源，会自动释放资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo09_1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">bw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;bw.txt&quot;</span>));<br>             <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;br.txt&quot;</span>));) &#123;<br>            String line;<br>            <span class="hljs-keyword">while</span> ((line = br.readLine()) != <span class="hljs-literal">null</span>) &#123;<br>                bw.write(line);<br>                bw.newLine();<br>                bw.flush();<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="JDK9的改进方案"><a href="#JDK9的改进方案" class="headerlink" title="JDK9的改进方案"></a>JDK9的改进方案</h3><p><em>在这里，JDK9的方案就是把JDK7方案中的try()里面的定义拿到外面去做定义，但会出现方法仍需抛出异常的问题，所以JDK7的方案更靠谱一些</em></p><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>JAVASE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>集合进阶-collections</title>
    <link href="/2022/08/26/%E9%9B%86%E5%90%88%E8%BF%9B%E9%98%B6-collections/"/>
    <url>/2022/08/26/%E9%9B%86%E5%90%88%E8%BF%9B%E9%98%B6-collections/</url>
    
    <content type="html"><![CDATA[<h1 id="Collections概述和使用"><a href="#Collections概述和使用" class="headerlink" title="Collections概述和使用"></a>Collections概述和使用</h1><p>Collections类的概述</p><ul><li>是针对集合操作的工具类</li></ul><p>Collections类的常用方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>&lt;T extends Comparable&lt;?super T&gt;&gt; void sort(List<T> list)</td><td>将指定的列表按升序排序</td></tr><tr><td>void reverse(List&lt;?&gt; list)</td><td>反转指定列表中元素的顺序</td></tr><tr><td>void shuffle(List&lt;?&gt; list)</td><td>使用默认的随即源随机排列指定的列表</td></tr></tbody></table><p> <em>sort英文释义：排序</em></p><p><em>shuffle英文释义：洗牌</em></p><p>如果使用自然排序的sort方法对引用类型对象进行排序，需要在对象内实现自然排序接口并重写compareTo方法</p><p>在这里，还有一个sort方法：sort(List&lt;?&gt; list,comparator&lt;? super  T&gt; c)</p><p>这个方法可以指定一个比较器对象来进行排序，例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        ArrayList&lt;Student&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Student&gt;();<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;XIAOBAI&quot;</span>, <span class="hljs-number">18</span>);<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;XIAOKAI&quot;</span>, <span class="hljs-number">21</span>);<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;XIAOXUE&quot;</span>, <span class="hljs-number">20</span>);<br>        list.add(s1);<br>        list.add(s2);<br>        list.add(s3);<br>        Collections.sort(list, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Student&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Student o1, Student o2)</span> &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">num1</span> <span class="hljs-operator">=</span> o1.getAge() - o2.getAge();<br>                <span class="hljs-type">int</span> <span class="hljs-variable">num2</span> <span class="hljs-operator">=</span> num1 == <span class="hljs-number">0</span> ? o1.getName().compareTo(o2.getName()) : num1;<br>                <span class="hljs-keyword">return</span> num2;<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">for</span> (Student s : list) &#123;<br>            System.out.println(s.getAge() + <span class="hljs-string">&quot;,&quot;</span> + s.getName());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>JAVASE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>集合进阶-map</title>
    <link href="/2022/08/25/%E9%9B%86%E5%90%88%E8%BF%9B%E9%98%B6-map/"/>
    <url>/2022/08/25/%E9%9B%86%E5%90%88%E8%BF%9B%E9%98%B6-map/</url>
    
    <content type="html"><![CDATA[<h1 id="Map集合的概述和使用"><a href="#Map集合的概述和使用" class="headerlink" title="Map集合的概述和使用"></a>Map集合的概述和使用</h1><p>Map集合概述</p><ul><li>Interface Map&lt;K,V&gt; K：键的类型V：值的类型</li><li>将键映射到值的对象；不能包含重复的键；每个键可以映射到最多一个值</li><li>举例，学生的学号（键）和姓名（值）</li></ul><p>创建Map集合的对象</p><ul><li>使用多态的方式</li><li>具体的实现类 HashMap</li></ul><h3 id="Map基本功能"><a href="#Map基本功能" class="headerlink" title="Map基本功能"></a>Map基本功能</h3><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>V put(K key,V value)</td><td>添加元素（也可以更新指定键的值）</td></tr><tr><td>V remove(Object key)</td><td>根据键删除值（返回键被删除的值）</td></tr><tr><td>void clear()</td><td>移除所有键值元素</td></tr><tr><td>boolean containsKey(Object key)</td><td>判断集合中是否包含指定的键</td></tr><tr><td>boolean containsValue(Object value)</td><td>判断集合是否包含指定的值</td></tr><tr><td>boolean isEmpty()</td><td>判断集合是否为空</td></tr><tr><td>int size()</td><td>集合的长度（集合中键值对的个数）</td></tr></tbody></table><hr><h3 id="Map集合的获取功能"><a href="#Map集合的获取功能" class="headerlink" title="Map集合的获取功能"></a>Map集合的获取功能</h3><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>V get(Object key)</td><td>根据键获取值</td></tr><tr><td>Set<K> keySet()</td><td>获取所有键的集合</td></tr><tr><td>Collection<V> values()</td><td>获取所有值的集合</td></tr><tr><td><strong>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</strong></td><td><strong>获取所有键值对 对象的集合</strong></td></tr></tbody></table><hr><p><em>注：keySet和values方法的返回值是Set接口实现类和Collection接口实现类的具体对象</em></p><h3 id="Map集合的遍历"><a href="#Map集合的遍历" class="headerlink" title="Map集合的遍历"></a>Map集合的遍历</h3><h5 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h5><ul><li>获取所有键的集合，使用keySet()方法实现</li><li>遍历这个集合</li><li>利用get(Object key)方法在集合中获取到每一个键的值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, String&gt;();<br>        map.put(<span class="hljs-string">&quot;no1&quot;</span>, <span class="hljs-string">&quot;Xiaobai&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;no2&quot;</span>, <span class="hljs-string">&quot;Xiaoxue&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;no3&quot;</span>, <span class="hljs-string">&quot;Xiaokai&quot;</span>);<br>        Set&lt;String&gt; keyset = map.keySet();<br>        <span class="hljs-keyword">for</span> (String s : keyset) &#123;<br>            System.out.println(s + <span class="hljs-string">&quot; &quot;</span> + map.get(s));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h5><ul><li>获取所有键值对 对象的集合，使用entrySet()方法实现</li><li>遍历键值对 对象的集合，得到每一个键值对 对象</li><li>使用getKey()得到键，使用getValue得到值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, String&gt;();<br>        map.put(<span class="hljs-string">&quot;no1&quot;</span>, <span class="hljs-string">&quot;Xiaobai&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;no2&quot;</span>, <span class="hljs-string">&quot;Xiaoxue&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;no3&quot;</span>, <span class="hljs-string">&quot;Xiaokai&quot;</span>);<br>        Set&lt;Map.Entry&lt;String, String&gt;&gt; entrySet = map.entrySet();<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;String, String&gt; me : entrySet) &#123;<br>            System.out.println(me.getKey() + <span class="hljs-string">&quot; &quot;</span> + me.getValue());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="Map补充"><a href="#Map补充" class="headerlink" title="Map补充"></a>Map补充</h5><p><em>HashMap实现类中重写了toString方法，输出格式为 键&#x3D;值</em></p><p><em>当key为引用类型对象时，我们需要在类中重写hashCode和equals方法才能保证键唯一性</em></p><p><em>Map中如果想要实现按键值有序排列元素，可以使用TreeMap实现类</em></p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>JAVASE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>泛型</title>
    <link href="/2022/08/24/%E6%B3%9B%E5%9E%8B/"/>
    <url>/2022/08/24/%E6%B3%9B%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>泛型：是JDK5中引入的特性，它提供了编译时安全检测机制，该机制允许在编译时检测到非法的类型，它的本质是<strong>参数化类型</strong></p><p>顾名思义，就是<strong>将类型由原来的具体类型参数化，然后再使用&#x2F;调用时传入具体的类型</strong></p><p>这种类型可以在类、方法和接口中，被称为泛型类，泛型方法和泛型接口</p><h5 id="泛型定义格式："><a href="#泛型定义格式：" class="headerlink" title="泛型定义格式："></a>泛型定义格式：</h5><ul><li>&lt;类型&gt;：指定一种类型的格式。这里的类型可以看作是形参</li><li>&lt;类型1，类型2&gt;指定多种类型的格式，多种类型之间用逗号隔开。这里的类型可以看成是形参</li><li>将来具体调用使用给定的类型可以看成是实参，并且实参的类型只能是引用数据类型</li></ul><h5 id="泛型的好处"><a href="#泛型的好处" class="headerlink" title="泛型的好处"></a>泛型的好处</h5><ul><li>把运行时期的问题提前到了编译期间</li><li>避免了强制类型转换</li></ul><p><em>Generic英文释义：通用的，一般的</em></p><hr><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p>泛型类的定义格式</p><ul><li><p>格式：修饰符class类名&lt;类型&gt;{ }</p></li><li><p>范例：public class Generic<T>{ }</p></li></ul><p><em>注：此处的T可以为任意标识，常用的有T、E、K、V来表示泛型</em></p><p>在使用类名实例化对象时，就可以在&lt;&gt;内规定数据类型（引用类型），类中属性类型将与&lt;&gt;内所写类型一致</p><p><em>泛型类中，可以定义返回值为泛型的方法和变量，这些方法和变量的类型在泛型类被实例化时确定</em></p><hr><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>泛型方法的定义格式：</p><ul><li>格式：修饰符&lt;类型&gt;返回值类型 方法名(形参){ }</li><li>范例：public <T>void show(T t){ }</li></ul><p><em>注：方法的返回值也可以为泛型，类为泛型类即可</em></p><hr><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><p>泛型接口的定义格式：</p><ul><li>格式：修饰符 interface 接口名&lt;类型&gt;{ }</li><li>范例：public interface Generic<T>{ }</li></ul><p><em>泛型接口的实现类一般时泛型类，其用法与泛型类相同</em></p><hr><h3 id="类型通配符"><a href="#类型通配符" class="headerlink" title="类型通配符"></a>类型通配符</h3><p>为了表示各种泛型List的父类，可以使用类型通配符</p><ul><li>类型通配符&lt;?&gt;</li><li>List&lt;?&gt;：表示元素类型位置的List，他的元素可以匹配任何的类型</li><li>这种带通配符的List仅表示它是各种泛型List的父类，并不能把元素添加到其中</li></ul><p>如果是我们不希望List&lt;?&gt;时任何泛型的父类，只希望它表示某一类泛型的父类，可以使用类型通配符的上限</p><ul><li>类型通配符的上限：&lt;?extends 类型&gt;</li><li>List&lt;?extends Number&gt;：他表示的类型是Number及子类</li></ul><p>除了可以指定类型通配符的上限，我们也可以指定类型通配符的下限</p><ul><li><p>类型通配符下限：&lt;?super 类型&gt;</p></li><li><p>List&lt;?super Number&gt;：他表示的类型是Number及父类</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Generic</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;?&gt; list1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Object&gt;();<br>        List&lt;?&gt; list2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Number&gt;();<br>        List&lt;?&gt; list3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>        System.out.println(<span class="hljs-string">&quot;==================&quot;</span>);<br>        <span class="hljs-comment">//类型通配符上限，类型标示为Number及子类</span><br><span class="hljs-comment">//        List&lt;? extends  Number&gt; list4 = new ArrayList&lt;Object&gt;(); 报错 因为Object是Number的父类</span><br>        List&lt;? <span class="hljs-keyword">extends</span>  <span class="hljs-title class_">Number</span>&gt; list5 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Number&gt;();<br>        List&lt;? <span class="hljs-keyword">extends</span>  <span class="hljs-title class_">Number</span>&gt; list6 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>        System.out.println(<span class="hljs-string">&quot;==================&quot;</span>);<br>        <span class="hljs-comment">//类型通配符上限，类型标示为Number及父类</span><br>        List&lt;? <span class="hljs-built_in">super</span> Number&gt; list7 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Object&gt;();<br>        List&lt;? <span class="hljs-built_in">super</span> Number&gt; list8 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Number&gt;();<br><span class="hljs-comment">//        List&lt;? super Number&gt; list9 = new ArrayList&lt;Integer&gt;();报错 因为Integer是Number的子类</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>可参考数组笔记，这里着重记录主要使用方法</p><p>Arrays工具类中有一个静态方法</p><ul><li>public static <T> List<T> asList(T… a)：返回由指定数组支持的固定大小的列表</li></ul><p>List接口中有一个静态方法</p><ul><li>public static <E> List<E> of(E… Elements)：返回包含任意数量元素的不可变列表</li></ul><p>Set接口中有一个静态方法</p><ul><li>Public Static <E> Set<E> of(E… Elements)：返回包含任意数量元素的不可变集合</li></ul><p>总结：三者都不能增加删除元素，Array可以更改元素，Set不能出现重复元素</p><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>JAVASE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>集合进阶</title>
    <link href="/2022/07/29/%E9%9B%86%E5%90%88%E8%BF%9B%E9%98%B6/"/>
    <url>/2022/07/29/%E9%9B%86%E5%90%88%E8%BF%9B%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="集合的体系结构"><a href="#集合的体系结构" class="headerlink" title="集合的体系结构"></a>集合的体系结构</h3><p><img src="/upload/1-1663752498592.png" alt="1-1663752498592"></p><p><em><strong>注：如果想要将基本类型存入集合，需要用基本类型包装类存入</strong></em></p><h1 id="Collection-集合"><a href="#Collection-集合" class="headerlink" title="Collection 集合"></a>Collection 集合</h1><p><em>Collection是一个接口</em></p><ul><li>Collection是单列集合的顶层接口，它表示一组对象，这些对象也称为Collection元素</li><li>JDK不提供此接口的任何直接实现，他提供更具体的子接口（如Set或List）实现类</li></ul><p>创建Collection集合的对象</p><ul><li>多态的方式</li><li>具体的实现类 ArrayList</li></ul><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Collection&lt;String&gt; c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<span class="hljs-comment">//利用多态创建集合</span><br></code></pre></td></tr></table></figure><hr><h3 id="Collection接口常用方法"><a href="#Collection接口常用方法" class="headerlink" title="Collection接口常用方法"></a>Collection接口常用方法</h3><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>boolean add(E e)</td><td>添加元素</td></tr><tr><td>boolean remove(Object o)</td><td>从集合中移除指定的元素</td></tr><tr><td>void clear()</td><td>清空集合中的元素</td></tr><tr><td>boolean contains(Object o)</td><td>判断集合中是否有指定元素</td></tr><tr><td>boolean isEmpty()</td><td>判断集合是否为空</td></tr><tr><td>int size()</td><td>集合长度，也就是集合中元素个数</td></tr></tbody></table><hr><h3 id="Collection集合的遍历"><a href="#Collection集合的遍历" class="headerlink" title="Collection集合的遍历"></a>Collection集合的遍历</h3><p>Iterator：迭代器，集合的专用遍历方式</p><ul><li><p>Iterator<E>iterator()：返回次集合中元素的迭代器，通过集合的ierator方法得到</p></li><li><p>迭代器通过集合的iterator()方法得到，所以说他依赖于集合而存在</p></li></ul><p>Iterator本身是一个接口，在ArrayList中重写了iterator()方法，并重写了内部实现类Itr</p><p>iterator()方法的返回值也为此接口的实现类 Itr的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Iterator&lt;String&gt; it = c.iterator();<span class="hljs-comment">//多态的一种用法，引用接口指向实现类对象</span><br></code></pre></td></tr></table></figure><p>有两个常用的调用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">it.next();<span class="hljs-comment">//迭代获取元素</span><br>it.hasNext();<span class="hljs-comment">//判断有没有下一个元素</span><br></code></pre></td></tr></table></figure><hr><h3 id="集合使用流程"><a href="#集合使用流程" class="headerlink" title="集合使用流程"></a>集合使用流程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//创建集合对象</span><br>        Collection&lt;String&gt; c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>        <span class="hljs-comment">//创建元素</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello&quot;</span>;<br>        <span class="hljs-comment">//添加元素到集合</span><br>        c.add(s);<br><br>        <span class="hljs-comment">//创建迭代器</span><br>        Iterator&lt;String&gt; it = c.iterator();<br>        <span class="hljs-comment">//通过迭代器判断是否还有元素</span><br>        <span class="hljs-keyword">while</span> (it.hasNext()) &#123;<br>            <span class="hljs-comment">//获取到元素</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> it.next();<br>            <span class="hljs-comment">//输出元素</span><br>            System.out.println(s1);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h1><p><em>List接口继承Collection接口</em></p><ul><li><strong>有序</strong>集合（也称为序列），用户可以精准控制列表中每个元素的插入位置。用户可以通过整数索引访问元素，并搜索列表中的元素。</li><li>与Set集合不同，列表通常允许<strong>重复</strong>的元素</li></ul><h3 id="List接口特有方法"><a href="#List接口特有方法" class="headerlink" title="List接口特有方法"></a>List接口特有方法</h3><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>void add(int index,E e)</td><td>在此集合中的指定位置添加指定元素</td></tr><tr><td>E remove (int index)</td><td>删除指定索引处的元素，返回被删除的元素</td></tr><tr><td>E set(int index,E e)</td><td>修改指定索引处的元素，返回被修改的元素</td></tr><tr><td>E get(int index)</td><td>返回指定索引出的元素</td></tr></tbody></table><p><em>注：List有一个具体的实现类ArrayList，在其中重写了两个父接口的方法</em></p><p><em>在ArrayList中，分别重写了List接口中E remove (int index)方法，和Collection接口中boolean remove(Object o)方法。（这里是方法的重写，不是方法的重载）</em></p><hr><h3 id="并发修改异常"><a href="#并发修改异常" class="headerlink" title="并发修改异常"></a>并发修改异常</h3><p><em><strong>ConcurrntModificationException</strong></em></p><p>使用迭代器时需要保证List集合的内容不发生改变，如果List集合中内容发生改变，迭代器又没有重新使用List集合iterator()方法去更新内容。直接调用迭代器的next()方法就会出现<strong>并发修改异常</strong>。</p><p><em>如果直接使用hasNext()方法则不会出现异常，因为这个方法没有检测判断</em></p><h5 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h5><p>modCount变量（List的父类抽象类AbstractList中）会在Itr实现类实例化时（调用iterator方法时）赋值给expectedModCount属性。</p><p>其意思为集合修改次数，和集合预期修改次数（初始化迭代器时这两个变量相等）</p><p><strong>当在寄存器遍历过程中调用add方法，则modCount++；</strong></p><p>调用next()方法时检测发现，集合修改次数与集合预期修改次数不相等，则抛出异常</p><p><em>个人理解就是不可以在迭代器遍历集合的过程中对集合添加元素</em></p><h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><p>不用迭代器，用for加索引的方式来遍历集合。</p><hr><h3 id="ListIterator列表迭代器"><a href="#ListIterator列表迭代器" class="headerlink" title="ListIterator列表迭代器"></a>ListIterator列表迭代器</h3><p>列表迭代器</p><ul><li>通过List接口的listIterator()方法得到，所以说它是List集合特有的迭代器</li><li>允许沿任意方向遍历列表的列表迭代器，在迭代期间修改列表，并获取列表中迭代器的当前位置</li></ul><p><em>ListIterator继承自Iterator接口</em></p><h4 id="ListIterator常用方法"><a href="#ListIterator常用方法" class="headerlink" title="ListIterator常用方法"></a>ListIterator常用方法</h4><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>E next()</td><td>返回迭代中的下一元素</td></tr><tr><td>boolean hasNext()</td><td>判断列表中是否还有下一元素</td></tr><tr><td>E previous()</td><td>返回列表中的上一元素</td></tr><tr><td>boolean hasPrevious()</td><td>判断列表是否还有上一元素</td></tr><tr><td>void add(E e)</td><td>将指定元素插入列表</td></tr></tbody></table><p><em>previous英文释义：以前的、先前的、以往的</em></p><h5 id="独有的add方法"><a href="#独有的add方法" class="headerlink" title="独有的add方法"></a>独有的add方法</h5><p>列表迭代器可以调用add()方法直接向集合中添加元素，而不会出现并发修改异常</p><p>原因是因为add()方法在添加元素后modCount重新赋值给expectedModCount属性</p><hr><h3 id="增强for循环"><a href="#增强for循环" class="headerlink" title="增强for循环"></a>增强for循环</h3><p>简化数组和Collection集合的遍历</p><ul><li>继承Iterable接口的实现类允许对象成为增强for的目标</li><li>增强for的内部原理是一个Iterator迭代器</li></ul><p><strong>格式：</strong></p><p>for(数组（集合）中元素的数据类型 变量名 : 数组（集合）){</p><p>在此处使用变量即可，该变量就是元素</p><p>}</p><p><em>注：增强for同样不可以在遍历时对集合进行添加元素操作</em></p><h1 id="LinkedList集合"><a href="#LinkedList集合" class="headerlink" title="LinkedList集合"></a>LinkedList集合</h1><p>LinkedList是List接口的具体实现类，与ArrayList同级别，底层通过链表实现</p><p>LinkedList遍历方式与ArrayList基本相同</p><h3 id="LinkedList集合特有方法"><a href="#LinkedList集合特有方法" class="headerlink" title="LinkedList集合特有方法"></a>LinkedList集合特有方法</h3><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>void addFirst(E e)</td><td>在该表开头插入指定元素</td></tr><tr><td>void addLast(E e)</td><td>将指定的元素追加到此列表的表尾</td></tr><tr><td>E getFirst()</td><td>获取表中第一个元素</td></tr><tr><td>E getLast()</td><td>获取表中最后一个元素</td></tr><tr><td>E removeFirst()</td><td>从此表中删除并返回第一个元素</td></tr><tr><td>E removeLast()</td><td>从此列表中删除并返回最后一个元素</td></tr></tbody></table><hr><h1 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h1><p>Set接口是继承于Collection接口</p><ul><li>Set集合中不包含重复元素的集合</li><li>没有带索引的方法，所以不能使用<strong>普通</strong>for循环进行遍历</li></ul><hr><h3 id="HashSet-实现类"><a href="#HashSet-实现类" class="headerlink" title="HashSet 实现类"></a>HashSet 实现类</h3><p>HashSet 实现类是继承于Set接口和Collection接口，在其中重写了Collection接口的方法</p><p><em>HashSet’实现类对集合的迭代顺序不做任何保证</em></p><h3 id="Hash值"><a href="#Hash值" class="headerlink" title="Hash值"></a>Hash值</h3><p>哈希值：是JDK根据对象的地址或者字符串或者数字计算出来的int类型的值</p><p>object类中的int hashCode()方法可以获取对象的哈希值</p><p>默认情况下，不同对象的哈希值是不同的</p><p><em>通过方法重写，可以实现不同对象的哈希值是相同的</em></p><h3 id="HashSet集合的概述和特点"><a href="#HashSet集合的概述和特点" class="headerlink" title="HashSet集合的概述和特点"></a>HashSet集合的概述和特点</h3><p>HashSet特点</p><ul><li>底层数据结构是哈希表</li><li>对集合的迭代顺序不做任何保证，也就是说不保证存储和取出的元素顺序一致</li><li>Set集合中不包含重复元素的集合</li><li>没有带索引的方法，所以不能使用<strong>普通</strong>for循环进行遍历</li></ul><p><em>注：HashSet集合类也继承于Set接口，所以继承Set集合特点</em></p><h5 id="存储流程"><a href="#存储流程" class="headerlink" title="存储流程*"></a>存储流程*</h5><ol><li>i获取对象的hash值，计算其地址判断有没有值</li><li>如果有值，就遍历该位置的所有的元素，判断哈希值是否与新元素相同</li><li>如果相同，判断元素内容是否相等（equals()）</li><li>如果相等，说明元素重复，不存储</li></ol><p><em>注：HashSet的数据结构用拉链法，也就是说同一个hash值算出的地址可以存储多个元素</em></p><h5 id="保证HashSet元素唯一性"><a href="#保证HashSet元素唯一性" class="headerlink" title="保证HashSet元素唯一性"></a>保证HashSet元素唯一性</h5><p>HashSet集合，采用哈希表结构存储数据，保证元素唯一性的方式依赖于：hashCode()与equals()方法。</p><ol><li>HashSet集合排重时，需要判断两个对象是否相同，对象相同的判断可以通过hashCode值判断，所以需要重写hashCode()方法</li><li>HashSet中不能有相同的元素，放入一个值调用hashCode()（获取位置）是否重复，然后用equals判断是否为重复值。</li><li>如果只重写其中一个方法的时候，向HashSet集合中添加多个对象时，所有属性都相同时，并没有完成想要的排重效果。</li></ol><p><em><strong>情况一：当我们往HashSet集合中添加 8大基本类型和String类型的时候，不需要重写hashCode()和equals()方法。因为任何对象都是Object类的子类，所以任何对象都拥有这个方法。</strong></em><br><em><strong>情况二：当我们往HashSet集合添加引用数据类型对象的时候，就需要重写hashCode()和equals()方法。建立自己的比较方式，才能保证HashSet集合中的对象唯一。</strong></em></p><hr><h3 id="LinkedHashSet集合的概述和特点"><a href="#LinkedHashSet集合的概述和特点" class="headerlink" title="LinkedHashSet集合的概述和特点"></a>LinkedHashSet集合的概述和特点</h3><p>LinkedHashSet集合特点</p><ul><li>哈希表和链表实现Set接口，具有可预测的迭代次序</li><li><strong>由链表保证元素有序，也就是说元素的存储和取出顺序是一致的</strong></li><li>有哈希表保证元素唯一，也就是说没有重复的元素</li></ul><hr><h3 id="TreeSet集合的概述和特点"><a href="#TreeSet集合的概述和特点" class="headerlink" title="TreeSet集合的概述和特点"></a>TreeSet集合的概述和特点</h3><p>TreeSet集合特点</p><ul><li><p>元素有序，这里的顺序不是指元素位置上有序，而是按照元素本身的关系进行排序，排序规则方式取决于构造方法</p><ul><li>TreeSet()：根据元素自然排序进行排序</li><li>TreeSet(Comparator comparator)：根据指定的比较器进行排序</li></ul><p><em>comparator英文释义：比较器</em></p></li><li><p>没有带索引的方法，所以不能使用<strong>普通</strong>for循环进行遍历</p></li><li><p>继承Set集合，不包含重复元素</p></li></ul><p><em>注：与hash类型集合不同，TreeSet保证元素唯一性的方式是判断差值是否为零</em> </p><hr><h3 id="自然排序Comparable的使用"><a href="#自然排序Comparable的使用" class="headerlink" title="自然排序Comparable的使用"></a>自然排序Comparable的使用</h3><p><em>comparable英文释义：类似的，可比较的</em></p><p><em>compara英文释义：比较</em></p><ul><li>用TreeSet集合存储自定义对象时，无参构造方法使用的是<strong>自然排序</strong>对元素进行排序</li><li>自然排序，就是<strong>让元素所属的类实现Comparable接口</strong>，重写**comparaTo(T o)**方法</li><li>重写方法时，一定要注意排序规则必须按照主要条件和次要条件来写</li></ul> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Student o)</span> &#123;<br>    <span class="hljs-comment">//return 1;</span><br>    <span class="hljs-comment">//假如这里的形参是s1    o.age==s1.age    this.age==s2.age</span><br>    <span class="hljs-comment">//如果想象成排序二叉树，就是-1在左子树，1在右子树，0不存</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.age - o.age;<span class="hljs-comment">//升序方法</span><br>    <span class="hljs-comment">//在String类中，重写了自然排序方法，这里可以直接用</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">num1</span> <span class="hljs-operator">=</span> num == <span class="hljs-number">0</span> ? <span class="hljs-built_in">this</span>.name.compareTo(o.name) : num;<br>    <span class="hljs-keyword">return</span> num1;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="比较器排序Comparator的使用"><a href="#比较器排序Comparator的使用" class="headerlink" title="比较器排序Comparator的使用"></a>比较器排序Comparator的使用</h3><ul><li>用TreeSet集合存储自定义对象时，带参构造方法使用的是<strong>比较器排序</strong>对元素进行排序</li><li>比较器排序，就是<strong>让集合构造方法接收Comparator的实现类对象</strong>，重写**compara(T o1,T o2)**方法</li><li>重写方法时，一定要注意排序规则必须按照主要条件和次要条件来写</li></ul><p><em>注：在TreeSet实例化时，带参构造方法的实参应该为Comparator类的对象</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        TreeSet&lt;Student&gt; ts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;Student&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Student&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Student o1, Student o2)</span> &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> o1.getAge() - o2.getAge();<br>                <span class="hljs-type">int</span> <span class="hljs-variable">num1</span> <span class="hljs-operator">=</span> num == <span class="hljs-number">0</span> ?o1.getName().compareTo(o2.getName()) : num;<br>                <span class="hljs-keyword">return</span> num1;<br>            &#125;<br>        &#125;);<span class="hljs-comment">//这里的实参使用了匿名内部类作为接口的实现类对象</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>JAVASE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>日期类</title>
    <link href="/2022/07/27/%E6%97%A5%E6%9C%9F%E7%B1%BB/"/>
    <url>/2022/07/27/%E6%97%A5%E6%9C%9F%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="date类"><a href="#date类" class="headerlink" title="date类"></a>date类</h1><p>在java.util和java.sql包下都有Date类，在这里我们学习的是java.util.Date</p><p>Date代表了一个特定的时间，精确到毫秒</p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><table><thead><tr><th align="left">方法名</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">Date()</td><td align="left">分配一个Date对象，并初始化，以便它代表它被分配的时间，精确到毫秒</td></tr><tr><td align="left">Date(long date)</td><td align="left">分配一个Date对象，并将其初始化为表示从标准基准时间起指定的毫秒数</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>        System.out.println(date);<span class="hljs-comment">//输出Wed Jul 27 13:01:47 CST 2022，这里重写了Date类的toString方法</span><br><br>        <span class="hljs-type">long</span> <span class="hljs-variable">datel</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span>*<span class="hljs-number">60</span>*<span class="hljs-number">60</span>;<br>        <span class="hljs-type">Date</span> <span class="hljs-variable">date2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(datel);<br>        System.out.println(date2);<span class="hljs-comment">//输出Thu Jan 01 09:00:00 CST 1970， 因中国时区时东8区，所以是9点</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="Date类常用方法"><a href="#Date类常用方法" class="headerlink" title="Date类常用方法"></a>Date类常用方法</h3><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>long getTime()</td><td>获取的是日期对象从1970年1月1日到现在的毫秒值</td></tr><tr><td>void setTime(long time)</td><td>设置时间，参数为毫秒值</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>        System.out.println(date.getTime());<span class="hljs-comment">//1658898667736</span><br><br>        date.setTime(<span class="hljs-number">1000</span>*<span class="hljs-number">60</span>*<span class="hljs-number">60</span>);<br>        System.out.println(date);<span class="hljs-comment">//Thu Jan 01 09:00:00 CST 1970</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="SimpleDateFormat类-概述"><a href="#SimpleDateFormat类-概述" class="headerlink" title="SimpleDateFormat类 概述"></a>SimpleDateFormat类 概述</h1><p>SimpleDateFormat是一个具体的类，用于以区域设置敏感的方式格式化解析和日期。我们重点学习日期的格式化和解析</p><p>日期和时间格式由日期和时间模式字符串指定，在日期和时间模式字符串中，从’A’到’Z’以及从’a’到’z’引号的字母被解释为表示日期或时间字符串的组件的模式字母</p><p><em>format英文释义：格式化</em></p><p><strong>注：其实SimpleDateForma类实例化的对象，基本上是存了一个模式，例XXXX年XX月XX日 xx:xx:xx这种的格式。调用方法传参（Date对象或String对象进去）就可以实现以SimpleDateForma模式为格式的转换（格式化和解析）</strong></p><p><strong>常用的模式字母及对应关系如下</strong></p><table><thead><tr><th align="left">模式字母</th><th align="left">对应关系</th></tr></thead><tbody><tr><td align="left">y</td><td align="left">年</td></tr><tr><td align="left"><strong>M</strong></td><td align="left">月</td></tr><tr><td align="left">d</td><td align="left">日</td></tr><tr><td align="left"><strong>H</strong></td><td align="left">时</td></tr><tr><td align="left">m</td><td align="left">分</td></tr><tr><td align="left">s</td><td align="left">秒</td></tr></tbody></table><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>SimpleDateFormat()</td><td>构造一个SimpleDateFormat，使用默认模式和日期格式</td></tr><tr><td>SimpleDateFormat(String patten)</td><td>构造一个SimpleDateFormat，使用给定的模式和默认的日期格式</td></tr></tbody></table><h3 id="SimpleDateFormat-格式化和解析"><a href="#SimpleDateFormat-格式化和解析" class="headerlink" title="SimpleDateFormat 格式化和解析"></a>SimpleDateFormat 格式化和解析</h3><ol><li><p>格式化（从Date到String）</p><p>final String format(Date date):将日期格式化成日期、时间字符串</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">+<span class="hljs-keyword">import</span> java.text.SimpleDateFormat;<br><span class="hljs-keyword">import</span> java.util.Date;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Date</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>      <span class="hljs-comment">//以yyyy年MM月dd日 HH:mm:ss格式构造</span><br>        <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy年MM月dd日 HH:mm:ss&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> sdf.format(d);<br>        System.out.println(s);<span class="hljs-comment">//输出以SimpleDateFormat模式为格式的当前时间</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><ol start="2"><li><p>解析（从String到Date）</p><p>Date parse(String source):从给定的字符串开始解析文本以生成日期</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.text.ParseException;<br><span class="hljs-keyword">import</span> java.text.SimpleDateFormat;<br><span class="hljs-keyword">import</span> java.util.Date;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ParseException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;2001-06-16 10:00:00&quot;</span>;<br>        <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br>        <span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>      <span class="hljs-comment">//以SimpleDateFormat的模式为格式接受s，并对其解析，返回Date类的对象</span><br>        date = sdf.parse(s);<br>        System.out.println(date);<span class="hljs-comment">//输出Sat Jun 16 10:00:00 CST 2001</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h1><p>Calendar本事是一个抽象类，他本身不能利用构造方法实例化对象</p><p>Calendar提供了一个静态方法getInstance用来获取Calendar子类对象，其日历字段已使用当前日期和时间初始化，这个方法在调用实例化对象时实现的本质是<strong>多态</strong></p><p><em>instance英文释义：实例</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Calendar</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Calendar.getInstance(); <span class="hljs-comment">//多态</span><br></code></pre></td></tr></table></figure><h3 id="Calendar常用方法"><a href="#Calendar常用方法" class="headerlink" title="Calendar常用方法"></a>Calendar常用方法</h3><p>Calender的方法主要是通过get、set、add对对象里的属性进行修改和读取。</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>int get(int field)</td><td>返回给定日历字段的值</td></tr><tr><td>abstarct void add(int field,int amount)</td><td>根据日历的规则，将指定的时间量添加或减去给定的日历属性</td></tr><tr><td>final void set(int year,int mounth,int date)</td><td>设置当前的年月日</td></tr></tbody></table><hr><h5 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Calendar</span> <span class="hljs-variable">cal</span> <span class="hljs-operator">=</span> Calendar.getInstance();<br><br>      <span class="hljs-comment">//yeah属性在Calendar类中是静态的常量，所以通过类名.属性获取该字段作为形参</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">year</span> <span class="hljs-operator">=</span> cal.get(Calendar.YEAR);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">month</span> <span class="hljs-operator">=</span> cal.get(Calendar.MONTH)+ <span class="hljs-number">1</span>;<span class="hljs-comment">//因为月从零开始，需要加 1</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> cal.get(Calendar.DATE);<br>        System.out.println(year +<span class="hljs-string">&quot;年&quot;</span> + month + <span class="hljs-string">&quot;月&quot;</span> + date+ <span class="hljs-string">&quot;日&quot;</span>);<span class="hljs-comment">//2022年7月27日</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="ADD方法"><a href="#ADD方法" class="headerlink" title="ADD方法"></a>ADD方法</h5><p><em>虽然这个方法是抽象方法，但是我们在实例化对象的时候也是用了多态，所以方法在子类中肯定是会重写</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Calendar</span> <span class="hljs-variable">cal</span> <span class="hljs-operator">=</span> Calendar.getInstance();<br>        <span class="hljs-comment">//add方法（十年后的五天前）</span><br>        cal.add(Calendar.YEAR,<span class="hljs-number">10</span>);<br>        cal.add(Calendar.DATE,-<span class="hljs-number">5</span>);<br>        <span class="hljs-comment">//get方法</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">year</span> <span class="hljs-operator">=</span> cal.get(Calendar.YEAR);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">month</span> <span class="hljs-operator">=</span> cal.get(Calendar.MONTH)+ <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> cal.get(Calendar.DATE);<br>        System.out.println(year +<span class="hljs-string">&quot;年&quot;</span> + month + <span class="hljs-string">&quot;月&quot;</span> + date+ <span class="hljs-string">&quot;日&quot;</span>);<span class="hljs-comment">//2032年7月22日</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="set方法"><a href="#set方法" class="headerlink" title="set方法"></a>set方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Calendar</span> <span class="hljs-variable">cal</span> <span class="hljs-operator">=</span> Calendar.getInstance();<br>        <span class="hljs-comment">//set方法</span><br>        cal.set(<span class="hljs-number">2001</span>,<span class="hljs-number">05</span>,<span class="hljs-number">16</span>);<br>        <span class="hljs-comment">//get方法</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">year</span> <span class="hljs-operator">=</span> cal.get(Calendar.YEAR);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">month</span> <span class="hljs-operator">=</span> cal.get(Calendar.MONTH)+ <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> cal.get(Calendar.DATE);<br>        System.out.println(year +<span class="hljs-string">&quot;年&quot;</span> + month + <span class="hljs-string">&quot;月&quot;</span> + date+ <span class="hljs-string">&quot;日&quot;</span>);<span class="hljs-comment">//2001.06.16</span><br>    &#125;<br></code></pre></td></tr></table></figure><hr><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>输入一个年份，求这个年的2月有多少天</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//从键盘上获取一个年份</span><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        System.out.println(<span class="hljs-string">&quot;请输入年份&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">year</span> <span class="hljs-operator">=</span> scanner.nextInt();<br><br>        <span class="hljs-comment">//设置日历对象的年月日</span><br>        <span class="hljs-type">Calendar</span> <span class="hljs-variable">cal</span> <span class="hljs-operator">=</span> Calendar.getInstance();<br>        cal.set(year,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>);<span class="hljs-comment">//设置为3月1日</span><br><br>        <span class="hljs-comment">//3月1日往前一天就是2月的最后一天</span><br>        cal.add(Calendar.DATE,-<span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">//获取这一天 输出即可</span><br>        System.out.println(cal.get(Calendar.DATE));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>JAVASE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>集合</title>
    <link href="/2022/07/27/%E9%9B%86%E5%90%88/"/>
    <url>/2022/07/27/%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h1 id="ArrayList-集合实现类"><a href="#ArrayList-集合实现类" class="headerlink" title="ArrayList 集合实现类"></a>ArrayList 集合实现类</h1><p><em>我们可以把ArrayList 看作是一个数据类型为引用类型的数组，并且该数组的长度用size表示，而且没有固定大小</em></p><p>ArrayList<E></p><ul><li>可调整大小的数组实现</li><li><E>:是一种特殊的数据类型，泛型</li></ul><p>使用方法：</p><pre><code class="hljs">在出现E的地方我们使用引用数据类型替换即可距离：ArrayList&lt;String&gt;,ArrayList&lt;Student&gt;</code></pre><h3 id="ArrayList构造方法和添加方法"><a href="#ArrayList构造方法和添加方法" class="headerlink" title="ArrayList构造方法和添加方法"></a>ArrayList构造方法和添加方法</h3><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td><strong>Arraylist()</strong></td><td><strong>创建一个空的集合对象 （构造方法）</strong></td></tr><tr><td>boolean add(E e)</td><td>将指定元素（对象）追加到此集合的末尾</td></tr><tr><td>void add(int index,E e)</td><td>在集合中的指定位置插入指定元素</td></tr></tbody></table><h5 id="构造和添加方法源代码"><a href="#构造和添加方法源代码" class="headerlink" title="构造和添加方法源代码"></a>构造和添加方法源代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        ArrayList&lt;String&gt; arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>        arr.add(<span class="hljs-string">&quot;Hellow&quot;</span>);<br>        arr.add(<span class="hljs-string">&quot;World&quot;</span>);<br>        <span class="hljs-comment">//在集合2的位置插入Xiaobai，如果在集合3的位置插入就会出现异常：集合的索引越界</span><br>        arr.add(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;Xiaobai&quot;</span>);<br>        System.out.println(arr); <span class="hljs-comment">//[Hellow, World, Xiaobai]</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="ArrayList集合常用方法"><a href="#ArrayList集合常用方法" class="headerlink" title="ArrayList集合常用方法"></a>ArrayList集合常用方法</h3><p><em>index英文释义：索引</em></p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>boolean remove(Object o )</td><td>删除指定元素，返回删除是否成功</td></tr><tr><td>E remove(int index)</td><td>删除指定位置的元素，并返回被删除的元素</td></tr><tr><td>E set(int index,E e)</td><td>修改指定位置的元素，返回被修改的元素</td></tr><tr><td>E get(int index)</td><td>返回指定位置的元素</td></tr><tr><td>int size()</td><td>返回集合中元素个数</td></tr></tbody></table><h3 id="集合元素的遍历"><a href="#集合元素的遍历" class="headerlink" title="集合元素的遍历"></a>集合元素的遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.size(); i++) &#123;<br><span class="hljs-comment">//在这里不能直接sout(arr.get(i))，因为Student是特殊的引用类型</span><br>  <span class="hljs-type">Student</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> arr.get(i);<br><span class="hljs-comment">//get方法获取到Student类对象s的name和age属性</span><br>  System.out.println(s.getName + <span class="hljs-string">&quot;,&quot;</span> + s.getAge);<br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>JAVASE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>内部类</title>
    <link href="/2022/07/24/%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    <url>/2022/07/24/%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="内部类（选修）"><a href="#内部类（选修）" class="headerlink" title="内部类（选修）"></a>内部类（选修）</h1><h5 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h5><p>内部类定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span> &#123;<br>            <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>; <span class="hljs-comment">//外部类中私有属性</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">out</span><span class="hljs-params">()</span>&#123;<br>                <span class="hljs-comment">//这是一个外部类方法</span><br>            &#125;<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span>&#123; <span class="hljs-comment">//这是一个内部类</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span>&#123;<br>                  <span class="hljs-comment">//这是一个内部类方法  </span><br>                  System.out.println(id);<span class="hljs-comment">//内部类可以获取到外部类私有变量</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>内部类实例化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Outer</span> <span class="hljs-variable">outer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>();<br>Outer.<span class="hljs-type">Inner</span> <span class="hljs-variable">inner</span> <span class="hljs-operator">=</span> outer.<span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>(); <span class="hljs-comment">//利用外部类定义的对象outer来实例化内部类</span><br></code></pre></td></tr></table></figure><hr><h1 id="匿名内部类（必修）"><a href="#匿名内部类（必修）" class="headerlink" title="匿名内部类（必修）"></a>匿名内部类（必修）</h1><p>匿名内部类是一个继承了该类或者实现了该接口的子类匿名对象</p><p><em>这里的类可以是具体类也可以是抽象类</em></p><h3 id="直接调用类中方法"><a href="#直接调用类中方法" class="headerlink" title="直接调用类中方法"></a>直接调用类中方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>().out; <span class="hljs-comment">//不实例化对象，只初始化类，也可以调用类中方法</span><br></code></pre></td></tr></table></figure><h3 id="在开发中的使用"><a href="#在开发中的使用" class="headerlink" title="在开发中的使用*"></a>在开发中的使用*</h3><p>new 接口直接给一个接口的对象，在执行体内重写方法，也叫做匿名内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Application</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//多态，接口引用指向匿名内部类对象</span><br>        <span class="hljs-type">UserService</span> <span class="hljs-variable">userService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserService</span>()&#123;<br>            <span class="hljs-comment">//重写hello方法</span><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">()</span> &#123; <br>                System.out.println(<span class="hljs-string">&quot;hello&quot;</span>);<br>            &#125;<br>        &#125;;<br>        <span class="hljs-comment">//可通过引用变量userService调用接口中重写过的方法</span><br>        userService.hello();<br>    &#125;<br>    <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserService</span>&#123; <span class="hljs-comment">//一个接口</span><br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">()</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>JAVASE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>简单的Dos命令</title>
    <link href="/2022/07/24/%E7%AE%80%E5%8D%95%E7%9A%84Dos%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/07/24/%E7%AE%80%E5%8D%95%E7%9A%84Dos%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="简单的Dos命令"><a href="#简单的Dos命令" class="headerlink" title="简单的Dos命令"></a>简单的Dos命令</h1><h2 id="打开cmd的方式"><a href="#打开cmd的方式" class="headerlink" title="打开cmd的方式"></a>打开cmd的方式</h2><ol><li><strong>打开+系统+命令提示符</strong></li><li><strong>win+r 输入cmd打开控制台</strong></li><li><strong>在任意文件夹下，按住shift+鼠标右键点击，在此处打开命令窗口</strong></li><li>**资源管理器地址栏前加上cmd **</li></ol><h2 id="常用的dos命令"><a href="#常用的dos命令" class="headerlink" title="常用的dos命令"></a>常用的dos命令</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">#盘符切换 </span><br>dir <span class="hljs-comment">#查看当前目录下所有文件 </span><br>cd change directory <span class="hljs-comment">#切换目录 </span><br>cd .. <span class="hljs-comment">#返回上一级</span><br>cls <span class="hljs-comment">#清理屏幕（clear screen）</span><br><span class="hljs-keyword">exit</span> <span class="hljs-comment">#退出终端</span><br>ipconfig <span class="hljs-comment">#查看ip信息</span><br>md <span class="hljs-comment">#创建文件夹</span><br>cd&gt; <span class="hljs-comment">#新建文件</span><br>del <span class="hljs-comment">#删除文件</span><br>rd <span class="hljs-comment">#移除目录</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>JAVASE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java常用类</title>
    <link href="/2022/07/24/Java%E5%B8%B8%E7%94%A8%E7%B1%BB/"/>
    <url>/2022/07/24/Java%E5%B8%B8%E7%94%A8%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h1><p>Math包含执行基本数字运算的方法</p><p><em>注：类似Math类的工具类中不是没有构造方法，而是构造方法被private修饰，无法实例化对象。但其所有方法（属性）都是静态的。都可以利用类名.方法（属性）的方式调用</em></p><h3 id="Math类的常用方法"><a href="#Math类的常用方法" class="headerlink" title="Math类的常用方法"></a>Math类的常用方法</h3><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>int abs(int)</td><td>返回参数的绝对值</td></tr><tr><td>double ceil(double a )</td><td>返回大于或等于参数的最小double值，等于一个整数(向上取整)</td></tr><tr><td>double floor(double a)</td><td>返回小于或等于参数的最小double值，等于一个整数(向下取整)</td></tr><tr><td>int round(float a)</td><td>按照四舍五入返回最接近参数的int</td></tr><tr><td>int max(int a, int b)</td><td>返回两个int中的较大值</td></tr><tr><td>int min(int a, int b)</td><td>返回两个int中的较小值</td></tr><tr><td>double pow(double a, double b)</td><td>返回a的b次幂的值</td></tr><tr><td>double random()</td><td>返回值为double的正值 , [0.0,1.0)（取随机数）</td></tr></tbody></table><p><em>注：如果想取1~100的随机数，可以先调用方法乘100之后用int进行强制类型转换</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">(<span class="hljs-type">int</span>)(Math.random() * <span class="hljs-number">100</span>) + <span class="hljs-number">1</span>; <span class="hljs-comment">//方法是取0~99所以要加1</span><br></code></pre></td></tr></table></figure><hr><h1 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h1><p>System类也是工具类，无法实例化对象</p><h3 id="System类的常用方法"><a href="#System类的常用方法" class="headerlink" title="System类的常用方法"></a>System类的常用方法</h3><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>void exit(int status)</td><td>终止当前运行的Java虚拟机，非零表示异常终止</td></tr><tr><td>long currentTimeMillis()</td><td>返回当前时间（以毫秒为单位）1970年距今的毫秒值</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.currentTimeMillis() * <span class="hljs-number">1.0</span> / <span class="hljs-number">1000</span> / <span class="hljs-number">60</span> / <span class="hljs-number">60</span> / <span class="hljs-number">24</span> / <span class="hljs-number">365</span>; <span class="hljs-comment">//1970距今有多少年</span><br></code></pre></td></tr></table></figure><hr><p>利用System.currentTimeMillis();方法实现记录整个循环所有时间为多少毫秒</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis(); <span class="hljs-comment">//记录for循环开始时间</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>            System.out.println(i);<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis(); <span class="hljs-comment">//记录for循环结束时间</span><br>        System.out.println(end - start); <span class="hljs-comment">//输出for所用时间</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h1><p>类Object是所有类的超类，所有类都直接的或者间接的继承Object类</p><p><strong>Object类中有构造方法</strong></p><h3 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h3><p>调用方法：对象a.toString();</p><p>toString方法会默认返回:全类名(包名+类名)+@+哈希值的十六进制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-keyword">return</span> getClass().getName() + <span class="hljs-string">&quot;@&quot;</span> + Integer.toHexString(hashCode());<br>   &#125;<br></code></pre></td></tr></table></figure><hr><p>通常情况下，我们经常会在类中重写toString方法来输出该对象的属性</p><blockquote><p>在idea中，用户可以通过快捷键alt+Insert键快速重写toString方法</p></blockquote><p>重写后,可以通过调用toString方法来对对象的属性进行输出</p><hr><h3 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a>equals方法</h3><p>调用方法，对象a.equals(对象b)；</p><p>equals方法会默认对比两个对象的地址值是否相等（引用类型）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Objects obj)</span>&#123;<br><span class="hljs-keyword">return</span> (<span class="hljs-built_in">this</span> == obj);<br>   &#125;<br></code></pre></td></tr></table></figure><hr><p>如果想让equals方法对比两个对象的属性值是否相等，需要在类中重写equals方法</p><blockquote><p>在idea中，用户可以通过快捷键alt+Insert键快速重写equals方法</p></blockquote><p>重写后，可以调用equals方法来对比属性值是否相等</p><hr><h1 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h1><p>Arrays类包含用于操作数组的各种方法</p><p>Arryas也是工具类，不能实例化对象</p><h3 id="Arrays类的常用方法"><a href="#Arrays类的常用方法" class="headerlink" title="Arrays类的常用方法"></a>Arrays类的常用方法</h3><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>String toString(int[] a)</td><td>返回指定数组的内容的字符串表现形式</td></tr><tr><td>void sort(int[] a)</td><td>按照数字排序排列指定的数组</td></tr></tbody></table><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>JAVASE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>基本类型包装类</title>
    <link href="/2022/07/24/%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%8C%85%E8%A3%85%E7%B1%BB/"/>
    <url>/2022/07/24/%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%8C%85%E8%A3%85%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<p>将基本数据类型封装成对象的好处在于可以在对象中定义更多的功能方法操作该数据</p><p>常用的操作之一：用于基本数据类型与字符串之间的转换</p><table><thead><tr><th align="center">基本数据类型</th><th align="center">包装类</th></tr></thead><tbody><tr><td align="center">byte</td><td align="center">Byte</td></tr><tr><td align="center">short</td><td align="center">Short</td></tr><tr><td align="center"><strong>int</strong></td><td align="center"><strong>Integer</strong></td></tr><tr><td align="center">long</td><td align="center">Long</td></tr><tr><td align="center">float</td><td align="center">Float</td></tr><tr><td align="center">double</td><td align="center">Double</td></tr><tr><td align="center"><strong>char</strong></td><td align="center"><strong>Character</strong></td></tr><tr><td align="center">boolean</td><td align="center">Boolean</td></tr></tbody></table><hr><h1 id="Integer包装类"><a href="#Integer包装类" class="headerlink" title="Integer包装类"></a>Integer包装类</h1><h3 id="Integer类的构造方法"><a href="#Integer类的构造方法" class="headerlink" title="Integer类的构造方法"></a>Integer类的构造方法</h3><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>Integer(int value)</td><td>根据int值创建Integer对象（过时）</td></tr><tr><td>Integer(String s)</td><td>根据String值创建Integer对象（过时）</td></tr><tr><td><strong>static Integer valueOf(int i)</strong></td><td><strong>返回表示指定int值的Integer实例</strong></td></tr><tr><td><strong>static Integer valueOf(String s)</strong></td><td><strong>返回一个保存指定值Integer对象String</strong></td></tr></tbody></table><p><em>注：Integer类的valueOf方法是静态方法，可直接通过Integer.valueOf()调用，其返回值应该是一个对象</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> Integer.valueOf(<span class="hljs-number">100</span>);<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">i2</span> <span class="hljs-operator">=</span> Integer.valueOf(<span class="hljs-string">&quot;100&quot;</span>);<span class="hljs-comment">//这里的字符串参数只能是由int型数据构成的字符串参数</span><br>        <span class="hljs-comment">//Integer i2 = Integer.valueOf(&quot;abc&quot;);//NumberFormatException异常</span><br>        System.out.println(i1);<br>        System.out.println(i2);<br>    &#125;<br></code></pre></td></tr></table></figure><hr><h3 id="int和String之间的相互转换"><a href="#int和String之间的相互转换" class="headerlink" title="int和String之间的相互转换"></a>int和String之间的相互转换</h3><ol><li>int转换为String</li></ol><p>static String valueOf(int i)：返回int参数的字符串表现形式，该方法是String类中的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//int -&gt; String</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>        <span class="hljs-comment">//方式一：</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span> + num;<br>        System.out.println(s1);<span class="hljs-comment">//这里的s1为字符串</span><br>        <span class="hljs-comment">//方式二（主要）</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> String.valueOf(num);<span class="hljs-comment">//使用String valueOf静态方法转成字符串类型</span><br>        System.out.println(s2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><ol start="2"><li>String转换为int</li></ol><p>static int parsenInt(String s)：将字符串解析为int类型，该方法是Integer类中方法</p><p><em>parse英文释义：语法分析</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//Sting -&gt; Integer -&gt; int</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;100&quot;</span>;<br>        <span class="hljs-comment">//方式一</span><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> Integer.valueOf(s);<span class="hljs-comment">//先把String转换成Integer类型对象i1</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> i1.intValue();<span class="hljs-comment">//使用对象i1调用intValue方法</span><br>        System.out.println(x);<span class="hljs-comment">//此时x为int类型</span><br>        <span class="hljs-comment">//方式二（主要）</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> Integer.parseInt(s);<span class="hljs-comment">//调用parseInt静态方法</span><br>        System.out.println(y);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="案例：对字符串中数据进行排序"><a href="#案例：对字符串中数据进行排序" class="headerlink" title="案例：对字符串中数据进行排序"></a>案例：对字符串中数据进行排序</h3><p>需求：有一个字符串：”91 27 46 38 50” 对其数据进行排序，并输出字符串</p><ol><li><p>使用String类中split方法对字符串进行分割，其返回值是一个字符串数组</p></li><li><p>定义一个int型数组，使用Integer类中parseInt方法把字符串数组转成int型数组</p></li><li><p>使用StringBuilder类中append方法对int型数组中元素进行拼接，得到一个字符串 <em>append英文释义：追加</em></p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;91 27 46 38 50&quot;</span>;<br>        String[] strArray = s1.split(<span class="hljs-string">&quot; &quot;</span>);<span class="hljs-comment">//以&quot; &quot;作为分割符，对s1进行分割</span><br>      <br>        <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[strArray.length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; strArray.length; i++) &#123;<br>            arr[i] = Integer.parseInt(strArray[i]); <span class="hljs-comment">//数据类型转换 Sring转int</span><br>        &#125;<br>      <br>        Arrays.sort(arr); <span class="hljs-comment">//数组排序</span><br>      <br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(); <span class="hljs-comment">//使用StringBuilder构建空的字符串</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i == arr.length - <span class="hljs-number">1</span>)<span class="hljs-comment">//最后一个数时</span><br>                s2.append(arr[i]);<br>            <span class="hljs-keyword">else</span> &#123;<br>                s2.append(arr[i]);<br>                s2.append(<span class="hljs-string">&quot; &quot;</span>);<br>            &#125;<br>          <span class="hljs-comment">//toString方法以字符串类型返回StringBuilder中的字符串</span><br>        &#125;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> s2.toString();<br>        System.out.println(result);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="自动装箱和拆箱"><a href="#自动装箱和拆箱" class="headerlink" title="自动装箱和拆箱"></a>自动装箱和拆箱</h1><p>装箱：基本数据类型转换为对应的包装数据类型</p><p>拆箱：反之</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">ii</span> <span class="hljs-operator">=</span> Integer.valueOf(i);<span class="hljs-comment">//装箱</span><br>        i = ii.intValue();<span class="hljs-comment">//拆箱</span><br><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">iii</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<span class="hljs-comment">//自动装箱</span><br>        i = iii;<span class="hljs-comment">//自动拆箱</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>注：如果对包装类类型数据进行操作，最好先进行判断是否为null</em></p><p><em><strong>只要是对象，在使用前就必须进行不为null的判断</strong></em></p><hr><p>自动装箱（拆箱）在jdk5之后的版本就可以实现了。其实联想到String类就能明白。String类不是基本数据类型，但是他的操作方式和基本数据类型又很相似，这里就应该是系统对String类操作的一个简化。</p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>JAVASE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>异常</title>
    <link href="/2022/07/24/%E5%BC%82%E5%B8%B8/"/>
    <url>/2022/07/24/%E5%BC%82%E5%B8%B8/</url>
    
    <content type="html"><![CDATA[<h1 id="异常（Exception）"><a href="#异常（Exception）" class="headerlink" title="异常（Exception）"></a>异常（Exception）</h1><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><ul><li>检查性异常</li><li>运行时异常</li><li>错误（Error）</li></ul><p>异常通过各种意义上可以分为不同的类别，比如分为运行时异常和非运行时异常，也可以分为异常和错误。</p><p><em><strong>Error和Exception的区别：</strong></em></p><p><em>Error通常是灾难性的致命性的错误，是程序无法处理的，当出现这种异常时，Java虚拟机（JVM）一般会选择终止线程</em></p><p><em>Exception通常情况下是可以被程序处理的，并且在程序中应该尽可能的去处理这些异常</em></p><h3 id="异常体系结构"><a href="#异常体系结构" class="headerlink" title="异常体系结构"></a>异常体系结构</h3><p>Java把异常当做对象来处理，并定义一个基类java.lang.Throwable作为所有异常的超类</p><p>在Java API很中已经定义了许多异常类，这些异常类又被分为两大类，错误（Error）和异常（Exception）</p><p><img src="/upload/2022/09/1-1663752290456.png" alt="1-1663752290456"></p><h3 id="异常处理机制"><a href="#异常处理机制" class="headerlink" title="异常处理机制"></a>异常处理机制</h3><p>异常处理的五个关键字</p><ul><li>try、catch、finally、throw、throws</li></ul><hr><h4 id="try、catch、finally的用法"><a href="#try、catch、finally的用法" class="headerlink" title="try、catch、finally的用法"></a>try、catch、finally的用法</h4><p>try、catch、finally一般连用，finally可选，try、catch必须存在</p><p><em>注：异常处理的实现机制有点类似选择结构的Switch ，一层层筛选到最后执行（Finally如果存在则一定执行）</em></p><h5 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h5><p>零不能作为除数的异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        System.out.println(a / b);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h5><p><img src="/upload/2022/09/2-1663752290344.png" alt="2-1663752290344"></p><hr><p>利用try、catch、finally 监控、捕获、处理异常</p><h5 id="源代码-1"><a href="#源代码-1" class="headerlink" title="源代码"></a>源代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//假设要捕获多个异常，类要从小到大排列 否则会报错</span><br>        <span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">//try 监控区域</span><br>            System.out.println(a/b);<br>        &#125;<span class="hljs-keyword">catch</span> (Error e)&#123; <span class="hljs-comment">//catch（捕获想要的异常类型） 捕获异常 这里的形参应该为异常类和对象</span><br>            System.out.println(<span class="hljs-string">&quot;Error&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Exception e)<br>        &#123;<br>            System.out.println(<span class="hljs-string">&quot;Exception&quot;</span>);<br>        &#125;<span class="hljs-keyword">catch</span> (Throwable t)&#123;<br>            System.out.println(<span class="hljs-string">&quot;Throwable&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">finally</span>&#123; <span class="hljs-comment">//处理善后工作(如果存在则必定执行)</span><br>            System.out.println(<span class="hljs-string">&quot;Finally&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">//finally关键字可选</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h5><p><img src="/upload/2022/09/3.png" alt="3"></p><hr><blockquote><p>在idea中，选择代码后，快捷键ctrl+alt+d快捷键可以使代码被…环绕</p><p><img src="/upload/2022/09/4.png" alt="4"></p></blockquote><hr><h4 id="throw-和-throws-总结"><a href="#throw-和-throws-总结" class="headerlink" title="throw 和 throws 总结"></a>throw 和 throws 总结</h4><p>虽然系统没有throw也要把异常抛回给上层调用，但是用户一般习惯于把自己所知的异常用throw抛出，在调用层使用catch来捕获异常，这样相呼应就写成了异常的处理方法。而一般没有写throw的异常基本都是用户预期之外发生的异常。</p><p>throws 关键字和 throw 关键字在使用上的几点区别如下：</p><ol><li>throws 用来声明一个方法可能抛出的所有异常信息，表示出现异常的一种可能性，但并不一定会发生这些异常；throw 则是指拋出的一个具体的异常类型，执行 throw 则一定抛出了某种异常对象。</li><li>通常在一个方法（类）的声明处通过 throws 声明方法（类）可能拋出的异常信息，而在方法（类）内部通过 throw 声明一个具体的异常信息。</li><li><del>throws 通常不用显示地捕获异常，可由系统自动将所有捕获的异常信息抛给上级方法；</del> throw 则需要用户自己捕获相关的异常，而后再对其进行相关包装，最后将包装后的异常信息抛出。</li></ol><p><em>注：经测试 idea编译器严格要求throws抛出异常后,上层需要捕获才能编译通过</em></p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>JAVASE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>接口</title>
    <link href="/2022/07/24/%E6%8E%A5%E5%8F%A3/"/>
    <url>/2022/07/24/%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p><strong>接口的目的就是定义一些方法，让不同的人实现</strong></p><p><em>注：接口可以作为方法的形参或者返回值，需要和返回的都是该接口的实现类对象</em></p><hr><p>普通类：只有具体实现</p><p>抽象类：具体实现和规范（抽象方法）都有</p><p>接口：只有规范，没有具体实现</p><p><em>注：抽象类和接口虽然都无法实例化对象，但是他有构造方法，而接口没有</em></p><p><em>java规定类都要有一个构造方法,没有默认提供一个空参构造（抽象类也是类）。构造方法不是用来实例化的,而是用来给属性初始化赋值的,抽象方法可以定义属性（抽象和普通）,那么就需要构造方法（有参和无参）给属性赋初值。这里就可以理解为什么接口没有构造方法了所以属性必须是常量了。</em></p><p><em>还可以从另一个角度理解，抽象类必须有实现类继承（extends）来实现，<strong>初始化一个子类会先初始化父类</strong>。所以抽象类要有构造方法</em></p><hr><ul><li>接口的关键字为：interface</li><li>接口都需要有实现类，关键字：implements</li></ul><p><em>implements英文释义：使生效，贯彻，执行</em></p><ul><li>接口中的方法都默认（且必须）带有修饰符public abstract</li><li>接口中的属性都默认（且必须）带有修饰符public static final</li><li>implements可以实现多个接口</li><li>和抽象类相同，在实现类中必须要重写接口中所有方法（默认为抽象方法）</li></ul><hr><p>接口UserService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(String name)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(String name)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span> <span class="hljs-params">(String name)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">query</span> <span class="hljs-params">(String name)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>接口TimeService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">TimeService</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">timer</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>调用接口的实现类（实现类可以implements多个接口，且必须要重写接口中每一个（抽象）方法）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span>,TimeService&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">timer</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(String name)</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(String name)</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(String name)</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">query</span><span class="hljs-params">(String name)</span> &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="匿名内部类与接口的实现"><a href="#匿名内部类与接口的实现" class="headerlink" title="匿名内部类与接口的实现"></a>匿名内部类与接口的实现</h3><p>接口无法直接实例化对象，因为没有构造方法。只能通过实现类重写接口方法之后，用实现类来实例化对象。这里可以使用多态，和匿名内部类来操作：</p><p><strong>接口引用指向匿名内部类（父类引用指向子类对象）</strong></p><p>可以虚假的实现 “接口实例化对象” </p><p>具体操作可以看匿名内部类笔记</p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>JAVASE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>abstract修饰符</title>
    <link href="/2022/07/24/abstract%E4%BF%AE%E9%A5%B0%E7%AC%A6/"/>
    <url>/2022/07/24/abstract%E4%BF%AE%E9%A5%B0%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="abstract修饰符"><a href="#abstract修饰符" class="headerlink" title="abstract修饰符"></a>abstract修饰符</h1><p>abstract可以修饰类也可以修饰方法，修饰类为抽象类，修饰方法为抽象方法</p><p>特点：</p><ol><li><p>抽象类中可以有普通方法和属性</p></li><li><p>抽象方法和抽象属性必须要在抽象类中</p></li><li><p>不能new抽象类，只能靠子类去实现它（约束）</p></li></ol><p>抽象类中的抽象方法只有方法的名字，没有方法的实现</p><h5 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Action</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span>;<br>  <span class="hljs-comment">//这里的doSomething方法应该由继承Action类的子类来重写方法</span><br>&#125;<br></code></pre></td></tr></table></figure><p>*注：抽象类的子类也可以为抽象类，通过子类的子类方法重写实现方法</p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>JAVASE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>static小结</title>
    <link href="/2022/07/23/static%E5%B0%8F%E7%BB%93/"/>
    <url>/2022/07/23/static%E5%B0%8F%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="static小结"><a href="#static小结" class="headerlink" title="static小结"></a>static小结</h1><h3 id="static修饰符"><a href="#static修饰符" class="headerlink" title="static修饰符"></a>static修饰符</h3><p>static修饰符通常用来修饰类中方法或属性，在实例化对象时和类一起加载，可以通过类名.方法或类名.属性的方式调用</p><ul><li><p><strong>静态方法可以直接调用静态方法</strong></p></li><li><p><strong>静态方法不可以直接调用非静态方法</strong></p></li><li><p><strong>非静态方法可以直接调用静态方法</strong></p></li></ul><h3 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h3><p>静态代码块在实例化对象时和类一起加载，加载优先级在匿名代码块和构造方法之前</p><h5 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-comment">//1</span><br>    &#123;<br>        <span class="hljs-comment">//静态代码块，只执行一次</span><br>        System.out.println(<span class="hljs-string">&quot;静态代码块&quot;</span>);<br>    &#125;<br><br>    &#123;   <span class="hljs-comment">//2  匿名代码块通常赋初始值</span><br>        <span class="hljs-comment">//代码块（匿名代码块）</span><br>        System.out.println(<span class="hljs-string">&quot;匿名代码块&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span> &#123;  <span class="hljs-comment">//3</span><br>        <span class="hljs-comment">//构造方法</span><br>        System.out.println(<span class="hljs-string">&quot;构造方法&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">student1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        System.out.println(<span class="hljs-string">&quot;============================&quot;</span>);<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">student2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h5><p><img src="/upload/1-1663752164057.png" alt="1-1663752164057"></p><hr><h3 id="静态导入包（拓展）"><a href="#静态导入包（拓展）" class="headerlink" title="静态导入包（拓展）"></a><em>静态导入包（拓展）</em></h3><p>在使用关键字import导入包的时候 可以加入static修饰符实现静态导入包中方法</p><h5 id="源代码-1"><a href="#源代码-1" class="headerlink" title="源代码"></a>源代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.lang.Math.PI;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(PI);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>JAVASE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>封装、继承、重写、多态</title>
    <link href="/2022/07/22/%E5%B0%81%E8%A3%85%E3%80%81%E7%BB%A7%E6%89%BF%E3%80%81%E9%87%8D%E5%86%99%E3%80%81%E5%A4%9A%E6%80%81/"/>
    <url>/2022/07/22/%E5%B0%81%E8%A3%85%E3%80%81%E7%BB%A7%E6%89%BF%E3%80%81%E9%87%8D%E5%86%99%E3%80%81%E5%A4%9A%E6%80%81/</url>
    
    <content type="html"><![CDATA[<h1 id="封装、继承、重写、多态"><a href="#封装、继承、重写、多态" class="headerlink" title="封装、继承、重写、多态"></a>封装、继承、重写、多态</h1><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><h3 id="封装（数据的隐藏）"><a href="#封装（数据的隐藏）" class="headerlink" title="封装（数据的隐藏）"></a>封装（数据的隐藏）</h3><ul><li>通常，应禁止直接访问一个对象中数据的实际表示，而应该通过操作接口来访问，这称为信息隐藏。</li></ul><h3 id="封装的操作"><a href="#封装的操作" class="headerlink" title="封装的操作"></a>封装的操作</h3><ol><li>将类中属性私有，利用修饰符private</li><li>给私有属性写get&#x2F;set方法一次来获取&#x2F;修改属性</li></ol><blockquote><p>在idea中，可以使用alt+Insert快捷键来快速生成私有属性的get&#x2F;set方法</p></blockquote><h3 id="封装的好处"><a href="#封装的好处" class="headerlink" title="封装的好处"></a>封装的好处</h3><ol><li>提高程序的安全性，保护数据</li><li>隐藏代码实现细节</li><li>统一接口</li><li>增加系统可维护性</li></ol><hr><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承的本质就是使子类能够使用其父类的（有权限的）属性或方法</p><p><em>注：如果拿二叉树来类比，叶子节点则可以使用所有其祖先节点的属性和方法。</em></p><ol><li>继承的关键字时extends</li><li>JAVA中，只有单继承，没有多继承，一个父类可以有多个子类，一个子类只能有一个父类（类似于树的结构）</li><li>在JAVA中，所有的类都将间接或直接的继承object类</li></ol><h3 id="super的用法"><a href="#super的用法" class="headerlink" title="super的用法"></a>super的用法</h3><p>与this用法类似，super.属性名可以访问到（有权限的）父类的属性</p><ul><li>super只能出现在子类的构造方法或者方法中</li></ul><h3 id="继承的构造方法"><a href="#继承的构造方法" class="headerlink" title="继承的构造方法"></a>继承的构造方法</h3><p>实例化对象时，不仅仅调用该类的构造方法，同时调用了其父类的无参构造方法</p><ul><li><del>如果父类没有无参构造方法，需要在子类构造方法中super();加上参数。</del> 一般不这么用，因为如果单独写出有参构造方法时，通常会再写一个无参构造方法</li><li><em>调用父类的构造方法 super(); 一定要在类的构造方法的第一行</em></li><li>super和this不能同时调用构造方法</li></ul><h5 id="源代码（子类）"><a href="#源代码（子类）" class="headerlink" title="源代码（子类）"></a>源代码（子类）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span>&#123;<br>    <span class="hljs-comment">//构造方法：</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Teacher</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>();<span class="hljs-comment">//该行代码隐藏，调用了父类的无参构造方法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><blockquote><p>在idea中，用户可使用快捷键 ctrl+h 层次结构 可以观察到类的所有父类</p></blockquote><h3 id="重写（Override）"><a href="#重写（Override）" class="headerlink" title="重写（Override）"></a>重写（Override）</h3><ul><li>重写需要有继承关系，是子类继承父类的方法</li><li>方法名和参数列表必须相同。（不相同则为方法的重载）</li><li>重写都是方法的重写，和属性无关</li><li>重写只跟非静态方法有关</li><li>修饰符：范围可以扩大但不能缩小</li><li>抛出的异常：范围可以缩小但不能扩大</li></ul><h5 id="为什么要重写"><a href="#为什么要重写" class="headerlink" title="为什么要重写"></a>为什么要重写</h5><p><em>父类的方法子类不一定需要或者不一定满足</em></p><blockquote><p>在idea中，可以通过快捷键alt+Insert选择Override进行重写</p></blockquote><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>同一方法可以根据发送对象的不同 而采用多种不同的行为方式</p><p> 多态存在的条件：</p><ol><li><p>有继承关系：只有继承关系才能多态，否则会类型转换异常（ClassCastException）</p></li><li><p>子类重写父类的方法</p></li><li><p>父类引用指向子类对象 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Father</span> <span class="hljs-variable">f1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Son</span>();<br></code></pre></td></tr></table></figure></li></ol><p>多态的实现本质也是类型转换，是子类转成父类（低转高自动转换），在转换时无法使用子类独有方法（丢失方法）。而如果想用父类引用调用子类方法，也需要类型转换，是父类转子类（高到低强制类型转换），才能使用子类方法。</p><p><em>注：被static、private、final修饰的方法不能重写，所以也不能多态</em></p><h5 id="instanceof-（类型转换）"><a href="#instanceof-（类型转换）" class="headerlink" title="instanceof （类型转换）"></a>instanceof （类型转换）</h5><p>A instanceof B 是用来判断A是否是B的<em>实例对象</em>或者B子类的<em>实例对象</em></p><p>instanceof的返回值为布尔类型，但是应该分为三种情况讨论</p><ol><li><p>返回值为true：A是B类的（及其子类）的<em>实例对象</em></p></li><li><p>返回值为false：A不是B类（及其子类）的<em>实例对象</em></p></li><li><p>在编译时报错：</p><ul><li>A使用了多态，A的引用类型与B类（及其子类）没有继承关系时就会在编译时报错。</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>JAVASE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>构造方法</title>
    <link href="/2022/07/21/%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/"/>
    <url>/2022/07/21/%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><ul><li>构造方法一定存在，如果没有单独声明则系统会给默认的构造方法</li><li>构造方法一定与类同名</li><li>构造方法除public一类（访问级别）修饰符外，没有其他的修饰符</li><li>实例化对象时，通常与new关键字连用</li><li>构造方法同样是方法，可以用方法的重载</li><li>如果用户定义了一个有参构造方法，需再定义一个无参构造方法，否则无参构造方法（默认生成）将不能使用</li></ul><p><em>注：当用户自己编写构造方法时，通常是为了初始化值</em></p><blockquote><p>用idea编译器时，可以使用alt+Insert快捷键来生成构造方法</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>JAVASE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>稀疏矩阵</title>
    <link href="/2022/07/21/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5/"/>
    <url>/2022/07/21/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="稀疏矩阵"><a href="#稀疏矩阵" class="headerlink" title="稀疏矩阵"></a>稀疏矩阵</h1><p>因为二维数组很多值默认为零，因此记录了很多没有意义的数据。</p><p>使用二维数组（三元组）来解决这种问题</p><h5 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo05</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建二维数组 11*11 0没有棋子， 1为黑棋 2为白棋</span><br>        <span class="hljs-type">int</span>[][] a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">11</span>][<span class="hljs-number">11</span>];<br>        a[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;<br>        a[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] = <span class="hljs-number">2</span>;<br>        <span class="hljs-comment">//输出原始数组（增强型数组方法）</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] ints : a) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> anInt : ints) &#123;<br>                System.out.print(anInt + <span class="hljs-string">&quot;\t&quot;</span>);<br>            &#125;<br>            System.out.println();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;=============================&quot;</span>);<br>        <span class="hljs-comment">//转换为稀疏数组</span><br>        <span class="hljs-comment">//统计三元组里有效元素个数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; a.length; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; a[<span class="hljs-number">0</span>].length; j++) &#123;<br>                <span class="hljs-keyword">if</span> (a[i][j]&gt;<span class="hljs-number">0</span>)<br>                &#123;<br>                    sum++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;有效值的个数： &quot;</span> + sum);<br><br>        <span class="hljs-comment">//创建一个稀疏数组的数组</span><br>        <span class="hljs-type">int</span> [][] a2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[sum+<span class="hljs-number">1</span>][<span class="hljs-number">3</span>];<br>        a2[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = a.length;    <span class="hljs-comment">//第一个数是行数</span><br>        a2[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = a[<span class="hljs-number">0</span>].length; <span class="hljs-comment">//第二个数是列数</span><br>        a2[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] = sum;         <span class="hljs-comment">//有效元素的个数</span><br><br>        <span class="hljs-comment">//遍历二维数组，将非零值存放在稀疏数组中</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; a.length; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; a[<span class="hljs-number">0</span>].length; j++) &#123;<br>                <span class="hljs-keyword">if</span> (a[i][j] &gt; <span class="hljs-number">0</span>)<br>                &#123;<br>                    count++;         <span class="hljs-comment">//遍历到有效值就跳转到行</span><br>                    a2[count][<span class="hljs-number">0</span>] = i;<span class="hljs-comment">//行</span><br>                    a2[count][<span class="hljs-number">1</span>] = j;<span class="hljs-comment">//列</span><br>                    a2[count][<span class="hljs-number">2</span>] = a[i][j];<span class="hljs-comment">//元素值</span><br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//输出稀疏矩阵（使用Arrays工具类的toString方法）</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; a2.length; i++) &#123;<br>            System.out.println(Arrays.toString(a2[i]));<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;=============================&quot;</span>);<br>        <span class="hljs-comment">//还原稀疏矩阵</span><br>        <span class="hljs-comment">//读取稀疏矩阵</span><br>        <span class="hljs-type">int</span> a3[][] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[a2[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]][a2[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]];<span class="hljs-comment">//用稀疏矩阵的第一行 也就是存原数组的行和列的数量来定义原数组大小</span><br>        <span class="hljs-comment">//给原数组还原他的值</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; a2.length; i++) &#123;<br>            a3[ a2[i][<span class="hljs-number">0</span>] ][ a2[i][<span class="hljs-number">1</span>] ]=a2[i][<span class="hljs-number">2</span>]; <span class="hljs-comment">// 行列值</span><br>        &#125;<br>        <span class="hljs-comment">//输出还原数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] ints : a3) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> anInt : ints) &#123;<br>                System.out.print(anInt+<span class="hljs-string">&quot;\t&quot;</span>);<br>            &#125;<br>            System.out.println();<br>        &#125;<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><h5 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h5><p><img src="/upload/1-1663752051332.png" alt="1-1663752051332"></p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>JAVASE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>方法</title>
    <link href="/2022/07/20/%E6%96%B9%E6%B3%95/"/>
    <url>/2022/07/20/%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><ul><li>一个方法只完成一个功能，这样有利于我们后期的扩展</li><li>方法的命名规则应遵守首字母小写的驼峰命名规则</li></ul><h3 id="方法的定义"><a href="#方法的定义" class="headerlink" title="方法的定义"></a>方法的定义</h3><p>方法包含一个方法头和方法体。下面是一个方法的所有部分</p><ol><li>修饰符（public、static）</li><li>返回值类型(void、int)</li><li>方法名</li><li>参数类型（形参）</li><li>方法体</li></ol><h3 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h3><p>调用方法：对象名.方法名（实参列表）</p><p>当方法返回一个值的使用，方法调用通常被当做一个值</p><p>当方法返回值是空的时候，方法调用一定是一条语句</p><h5 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//静态方法的调用可以为类.方法</span><br>        Class.say();<br>        <span class="hljs-comment">//非静态方法的调用不可以直接类.方法 需要先实例化对象之后用对象.方法的方式调用</span><br>        <span class="hljs-comment">//Class.say1();错误</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>();<span class="hljs-comment">//实例化对象student， 利用和类同名的构造方法</span><br>        student.say1();<span class="hljs-comment">//利用对象.方法来调用方法</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">a</span><span class="hljs-params">()</span>&#123;<br>        b();<br>    &#125;<br>    <span class="hljs-comment">//静态方法可以直接调用静态方法</span><br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">static</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">b</span><span class="hljs-params">()</span>&#123;<br>        d();<span class="hljs-comment">//报错，静态方法无法直接调用非静态方法</span><br>    &#125;<br>    <span class="hljs-comment">//非静态方法可直接调用非静态方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">c</span> <span class="hljs-params">()</span>&#123;<br>        d();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">d</span><span class="hljs-params">()</span>&#123;<br>        b();<span class="hljs-comment">//非静态方法可以直接调用静态方法</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><p><em>注：静态方法和类一起加载，而非静态方法是实例化之后才会存在。所以非静态方法无法直接调用静态方法</em></p><h3 id="方法的重载（Overload）"><a href="#方法的重载（Overload）" class="headerlink" title="方法的重载（Overload）"></a>方法的重载（Overload）</h3><p>方法重载的规则：</p><ul><li>方法名称必须相同。</li><li>参数列表必须不同（可以是个数不同，类型不同，顺序不同）</li></ul><p>实践理论：</p><ul><li>方法名称相同时，编译器会根据调用方法的参数个数，参数类型等去逐个匹配，以选择对应的方法，如果匹配失败，则编译器报错。</li></ul><p><em>注：方法的重载的目的 就是通过传不同的参数达到调用不同的方法</em></p><h3 id="命令行传参"><a href="#命令行传参" class="headerlink" title="命令行传参"></a>命令行传参</h3><p>有时候你希望运行一个程序时候再传递给它消息。这要靠传递命令行参数给main（）方法实现</p><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>在方法声明中，在指定参数类型后加一个省略号（…）</p><p>一个方法中只能指定一个可变参数，他必须是方法的最后一个形参，其他的参数都要在它之前声明</p><p><em>注：可变参数有点类似与C语言中数组的首地址传递。</em></p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>递归分为递归头和递归体</p><ul><li>递归头：什么时候不调用自身方法。如果没有头，将陷入死循环。</li><li>递归体：什么时候需要调用自身方法。</li></ul><h5 id="源代码-1"><a href="#源代码-1" class="headerlink" title="源代码"></a>源代码</h5><p><em>5的阶乘，递归算法</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo03</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(f(<span class="hljs-number">5</span>)); <span class="hljs-comment">//120</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>        <span class="hljs-keyword">if</span> (n==<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f(n-<span class="hljs-number">1</span>)*n;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><h3 id="方法的数组参数传递"><a href="#方法的数组参数传递" class="headerlink" title="方法的数组参数传递"></a>方法的数组参数传递</h3><p>作为引用类型的数组也可以作为数组的形参或者返回值</p><p><em>注：JAVA中方法的数组（引用）传递类似于C语言中的地址传递，方法中对数组进行的操作对方法外也有影响</em></p><h3 id="方法的引用类型的传递"><a href="#方法的引用类型的传递" class="headerlink" title="方法的引用类型的传递"></a>方法的引用类型的传递</h3><p>同数组一样，引用类型的传递也是地址传递</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>        System.out.println(person.name);<span class="hljs-comment">//null</span><br>        change(person);<br>        System.out.println(person.name);<span class="hljs-comment">//Xiaobai</span><br>    &#125;<br>    <span class="hljs-comment">//引用类型的传递不是值传递。这里person.name的改变就是person对象中属性name的改变</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">change</span><span class="hljs-params">(Person person)</span>&#123;<br>        person.name = <span class="hljs-string">&quot;Xiaobai&quot;</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//定义一个person类，有一个属性：name</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br>    String name;<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><p><em>注：类中属性和类中方法一样，如果想要用类名.属性名调用该属性，则该属性必须要用static修饰符修饰</em></p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>JAVASE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Scanner对象</title>
    <link href="/2022/07/20/Scanner%E5%AF%B9%E8%B1%A1/"/>
    <url>/2022/07/20/Scanner%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="Scanner对象"><a href="#Scanner对象" class="headerlink" title="Scanner对象"></a>Scanner对象</h1><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Scanner</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br></code></pre></td></tr></table></figure><hr><ul><li>通过Scanner类的next()与nextLine()的方法获取输入的字符串，在读取前我们一般需要使用hasNext()与hasNextLine()判断是否还有输入的数据</li></ul><h3 id="next-与nextLine-方法的区别"><a href="#next-与nextLine-方法的区别" class="headerlink" title="next()与nextLine()方法的区别"></a>next()与nextLine()方法的区别</h3><ul><li><strong>next()</strong><ol><li>一定要读取到有效字符后才可以结束输入</li><li>对输入有效字符之前遇到的空白，next()方法会自动将其去掉</li><li>只有输入有效字符后才能将其后面输入的空白作为分隔符或者结束符</li><li>next()方法不能得到含有空格的字符串</li></ol></li><li><strong>nextLine()</strong><ol><li>以Enter作为结束符，也就是说 nextLine()方法返回的是输入回车之前的所有字符。</li><li>可以获得空白</li></ol></li></ul><h5 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.sun.org.apache.xerces.internal.impl.xs.SchemaNamespaceSupport;<br><br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo02</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><br>    <span class="hljs-keyword">if</span> (scanner.hasNextLine()) &#123;<br>      <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> scanner.nextLine();<br>      System.out.println(<span class="hljs-string">&quot;输入的内容为：&quot;</span> + str);<br>    &#125;<br>    scanner.close();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>注：实例化方法，不能直接调用类中的方法，需要实例化对象后，使用对象去调用类中方法。</p><p>在实例化对象时，必须要用到构造方法。每一个类一定存在一个构造方法。且构造方法必须与类同名。</p><p><em>如果是静态变量或方法（static）就可以用类名直接调用方法或变量</em></p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>JAVASE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>运算符</title>
    <link href="/2022/07/20/%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <url>/2022/07/20/%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h3 id="字符串连接符"><a href="#字符串连接符" class="headerlink" title="字符串连接符"></a>字符串连接符</h3><h5 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>          <span class="hljs-comment">//字符串连接符”+“</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br>        System.out.println(<span class="hljs-string">&quot;a+b= &quot;</span> + a + b); <span class="hljs-comment">//这里的a+b已经被转变成字符串且链接</span><br>        System.out.println(a + b + <span class="hljs-string">&quot;=a+b&quot;</span>); <span class="hljs-comment">//这里的a+b先计算后再与后面的字符串链接</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>JAVASE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>变量</title>
    <link href="/2022/07/20/%E5%8F%98%E9%87%8F/"/>
    <url>/2022/07/20/%E5%8F%98%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h3 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h3><ol><li>类变量<br>从属于类，使用时在方法内直接使用。在定义变量前加上static即可</li><li>实例变量<br>从属于对象，使用时在方法内要先声明在使用。使用时跟C语言结构体变量有些相似</li><li>局部变量</li></ol><h5 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DEMO05</span> &#123;<br>    <span class="hljs-comment">//实例变量：从属于对象：如果不自行初始化，其值为这个类型的默认值</span><br>    <span class="hljs-comment">//注：除了基本类型其余默认值为NULL ，布尔值默认值为false</span><br>    String name;<br>    <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-comment">//类变量</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-variable">salary</span> <span class="hljs-operator">=</span> <span class="hljs-number">2500</span>;<br><br><br>    <span class="hljs-comment">//main方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        <span class="hljs-comment">//局部变量</span><br>        <span class="hljs-type">DEMO05</span> <span class="hljs-variable">demo05</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DEMO05</span>(); <br>        System.out.println(demo05.age); <span class="hljs-comment">//0</span><br>        System.out.println(demo05.name); <span class="hljs-comment">//NULL</span><br>        <span class="hljs-comment">//类变量</span><br>        System.out.println(salary); <span class="hljs-comment">//2500.0</span><br>    &#125;<br>    <span class="hljs-comment">//其他的方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span>&#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="变量的命名规范"><a href="#变量的命名规范" class="headerlink" title="变量的命名规范"></a>变量的命名规范</h3><ul><li><strong>所有变量、方法、类名：见名知意</strong></li><li><strong>类成员变量：首字母小写和驼峰原则</strong></li><li><strong>局部变量：首字母小写和驼峰原则</strong></li><li><em><strong>常量：大写字母和下划线</strong></em></li><li><strong>类名：首字母大写和驼峰原则</strong></li><li><strong>方法名：首字母小写和驼峰原则</strong></li></ul><h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><h3 id="常量的定义"><a href="#常量的定义" class="headerlink" title="常量的定义"></a>常量的定义</h3><p>常量的定义关键字是 <em><strong>final</strong></em></p><h5 id="源代码-1"><a href="#源代码-1" class="headerlink" title="源代码"></a>源代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DEMO06</span> &#123;<br>    <span class="hljs-comment">//修饰符，不存在先后顺序</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-variable">PI</span> <span class="hljs-operator">=</span> <span class="hljs-number">3.14</span>;  <span class="hljs-comment">//定义一个类常量</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(PI); <span class="hljs-comment">//3.14</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>JAVASE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据类型转换</title>
    <link href="/2022/07/19/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <url>/2022/07/19/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h1><h5 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DEMO4</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] <span class="hljs-keyword">args</span></span>)</span> &#123;<br>        <span class="hljs-built_in">int</span> i = <span class="hljs-number">128</span>;<br>        <span class="hljs-built_in">byte</span> b = (<span class="hljs-built_in">byte</span>)i; <span class="hljs-comment">//内存溢出</span><br>        <span class="hljs-built_in">double</span> d = i;<br>        <span class="hljs-comment">//强制类型转换 （类型）变量名 高--低</span><br>        <span class="hljs-comment">//自动转换     低--高</span><br>        System.<span class="hljs-keyword">out</span>.println(i);<br>        System.<span class="hljs-keyword">out</span>.println(b);<br>        System.<span class="hljs-keyword">out</span>.println(d);<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;===============================&quot;</span>);<br>        <span class="hljs-built_in">char</span> c = <span class="hljs-string">&#x27;a&#x27;</span>;<br>        <span class="hljs-built_in">int</span> i1 = c + <span class="hljs-number">1</span>;<br>        System.<span class="hljs-keyword">out</span>.println(i1);<br>        System.<span class="hljs-keyword">out</span>.println((<span class="hljs-built_in">char</span>)i1);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h5><p><img src="/upload/1.jpg" alt="1"></p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li><strong>不能对布尔值进行转换</strong></li><li><strong>不能把对象类型转换为不相关的类型</strong></li><li><strong>把高精度转换到低精度的时候，强制转换</strong></li><li><strong>转换的时候可能存在内存溢出，或精度问题</strong></li><li><strong>JDK7新特性，数字之间可以被下划线分割</strong></li><li><strong>long类型数据后最好使用大写L，因为小写l和1在某种字体下难于区分</strong></li></ul>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>JAVASE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java的数据类型</title>
    <link href="/2022/07/19/Java%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2022/07/19/Java%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>JAVA的数据类型</p><p>JAVA是一种强类型语言</p><ul><li>要求变量的使用要严格符合规定，所有变量都必须定义后才能够使用</li></ul><h3 id="基本类型（primitive-type）"><a href="#基本类型（primitive-type）" class="headerlink" title="基本类型（primitive type）"></a>基本类型（primitive type）</h3><p>int  &#x2F;&#x2F;整形，还有byte（1字节），short（2字节），long（8字节）<br>float &#x2F;&#x2F;浮点类型。还有double（8字节）<br>boolean &#x2F;&#x2F;布尔类型 （1位）</p><ul><li>注意，String不是基本类型，String不是关键字，而是一个类</li></ul><h3 id="引用类型（reference-type）"><a href="#引用类型（reference-type）" class="headerlink" title="引用类型（reference type）"></a>引用类型（reference type）</h3><p>除基本类型的都是引用类型</p><h3 id="数据类型拓展"><a href="#数据类型拓展" class="headerlink" title="数据类型拓展"></a>数据类型拓展</h3><h5 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DEMO03</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//整形拓展：进制</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> <span class="hljs-number">010</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i2</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x10</span>;<br>        System.out.println(i);<br>        System.out.println(i1);<br>        System.out.println(i2);<br>        System.out.println(<span class="hljs-string">&quot;===============================&quot;</span>);<br><br>        <span class="hljs-comment">//浮点型拓展 ？ 银行业务怎么表示钱</span><br>        <span class="hljs-comment">//BigDecimal 数学工具类</span><br>        <span class="hljs-comment">//float 有限 离散 舍入误差 大约 接近但不等于</span><br>        <span class="hljs-comment">//最好完全不使用浮点型进行比较</span><br>        <span class="hljs-comment">//最好完全不使用浮点型进行比较</span><br>        <span class="hljs-comment">//最好完全不使用浮点型进行比较</span><br>        <span class="hljs-type">float</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.1f</span>;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">1.0</span>/<span class="hljs-number">10</span>;<br>        System.out.println(f==d); <span class="hljs-comment">//false</span><br><br>        <span class="hljs-type">float</span> <span class="hljs-variable">d1</span> <span class="hljs-operator">=</span> <span class="hljs-number">123123123123123f</span>;<br>        <span class="hljs-type">float</span> <span class="hljs-variable">d2</span> <span class="hljs-operator">=</span> d1 + <span class="hljs-number">1</span>;<br>        System.out.println(d1==d2);<span class="hljs-comment">//true</span><br>        System.out.println(<span class="hljs-string">&quot;===============================&quot;</span>);<br><br>        <span class="hljs-comment">//字符拓展</span><br>        <span class="hljs-type">char</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;a&#x27;</span>;<br>        <span class="hljs-type">char</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;中&#x27;</span>;<br>        System.out.println(c1);<br>        System.out.println((<span class="hljs-type">int</span>)c1);<br>        System.out.println(c2);<br>        System.out.println((<span class="hljs-type">int</span>)c2);<br>        <span class="hljs-comment">//所有的字符本质还是数字</span><br>        <span class="hljs-comment">//编码 Unicode 2字节 0 - 65536 excel 最长是2的16次方位65536</span><br>        <span class="hljs-type">char</span> <span class="hljs-variable">c3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;\u0061&#x27;</span>;<br>        System.out.println(c3);<span class="hljs-comment">//输出字符a</span><br>        System.out.println(<span class="hljs-string">&quot;===============================&quot;</span>);<br><br>        <span class="hljs-comment">//转义字符</span><br>        System.out.println(<span class="hljs-string">&quot;hellow\tworld&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;hellow\nworld&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;===============================&quot;</span>);<br><br>        <span class="hljs-comment">//布尔值扩展</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(flag)&#123;&#125; <span class="hljs-comment">//老手</span><br>        <span class="hljs-keyword">if</span>(flag=<span class="hljs-literal">true</span>)&#123;&#125;<span class="hljs-comment">//新手</span><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h5><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul><li><strong>和C语言不同的是，JAVA的字符型数据储存方式为Unicode编码（16位），Unicode编码包含了ASCII（8位）编码</strong></li><li><strong>在处理银行问题时要尽量完全避免使用实型数据进行比较，可以使用BigDecimal 数学工具类</strong></li><li><strong>和C语言不同的是，JAVA的基本数据类型中有布尔类型，其关键字位boolean</strong></li><li><strong>使用long和float定义数据时，数据后分别应加上L和F ，否则会报错</strong></li></ul>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>JAVASE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hellow world</title>
    <link href="/2022/07/19/Hellow%20world/"/>
    <url>/2022/07/19/Hellow%20world/</url>
    
    <content type="html"><![CDATA[<h1 id="Hellow-world"><a href="#Hellow-world" class="headerlink" title="Hellow world"></a>Hellow world</h1><ol><li>新建一个java文件<ul><li>后缀名为.java</li><li>注意，系统可能不显示后缀名</li></ul></li><li>编写代码</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hello</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>System.out.print(<span class="hljs-string">&quot;hellow world!&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>使用javac命令编译.java文件</li><li>使用java命令运行 .class文件<br><img src="/upload/1-1663751619053.png" alt="1-1663751619053"></li></ol><h3 id="可能会遇到的情况"><a href="#可能会遇到的情况" class="headerlink" title="可能会遇到的情况"></a>可能会遇到的情况</h3><ol><li>每个单词的大小写不能出现问题</li><li>尽量使用英文</li><li>文件名和类名要保证一致</li><li>符号使用了中文AC</li></ol>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>JAVASE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java开发环境搭建</title>
    <link href="/2022/07/19/Java%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <url>/2022/07/19/Java%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="JAVA开发环境搭建"><a href="#JAVA开发环境搭建" class="headerlink" title="JAVA开发环境搭建"></a>JAVA开发环境搭建</h1><h2 id="JDK、JRE、JVM的区别"><a href="#JDK、JRE、JVM的区别" class="headerlink" title="JDK、JRE、JVM的区别"></a>JDK、JRE、JVM的区别</h2><p>JDK： Java Development Kit<br>JRE： Java Runtime Environment<br>JVM： JAVA Virtual Machine</p><p>JDK是面对开发者，JRE面对用户，JDK包括JRE</p><h2 id="jdk的安装"><a href="#jdk的安装" class="headerlink" title="jdk的安装"></a>jdk的安装</h2><ol><li>下载jdk8安装包，<a href="https://www.oracle.com/java/technologies/downloads/#java8-windows">JDK8下载链接</a></li><li>双击安装JDK（这里要选择完整安装，否则会出现没有jre的情况）</li><li>记住安装路径</li><li>配置环境变量<ol><li>右键此电脑-属性-高级系统设置-环境变量</li><li>新建系统变量-变量名称为JAVA_HOME 变量为java根目录地址</li><li>配置PATH变量分别为为%JAVA_HOME%\bin 和 %JAVA_HOME%\jre\bin</li></ol></li><li>使用java -version测试JAVA是否安装成功</li></ol>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>JAVASE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Markdown学习</title>
    <link href="/2022/07/19/Markdown%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/07/19/Markdown%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Markdown-学习"><a href="#Markdown-学习" class="headerlink" title="Markdown 学习"></a>Markdown 学习</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><p><strong>hello ，word！</strong><br><em>hello ，word！</em><br><em><strong>hello ，word！</strong></em><br><del>hello ，word！</del></p><h2 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h2><p>markdown规定用两行回车来表示换行</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><blockquote><p>选择java ，走向人生巅峰</p></blockquote><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><hr><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p><img src="/upload/1.png" alt="1"></p><p><img src="https://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png" alt="网络图片"></p><blockquote><p>sublime text 插件快捷键是：shift+win+k</p></blockquote><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p><a href="https://www.baidu.com/">百度</a></p><blockquote><p>sublime text 插件快捷键是：ctrl+win+k</p></blockquote><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><ol><li>A</li><li>B</li><li>C</li></ol><ul><li>无序列表1</li><li>无序列表2</li></ul><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><table><thead><tr><th align="left">名字</th><th>性别</th><th>生日</th></tr></thead><tbody><tr><td align="left">张三</td><td>男</td><td>1997.1.1</td></tr></tbody></table><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span><br></code></pre></td></tr></table></figure><h1 id="百度脑图快捷键"><a href="#百度脑图快捷键" class="headerlink" title="百度脑图快捷键"></a>百度脑图快捷键</h1><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><table><thead><tr><th>快捷键</th><th>功能</th></tr></thead><tbody><tr><td>Enter</td><td>插入同级主题</td></tr><tr><td>Tab&#x2F;Insert</td><td>插入下级主题</td></tr><tr><td>Shift+Tab</td><td>插入上级主题</td></tr><tr><td>Delete</td><td>删除主题</td></tr><tr><td>Up（↑）&#x2F;Down（↓）&#x2F;Left（←）&#x2F;Right（→）</td><td>主题巡航</td></tr><tr><td>Alt+Up（↑）&#x2F;Down（↓）</td><td>向上&#x2F;向下调整顺序</td></tr><tr><td>F2</td><td>编辑主题</td></tr><tr><td>Shift+Enter</td><td>文本换行</td></tr><tr><td>Ctrl+A</td><td>全选主题</td></tr><tr><td>Ctrl+C</td><td>复制主题</td></tr><tr><td>Ctrl+X</td><td>剪切主题</td></tr><tr><td>Ctrl+V</td><td>粘贴主题</td></tr><tr><td>Ctrl+B</td><td>加粗主题内字体</td></tr><tr><td>Ctrl+I</td><td>倾斜主题内字体</td></tr><tr><td>Ctrl+F</td><td>查找主题（输入关键字搜索）</td></tr></tbody></table><h3 id="视野控制"><a href="#视野控制" class="headerlink" title="视野控制"></a>视野控制</h3><table><thead><tr><th>快捷键</th><th>功能</th></tr></thead><tbody><tr><td>Ait+拖动+右键拖动</td><td>拖动视野</td></tr><tr><td>鼠标滚轮&#x2F;触摸板</td><td>移动视野</td></tr><tr><td>鼠标双击文档空白处&#x2F;Ctrl+Enter</td><td>居中母主题</td></tr><tr><td>Ctrl+（+）&#x2F;Ctrl+（-）</td><td>放大&#x2F;缩小视野</td></tr></tbody></table><h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><table><thead><tr><th>快捷键</th><th>功能</th></tr></thead><tbody><tr><td>Ctrl+Shift+L</td><td>整理布局</td></tr></tbody></table><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><table><thead><tr><th>快捷键</th><th>功能</th></tr></thead><tbody><tr><td>Ctrl+Z</td><td>撤销</td></tr><tr><td>Ctrl+Y</td><td>重写脑图</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>JAVASE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
